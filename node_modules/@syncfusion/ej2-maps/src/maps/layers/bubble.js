import { ColorMapping, bubbleRendering } from '../index';
import { bubbleClick, bubbleMouseMove } from '../index';
import { isNullOrUndefined } from '@syncfusion/ej2-base';
import { CircleOption, MapLocation, findMidPointOfPolygon, Point, drawCircle, elementAnimate, getTranslate } from '../utils/helper';
import { RectOption, Rect, drawRectangle } from '../utils/helper';
/**
 * Bubble module class
 */
var Bubble = /** @class */ (function () {
    function Bubble(maps) {
        /**
         * Bubble Id for current layer
         */
        this.id = '';
        this.maps = maps;
        this.bubbleCollection = [];
    }
    /**
     * To render bubble
     */
    /* tslint:disable:no-string-literal */
    Bubble.prototype.renderBubble = function (bubbleSettings, shapeData, color, range, bubbleIndex, dataIndex, layerIndex, layer, group) {
        var layerData = layer.layerData;
        var colorValuePath = bubbleSettings.colorValuePath;
        var equalValue = shapeData[colorValuePath];
        var colorValue = Number(shapeData[colorValuePath]);
        var bubbleValue = Number(shapeData[bubbleSettings.valuePath]);
        if (isNaN(bubbleValue) && isNaN(colorValue) && isNullOrUndefined(equalValue)) {
            return null;
        }
        var radius = this.getRatioOfBubble(bubbleSettings.minRadius, bubbleSettings.maxRadius, bubbleValue, range.min, range.max);
        var colorMapping = new ColorMapping(this.maps);
        var shapeColor = colorMapping.getColorByValue(bubbleSettings.colorMapping, colorValue, equalValue);
        shapeColor = shapeColor ? shapeColor : color;
        var shapePoints = [[]];
        var midIndex = 0;
        var pointsLength = 0;
        var currentLength = 0;
        for (var i = 0, len = layerData.length; i < len; i++) {
            var shape = layerData[i];
            shape = shape['property'];
            if (shapeData[layer.shapeDataPath] === shape[layer.shapePropertyPath]) {
                if (!layerData[i]['_isMultiPolygon']) {
                    shapePoints.push(this.getPoints(layerData[i], []));
                    currentLength = shapePoints[shapePoints.length - 1].length;
                    if (pointsLength < currentLength) {
                        pointsLength = currentLength;
                        midIndex = shapePoints.length - 1;
                    }
                }
                else {
                    var layer_1 = layerData[i];
                    for (var j = 0; j < layer_1.length; j++) {
                        shapePoints.push(this.getPoints(layer_1[j], []));
                        currentLength = shapePoints[shapePoints.length - 1].length;
                        if (pointsLength < currentLength) {
                            pointsLength = currentLength;
                            midIndex = shapePoints.length - 1;
                        }
                    }
                }
            }
        }
        var center = findMidPointOfPolygon(shapePoints[midIndex]);
        if (!isNullOrUndefined(center)) {
            var centerY = this.maps.projectionType === 'Mercator' ? center['y'] : (-center['y']);
            var eventArgs = {
                cancel: false, name: bubbleRendering, border: bubbleSettings.border,
                cx: center['x'], cy: centerY, data: shapeData, fill: shapeColor, maps: this.maps,
                radius: radius
            };
            this.maps.trigger(bubbleRendering, eventArgs);
            if (eventArgs.cancel) {
                return;
            }
            var bubbleElement = void 0;
            if (bubbleSettings.bubbleType === 'Circle') {
                var circle = new CircleOption(this.id, eventArgs.fill, eventArgs.border, bubbleSettings.opacity, 0, 0, eventArgs.radius, null);
                bubbleElement = drawCircle(this.maps, circle, group);
            }
            else {
                var y = this.maps.projectionType === 'Mercator' ? (eventArgs.cy - radius) : (eventArgs.cy + radius);
                var rectangle = new RectOption(this.id, eventArgs.fill, eventArgs.border, bubbleSettings.opacity, new Rect(0, 0, radius * 2, radius * 2), 2, 2);
                eventArgs.cx -= radius;
                eventArgs.cy = y;
                bubbleElement = drawRectangle(this.maps, rectangle, group);
            }
            this.bubbleCollection.push({
                LayerIndex: layerIndex,
                BubbleIndex: bubbleIndex,
                DataIndex: dataIndex,
                element: bubbleElement,
                center: { x: eventArgs.cx, y: eventArgs.cy }
            });
            var animate = layer.animationDuration !== 0 || isNullOrUndefined(this.maps.zoomModule);
            var translate = getTranslate(this.maps, layer, animate);
            var scale = translate['scale'];
            var transPoint = translate['location'];
            var position = new MapLocation((this.maps.isTileMap ? (eventArgs.cx) : ((eventArgs.cx + transPoint.x) * scale)), (this.maps.isTileMap ? (eventArgs.cy) : ((eventArgs.cy + transPoint.y) * scale)));
            bubbleElement.setAttribute('transform', 'translate( ' + (position.x) + ' ' + (position.y) + ' )');
            var bubble = (bubbleSettings.dataSource.length - 1) === dataIndex ? 'bubble' : null;
            if (bubbleSettings.bubbleType === 'Square') {
                position.x += radius;
                position.y += radius * (this.maps.projectionType === 'Mercator' ? 1 : -1);
            }
            else {
                radius = 0;
            }
            if (bubbleSettings.animationDuration > 0) {
                elementAnimate(bubbleElement, bubbleSettings.animationDelay, bubbleSettings.animationDuration, position, this.maps, bubble, radius);
            }
        }
    };
    Bubble.prototype.getPoints = function (shape, points) {
        shape.map(function (current, index) {
            points.push(new Point(current['point']['x'], current['point']['y']));
        });
        return points;
    };
    Bubble.prototype.getRatioOfBubble = function (min, max, value, minValue, maxValue) {
        var percent = (100 / (maxValue - minValue)) * (value - minValue);
        var bubbleRadius = (((max - min) / 100) * percent) + min;
        if (maxValue === minValue) {
            bubbleRadius = (((max - min) / 100)) + min;
        }
        return bubbleRadius;
    };
    /**
     * To check and trigger bubble click event
     */
    Bubble.prototype.bubbleClick = function (e) {
        var target = e.target.id;
        if (target.indexOf('_LayerIndex_') === -1) {
            return;
        }
        var data = this.getbubble(target);
        if (isNullOrUndefined(data)) {
            return;
        }
        var eventArgs = {
            cancel: false, name: bubbleClick, data: data, maps: this.maps,
            target: target, x: e.clientX, y: e.clientY
        };
        this.maps.trigger(bubbleClick, eventArgs);
    };
    /**
     * To get bubble from target id
     */
    Bubble.prototype.getbubble = function (target) {
        var id = target.split('_LayerIndex_');
        var index = parseInt(id[1].split('_')[0], 10);
        var layer = this.maps.layers[index];
        var data;
        if (target.indexOf('_BubbleIndex_') > -1) {
            var bubbleIndex = parseInt(id[1].split('_BubbleIndex_')[1], 10);
            if (!isNaN(bubbleIndex)) {
                data = layer.dataSource[bubbleIndex];
                return data;
            }
        }
        return null;
    };
    /**
     * To check and trigger bubble move event
     */
    Bubble.prototype.bubbleMove = function (e) {
        var target = e.target.id;
        if (target.indexOf('_LayerIndex_') === -1) {
            return;
        }
        var data = this.getbubble(target);
        if (isNullOrUndefined(data)) {
            return;
        }
        var eventArgs = {
            cancel: false, name: bubbleMouseMove, data: data, maps: this.maps,
            target: target, x: e.clientX, y: e.clientY
        };
        this.maps.trigger(bubbleMouseMove, eventArgs);
    };
    /**
     * Get module name.
     */
    Bubble.prototype.getModuleName = function () {
        return 'Bubble';
    };
    /**
     * To destroy the bubble.
     * @return {void}
     * @private
     */
    Bubble.prototype.destroy = function (maps) {
        /**
         * Destroy method performed here
         */
    };
    return Bubble;
}());
export { Bubble };
