import { Browser, Component, Event, L10n, NotifyPropertyChanges, Property, classList, createElement, isNullOrUndefined, setCulture } from '@syncfusion/ej2-base';
import { Save, StreamWriter, XmlWriter } from '@syncfusion/ej2-file-utils';
import { ContextMenu, Tab } from '@syncfusion/ej2-navigations';
import { Dialog, Popup, Tooltip } from '@syncfusion/ej2-popups';
import { Button, CheckBox, RadioButton } from '@syncfusion/ej2-buttons';
import { ZipArchive, ZipArchiveItem } from '@syncfusion/ej2-compression';
import { ComboBox, DropDownList } from '@syncfusion/ej2-dropdowns';
import { ColorPicker, NumericTextBox } from '@syncfusion/ej2-inputs';
import { ListView } from '@syncfusion/ej2-lists';
import { DropDownButton } from '@syncfusion/ej2-splitbuttons';

/**
 * @private
 */
class Dictionary {
    constructor() {
        this.keysInternal = [];
        this.valuesInternal = [];
        this.item = [];
    }
    /**
     * @private
     */
    get length() {
        return this.keysInternal.length;
    }
    /**
     * @private
     */
    get keys() {
        return this.getItem();
    }
    /**
     * @private
     */
    getItem() {
        this.item = [];
        for (let i = 0; i < this.keysInternal.length; i++) {
            this.item.push(this.keysInternal[i]);
        }
        return this.item;
    }
    /**
     * @private
     */
    add(key, value) {
        if (isNullOrUndefined(key)) {
            throw new ReferenceError('Provided key or value is not valid.');
        }
        let index = this.keysInternal.indexOf(key);
        // if (index < 0 || index > this.keysInternal.length - 1) {
        if (index < 0) {
            this.keysInternal.push(key);
            this.valuesInternal.push(value);
        }
        return 1;
        // else {
        //     throw new RangeError('An item with the same key has already been added.');
        // }
    }
    /**
     * @private
     */
    get(key) {
        if (isNullOrUndefined(key)) {
            throw new ReferenceError('Provided key is not valid.');
        }
        let index = this.keysInternal.indexOf(key);
        if (index < 0 || index > this.keysInternal.length - 1) {
            throw new RangeError('No item with the specified key has been added.');
        }
        else {
            return this.valuesInternal[index];
        }
    }
    /**
     * @private
     */
    set(key, value) {
        if (isNullOrUndefined(key)) {
            throw new ReferenceError('Provided key is not valid.');
        }
        let index = this.keysInternal.indexOf(key);
        if (index < 0 || index > this.keysInternal.length - 1) {
            throw new RangeError('No item with the specified key has been added.');
        }
        else {
            this.valuesInternal[index] = value;
        }
    }
    /**
     * @private
     */
    remove(key) {
        if (isNullOrUndefined(key)) {
            throw new ReferenceError('Provided key is not valid.');
        }
        let index = this.keysInternal.indexOf(key);
        if (index < 0 || index > this.keysInternal.length - 1) {
            throw new RangeError('No item with the specified key has been added.');
        }
        else {
            this.keysInternal.splice(index, 1);
            this.valuesInternal.splice(index, 1);
            return true;
        }
    }
    /**
     * @private
     */
    containsKey(key) {
        if (isNullOrUndefined(key)) {
            throw new ReferenceError('Provided key is not valid.');
        }
        let index = this.keysInternal.indexOf(key);
        if (index < 0 || index > this.keysInternal.length - 1) {
            return false;
        }
        return true;
    }
    /**
     * @private
     */
    clear() {
        this.keysInternal = [];
        this.valuesInternal = [];
    }
    /**
     * @private
     */
    destroy() {
        this.clear();
        this.keysInternal = undefined;
        this.valuesInternal = undefined;
    }
}

/**
 * @private
 */
class WUniqueFormat {
    constructor(type) {
        this.referenceCount = 0;
        this.uniqueFormatType = type;
        this.propertiesHash = new Dictionary();
    }
    /**
     * @private
     */
    isEqual(source, property, modifiedValue) {
        let isEqual = false;
        switch (this.uniqueFormatType) {
            case 1:
                isEqual = this.isBorderEqual(source, property, modifiedValue);
                break;
            case 2:
                isEqual = this.isCharacterFormatEqual(source, property, modifiedValue);
                break;
            case 3:
                isEqual = this.isParagraphFormatEqual(source, property, modifiedValue);
                break;
            case 4:
                isEqual = this.isCellFormatEqual(source, property, modifiedValue);
                break;
            case 5:
                isEqual = this.isShadingEqual(source, property, modifiedValue);
                break;
            case 6:
                isEqual = this.isRowFormatEqual(source, property, modifiedValue);
                break;
            case 7:
                isEqual = this.isListFormatEqual(source, property, modifiedValue);
                break;
            case 8:
                isEqual = this.isTableFormatEqual(source, property, modifiedValue);
                break;
            case 9:
                isEqual = this.isListLevelEqual(source, property, modifiedValue);
                break;
            case 10:
                isEqual = this.isSectionFormatEqual(source, property, modifiedValue);
                break;
            default:
                break;
        }
        return isEqual;
    }
    // tslint:disable-next-line:max-line-length
    isNotEqual(property, source, modifiedProperty, modifiedValue, uniqueFormatType) {
        let targetValue = undefined;
        let propertyType = WUniqueFormat.getPropertyType(uniqueFormatType, property);
        if (this.propertiesHash.containsKey(propertyType)) {
            targetValue = this.propertiesHash.get(propertyType);
        }
        let sourceValue = undefined;
        if (property === modifiedProperty) {
            sourceValue = modifiedValue;
        }
        else if (source.containsKey(propertyType)) {
            sourceValue = source.get(propertyType);
        }
        // tslint:disable-next-line:max-line-length
        if (!(targetValue === sourceValue || (!isNullOrUndefined(targetValue) && !isNullOrUndefined(sourceValue) && targetValue === sourceValue))) {
            return true;
        }
        return false;
    }
    /**
     * @private
     */
    static getPropertyType(uniqueFormatType, property) {
        let type = 0;
        switch (uniqueFormatType) {
            case 1:
                type = this.getBorderPropertyType(property);
                break;
            case 2:
                type = this.getCharacterFormatPropertyType(property);
                break;
            case 3:
                type = this.getParaFormatPropertyType(property);
                break;
            case 4:
                type = this.getCellFormatPropertyType(property);
                break;
            case 5:
                type = this.getShadingPropertyType(property);
                break;
            case 6:
                type = this.getRowFormatType(property);
                break;
            case 7:
                type = this.getListFormatType(property);
                break;
            case 8:
                type = this.getTableFormatType(property);
                break;
            case 9:
                type = this.getListLevelType(property);
                break;
            case 10:
                type = this.getSectionFormatType(property);
                break;
            default:
                break;
        }
        return type;
    }
    static getRowFormatType(property) {
        if (property === 'allowBreakAcrossPages') {
            return 1;
        }
        if (property === 'isHeader') {
            return 2;
        }
        if (property === 'height') {
            return 3;
        }
        if (property === 'heightType') {
            return 4;
        }
        if (property === 'gridBefore') {
            return 5;
        }
        if (property === 'gridBeforeWidth') {
            return 6;
        }
        if (property === 'gridBeforeWidthType') {
            return 7;
        }
        if (property === 'gridAfter') {
            return 8;
        }
        if (property === 'gridAfterWidth') {
            return 9;
        }
        if (property === 'gridAfterWidthType') {
            return 10;
        }
        return 0;
    }
    static getListFormatType(property) {
        if (property === 'listId') {
            return 1;
        }
        if (property === 'listLevelNumber') {
            return 2;
        }
        return 0;
    }
    static getTableFormatType(property) {
        if (property === 'leftMargin') {
            return 1;
        }
        if (property === 'rightMargin') {
            return 2;
        }
        if (property === 'topMargin') {
            return 3;
        }
        if (property === 'bottomMargin') {
            return 4;
        }
        if (property === 'cellSpacing') {
            return 5;
        }
        if (property === 'leftIndent') {
            return 6;
        }
        if (property === 'tableAlignment') {
            return 7;
        }
        if (property === 'preferredWidth') {
            return 8;
        }
        if (property === 'preferredWidthType') {
            return 9;
        }
        return 0;
    }
    static getListLevelType(property) {
        if (property === 'listLevelPattern') {
            return 1;
        }
        if (property === 'startAt') {
            return 2;
        }
        if (property === 'followCharacter') {
            return 3;
        }
        if (property === 'numberFormat') {
            return 4;
        }
        if (property === 'restartLevel') {
            return 5;
        }
        return 0;
    }
    static getShadingPropertyType(property) {
        if (property === 'backgroundColor') {
            return 1;
        }
        if (property === 'foregroundColor') {
            return 2;
        }
        if (property === 'textureStyle') {
            return 3;
        }
        return 0;
    }
    static getCellFormatPropertyType(property) {
        if (property === 'leftMargin') {
            return 1;
        }
        if (property === 'rightMargin') {
            return 2;
        }
        if (property === 'topMargin') {
            return 3;
        }
        if (property === 'bottomMargin') {
            return 4;
        }
        if (property === 'columnSpan') {
            return 5;
        }
        if (property === 'rowSpan') {
            return 6;
        }
        if (property === 'verticalAlignment') {
            return 7;
        }
        if (property === 'preferredWidthType') {
            return 8;
        }
        if (property === 'preferredWidth') {
            return 9;
        }
        if (property === 'cellWidth') {
            return 10;
        }
        return 0;
    }
    static getBorderPropertyType(property) {
        if (property === 'color') {
            return 1;
        }
        if (property === 'lineStyle') {
            return 2;
        }
        if (property === 'lineWidth') {
            return 3;
        }
        if (property === 'shadow') {
            return 4;
        }
        if (property === 'space') {
            return 5;
        }
        if (property === 'hasNoneStyle') {
            return 6;
        }
        return 0;
    }
    static getCharacterFormatPropertyType(property) {
        if (property === 'fontColor') {
            return 1;
        }
        if (property === 'fontFamily') {
            return 2;
        }
        if (property === 'fontSize') {
            return 3;
        }
        if (property === 'bold') {
            return 4;
        }
        if (property === 'italic') {
            return 5;
        }
        if (property === 'underline') {
            return 6;
        }
        if (property === 'strikethrough') {
            return 7;
        }
        if (property === 'baselineAlignment') {
            return 8;
        }
        if (property === 'highlightColor') {
            return 9;
        }
        return 0;
    }
    static getParaFormatPropertyType(property) {
        if (property === 'leftIndent') {
            return 1;
        }
        if (property === 'rightIndent') {
            return 2;
        }
        if (property === 'firstLineIndent') {
            return 3;
        }
        if (property === 'textAlignment') {
            return 4;
        }
        if (property === 'beforeSpacing') {
            return 5;
        }
        if (property === 'afterSpacing') {
            return 6;
        }
        if (property === 'lineSpacing') {
            return 7;
        }
        if (property === 'lineSpacingType') {
            return 8;
        }
        if (property === 'outlineLevel') {
            return 9;
        }
        return 0;
    }
    static getSectionFormatType(property) {
        if (property === 'headerDistance') {
            return 1;
        }
        if (property === 'footerDistance') {
            return 2;
        }
        if (property === 'differentFirstPage') {
            return 3;
        }
        if (property === 'differentOddAndEvenPages') {
            return 4;
        }
        if (property === 'pageWidth') {
            return 5;
        }
        if (property === 'pageHeight') {
            return 6;
        }
        if (property === 'leftMargin') {
            return 7;
        }
        if (property === 'topMargin') {
            return 8;
        }
        if (property === 'rightMargin') {
            return 9;
        }
        if (property === 'bottomMargin') {
            return 10;
        }
        return 0;
    }
    /**
     * @private
     */
    isBorderEqual(source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('color', source, modifiedProperty, modifiedValue, 1)) {
            return false;
        }
        if (this.isNotEqual('lineStyle', source, modifiedProperty, modifiedValue, 1)) {
            return false;
        }
        if (this.isNotEqual('lineWidth', source, modifiedProperty, modifiedValue, 1)) {
            return false;
        }
        if (this.isNotEqual('shadow', source, modifiedProperty, modifiedValue, 1)) {
            return false;
        }
        if (this.isNotEqual('space', source, modifiedProperty, modifiedValue, 1)) {
            return false;
        }
        if (this.isNotEqual('hasNoneStyle', source, modifiedProperty, modifiedValue, 1)) {
            return false;
        }
        return true;
    }
    /**
     * @private
     */
    isCharacterFormatEqual(source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('fontColor', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('fontFamily', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('fontSize', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('bold', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('italic', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('underline', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('strikethrough', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('baselineAlignment', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('highlightColor', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        return true;
    }
    isParagraphFormatEqual(source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('leftIndent', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('rightIndent', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('firstLineIndent', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('textAlignment', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('beforeSpacing', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('afterSpacing', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('lineSpacing', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('lineSpacingType', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('outlineLevel', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        return true;
    }
    /**
     * @private
     */
    isCellFormatEqual(source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('leftMargin', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('rightMargin', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('topMargin', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('bottomMargin', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('columnSpan', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('rowSpan', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('verticalAlignment', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('preferredWidthType', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('preferredWidth', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('cellWidth', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        return true;
    }
    /**
     * @private
     */
    isShadingEqual(source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('backgroundColor', source, modifiedProperty, modifiedValue, 5)) {
            return false;
        }
        if (this.isNotEqual('foregroundColor', source, modifiedProperty, modifiedValue, 5)) {
            return false;
        }
        if (this.isNotEqual('textureStyle', source, modifiedProperty, modifiedValue, 5)) {
            return false;
        }
        return true;
    }
    /**
     * @private
     */
    isRowFormatEqual(source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('allowBreakAcrossPages', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('isHeader', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('height', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('heightType', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('gridBefore', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('gridBeforeWidth', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('gridBeforeWidthType', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('gridAfter', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('gridAfterWidth', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('gridAfterWidthType', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        return true;
    }
    /**
     * @private
     */
    isListFormatEqual(source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('listId', source, modifiedProperty, modifiedValue, 7)) {
            return false;
        }
        if (this.isNotEqual('listLevelNumber', source, modifiedProperty, modifiedValue, 7)) {
            return false;
        }
        return true;
    }
    /**
     * @private
     */
    isTableFormatEqual(source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('leftMargin', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('rightMargin', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('topMargin', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('bottomMargin', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('cellSpacing', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('leftIndent', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('tableAlignment', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('preferredWidth', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('preferredWidthType', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        return true;
    }
    /**
     * @private
     */
    isListLevelEqual(source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('listLevelPattern', source, modifiedProperty, modifiedValue, 9)) {
            return false;
        }
        if (this.isNotEqual('startAt', source, modifiedProperty, modifiedValue, 9)) {
            return false;
        }
        if (this.isNotEqual('followCharacter', source, modifiedProperty, modifiedValue, 9)) {
            return false;
        }
        if (this.isNotEqual('numberFormat', source, modifiedProperty, modifiedValue, 9)) {
            return false;
        }
        if (this.isNotEqual('restartLevel', source, modifiedProperty, modifiedValue, 9)) {
            return false;
        }
        return true;
    }
    /**
     * @private
     */
    isSectionFormatEqual(source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('headerDistance', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('footerDistance', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('differentFirstPage', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('differentOddAndEvenPages', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('pageWidth', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('pageHeight', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('leftMargin', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('topMargin', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('rightMargin', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('bottomMargin', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        return true;
    }
    /**
     * @private
     */
    cloneItems(format, property, value, uniqueFormatType) {
        let propertyType = WUniqueFormat.getPropertyType(uniqueFormatType, property);
        let keys = format.propertiesHash.getItem();
        for (let i = 0; i < keys.length; i++) {
            if (keys[i] === propertyType) {
                this.propertiesHash.add(propertyType, value);
            }
            else {
                this.propertiesHash.add(keys[i], format.propertiesHash.get(keys[i]));
            }
        }
        if (!format.propertiesHash.containsKey(propertyType)) {
            this.propertiesHash.add(propertyType, value);
        }
    }
    /**
     * @private
     */
    mergeProperties(format) {
        let hash = format.cloneProperties();
        let keys = this.propertiesHash.keys;
        for (let i = 0; i < keys.length; i++) {
            if (!hash.containsKey(keys[i])) {
                hash.add(keys[i], this.propertiesHash.get(keys[i]));
            }
        }
        return hash;
    }
    /**
     * @private
     */
    cloneProperties() {
        let hash = new Dictionary();
        let keys = this.propertiesHash.keys;
        for (let i = 0; i < keys.length; i++) {
            hash.add(keys[i], this.propertiesHash.get(keys[i]));
        }
        return hash;
    }
    // public cloneItemsInternal(format: WUniqueFormat): void {
    //     let keys: number[] = format.propertiesHash.getItem();
    //     for (let i: number = 0; i < keys.length; i++) {
    //         this.propertiesHash.add(keys[i], format.propertiesHash.get(keys[i]));
    //     }
    //     this.referenceCount = format.referenceCount;
    // }
    /**
     * @private
     */
    destroy() {
        if (!isNullOrUndefined(this.propertiesHash)) {
            this.propertiesHash.destroy();
        }
        this.propertiesHash = undefined;
        this.referenceCount = undefined;
        this.uniqueFormatType = undefined;
    }
}

/**
 * @private
 */
class WUniqueFormats {
    constructor() {
        this.items = [];
    }
    /**
     * @private
     */
    addUniqueFormat(format, type) {
        let matchedFormat = undefined;
        for (let i = 0; i < this.items.length; i++) {
            if (this.items[i].isEqual(format, undefined, undefined)) {
                matchedFormat = this.items[i];
                break;
            }
        }
        if (isNullOrUndefined(matchedFormat)) {
            matchedFormat = new WUniqueFormat(type);
            matchedFormat.propertiesHash = format;
            matchedFormat.referenceCount = 1;
            this.items.push(matchedFormat);
        }
        else {
            matchedFormat.referenceCount++;
        }
        return matchedFormat;
    }
    /**
     * @private
     */
    updateUniqueFormat(uniqueFormat, property, value) {
        let matchedFormat = undefined;
        for (let i = 0; i < this.items.length; i++) {
            if (this.items[i].isEqual(uniqueFormat.propertiesHash, property, value)) {
                matchedFormat = this.items[i];
                break;
            }
        }
        if (isNullOrUndefined(matchedFormat)) {
            matchedFormat = new WUniqueFormat(uniqueFormat.uniqueFormatType);
            matchedFormat.cloneItems(uniqueFormat, property, value, uniqueFormat.uniqueFormatType);
            matchedFormat.referenceCount = 1;
            this.items.push(matchedFormat);
        }
        else {
            matchedFormat.referenceCount++;
        }
        this.remove(uniqueFormat);
        uniqueFormat = undefined;
        return matchedFormat;
    }
    /**
     * @private
     */
    remove(uniqueFormat) {
        uniqueFormat.referenceCount--;
        if (uniqueFormat.referenceCount <= 0) {
            this.items.splice(this.items.indexOf(uniqueFormat), 1);
            uniqueFormat.destroy();
            uniqueFormat = undefined;
        }
    }
    /**
     * @private
     */
    clear() {
        if (isNullOrUndefined(this.items)) {
            for (let i = 0; i < this.items.length; i++) {
                this.items[i].destroy();
            }
        }
        this.items = [];
    }
    /**
     * @private
     */
    destroy() {
        this.clear();
        this.items = undefined;
    }
}

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * The Document editor component is used to draft, save or print rich text contents as page by page.
 */
let DocumentEditor = DocumentEditor_1 = class DocumentEditor extends Component {
    /**
     * Initialize the constructor of DocumentEditor
     */
    constructor(options, element) {
        super(options, element);
        //Internal Variable
        this.enableHeaderFooterIn = false;
        /**
         * @private
         */
        this.isShiftingEnabled = false;
        /**
         * @private
         */
        this.isLayoutEnabled = true;
        /**
         * @private
         */
        this.isPastingContent = false;
        /**
         * @private
         */
        this.parser = undefined;
        this.disableHistoryIn = false;
        /**
         * @private
         */
        this.findResultsList = undefined;
        /**
         * Gets or sets the name of the document.
         */
        this.documentName = '';
        /**
         * @private
         */
        this.tablePropertiesDialogModule = undefined;
        /**
         * @private
         */
        this.bordersAndShadingDialogModule = undefined;
        /**
         * @private
         */
        this.cellOptionsDialogModule = undefined;
        /**
         * @private
         */
        this.tableOptionsDialogModule = undefined;
        /**
         * @private
         */
        this.paragraphDialogModule = undefined;
        /**
         * @private
         */
        this.imageResizerModule = undefined;
        /**
         * Gets or Sets a value indicating whether holding Ctrl key is required to follow hyperlink on click. The default value is true.
         */
        this.useCtrlClickToFollowHyperlink = true;
        /**
         * Gets or sets the page outline color.
         */
        this.pageOutline = '#000000';
        /**
         * Gets or sets a value indicating whether to enable cursor in document editor on read only state or not. The default value is false.
         */
        this.enableCursorOnReadOnly = false;
        /**
         * Gets or sets a value indicating whether local paste needs to be enabled or not.
         */
        this.enableLocalPaste = false;
        /**
         * @private
         */
        this.defaultLocale = {
            'Table': 'Table',
            'Row': 'Row',
            'Cell': 'Cell',
            'Ok': 'Ok',
            'Cancel': 'Cancel',
            'Size': 'Size',
            'Preferred Width': 'Preferred width',
            'Points': 'Points',
            'Percent': 'Percent',
            'Measure in': 'Measure in',
            'Alignment': 'Alignment',
            'Left': 'Left',
            'Center': 'Center',
            'Right': 'Right',
            'Justify': 'Justify',
            'Indent from left': 'Indent from left',
            'Borders and Shading': 'Borders and Shading',
            'Options': 'Options',
            'Specify height': 'Specify height',
            'At least': 'At least',
            'Exactly': 'Exactly',
            'Row height is': 'Row height is',
            'Allow row to break across pages': 'Allow row to break across pages',
            'Repeat as header row at the top of each page': 'Repeat as header row at the top of each page',
            'Vertical alignment': 'Vertical alignment',
            'Top': 'Top',
            'Bottom': 'Bottom',
            'Default cell margins': 'Default cell margins',
            'Default cell spacing': 'Default cell spacing',
            'Allow spacing between cells': 'Allow spacing between cells',
            'Cell margins': 'Cell margins',
            'Same as the whole table': 'Same as the whole table',
            'Borders': 'Borders',
            'None': 'None',
            'Single': 'Single',
            'Dot': 'Dot',
            'DashSmallGap': 'DashSmallGap',
            'DashLargeGap': 'DashLargeGap',
            'DashDot': 'DashDot',
            'DashDotDot': 'DashDotDot',
            'Double': 'Double',
            'Triple': 'Triple',
            'ThinThickSmallGap': 'ThinThickSmallGap',
            'ThickThinSmallGap': 'ThickThinSmallGap',
            'ThinThickThinSmallGap': 'ThinThickThinSmallGap',
            'ThinThickMediumGap': 'ThinThickMediumGap',
            'ThickThinMediumGap': 'ThickThinMediumGap',
            'ThinThickThinMediumGap': 'ThinThickThinMediumGap',
            'ThinThickLargeGap': 'ThinThickLargeGap',
            'ThickThinLargeGap': 'ThickThinLargeGap',
            'ThinThickThinLargeGap': 'ThinThickThinLargeGap',
            'SingleWavy': 'SingleWavy',
            'DoubleWavy': 'DoubleWavy',
            'DashDotStroked': 'DashDotStroked',
            'Emboss3D': 'Emboss3D',
            'Engrave3D': 'Engrave3D',
            'Outset': 'Outset',
            'Inset': 'Inset',
            'Thick': 'Thick',
            'Style': 'Style',
            'Width': 'Width',
            'Height': 'Height',
            'Letter': 'Letter',
            'Tabloid': 'Tabloid',
            'Legal': 'Legal',
            'Statement': 'Statement',
            'Executive': 'Executive',
            'A3': 'A3',
            'A4': 'A4',
            'A5': 'A5',
            'B4': 'B4',
            'B5': 'B5',
            'Custom Size': 'Custom size',
            'Different odd and even': 'Different odd and even',
            'Different first page': 'Different first page',
            'From edge': 'From edge',
            'Header': 'Header',
            'Footer': 'Footer',
            'Margin': 'Margins',
            'Paper': 'Paper',
            'Layout': 'Layout',
            'Orientation': 'Orientation',
            'Landscape': 'Landscape',
            'Portrait': 'Portrait',
            'Table Of Contents': 'Table Of Contents',
            'Show page numbers': 'Show page numbers',
            'Right align page numbers': 'Right align page numbers',
            'Nothing': 'Nothing',
            'Tab leader': 'Tab leader',
            'Show levels': 'Show levels',
            'Use hyperlinks instead of page numbers': 'Use hyperlinks instead of page numbers',
            'Build table of contents from': 'Build table of contents from',
            'Styles': 'Styles',
            'Available styles': 'Available styles',
            'TOC level': 'TOC level',
            'Heading': 'Heading',
            'List Paragraph': 'List Paragraph',
            'Normal': 'Normal',
            'Outline levels': 'Outline levels',
            'Table entry fields': 'Table entry fields',
            'Modify': 'Modify',
            'Color': 'Color',
            'Setting': 'Setting',
            'Box': 'Box',
            'All': 'All',
            'Custom': 'Custom',
            'Preview': 'Preview',
            'Shading': 'Shading',
            'Fill': 'Fill',
            'Apply To': 'Apply to',
            'Table Properties': 'Table Properties',
            'Cell Options': 'Cell Options',
            'Table Options': 'Table Options',
            'Insert Table': 'Insert Table',
            'Number of columns': 'Number of columns',
            'Number of rows': 'Number of rows',
            'Text to display': 'Text to display',
            'Address': 'Address',
            'Insert Hyperlink': 'Insert Hyperlink',
            'Edit Hyperlink': 'Edit Hyperlink',
            'Insert': 'Insert',
            'General': 'General',
            'Indentation': 'Indentation',
            'Before text': 'Before text',
            'Special': 'Special',
            'First line': 'First line',
            'Hanging': 'Hanging',
            'After text': 'After text',
            'By': 'By',
            'Before': 'Before',
            'Line Spacing': 'Line spacing',
            'After': 'After',
            'At': 'At',
            'Multiple': 'Multiple',
            'Spacing': 'Spacing',
            'Define new Multilevel list': 'Define new Multilevel list',
            'List level': 'List level',
            'Choose level to modify': 'Choose level to modify',
            'Level': 'Level',
            'Number format': 'Number format',
            'Number style for this level': 'Number style for this level',
            'Enter formatting for number': 'Enter formatting for number',
            'Start at': 'Start at',
            'Restart list after': 'Restart list after',
            'Position': 'Position',
            'Text indent at': 'Text indent at',
            'Aligned at': 'Aligned at',
            'Follow number with': 'Follow number with',
            'Tab character': 'Tab character',
            'Space': 'Space',
            'Arabic': 'Arabic',
            'UpRoman': 'UpRoman',
            'LowRoman': 'LowRoman',
            'UpLetter': 'UpLetter',
            'LowLetter': 'LowLetter',
            'Number': 'Number',
            'Leading zero': 'Leading zero',
            'Bullet': 'Bullet',
            'Ordinal': 'Ordinal',
            'Ordinal Text': 'Ordinal Text',
            'For East': 'For East',
            'No Restart': 'No Restart',
            'Font': 'Font',
            'Font style': 'Font style',
            'Underline style': 'Underline style',
            'Font color': 'Font color',
            'Effects': 'Effects',
            'Strikethrough': 'Strikethrough',
            'Superscript': 'Superscript',
            'Subscript': 'Subscript',
            'Double strikethrough': 'Double strikethrough',
            'Regular': 'Regular',
            'Bold': 'Bold',
            'Italic': 'Italic',
            'Cut': 'Cut',
            'Copy': 'Copy',
            'Paste': 'Paste',
            'Hyperlink': 'Hyperlink',
            'Open Hyperlink': 'Open Hyperlink',
            'Copy Hyperlink': 'Copy Hyperlink',
            'Remove Hyperlink': 'Remove Hyperlink',
            'Paragraph': 'Paragraph',
            'Merge Cells': 'Merge Cells',
            'Insert Above': 'Insert Above',
            'Insert Below': 'Insert Below',
            'Insert Left': 'Insert Left',
            'Insert Right': 'Insert Right',
            'Delete': 'Delete',
            'Delete Table': 'Delete Table',
            'Delete Row': 'Delete Row',
            'Delete Column': 'Delete Column',
            'File Name': 'File Name',
            'Format Type': 'Format Type',
            'Save': 'Save',
            'Navigation': 'Navigation',
            'Results': 'Results',
            'Replace': 'Replace',
            'Replace All': 'Replace All',
            'We replaced all': 'We replaced all',
            'Find': 'Find',
            'No matches': 'No matches',
            'All Done': 'All Done',
            'Result': 'Result',
            'of': 'of',
            'instances': 'instances',
            'with': 'with',
            'Click to follow link': 'Click to follow link',
            'Continue Numbering': 'Continue Numbering',
            'Bookmark name': 'Bookmark name',
            'Close': 'Close',
            'Restart At': 'Restart At',
            'Properties': 'Properties',
            'Name': 'Name',
            'Style type': 'Style type',
            'Style based on': 'Style based on',
            'Style for following paragraph': 'Style for following paragraph',
            'Formatting': 'Formatting',
            'Numbering and Bullets': 'Numbering and Bullets',
            'Numbering': 'Numbering',
            'Update Field': 'Update Field',
            'Edit Field': 'Edit Field',
            'Bookmark': 'Bookmark',
            'Page Setup': 'Page Setup',
            'No bookmarks found': 'No bookmarks found',
            'Number format tooltip information': 'Single-level number format: </br>[PREFIX]%[LEVELNUMBER][SUFFIX]</br>'
                + 'For example, "Chapter %1." will display numbering like</br>Chapter 1. Item</br>Chapter 2. Item</br>…'
                + '</br>Chapter N. Item</br>'
                + '</br>Multilevel number format:</br>[PREFIX]%[LEVELNUMBER][SUFFIX]+[PREFIX]%[LEVELNUMBER][SUFFIX]'
                + '</br>For example, "%1.%2." will display numbering like</br>1.1. Item</br>1.2. Item</br>…</br>1.N. Item',
            'Format': 'Format',
            'Create New Style': 'Create New Style',
            'Modify Style': 'Modify Style',
            'New': 'New',
            'Bullets': 'Bullets',
            'Use bookmarks': 'Use bookmarks',
            'Table of Contents': 'Table of Contents'
        };
        this.viewer = new PageLayoutViewer(this);
        this.parser = new SfdtReader(this.viewer);
    }
    /**
     * @private
     */
    get enableHeaderAndFooter() {
        return this.enableHeaderFooterIn;
    }
    set enableHeaderAndFooter(value) {
        this.enableHeaderFooterIn = value;
        this.viewer.updateScrollBars();
    }
    /**
     * Gets the total number of pages.
     */
    get pageCount() {
        if (!this.isDocumentLoaded || isNullOrUndefined(this.viewer)) {
            return 1;
        }
        return this.viewer.pages.length;
    }
    /**
     *  Gets the selection object of the document editor.
     * @returns Selection
     * @default undefined
     */
    get selection() {
        return this.selectionModule;
    }
    /**
     *  Gets the editor object of the document editor.
     * @returns Editor
     * @default undefined
     */
    get editor() {
        return this.editorModule;
    }
    /**
     * Gets the editor history object of the document editor.
     * @returns EditorHistory
     */
    get editorHistory() {
        return this.editorHistoryModule;
    }
    /**
     * Gets the search object of the document editor.
     * @returns { Search }
     */
    get search() {
        return this.searchModule;
    }
    /**
     * Gets the context menu object of the document editor.
     * @returns ContextMenu
     */
    get contextMenu() {
        return this.contextMenuModule;
    }
    /**
     * @private
     */
    get containerId() {
        return this.element.id;
    }
    /**
     * @private
     */
    get isDocumentLoaded() {
        return this.isDocumentLoadedIn;
    }
    set isDocumentLoaded(value) {
        this.isDocumentLoadedIn = value;
    }
    /**
     * Determines whether history needs to be enabled or not.
     * @default - false
     * @private
     */
    get enableHistoryMode() {
        return this.enableEditorHistory && !isNullOrUndefined(this.editorHistoryModule);
    }
    /**
     * Gets the start text position in the document.
     * @default undefined
     * @private
     */
    get documentStart() {
        if (!isNullOrUndefined(this.selectionModule)) {
            return this.selection.getDocumentStart();
        }
        return undefined;
    }
    /**
     * Gets the end text position in the document.
     * @default undefined
     * @private
     */
    get documentEnd() {
        if (!isNullOrUndefined(this.selectionModule)) {
            return this.selection.getDocumentEnd();
        }
        return undefined;
    }
    /**
     * @private
     */
    get isReadOnlyMode() {
        return this.isReadOnly || isNullOrUndefined(this.editorModule) || isNullOrUndefined(this.selectionModule);
    }
    /**
     * Specifies to enable image resizer option
     * default - false
     * @private
     */
    get enableImageResizerMode() {
        return this.enableImageResizer && !isNullOrUndefined(this.imageResizerModule);
    }
    preRender() {
        this.findResultsList = [];
        //pre render section
    }
    render() {
        this.viewer.initializeComponents();
        this.openBlank();
        if (!isNullOrUndefined(this.element)) {
            let container = this.element;
            container.style.minHeight = '200px';
            container.style.minWidth = '200px';
        }
    }
    /**
     * Get component name
     * @private
     */
    getModuleName() {
        return 'DocumentEditor';
    }
    /**
     * Called internally if any of the property value changed.
     * @private
     */
    onPropertyChanged(model, oldProp) {
        for (let prop of Object.keys(model)) {
            switch (prop) {
                case 'zoomFactor':
                    if (this.viewer) {
                        this.viewer.zoomFactor = model.zoomFactor;
                    }
                    break;
                case 'locale':
                    this.localizeDialogs();
                    break;
                case 'isReadOnly':
                    if (!isNullOrUndefined(this.optionsPaneModule) && this.optionsPaneModule.isOptionsPaneShow) {
                        this.optionsPaneModule.showHideOptionsPane(false);
                    }
                    break;
            }
        }
    }
    localizeDialogs() {
        if (this.locale !== '') {
            let l10n = new L10n('documenteditor', this.defaultLocale);
            l10n.setLocale(this.locale);
            setCulture(this.locale);
            if (this.optionsPaneModule) {
                this.optionsPaneModule.initOptionsPane(l10n);
            }
            if (this.paragraphDialogModule) {
                this.paragraphDialogModule.initParagraphDialog(l10n);
            }
            if (this.pageSetupDialogModule) {
                this.pageSetupDialogModule.initPageSetupDialog(l10n);
            }
            if (this.fontDialogModule) {
                this.fontDialogModule.initFontDialog(l10n);
            }
            if (this.hyperlinkDialogModule) {
                this.hyperlinkDialogModule.initHyperlinkDialog(l10n);
            }
            if (this.contextMenuModule) {
                this.contextMenuModule.initContextMenu(l10n);
            }
            if (this.listDialogModule) {
                this.listDialogModule.initListDialog(l10n);
            }
            if (this.tablePropertiesDialogModule) {
                this.tablePropertiesDialogModule.initTablePropertyDialog(l10n);
            }
            if (this.bordersAndShadingDialogModule) {
                this.bordersAndShadingDialogModule.initBordersAndShadingsDialog(l10n);
            }
            if (this.cellOptionsDialogModule) {
                this.cellOptionsDialogModule.initCellMarginsDialog(l10n);
            }
            if (this.tableOptionsDialogModule) {
                this.tableOptionsDialogModule.initTableOptionsDialog(l10n);
            }
            if (this.tableDialogModule) {
                this.tableDialogModule.initTableDialog(l10n);
            }
            if (this.styleDialogModule) {
                this.styleDialogModule.initStyleDialog(l10n);
            }
            if (this.tableOfContentsDialogModule) {
                this.tableOfContentsDialogModule.initTableOfContentDialog(l10n);
            }
        }
    }
    /**
     * Get the properties to be maintained in the persisted state.
     * @private
     */
    getPersistData() {
        return 'documenteditor';
    }
    clearPreservedCollectionsInViewer() {
        if (this.viewer instanceof LayoutViewer) {
            this.viewer.clearDocumentItems();
        }
    }
    /**
     * @private
     */
    getDocumentEditorElement() {
        return this.element;
    }
    /**
     * @private
     */
    fireContentChange() {
        let eventArgs = { source: this };
        this.trigger('contentChange', eventArgs);
    }
    /**
     * @private
     */
    fireDocumentChange() {
        let eventArgs = { source: this };
        this.trigger('documentChange', eventArgs);
    }
    /**
     * @private
     */
    fireSelectionChange() {
        if (!this.viewer.isCompositionStart && Browser.isDevice && this.editorModule) {
            this.editorModule.predictText();
        }
        let eventArgs = { source: this };
        this.trigger('selectionChange', eventArgs);
    }
    /**
     * @private
     */
    fireZoomFactorChange() {
        let eventArgs = { source: this };
        this.trigger('zoomFactorChange', eventArgs);
    }
    /**
     * @private
     */
    fireViewChange() {
        if (this.viewer && this.viewer.pages.length > 0) {
            if (this.viewer.visiblePages.length > 0) {
                let pages = this.viewer.visiblePages;
                let eventArgs = {
                    startPage: pages[0].index + 1,
                    endPage: pages[pages.length - 1].index + 1,
                    source: this
                };
                this.trigger('viewChange', eventArgs);
            }
        }
    }
    /**
     * Shows the Paragraph dialog
     * @private
     */
    showParagraphDialog(paragraphFormat) {
        if (this.paragraphDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.paragraphDialogModule.show(paragraphFormat);
        }
    }
    /**
     * Shows the margin dialog
     * @private
     */
    showPageSetupDialog() {
        if (this.pageSetupDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.pageSetupDialogModule.show();
        }
    }
    /**
     * Shows the font dialog
     * @private
     */
    showFontDialog(characterFormat) {
        if (this.fontDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.fontDialogModule.showFontDialog(characterFormat);
        }
    }
    /**
     * Shows the cell option dialog
     * @private
     */
    showCellOptionsDialog() {
        if (this.cellOptionsDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.cellOptionsDialogModule.show();
        }
    }
    /**
     * Shows the table options dialog.
     * @private
     */
    showTableOptionsDialog() {
        if (this.tableOptionsDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.tableOptionsDialogModule.show();
        }
    }
    /**
     * Shows insert table dialog
     * @private
     */
    showTableDialog() {
        if (this.tableDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.tableDialogModule.show();
        }
    }
    /**
     * Shows the table of content dialog
     * @private
     */
    showTableOfContentsDialog() {
        if (this.tableOfContentsDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.tableOfContentsDialogModule.show();
        }
    }
    /* tslint:enable:no-any */
    /**
     * Shows the style dialog
     * @private
     */
    showStyleDialog() {
        if (this.styleDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.styleDialogModule.show();
        }
    }
    /**
     * Shows the hyperlink dialog
     * @private
     */
    showHyperlinkDialog() {
        if (this.hyperlinkDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.hyperlinkDialogModule.show();
        }
    }
    /**
     * Shows the bookmark dialog.
     * @private
     */
    showBookmarkDialog() {
        if (this.bookmarkDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.bookmarkDialogModule.show();
        }
    }
    /**
     * Shows the styles dialog.
     * @private
     */
    showStylesDialog() {
        if (this.stylesDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.stylesDialogModule.show();
        }
    }
    /**
     * Shows the List dialog
     * @private
     */
    showListDialog() {
        if (this.listDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.listDialogModule.showListDialog();
        }
    }
    /**
     * Shows the table properties dialog
     * @private
     */
    showTablePropertiesDialog() {
        if (this.tablePropertiesDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.tablePropertiesDialogModule.show();
        }
    }
    /**
     * Shows the borders and shading dialog
     * @private
     */
    showBordersAndShadingDialog() {
        if (this.bordersAndShadingDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.bordersAndShadingDialogModule.show();
        }
    }
    //tslint:disable: max-func-body-length
    requiredModules() {
        let modules = [];
        if (this.enablePrint) {
            modules.push({
                member: 'Print', args: []
            });
        }
        if (this.enableSfdtExport || this.enableWordExport || this.enableTextExport || this.enableSelection || this.enableEditor) {
            modules.push({
                member: 'SfdtExport', args: [this.viewer]
            });
        }
        if (this.enableWordExport) {
            modules.push({
                member: 'WordExport', args: []
            });
        }
        if (this.enableTextExport) {
            modules.push({
                member: 'TextExport', args: []
            });
        }
        if (this.enableSelection || this.enableSearch || this.enableEditor) {
            modules.push({
                member: 'Selection', args: [this]
            });
            if (this.enableContextMenu) {
                modules.push({
                    member: 'ContextMenu', args: [this.viewer]
                });
            }
        }
        if (this.enableSearch) {
            modules.push({
                member: 'Search', args: [this]
            });
            if (this.enableOptionsPane) {
                modules.push({
                    member: 'OptionsPane', args: [this.viewer]
                });
            }
        }
        if (this.enableEditor) {
            modules.push({
                member: 'Editor', args: [this.viewer]
            });
            if (this.enableImageResizer) {
                modules.push({
                    member: 'ImageResizer', args: [this, this.viewer]
                });
            }
            if (this.enableEditorHistory) {
                modules.push({
                    member: 'EditorHistory', args: [this]
                });
            }
            if (this.enableHyperlinkDialog) {
                modules.push({
                    member: 'HyperlinkDialog', args: [this.viewer]
                });
            }
            if (this.enableTableDialog) {
                modules.push({
                    member: 'TableDialog', args: [this.viewer]
                });
            }
            if (this.enableBookmarkDialog) {
                modules.push({
                    member: 'BookmarkDialog', args: [this.viewer]
                });
            }
            if (this.enableTableOfContentsDialog) {
                modules.push({
                    member: 'TableOfContentsDialog', args: [this.viewer]
                });
            }
            if (this.enablePageSetupDialog) {
                modules.push({
                    member: 'PageSetupDialog', args: [this.viewer]
                });
            }
            if (this.enableStyleDialog) {
                modules.push({
                    member: 'StylesDialog', args: [this.viewer]
                });
                modules.push({
                    member: 'StyleDialog', args: [this.viewer]
                });
                modules.push({
                    member: 'BulletsAndNumberingDialog', args: [this.viewer]
                });
            }
            if (this.enableListDialog) {
                modules.push({
                    member: 'ListDialog', args: [this.viewer]
                });
            }
            if (this.enableParagraphDialog) {
                modules.push({
                    member: 'ParagraphDialog', args: [this.viewer]
                });
            }
            if (this.enableFontDialog) {
                modules.push({
                    member: 'FontDialog', args: [this.viewer]
                });
            }
            if (this.enableTablePropertiesDialog) {
                modules.push({
                    member: 'TablePropertiesDialog', args: [this.viewer]
                });
                modules.push({
                    member: 'CellOptionsDialog', args: [this.viewer]
                });
            }
            if (this.enableBordersAndShadingDialog) {
                modules.push({
                    member: 'BordersAndShadingDialog', args: [this.viewer]
                });
            }
            if (this.enableTableOptionsDialog) {
                modules.push({
                    member: 'TableOptionsDialog', args: [this.viewer]
                });
            }
        }
        return modules;
    }
    // Public Implementation Starts
    /**
     * Opens the given Sfdt text.
     * @param {string} sfdtText.
     */
    open(sfdtText) {
        if (!isNullOrUndefined(this.viewer)) {
            this.clearPreservedCollectionsInViewer();
            this.viewer.lists = [];
            this.viewer.abstractLists = [];
            this.viewer.styles = new WStyles();
            if (!isNullOrUndefined(sfdtText) && this.viewer) {
                this.viewer.onDocumentChanged(this.parser.convertJsonToDocument(sfdtText));
                if (this.editorModule) {
                    this.editorModule.intializeDefaultStyles();
                }
            }
        }
    }
    /**
     * Scrolls view to start of the given page number if exists.
     * @param  {number} pageNumber.
     * @returns void
     */
    scrollToPage(pageNumber) {
        if (isNullOrUndefined(this.viewer) || pageNumber < 1 || pageNumber > this.viewer.pages.length) {
            return false;
        }
        this.viewer.scrollToPage(pageNumber - 1);
        return true;
    }
    /**
     * Enables all the modules.
     * @returns void
     */
    enableAllModules() {
        this.enablePrint = this.enableSfdtExport = this.enableWordExport = this.enableTextExport
            = this.enableSelection = this.enableContextMenu = this.enableSearch = this.enableOptionsPane
                = this.enableEditor = this.enableImageResizer = this.enableEditorHistory
                    = this.enableHyperlinkDialog = this.enableTableDialog = this.enableBookmarkDialog
                        = this.enableTableOfContentsDialog = this.enablePageSetupDialog = this.enableStyleDialog
                            = this.enableListDialog = this.enableParagraphDialog = this.enableFontDialog
                                = this.enableTablePropertiesDialog = this.enableBordersAndShadingDialog
                                    = this.enableTableOptionsDialog = true;
        // tslint:disable-next-line:max-line-length
        DocumentEditor_1.Inject(Print, SfdtExport, WordExport, TextExport, Selection, Search, Editor, ImageResizer, EditorHistory, ContextMenu$1, OptionsPane, HyperlinkDialog, TableDialog, BookmarkDialog, TableOfContentsDialog, PageSetupDialog, StyleDialog, ListDialog, ParagraphDialog, BulletsAndNumberingDialog, FontDialog, TablePropertiesDialog, BordersAndShadingDialog, TableOptionsDialog, CellOptionsDialog, StylesDialog);
    }
    /**
     * Resizes the component and its sub elements based on given size or container size.
     * @param width
     * @param height
     */
    resize(width, height) {
        if (this.element) {
            if (!isNullOrUndefined(width) && width > 200) {
                this.element.style.width = width + 'px';
            }
            if (!isNullOrUndefined(height) && height > 200) {
                this.element.style.height = height + 'px';
            }
            if (this.viewer) {
                this.viewer.updateViewerSize();
            }
        }
    }
    /**
     * Shifts the focus to the document.
     */
    focusIn() {
        if (this.viewer) {
            this.viewer.updateFocus();
        }
    }
    /**
     * Fits the page based on given fit type.
     * @param  {PageFitType} pageFitType? - Default value of ‘pageFitType’ parameter is 'None'
     * @returns void
     */
    fitPage(pageFitType) {
        if (isNullOrUndefined(pageFitType)) {
            pageFitType = 'None';
        }
        if (this.viewer) {
            this.viewer.pageFitType = pageFitType;
        }
    }
    /**
     * Prints the document.
     * @param  {Window} printWindow? - Default value of 'printWindow' parameter is undefined.
     */
    print(printWindow) {
        if (isNullOrUndefined(this.viewer)) {
            throw new Error('Invalid operation.');
        }
        if (this.printModule) {
            this.printModule.print(this.viewer, printWindow);
        }
        else {
            throw new Error('Invalid operation. Print is not enabled.');
        }
    }
    /**
     * Serialize the data to JSON string.
     */
    serialize() {
        let json = '';
        if (this.enableSfdtExport && this.sfdtExportModule instanceof SfdtExport) {
            json = this.sfdtExportModule.serialize();
        }
        else {
            throw new Error('Invalid operation. Sfdt export is not enabled.');
        }
        return json;
    }
    /**
     * Saves the document.
     * @param {string} fileName
     * @param {FormatType} formatType
     */
    save(fileName, formatType) {
        fileName = fileName || 'Untitled';
        if (isNullOrUndefined(this.viewer)) {
            throw new Error('Invalid operation.');
        }
        if (formatType === 'Docx' && this.wordExportModule) {
            if (this.wordExportModule) {
                this.wordExportModule.save(this.viewer, fileName);
            }
        }
        else if (formatType === 'Txt' && this.textExportModule) {
            this.textExportModule.save(this.viewer, fileName);
        }
        else if (formatType === 'Sfdt' && this.enableSfdtExport && this.sfdtExportModule) {
            let jsonString = this.serialize();
            let blob = new Blob([jsonString], {
                type: 'application/json'
            });
            Save.save(fileName + '.sfdt', blob);
        }
        else {
            throw new Error('Invalid operation. Specified export is not enabled.');
        }
    }
    /**
     * Saves the document as blob.
     * @param {FormatType} formatType
     */
    saveAsBlob(formatType) {
        if (isNullOrUndefined(this.viewer)) {
            throw new Error('Invalid operation');
        }
        return new Promise((resolve, reject) => {
            if (formatType === 'Docx' && this.wordExportModule) {
                resolve(this.wordExportModule.saveAsBlob(this.viewer));
            }
            else if (formatType === 'Txt' && this.textExportModule) {
                resolve(this.textExportModule.saveAsBlob(this.viewer));
            }
            else if (formatType === 'Sfdt' && this.enableSfdtExport && this.sfdtExportModule) {
                resolve(this.sfdtExportModule.saveAsBlob(this.viewer));
            }
        });
    }
    /**
     * Opens a blank document.
     */
    openBlank() {
        let section = new BodyWidget();
        section.index = 0;
        section.sectionFormat = new WSectionFormat(section);
        let paragraph = new ParagraphWidget();
        paragraph.index = 0;
        paragraph.paragraphFormat = new WParagraphFormat(paragraph);
        paragraph.characterFormat = new WCharacterFormat(paragraph);
        section.childWidgets.push(paragraph);
        paragraph.containerWidget = section;
        let sections = [];
        sections.push(section);
        // tslint:disable-next-line:max-line-length
        let hfs = this.parser.parseHeaderFooter({ header: {}, footer: {}, evenHeader: {}, evenFooter: {}, firstPageHeader: {}, firstPageFooter: {} }, undefined);
        if (this.viewer) {
            this.clearPreservedCollectionsInViewer();
            this.viewer.headersFooters.push(hfs);
            this.viewer.onDocumentChanged(sections);
            if (this.editorModule) {
                this.editorModule.intializeDefaultStyles();
                let style = this.viewer.styles.findByName('Normal');
                paragraph.paragraphFormat.baseStyle = style;
                paragraph.paragraphFormat.listFormat.baseStyle = style;
            }
        }
    }
    /**
     * Gets the style names based on given style type.
     * @param styleType
     */
    getStyleNames(styleType) {
        if (this.viewer) {
            return this.viewer.styles.getStyleNames(styleType);
        }
        return [];
    }
    /**
     * Gets the style objects on given style type.
     * @param styleType
     */
    getStyles(styleType) {
        if (this.viewer) {
            return this.viewer.styles.getStyles(styleType);
        }
        return [];
    }
    /**
     * Shows the dialog.
     * @param {DialogType} dialogType
     * @returns void
     */
    showDialog(dialogType) {
        switch (dialogType) {
            case 'Hyperlink':
                this.showHyperlinkDialog();
                break;
            case 'Table':
                this.showTableDialog();
                break;
            case 'Bookmark':
                this.showBookmarkDialog();
                break;
            case 'TableOfContents':
                this.showTableOfContentsDialog();
                break;
            case 'PageSetup':
                this.showPageSetupDialog();
                break;
            case 'List':
                this.showListDialog();
                break;
            case 'Styles':
                this.showStylesDialog();
                break;
            case 'Style':
                this.showStyleDialog();
                break;
            case 'Paragraph':
                this.showParagraphDialog();
                break;
            case 'Font':
                this.showFontDialog();
                break;
            case 'TableProperties':
                this.showTablePropertiesDialog();
                break;
            case 'BordersAndShading':
                this.showBordersAndShadingDialog();
                break;
            case 'TableOptions':
                this.showTableOptionsDialog();
                break;
        }
    }
    /**
     * Shows the options pane.
     */
    showOptionsPane() {
        if (!isNullOrUndefined(this.optionsPaneModule) && !isNullOrUndefined(this.viewer)) {
            this.optionsPaneModule.showHideOptionsPane(true);
        }
    }
    /**
     * Destroys all managed resources used by this object.
     */
    destroy() {
        super.destroy();
        this.destroyDependentModules();
        if (!isNullOrUndefined(this.viewer)) {
            this.viewer.destroy();
        }
        this.viewer = undefined;
        if (!isNullOrUndefined(this.element)) {
            this.element.classList.remove('e-documenteditor');
            this.element.innerHTML = '';
        }
        this.element = undefined;
        this.findResultsList = [];
        this.findResultsList = undefined;
    }
    destroyDependentModules() {
        if (this.printModule) {
            this.printModule.destroy();
            this.printModule = undefined;
        }
        if (this.sfdtExportModule) {
            this.sfdtExportModule.destroy();
            this.sfdtExportModule = undefined;
        }
        if (this.optionsPaneModule) {
            this.optionsPaneModule.destroy();
            this.optionsPaneModule = undefined;
        }
        if (!isNullOrUndefined(this.hyperlinkDialogModule)) {
            this.hyperlinkDialogModule.destroy();
            this.hyperlinkDialogModule = undefined;
        }
        if (this.searchModule) {
            this.searchModule.destroy();
            this.searchModule = undefined;
        }
        if (this.contextMenuModule) {
            this.contextMenuModule.destroy();
            this.contextMenuModule = undefined;
        }
        if (this.editorModule) {
            this.editorModule.destroy();
            this.editorModule = undefined;
        }
        if (this.selectionModule) {
            this.selectionModule.destroy();
            this.selectionModule = undefined;
        }
        if (this.editorHistoryModule) {
            this.editorHistoryModule.destroy();
            this.editorHistoryModule = undefined;
        }
        if (!isNullOrUndefined(this.paragraphDialogModule)) {
            this.paragraphDialogModule.destroy();
            this.paragraphDialogModule = undefined;
        }
        if (this.pageSetupDialogModule) {
            this.pageSetupDialogModule.destroy();
            this.pageSetupDialogModule = undefined;
        }
        if (this.fontDialogModule) {
            this.fontDialogModule.destroy();
            this.fontDialogModule = undefined;
        }
        if (this.listDialogModule) {
            this.listDialogModule.destroy();
            this.listDialogModule = undefined;
        }
        if (this.imageResizerModule) {
            this.imageResizerModule.destroy();
            this.imageResizerModule = undefined;
        }
        if (this.tablePropertiesDialogModule) {
            this.tablePropertiesDialogModule.destroy();
            this.tablePropertiesDialogModule = undefined;
        }
        if (this.bordersAndShadingDialogModule) {
            this.bordersAndShadingDialogModule.destroy();
            this.bordersAndShadingDialogModule = undefined;
        }
        if (this.cellOptionsDialogModule) {
            this.cellOptionsDialogModule.destroy();
            this.cellOptionsDialogModule = undefined;
        }
        if (this.tableOptionsDialogModule) {
            this.tableOptionsDialogModule.destroy();
            this.tableOptionsDialogModule = undefined;
        }
        if (this.tableDialogModule) {
            this.tableDialogModule.destroy();
            this.tableDialogModule = undefined;
        }
        if (this.styleDialogModule) {
            this.styleDialogModule = undefined;
        }
        if (this.bookmarkDialogModule) {
            this.bookmarkDialogModule.destroy();
            this.bookmarkDialogModule = undefined;
        }
        if (this.styleDialogModule) {
            this.styleDialogModule.destroy();
            this.styleDialogModule = undefined;
        }
        if (this.textExportModule) {
            this.textExportModule.destroy();
            this.textExportModule = undefined;
        }
        if (this.wordExportModule) {
            this.wordExportModule.destroy();
            this.wordExportModule = undefined;
        }
        if (this.tableOfContentsDialogModule) {
            this.tableOfContentsDialogModule.destroy();
            this.tableOfContentsDialogModule = undefined;
        }
    }
};
__decorate([
    Property(1)
], DocumentEditor.prototype, "zoomFactor", void 0);
__decorate([
    Property(true)
], DocumentEditor.prototype, "isReadOnly", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enablePrint", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableSelection", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableEditor", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableEditorHistory", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableSfdtExport", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableWordExport", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableTextExport", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableOptionsPane", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableContextMenu", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableHyperlinkDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableBookmarkDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableTableOfContentsDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableSearch", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableParagraphDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableListDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableTablePropertiesDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableBordersAndShadingDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enablePageSetupDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableStyleDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableFontDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableTableOptionsDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableTableDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableImageResizer", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "documentChange", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "viewChange", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "zoomFactorChange", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "selectionChange", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "requestNavigate", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "contentChange", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "keyDown", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "searchResultsChange", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "created", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "destroyed", void 0);
DocumentEditor = DocumentEditor_1 = __decorate([
    NotifyPropertyChanges
], DocumentEditor);
var DocumentEditor_1;

/**
 * Print class
 */
class Print {
    /**
     * Gets module name.
     */
    getModuleName() {
        return 'Print';
    }
    /**
     * Prints the current viewer
     * @param viewer
     * @param printWindow
     * @private
     */
    print(viewer, printWindow) {
        this.printWindow(viewer, navigator.userAgent, printWindow);
    }
    /**
     * Opens print window and displays current page to print.
     * @private
     */
    printWindow(viewer, browserUserAgent, printWindow) {
        let height = this.getPageHeight(viewer.pages);
        let width = this.getPageWidth(viewer.pages);
        let printElement = document.createElement('div');
        printElement.style.width = '100%';
        printElement.style.height = '100%';
        printElement.style.overflow = 'scroll';
        // Rendering canvas to print
        this.generatePrintContent(viewer, printElement);
        if (isNullOrUndefined(printWindow)) {
            printWindow = window.open('', 'print', 'height=452,width=1024,tabbar=no');
        }
        if ((browserUserAgent.indexOf('Chrome') !== -1) || (browserUserAgent.indexOf('Firefox')) !== -1) {
            // Chrome and Firefox
            printWindow.document.write('<!DOCTYPE html>');
            // tslint:disable-next-line:max-line-length
            printWindow.document.write('<html moznomarginboxes mozdisallowselectionprint><head><style>html, body { height: 100 %; } img { height: 100 %; width: 100 %; display: block;}img { box-sizing: border-box; }br, button { display: none; }@page{ margin: 0cm; size:' + width.toString() + 'px ' + height.toString() + 'px; }@media print{ body { margin: 0cm; }</style></head> <body><center>');
        }
        else {
            // Internet Explorer and Edge
            // tslint:disable-next-line:max-line-length
            printWindow.document.write('<html><head><style>@page{margin:0;size:' + width.toString() + 'px ' + height.toString() + 'px;}</style></head><body><center>');
        }
        // tslint:disable-next-line:max-line-length
        printWindow.document.write(printElement.innerHTML + '</center><script> (function() { window.ready = true; })(); </script></body></html>');
        printElement = undefined;
        printWindow.document.close();
        printWindow.focus();
        let interval = setInterval(() => {
            if (printWindow.ready) {
                printWindow.print();
                printWindow.close();
                clearInterval(interval);
            }
        }, 500);
    }
    /**
     * Generates print content.
     * @private
     */
    generatePrintContent(viewer, element) {
        // Rendering canvas to print
        let htmlString = '';
        for (let i = 0; i < viewer.pages.length; i++) {
            let page = viewer.pages[i];
            let pageHeight = page.boundingRectangle.height;
            let pageWidth = page.boundingRectangle.width;
            viewer.render.isPrinting = true;
            viewer.render.renderWidgets(page, 0, 0, 0, 0);
            let canvasURL = viewer.render.pageCanvas.toDataURL();
            viewer.render.isPrinting = false;
            // tslint:disable-next-line:max-line-length
            htmlString += '<div><img src=' + canvasURL + ' style="margin:0px;display:block;width: ' + pageWidth.toString() + 'px; height:' + pageHeight.toString() + 'px; "/></div><br/>';
        }
        element.innerHTML = htmlString;
    }
    /**
     * Gets page width.
     * @param pages
     * @private
     */
    getPageWidth(pages) {
        let width = 0;
        for (let i = 0; i < pages.length; i++) {
            if (width < pages[i].boundingRectangle.width) {
                width = pages[i].boundingRectangle.width;
            }
        }
        return width;
    }
    /**
     *  Gets page height.
     * @private
     */
    getPageHeight(pages) {
        let height = 0;
        for (let i = 0; i < pages.length; i++) {
            if (height < pages[i].boundingRectangle.height) {
                height = pages[i].boundingRectangle.height;
            }
        }
        return height;
    }
    /**
     * @private
     */
    destroy() {
        return;
    }
}

/**
 * @private
 */
class WSectionFormat {
    constructor(node) {
        this.uniqueSectionFormat = undefined;
        this.ownerBase = node;
    }
    get headerDistance() {
        return this.getPropertyValue('headerDistance');
    }
    set headerDistance(value) {
        this.setPropertyValue('headerDistance', value);
    }
    get footerDistance() {
        return this.getPropertyValue('footerDistance');
    }
    set footerDistance(value) {
        this.setPropertyValue('footerDistance', value);
    }
    get differentFirstPage() {
        return this.getPropertyValue('differentFirstPage');
    }
    set differentFirstPage(value) {
        this.setPropertyValue('differentFirstPage', value);
    }
    get differentOddAndEvenPages() {
        return this.getPropertyValue('differentOddAndEvenPages');
    }
    set differentOddAndEvenPages(value) {
        this.setPropertyValue('differentOddAndEvenPages', value);
    }
    get pageHeight() {
        return this.getPropertyValue('pageHeight');
    }
    set pageHeight(value) {
        this.setPropertyValue('pageHeight', value);
    }
    get rightMargin() {
        return this.getPropertyValue('rightMargin');
    }
    set rightMargin(value) {
        this.setPropertyValue('rightMargin', value);
    }
    get pageWidth() {
        return this.getPropertyValue('pageWidth');
    }
    set pageWidth(value) {
        this.setPropertyValue('pageWidth', value);
    }
    get leftMargin() {
        return this.getPropertyValue('leftMargin');
    }
    set leftMargin(value) {
        this.setPropertyValue('leftMargin', value);
    }
    get bottomMargin() {
        return this.getPropertyValue('bottomMargin');
    }
    set bottomMargin(value) {
        this.setPropertyValue('bottomMargin', value);
    }
    get topMargin() {
        return this.getPropertyValue('topMargin');
    }
    set topMargin(value) {
        this.setPropertyValue('topMargin', value);
    }
    destroy() {
        if (!isNullOrUndefined(this.uniqueSectionFormat)) {
            WSectionFormat.uniqueSectionFormats.remove(this.uniqueSectionFormat);
        }
        this.uniqueSectionFormat = undefined;
    }
    hasValue(property) {
        if (!isNullOrUndefined(this.uniqueSectionFormat)) {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueSectionFormat.uniqueFormatType, property);
            return this.uniqueSectionFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    }
    static getPropertyDefaultValue(property) {
        let value = undefined;
        switch (property) {
            case 'headerDistance':
                value = 36;
                break;
            case 'footerDistance':
                value = 36;
                break;
            case 'differentFirstPage':
                value = false;
                break;
            case 'differentOddAndEvenPages':
                value = false;
                break;
            case 'pageWidth':
                value = 612;
                break;
            case 'pageHeight':
                value = 792;
                break;
            case 'leftMargin':
                value = 72;
                break;
            case 'topMargin':
                value = 72;
                break;
            case 'rightMargin':
                value = 72;
                break;
            case 'bottomMargin':
                value = 72;
                break;
        }
        return value;
    }
    getPropertyValue(property) {
        let hasValue = this.hasValue(property);
        if (hasValue) {
            let propertyType = WUniqueFormat.getPropertyType(WSectionFormat.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueSectionFormat) && this.uniqueSectionFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueSectionFormat.propertiesHash.get(propertyType);
            }
        }
        return WSectionFormat.getPropertyDefaultValue(property);
    }
    setPropertyValue(property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WSectionFormat.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueSectionFormat)) {
            this.initializeUniqueSectionFormat(property, value);
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueSectionFormat.uniqueFormatType, property);
            if (this.uniqueSectionFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueSectionFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            // tslint:disable-next-line:max-line-length
            this.uniqueSectionFormat = WSectionFormat.uniqueSectionFormats.updateUniqueFormat(this.uniqueSectionFormat, property, value);
        }
    }
    initializeUniqueSectionFormat(property, propValue) {
        let uniqueSectionFormatTemp = new Dictionary();
        this.addUniqueSectionFormat('headerDistance', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('footerDistance', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('differentFirstPage', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('differentOddAndEvenPages', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('pageWidth', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('pageHeight', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('leftMargin', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('topMargin', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('rightMargin', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('bottomMargin', property, propValue, uniqueSectionFormatTemp);
        // tslint:disable-next-line:max-line-length
        this.uniqueSectionFormat = WSectionFormat.uniqueSectionFormats.addUniqueFormat(uniqueSectionFormatTemp, WSectionFormat.uniqueFormatType);
    }
    // tslint:disable-next-line:max-line-length
    addUniqueSectionFormat(property, modifiedProperty, propValue, uniqueSectionFormatTemp) {
        let propertyType;
        propertyType = WUniqueFormat.getPropertyType(WSectionFormat.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueSectionFormatTemp.add(propertyType, propValue);
        }
        else {
            uniqueSectionFormatTemp.add(propertyType, WSectionFormat.getPropertyDefaultValue(property));
        }
    }
    copyFormat(format, history) {
        if (history && (history.isUndoing || history.isRedoing)) {
            this.uniqueSectionFormat = format.uniqueSectionFormat;
        }
        else {
            if (!isNullOrUndefined(format)) {
                if (!isNullOrUndefined(format.uniqueSectionFormat) && format.uniqueSectionFormat.propertiesHash) {
                    this.updateUniqueSectionFormat(format);
                }
            }
        }
    }
    updateUniqueSectionFormat(format) {
        let hash = undefined;
        if (this.uniqueSectionFormat) {
            hash = this.uniqueSectionFormat.mergeProperties(format.uniqueSectionFormat);
            if (this.uniqueSectionFormat.referenceCount === 0) {
                WSectionFormat.uniqueSectionFormats.remove(this.uniqueSectionFormat);
                this.uniqueSectionFormat = undefined;
            }
        }
        this.uniqueSectionFormat = new WUniqueFormat(WSectionFormat.uniqueFormatType);
        if (isNullOrUndefined(hash)) {
            hash = this.uniqueSectionFormat.mergeProperties(format.uniqueSectionFormat);
        }
        this.uniqueSectionFormat = WSectionFormat.uniqueSectionFormats.addUniqueFormat(hash, WSectionFormat.uniqueFormatType);
    }
    cloneFormat() {
        let format = new WSectionFormat();
        format.uniqueSectionFormat = this.uniqueSectionFormat;
        return format;
    }
    static clear() {
        this.uniqueSectionFormats.clear();
    }
}
WSectionFormat.uniqueSectionFormats = new WUniqueFormats();
WSectionFormat.uniqueFormatType = 10;

/**
 * @private
 */
class WLevelOverride {
    destroy() {
        if (!isNullOrUndefined(this.overrideListLevel)) {
            this.overrideListLevel.destroy();
        }
        this.levelNumber = undefined;
        this.startAt = undefined;
        this.overrideListLevel = undefined;
    }
}

/**
 * @private
 */
class WList {
    constructor() {
        this.listId = -1;
        this.sourceListId = -1;
        this.abstractListId = -1;
        this.abstractList = undefined;
        this.levelOverrides = [];
    }
    getListLevel(levelNumber) {
        let listLevel = undefined;
        let levelOverride = this.getLevelOverride(levelNumber);
        if (!isNullOrUndefined(levelOverride) && !isNullOrUndefined(levelOverride.overrideListLevel)) {
            listLevel = levelOverride.overrideListLevel;
        }
        else {
            listLevel = this.abstractList.levels[levelNumber];
        }
        return listLevel;
    }
    getLevelOverride(levelNumber) {
        for (let i = 0; i < this.levelOverrides.length; i++) {
            if (this.levelOverrides[i] instanceof WLevelOverride) {
                let levelOverride = this.levelOverrides[i];
                if (levelOverride.levelNumber === levelNumber) {
                    return levelOverride;
                }
            }
        }
        return undefined;
    }
    destroy() {
        if (!isNullOrUndefined(this.levelOverrides)) {
            this.levelOverrides = [];
        }
        this.abstractListId = undefined;
        this.listId = undefined;
        this.sourceListId = undefined;
        this.levelOverrides = undefined;
    }
    mergeList(list) {
        if (!isNullOrUndefined(this.abstractListId) && this.abstractListId !== -1) {
            this.abstractListId = list.abstractListId;
        }
        if (!isNullOrUndefined(this.listId) && this.listId !== -1) {
            this.listId = list.listId;
        }
        if (!isNullOrUndefined(this.sourceListId) && this.sourceListId !== -1) {
            this.sourceListId = list.sourceListId;
        }
        if (!isNullOrUndefined(this.levelOverrides) && this.levelOverrides.length !== 0) {
            this.levelOverrides = list.levelOverrides;
        }
    }
}

/**
 * @private
 */
class WListFormat {
    constructor(node) {
        this.uniqueListFormat = undefined;
        this.ownerBase = undefined;
        this.baseStyle = undefined;
        this.list = undefined;
        this.ownerBase = node;
    }
    get listId() {
        return this.getPropertyValue('listId');
    }
    set listId(listId) {
        this.setPropertyValue('listId', listId);
    }
    get listLevelNumber() {
        return this.getPropertyValue('listLevelNumber');
    }
    set listLevelNumber(value) {
        this.setPropertyValue('listLevelNumber', value);
    }
    get listLevel() {
        let list = undefined;
        if (!isNullOrUndefined(this.list)) {
            list = this.list;
        }
        else {
            /* tslint:disable-next-line:no-any */
            let baseListStyle = this.baseStyle;
            while (!isNullOrUndefined(baseListStyle)) {
                if (baseListStyle.paragraphFormat.listFormat.list) {
                    list = baseListStyle.paragraphFormat.listFormat.list;
                    break;
                }
                else {
                    baseListStyle = baseListStyle.basedOn;
                }
            }
        }
        if (!isNullOrUndefined(list)) {
            return list.getListLevel(this.listLevelNumber);
        }
        else {
            return undefined;
        }
    }
    getPropertyValue(property) {
        if (!this.hasValue(property)) {
            if (this.baseStyle instanceof WParagraphStyle) {
                /* tslint:disable-next-line:no-any */
                let baseStyle = this.baseStyle;
                while (!isNullOrUndefined(baseStyle)) {
                    if (baseStyle.paragraphFormat.listFormat.hasValue(property)) {
                        break;
                    }
                    else {
                        baseStyle = baseStyle.basedOn;
                    }
                }
                if (!isNullOrUndefined(baseStyle)) {
                    let propertyType = WUniqueFormat.getPropertyType(WListFormat.uniqueFormatType, property);
                    return baseStyle.paragraphFormat.listFormat.uniqueListFormat.propertiesHash.get(propertyType);
                }
            }
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(WListFormat.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueListFormat) && this.uniqueListFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueListFormat.propertiesHash.get(propertyType);
            }
        }
        return WListFormat.getPropertyDefaultValue(property);
    }
    setPropertyValue(property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WListFormat.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueListFormat)) {
            this.initializeUniqueListFormat(property, value);
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueListFormat.uniqueFormatType, property);
            if (this.uniqueListFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueListFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            this.uniqueListFormat = WListFormat.uniqueListFormats.updateUniqueFormat(this.uniqueListFormat, property, value);
        }
    }
    initializeUniqueListFormat(property, propValue) {
        let uniqueListFormatTemp = new Dictionary();
        this.addUniqueListFormat('listId', property, propValue, uniqueListFormatTemp);
        this.addUniqueListFormat('listLevelNumber', property, propValue, uniqueListFormatTemp);
        this.uniqueListFormat = WListFormat.uniqueListFormats.addUniqueFormat(uniqueListFormatTemp, WListFormat.uniqueFormatType);
    }
    // tslint:disable-next-line:max-line-length
    addUniqueListFormat(property, modifiedProperty, propValue, uniqueListFormatTemp) {
        let propertyType;
        propertyType = WUniqueFormat.getPropertyType(WListFormat.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueListFormatTemp.add(propertyType, propValue);
        }
    }
    static getPropertyDefaultValue(property) {
        let value = undefined;
        switch (property) {
            case 'listId':
                value = -1;
                break;
            case 'listLevelNumber':
                value = 0;
                break;
        }
        return value;
    }
    copyFormat(format) {
        if (!isNullOrUndefined(format)) {
            if (!isNullOrUndefined(format.uniqueListFormat)) {
                this.listId = format.listId;
                this.listLevelNumber = format.listLevelNumber;
            }
            if (!isNullOrUndefined(format.baseStyle)) {
                this.baseStyle = format.baseStyle;
            }
            if (!isNullOrUndefined(format.list)) {
                this.list = format.list;
            }
        }
    }
    hasValue(property) {
        if (!isNullOrUndefined(this.uniqueListFormat)) {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueListFormat.uniqueFormatType, property);
            return this.uniqueListFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    }
    clearFormat() {
        if (!isNullOrUndefined(this.uniqueListFormat) && this.uniqueListFormat.referenceCount === 0) {
            WListFormat.uniqueListFormats.remove(this.uniqueListFormat);
        }
        this.uniqueListFormat = undefined;
        this.list = undefined;
    }
    destroy() {
        this.clearFormat();
    }
    static clear() {
        this.uniqueListFormats.clear();
    }
    ApplyStyle(baseStyle) {
        this.baseStyle = baseStyle;
    }
    /**
     * For internal use
     * @private
     */
    getValue(property) {
        return this.hasValue(property) ? this.getPropertyValue(property) : undefined;
    }
    /**
     * For internal use
     * @private
     */
    mergeFormat(format) {
        if (isNullOrUndefined(this.getValue('listId'))) {
            this.listId = format.getValue('listId');
        }
        if (isNullOrUndefined(this.getValue('listLevelNumber'))) {
            this.listLevelNumber = format.getValue('listLevelNumber');
        }
        if (!isNullOrUndefined(format.list)) {
            if (isNullOrUndefined(this.list)) {
                this.list = new WList();
            }
            this.list.mergeList(format.list);
        }
    }
}
WListFormat.uniqueListFormats = new WUniqueFormats();
WListFormat.uniqueFormatType = 7;

/**
 * @private
 */
class WTabStop {
    get position() {
        return this.positionIn;
    }
    set position(value) {
        this.positionIn = value;
    }
    get deletePosition() {
        return this.deletePositionIn;
    }
    set deletePosition(value) {
        this.deletePositionIn = value;
    }
    get tabJustification() {
        return this.justification;
    }
    set tabJustification(value) {
        this.justification = value;
    }
    get tabLeader() {
        return this.leader;
    }
    set tabLeader(value) {
        this.leader = value;
    }
    destroy() {
        this.position = undefined;
        this.deletePosition = undefined;
        this.tabJustification = undefined;
        this.leader = undefined;
    }
}
/**
 * @private
 */
class WParagraphFormat {
    constructor(node) {
        this.uniqueParagraphFormat = undefined;
        this.ownerBase = undefined;
        this.baseStyle = undefined;
        this.tabs = undefined;
        this.ownerBase = node;
        this.listFormat = new WListFormat(this);
        this.tabs = [];
    }
    getUpdatedTabs() {
        let inTabs = [];
        if (!isNullOrUndefined(this.baseStyle)) {
            /* tslint:disable-next-line:no-any */
            let baseStyle = this.baseStyle;
            let tabStops = new Dictionary();
            while (!isNullOrUndefined(baseStyle)) {
                for (let tab of baseStyle.paragraphFormat.tabs) {
                    if (!tabStops.containsKey(tab.position)) {
                        tabStops.add(tab.position, tab);
                    }
                }
                baseStyle = baseStyle.basedOn;
            }
            for (let key of tabStops.keys) {
                if (!this.hasTabStop(key)) {
                    inTabs.push(tabStops.get(key));
                }
            }
            inTabs = inTabs.concat(this.tabs.filter((a) => (a.position !== 0 && a.deletePosition === 0)));
            inTabs = inTabs.sort((a, b) => a.position - b.position);
        }
        return inTabs;
    }
    hasTabStop(position) {
        for (let i = 0; i < this.tabs.length; i++) {
            if (this.tabs[i].deletePosition === position) {
                return true;
            }
        }
        return false;
    }
    get leftIndent() {
        return this.getPropertyValue('leftIndent');
    }
    set leftIndent(value) {
        this.setPropertyValue('leftIndent', value);
    }
    get rightIndent() {
        return this.getPropertyValue('rightIndent');
    }
    set rightIndent(value) {
        this.setPropertyValue('rightIndent', value);
    }
    get firstLineIndent() {
        return this.getPropertyValue('firstLineIndent');
    }
    set firstLineIndent(value) {
        this.setPropertyValue('firstLineIndent', value);
    }
    get beforeSpacing() {
        return this.getPropertyValue('beforeSpacing');
    }
    set beforeSpacing(value) {
        this.setPropertyValue('beforeSpacing', value);
    }
    get afterSpacing() {
        return this.getPropertyValue('afterSpacing');
    }
    set afterSpacing(value) {
        this.setPropertyValue('afterSpacing', value);
    }
    get lineSpacing() {
        return this.getPropertyValue('lineSpacing');
    }
    set lineSpacing(value) {
        this.setPropertyValue('lineSpacing', value);
    }
    get lineSpacingType() {
        return this.getPropertyValue('lineSpacingType');
    }
    set lineSpacingType(value) {
        this.setPropertyValue('lineSpacingType', value);
    }
    get textAlignment() {
        return this.getPropertyValue('textAlignment');
    }
    set textAlignment(value) {
        this.setPropertyValue('textAlignment', value);
    }
    get outlineLevel() {
        return this.getPropertyValue('outlineLevel');
    }
    set outlineLevel(value) {
        this.setPropertyValue('outlineLevel', value);
    }
    getListFormatParagraphFormat(property) {
        if (this.listFormat.listId > -1 && this.listFormat.listLevelNumber > -1) {
            let level = this.listFormat.listLevel;
            let propertyType = WUniqueFormat.getPropertyType(WParagraphFormat.uniqueFormatType, property);
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(level) && !isNullOrUndefined(level.paragraphFormat.uniqueParagraphFormat) && level.paragraphFormat.uniqueParagraphFormat.propertiesHash.containsKey(propertyType)) {
                return level.paragraphFormat.uniqueParagraphFormat.propertiesHash.get(propertyType);
            }
            else {
                return undefined;
            }
        }
        return undefined;
    }
    getPropertyValue(property) {
        if (!this.hasValue(property)) {
            let ifListFormat = this.getListFormatParagraphFormat(property);
            if (!isNullOrUndefined(ifListFormat)) {
                return ifListFormat;
            }
            else {
                if (this.baseStyle instanceof WParagraphStyle) {
                    /* tslint:disable-next-line:no-any */
                    let baseStyle = this.baseStyle;
                    while (!isNullOrUndefined(baseStyle)) {
                        if (baseStyle.paragraphFormat.hasValue(property)) {
                            break;
                        }
                        else {
                            baseStyle = baseStyle.basedOn;
                        }
                    }
                    if (!isNullOrUndefined(baseStyle)) {
                        let propertyType = WUniqueFormat.getPropertyType(WParagraphFormat.uniqueFormatType, property);
                        return baseStyle.paragraphFormat.uniqueParagraphFormat.propertiesHash.get(propertyType);
                    }
                }
            }
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(WParagraphFormat.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueParagraphFormat) && this.uniqueParagraphFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueParagraphFormat.propertiesHash.get(propertyType);
            }
        }
        return this.getDefaultValue(property);
    }
    getDefaultValue(property) {
        let propertyType = WUniqueFormat.getPropertyType(WParagraphFormat.uniqueFormatType, property);
        let docParagraphFormat = this.documentParagraphFormat();
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(docParagraphFormat) && !isNullOrUndefined(docParagraphFormat.uniqueParagraphFormat) && docParagraphFormat.uniqueParagraphFormat.propertiesHash.containsKey(propertyType)) {
            return docParagraphFormat.uniqueParagraphFormat.propertiesHash.get(propertyType);
        }
        else {
            return WParagraphFormat.getPropertyDefaultValue(property);
        }
    }
    documentParagraphFormat() {
        let docParagraphFormat;
        if (!isNullOrUndefined(this.ownerBase)) {
            if (!isNullOrUndefined(this.ownerBase.bodyWidget)) {
                docParagraphFormat = this.ownerBase.bodyWidget.page.viewer.paragraphFormat;
            }
        }
        return docParagraphFormat;
    }
    setPropertyValue(property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WParagraphFormat.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueParagraphFormat)) {
            this.initializeUniqueParagraphFormat(property, value);
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueParagraphFormat.uniqueFormatType, property);
            if (this.uniqueParagraphFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueParagraphFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            // tslint:disable-next-line:max-line-length
            this.uniqueParagraphFormat = WParagraphFormat.uniqueParagraphFormats.updateUniqueFormat(this.uniqueParagraphFormat, property, value);
        }
    }
    initializeUniqueParagraphFormat(property, propValue) {
        let uniqueParaFormatTemp = new Dictionary();
        this.addUniqueParaFormat('leftIndent', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('rightIndent', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('firstLineIndent', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('textAlignment', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('beforeSpacing', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('afterSpacing', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('lineSpacing', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('lineSpacingType', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('outlineLevel', property, propValue, uniqueParaFormatTemp);
        // tslint:disable-next-line:max-line-length
        this.uniqueParagraphFormat = WParagraphFormat.uniqueParagraphFormats.addUniqueFormat(uniqueParaFormatTemp, WParagraphFormat.uniqueFormatType);
    }
    // tslint:disable-next-line:max-line-length
    addUniqueParaFormat(property, modifiedProperty, propValue, uniqueParaFormatTemp) {
        let propertyType;
        propertyType = WUniqueFormat.getPropertyType(WParagraphFormat.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueParaFormatTemp.add(propertyType, propValue);
        }
    }
    static getPropertyDefaultValue(property) {
        let value = undefined;
        switch (property) {
            case 'leftIndent':
                value = 0;
                break;
            case 'rightIndent':
                value = 0;
                break;
            case 'firstLineIndent':
                value = 0;
                break;
            case 'textAlignment':
                value = 'Left';
                break;
            case 'beforeSpacing':
                value = 0;
                break;
            case 'afterSpacing':
                value = 0;
                break;
            case 'lineSpacing':
                value = 1;
                break;
            case 'lineSpacingType':
                value = 'Multiple';
                break;
            case 'styleName':
                value = 'Normal';
                break;
            case 'outlineLevel':
                value = 'BodyText';
                break;
        }
        return value;
    }
    clearFormat() {
        if (!isNullOrUndefined(this.listFormat)) {
            this.listFormat.clearFormat();
        }
        if (!isNullOrUndefined(this.uniqueParagraphFormat) && this.uniqueParagraphFormat.referenceCount === 0) {
            WParagraphFormat.uniqueParagraphFormats.remove(this.uniqueParagraphFormat);
        }
        this.uniqueParagraphFormat = undefined;
        this.baseStyle = undefined;
    }
    destroy() {
        this.clearFormat();
        if (!isNullOrUndefined(this.listFormat)) {
            this.listFormat.destroy();
        }
        this.listFormat = undefined;
        if (this.tabs !== undefined) {
            for (let i = 0; i < this.tabs.length; i++) {
                this.tabs[i].destroy();
            }
            this.tabs = undefined;
        }
    }
    copyFormat(format) {
        if (!isNullOrUndefined(format)) {
            if (!isNullOrUndefined(format.uniqueParagraphFormat)) {
                this.updateUniqueParagraphFormat(format);
            }
            if (!isNullOrUndefined(format.listFormat)) {
                this.listFormat.copyFormat(format.listFormat);
            }
            if (!isNullOrUndefined(format.baseStyle)) {
                this.baseStyle = format.baseStyle;
            }
            if (!isNullOrUndefined(format.tabs)) {
                for (let i = 0; i < format.tabs.length; i++) {
                    this.tabs[i] = format.tabs[i];
                }
            }
        }
    }
    updateUniqueParagraphFormat(format) {
        let hash = undefined;
        if (this.uniqueParagraphFormat) {
            hash = this.uniqueParagraphFormat.mergeProperties(format.uniqueParagraphFormat);
            if (this.uniqueParagraphFormat.referenceCount === 0) {
                WParagraphFormat.uniqueParagraphFormats.remove(this.uniqueParagraphFormat);
                this.uniqueParagraphFormat = undefined;
            }
        }
        this.uniqueParagraphFormat = new WUniqueFormat(WParagraphFormat.uniqueFormatType);
        if (isNullOrUndefined(hash)) {
            hash = this.uniqueParagraphFormat.mergeProperties(format.uniqueParagraphFormat);
        }
        this.uniqueParagraphFormat = WParagraphFormat.uniqueParagraphFormats.addUniqueFormat(hash, WParagraphFormat.uniqueFormatType);
    }
    cloneFormat() {
        let format = new WParagraphFormat(undefined);
        format.uniqueParagraphFormat = this.uniqueParagraphFormat;
        format.baseStyle = this.baseStyle;
        if (isNullOrUndefined(this.listFormat)) {
            format.listFormat = undefined;
        }
        else {
            format.listFormat = new WListFormat();
            format.listFormat.listId = this.listFormat.listId;
            format.listFormat.listLevelNumber = this.listFormat.listLevelNumber;
        }
        return format;
    }
    hasValue(property) {
        if (!isNullOrUndefined(this.uniqueParagraphFormat) && !isNullOrUndefined(this.uniqueParagraphFormat.propertiesHash)) {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueParagraphFormat.uniqueFormatType, property);
            return this.uniqueParagraphFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    }
    static clear() {
        this.uniqueParagraphFormats.clear();
    }
    ApplyStyle(baseStyle) {
        this.baseStyle = baseStyle;
        this.listFormat.ApplyStyle(this.baseStyle);
    }
    /**
     * For internal use
     * @private
     */
    getValue(property) {
        return this.hasValue(property) ? this.getPropertyValue(property) : undefined;
    }
    /**
     * For internal use
     * @private
     */
    mergeFormat(format) {
        if (isNullOrUndefined(this.getValue('leftIndent'))) {
            this.leftIndent = format.getValue('leftIndent');
        }
        if (isNullOrUndefined(this.getValue('rightIndent'))) {
            this.rightIndent = format.getValue('rightIndent');
        }
        if (isNullOrUndefined(this.getValue('firstLineIndent'))) {
            this.firstLineIndent = format.getValue('firstLineIndent');
        }
        if (isNullOrUndefined(this.getValue('beforeSpacing'))) {
            this.beforeSpacing = format.getValue('beforeSpacing');
        }
        if (isNullOrUndefined(this.getValue('afterSpacing'))) {
            this.afterSpacing = format.getValue('afterSpacing');
        }
        if (isNullOrUndefined(this.getValue('lineSpacing'))) {
            this.lineSpacing = format.getValue('lineSpacing');
        }
        if (isNullOrUndefined(this.getValue('lineSpacingType'))) {
            this.lineSpacingType = format.getValue('lineSpacingType');
        }
        if (isNullOrUndefined(this.getValue('textAlignment'))) {
            this.textAlignment = format.getValue('textAlignment');
        }
        if (isNullOrUndefined(this.getValue('outlineLevel'))) {
            this.outlineLevel = format.getValue('outlineLevel');
        }
        if (isNullOrUndefined(this.listFormat)) {
            this.listFormat.mergeFormat(format.listFormat);
        }
    }
}
WParagraphFormat.uniqueParagraphFormats = new WUniqueFormats();
WParagraphFormat.uniqueFormatType = 3;

/**
 * @private
 */
class WCharacterFormat {
    constructor(node) {
        this.uniqueCharacterFormat = undefined;
        this.ownerBase = undefined;
        this.baseCharStyle = undefined;
        this.ownerBase = node;
    }
    get bold() {
        return this.getPropertyValue('bold');
    }
    set bold(value) {
        this.setPropertyValue('bold', value);
    }
    get italic() {
        return this.getPropertyValue('italic');
    }
    set italic(value) {
        this.setPropertyValue('italic', value);
    }
    get fontSize() {
        return this.getPropertyValue('fontSize');
    }
    set fontSize(value) {
        this.setPropertyValue('fontSize', value);
    }
    get fontFamily() {
        return this.getPropertyValue('fontFamily');
    }
    set fontFamily(value) {
        this.setPropertyValue('fontFamily', value);
    }
    get underline() {
        return this.getPropertyValue('underline');
    }
    set underline(value) {
        this.setPropertyValue('underline', value);
    }
    get strikethrough() {
        return this.getPropertyValue('strikethrough');
    }
    set strikethrough(value) {
        this.setPropertyValue('strikethrough', value);
    }
    get baselineAlignment() {
        return this.getPropertyValue('baselineAlignment');
    }
    set baselineAlignment(value) {
        this.setPropertyValue('baselineAlignment', value);
    }
    get highlightColor() {
        return this.getPropertyValue('highlightColor');
    }
    set highlightColor(value) {
        this.setPropertyValue('highlightColor', value);
    }
    get fontColor() {
        return this.getPropertyValue('fontColor');
    }
    set fontColor(value) {
        this.setPropertyValue('fontColor', value);
    }
    getPropertyValue(property) {
        if (!this.hasValue(property)) {
            let charStyleValue = this.checkCharacterStyle(property);
            if (!isNullOrUndefined(charStyleValue)) {
                return charStyleValue;
            }
            else {
                let baseStyleValue = this.checkBaseStyle(property);
                if (!isNullOrUndefined(baseStyleValue)) {
                    return baseStyleValue;
                }
            }
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(WCharacterFormat.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueCharacterFormat) && this.uniqueCharacterFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueCharacterFormat.propertiesHash.get(propertyType);
            }
        }
        return this.getDefaultValue(property);
    }
    getDefaultValue(property) {
        let propertyType = WUniqueFormat.getPropertyType(WCharacterFormat.uniqueFormatType, property);
        let docCharacterFormat = this.documentCharacterFormat();
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(docCharacterFormat) && !isNullOrUndefined(docCharacterFormat.uniqueCharacterFormat) && docCharacterFormat.uniqueCharacterFormat.propertiesHash.containsKey(propertyType)) {
            return docCharacterFormat.uniqueCharacterFormat.propertiesHash.get(propertyType);
        }
        else {
            return WCharacterFormat.getPropertyDefaultValue(property);
        }
    }
    documentCharacterFormat() {
        let docCharacterFormat;
        if (!isNullOrUndefined(this.ownerBase)) {
            if (!isNullOrUndefined(this.ownerBase.paragraph)) {
                docCharacterFormat = this.ownerBase.paragraph.bodyWidget.page.viewer.characterFormat;
            }
            else {
                if (!isNullOrUndefined(this.ownerBase.bodyWidget)) {
                    docCharacterFormat = this.ownerBase.bodyWidget.page.viewer.characterFormat;
                }
            }
        }
        return docCharacterFormat;
    }
    checkBaseStyle(property) {
        /* tslint:disable-next-line:no-any */
        let baseStyle;
        if (!isNullOrUndefined(this.ownerBase)) {
            if (!isNullOrUndefined(this.ownerBase.paragraph)) {
                baseStyle = this.ownerBase.paragraph.paragraphFormat.baseStyle;
            }
            else {
                // tslint:disable-next-line:max-line-length
                if ((this.ownerBase instanceof ParagraphWidget) && !isNullOrUndefined(this.ownerBase.paragraphFormat)) {
                    baseStyle = this.ownerBase.paragraphFormat.baseStyle;
                }
                else {
                    if (!isNullOrUndefined(this.ownerBase instanceof WParagraphStyle)) {
                        baseStyle = this.ownerBase.basedOn;
                    }
                }
            }
        }
        while (!isNullOrUndefined(baseStyle)) {
            if (baseStyle.characterFormat.hasValue(property)) {
                break;
            }
            else {
                baseStyle = baseStyle.basedOn;
            }
        }
        if (!isNullOrUndefined(baseStyle)) {
            let propertyType = WUniqueFormat.getPropertyType(WCharacterFormat.uniqueFormatType, property);
            return baseStyle.characterFormat.uniqueCharacterFormat.propertiesHash.get(propertyType);
        }
        return undefined;
    }
    checkCharacterStyle(property) {
        /* tslint:disable-next-line:no-any */
        let baseStyle = this.baseCharStyle;
        if (!isNullOrUndefined(baseStyle)) {
            while (!isNullOrUndefined(baseStyle) && baseStyle.name !== 'Default Paragraph Font') {
                let hasKey = baseStyle.characterFormat.hasValue(property);
                if (hasKey) {
                    let returnPropertyType = WUniqueFormat.getPropertyType(WCharacterFormat.uniqueFormatType, property);
                    return baseStyle.characterFormat.uniqueCharacterFormat.propertiesHash.get(returnPropertyType);
                }
                else {
                    baseStyle = baseStyle.basedOn;
                }
            }
        }
        return undefined;
    }
    setPropertyValue(property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WCharacterFormat.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueCharacterFormat)) {
            this.initializeUniqueCharacterFormat(property, value);
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueCharacterFormat.uniqueFormatType, property);
            if (this.uniqueCharacterFormat.propertiesHash.containsKey(propertyType) &&
                // tslint:disable-next-line:max-line-length
                this.uniqueCharacterFormat.propertiesHash.get(propertyType) === value) {
                return;
            }
            // tslint:disable-next-line:max-line-length
            this.uniqueCharacterFormat = WCharacterFormat.uniqueCharacterFormats.updateUniqueFormat(this.uniqueCharacterFormat, property, value);
        }
    }
    initializeUniqueCharacterFormat(property, propValue) {
        let uniqueCharFormatTemp = new Dictionary();
        this.addUniqueCharacterFormat('fontColor', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('fontFamily', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('fontSize', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('bold', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('italic', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('underline', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('strikethrough', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('baselineAlignment', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('highlightColor', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('styleName', property, propValue, uniqueCharFormatTemp);
        // tslint:disable-next-line:max-line-length
        this.uniqueCharacterFormat = WCharacterFormat.uniqueCharacterFormats.addUniqueFormat(uniqueCharFormatTemp, WCharacterFormat.uniqueFormatType);
    }
    // tslint:disable-next-line:max-line-length
    addUniqueCharacterFormat(property, modifiedProperty, propValue, uniqueCharFormatTemp) {
        let propertyType;
        propertyType = WUniqueFormat.getPropertyType(WCharacterFormat.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueCharFormatTemp.add(propertyType, propValue);
        }
    }
    static getPropertyDefaultValue(property) {
        let value = undefined;
        switch (property) {
            case 'bold':
                value = false;
                break;
            case 'italic':
                value = false;
                break;
            case 'fontSize':
                value = 11;
                break;
            case 'underline':
                value = 'None';
                break;
            case 'strikethrough':
                value = 'None';
                break;
            case 'baselineAlignment':
                value = 'Normal';
                break;
            case 'highlightColor':
                value = 'NoColor';
                break;
            case 'fontColor':
                value = '#000000';
                break;
            case 'fontFamily':
                value = 'Calibri';
                break;
            case 'styleName':
                value = 'Default Paragraph Font';
                break;
        }
        return value;
    }
    isEqualFormat(format) {
        return (this.fontSize === format.fontSize
            && this.fontFamily === format.fontFamily
            && this.bold === format.bold
            && this.italic === format.italic
            && this.baselineAlignment === format.baselineAlignment
            && this.underline === format.underline
            && this.fontColor === format.fontColor
            && this.strikethrough === format.strikethrough
            && this.highlightColor === format.highlightColor);
    }
    isSameFormat(format) {
        return this.baseCharStyle === format.baseCharStyle &&
            this.uniqueCharacterFormat === format.uniqueCharacterFormat;
    }
    cloneFormat() {
        let format = new WCharacterFormat(undefined);
        format.uniqueCharacterFormat = this.uniqueCharacterFormat;
        format.baseCharStyle = this.baseCharStyle;
        return format;
    }
    hasValue(property) {
        if (!isNullOrUndefined(this.uniqueCharacterFormat) && !isNullOrUndefined(this.uniqueCharacterFormat.propertiesHash)) {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueCharacterFormat.uniqueFormatType, property);
            return this.uniqueCharacterFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    }
    clearFormat() {
        if (!isNullOrUndefined(this.uniqueCharacterFormat) && this.uniqueCharacterFormat.referenceCount === 0) {
            WCharacterFormat.uniqueCharacterFormats.remove(this.uniqueCharacterFormat);
        }
        this.uniqueCharacterFormat = undefined;
        this.baseCharStyle = undefined;
    }
    destroy() {
        this.clearFormat();
    }
    copyFormat(format) {
        if (!isNullOrUndefined(format)) {
            if (!isNullOrUndefined(format.uniqueCharacterFormat) && format.uniqueCharacterFormat.propertiesHash) {
                this.updateUniqueCharacterFormat(format);
            }
            if (!isNullOrUndefined(format.baseCharStyle)) {
                this.baseCharStyle = format.baseCharStyle;
            }
        }
    }
    updateUniqueCharacterFormat(format) {
        let hash = undefined;
        if (this.uniqueCharacterFormat) {
            hash = this.uniqueCharacterFormat.mergeProperties(format.uniqueCharacterFormat);
            if (this.uniqueCharacterFormat.referenceCount === 0) {
                WCharacterFormat.uniqueCharacterFormats.remove(this.uniqueCharacterFormat);
                this.uniqueCharacterFormat = undefined;
            }
        }
        this.uniqueCharacterFormat = new WUniqueFormat(WCharacterFormat.uniqueFormatType);
        if (isNullOrUndefined(hash)) {
            hash = this.uniqueCharacterFormat.mergeProperties(format.uniqueCharacterFormat);
        }
        this.uniqueCharacterFormat = WCharacterFormat.uniqueCharacterFormats.addUniqueFormat(hash, WCharacterFormat.uniqueFormatType);
    }
    static clear() {
        this.uniqueCharacterFormats.clear();
    }
    ApplyStyle(baseCharStyle) {
        this.baseCharStyle = baseCharStyle;
    }
    /**
     * For internal use
     * @private
     */
    getValue(property) {
        return this.hasValue(property) ? this.getPropertyValue(property) : undefined;
    }
    /**
     * For internal use
     * @private
     */
    mergeFormat(format) {
        if (isNullOrUndefined(this.getValue('bold'))) {
            this.bold = format.getValue('bold');
        }
        if (isNullOrUndefined(this.getValue('italic'))) {
            this.italic = format.getValue('italic');
        }
        if (isNullOrUndefined(this.getValue('fontSize'))) {
            this.fontSize = format.getValue('fontSize');
        }
        if (isNullOrUndefined(this.getValue('fontFamily'))) {
            this.fontFamily = format.getValue('fontFamily');
        }
        if (isNullOrUndefined(this.getValue('underline'))) {
            this.underline = format.getValue('underline');
        }
        if (isNullOrUndefined(this.getValue('strikethrough'))) {
            this.strikethrough = format.getValue('strikethrough');
        }
        if (isNullOrUndefined(this.getValue('baselineAlignment'))) {
            this.baselineAlignment = format.getValue('baselineAlignment');
        }
        if (isNullOrUndefined(this.getValue('highlightColor'))) {
            this.highlightColor = format.getValue('highlightColor');
        }
        if (isNullOrUndefined(this.getValue('fontColor'))) {
            this.fontColor = format.getValue('fontColor');
        }
    }
}
WCharacterFormat.uniqueCharacterFormats = new WUniqueFormats();
WCharacterFormat.uniqueFormatType = 2;

/**
 * @private
 */
class HelperMethods {
    /**
     * Inserts text at specified index in string.
     * @param {string} spanText
     * @param {number} index
     * @param {string} text
     * @private
     */
    static insert(spanText, index, text) {
        if (index >= 0) {
            return [spanText.slice(0, index) + text + spanText.slice(index)].join('');
        }
        else {
            return text + this;
        }
    }
    /**
     * Removes text from specified index in string.
     * @param {string} text
     * @param {number} index
     * @param {number} length
     * @private
     */
    static remove(text, index, length) {
        if (index === 0) {
            return text.substring(index + 1, text.length);
        }
        else {
            return text.substring(0, index) + text.substring(index + 1, text.length);
        }
    }
    /**
     * Returns the index of word split character in a string.
     * @param {string} text
     * @param {string[]} wordSplitCharacter
     * @private
     */
    /* tslint:disable:no-any */
    static indexOfAny(text, wordSplitCharacter) {
        let index = undefined;
        for (let j = 0; j < wordSplitCharacter.length; j++) {
            let temp = text.indexOf(wordSplitCharacter[j]);
            if (temp !== -1 && isNullOrUndefined(index)) {
                index = temp;
            }
            else if (temp !== -1 && temp < index) {
                index = temp;
            }
        }
        return isNullOrUndefined(index) ? -1 : index;
    }
    /**
     * Returns the last index of word split character in a string.
     * @param {string} text
     * @param {string[]} wordSplitCharacter
     * @private
     */
    static lastIndexOfAny(text, wordSplitCharacter) {
        for (let i = text.length - 1; i >= 0; i--) {
            for (let j = 0; j <= wordSplitCharacter.length - 1; j++) {
                if (text[i] === wordSplitCharacter[j]) {
                    return i;
                }
            }
        }
        return -1;
    }
    /**
     * Adds css styles to document header.
     * @param {string} css
     * @private
     */
    static addCssStyle(css) {
        let style = document.createElement('style');
        if (style.style.cssText) {
            style.style.cssText = css;
        }
        else {
            style.appendChild(document.createTextNode(css));
        }
        document.getElementsByTagName('head')[0].appendChild(style);
    }
    /**
     * Gets highlight color code.
     * @param {HighlightColor} highlightColor
     * @private
     */
    static getHighlightColorCode(highlightColor) {
        let color = '#ffffff';
        switch (highlightColor) {
            case 'Yellow':
                color = '#ffff00';
                break;
            case 'BrightGreen':
                color = '#00ff00';
                break;
            case 'Turquoise':
                color = '#00ffff';
                break;
            case 'Pink':
                color = '#ff00ff';
                break;
            case 'Blue':
                color = '#0000ff';
                break;
            case 'Red':
                color = '#ff0000';
                break;
            case 'DarkBlue':
                color = '#000080';
                break;
            case 'Teal':
                color = '#008080';
                break;
            case 'Green':
                color = '#008000';
                break;
            case 'Violet':
                color = '#800080';
                break;
            case 'DarkRed':
                color = '#800000';
                break;
            case 'DarkYellow':
                color = '#808000';
                break;
            case 'Gray50':
                color = '#808080';
                break;
            case 'Gray25':
                color = '#c0c0c0';
                break;
            case 'Black':
                color = '#000000';
                break;
        }
        return color;
    }
    /**
     * Converts point to pixel.
     * @param {number} point
     * @private
     */
    static convertPointToPixel(point) {
        let pixel = HelperMethods.round((point * 96 / 72), 5);
        return pixel;
    }
    /**
     * Converts pixel to point.
     * @param {number} pixel
     * @private
     */
    static convertPixelToPoint(pixel) {
        let point = HelperMethods.round((pixel * 72 / 96), 5);
        return point;
    }
    /**
     * Return true if field linked
     * @private
     */
    static isLinkedFieldCharacter(inline) {
        if (inline instanceof FieldElementBox && inline.fieldType === 0) {
            return !isNullOrUndefined(inline.fieldEnd);
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 2) {
            return !isNullOrUndefined(inline.fieldBegin) && !isNullOrUndefined(inline.fieldEnd);
        }
        else {
            return !isNullOrUndefined(inline.fieldBegin);
        }
    }
    /**
     * Removes white space in a string.
     * @param {string} text
     * @private
     */
    static removeSpace(text) {
        if (!isNullOrUndefined(text) && text.length !== 0) {
            for (let i = 0; i < text.length; i++) {
                if (text.charAt(i) === ' ') {
                    //replace the space by empty string in string
                    text = text.replace(' ', '');
                }
            }
        }
        return text;
    }
    /**
     * Trims white space at start of the string.
     * @param {string} text
     * @private
     */
    static trimStart(text) {
        let i = 0;
        for (i; i < text.length; i++) {
            if (text[i] !== ' ') {
                break;
            }
        }
        return text.substring(i, text.length);
    }
    /**
     * Trims white space at end of the string.
     * @param {string} text
     * @private
     */
    static trimEnd(text) {
        let i = text.length - 1;
        for (i; i >= 0; i--) {
            if (text[i] !== ' ') {
                break;
            }
        }
        return text.substring(0, i + 1);
    }
    /**
     * Checks whether string ends with whitespace.
     * @param {string} text
     * @private
     */
    static endsWith(text) {
        if (!isNullOrUndefined(text) && text.length !== 0) {
            return text[text.length - 1] === ' ';
        }
        return false;
    }
    /**
     * @private
     * Write Characterformat
     * @param {any} characterFormat
     * @param {boolean} isInline
     * @param {WCharacterFormat} format
     */
    static writeCharacterFormat(characterFormat, isInline, format) {
        characterFormat.bold = isInline ? format.bold : format.getValue('bold');
        characterFormat.italic = isInline ? format.italic : format.getValue('italic');
        characterFormat.fontSize = isInline ? format.fontSize : format.getValue('fontSize');
        characterFormat.fontFamily = isInline ? format.fontFamily : format.getValue('fontFamily');
        characterFormat.underline = isInline ? format.underline : format.getValue('underline');
        characterFormat.strikethrough = isInline ? format.strikethrough : format.getValue('strikethrough');
        characterFormat.baselineAlignment = isInline ? format.baselineAlignment : format.getValue('baselineAlignment');
        characterFormat.highlightColor = isInline ? format.highlightColor : format.getValue('highlightColor');
        characterFormat.fontColor = isInline ? format.fontColor : format.getValue('fontColor');
        characterFormat.styleName = !isNullOrUndefined(format.baseCharStyle) ? format.baseCharStyle.name : undefined;
    }
    /* tslint:enable:no-any */
    /**
     * Rounds the values with specified decimal digits.
     * @param {number} value
     * @param {number} decimalDigits
     * @private
     */
    static round(value, decimalDigits) {
        let temp = value;
        for (let i = 0; i < decimalDigits; i++) {
            temp = temp * 10;
        }
        temp = Math.round(temp);
        for (let i = 0; i < decimalDigits; i++) {
            temp = temp / 10;
        }
        return temp;
    }
}
/**
 * @private
 */
HelperMethods.wordBefore = '\\b';
/**
 * @private
 */
HelperMethods.wordAfter = '\\b';
/**
 * @private
 */
HelperMethods.wordSplitCharacters = [' ', ',', '.', ':', ';', '<', '>', '=',
    '+', '-', '_', '{', '}', '[', ']', '`', '~', '!', '@', '#', '$', '%', '^', '&',
    '*', '(', ')', '"', '?', '/', '|', '\\', '”'];
/**
 * @private
 */
class Point {
    constructor(xPosition, yPosition) {
        this.xIn = 0;
        this.yIn = 0;
        this.xIn = xPosition;
        this.yIn = yPosition;
    }
    /**
     * Gets or sets x value.
     * @private
     */
    get x() {
        return this.xIn;
    }
    set x(value) {
        this.xIn = value;
    }
    /**
     * Gets or sets y value.
     * @private
     */
    get y() {
        return this.yIn;
    }
    set y(value) {
        this.yIn = value;
    }
    /**
     * @private
     */
    copy(point) {
        this.xIn = point.xIn;
        this.yIn = point.yIn;
    }
    /**
     * Destroys the internal objects maintained.
     * @returns void
     */
    destroy() {
        this.xIn = undefined;
        this.yIn = undefined;
    }
}

/**
 * @private
 */
class WStyle {
}
/**
 * @private
 */
class WParagraphStyle extends WStyle {
    constructor(node) {
        super();
        this.ownerBase = node;
        this.paragraphFormat = new WParagraphFormat(this);
        this.characterFormat = new WCharacterFormat(this);
    }
    destroy() {
        this.characterFormat.destroy();
        this.paragraphFormat.destroy();
    }
    copyStyle(paraStyle) {
        this.name = paraStyle.name;
        this.ownerBase = paraStyle.ownerBase;
        this.type = paraStyle.type;
        this.next = paraStyle.next;
        this.basedOn = paraStyle.basedOn;
        this.link = paraStyle.link;
        this.characterFormat.copyFormat(paraStyle.characterFormat);
        this.paragraphFormat.copyFormat(paraStyle.paragraphFormat);
    }
}
/**
 * @private
 */
class WCharacterStyle extends WStyle {
    constructor(node) {
        super();
        this.ownerBase = node;
        this.characterFormat = new WCharacterFormat(this);
    }
    destroy() {
        this.characterFormat.destroy();
    }
    copyStyle(charStyle) {
        this.name = charStyle.name;
        this.ownerBase = charStyle.ownerBase;
        this.type = charStyle.type;
        this.next = charStyle.next;
        this.basedOn = charStyle.basedOn;
        this.characterFormat.copyFormat(charStyle.characterFormat);
    }
}
/**
 * @private
 */
class WStyles {
    constructor() {
        this.collection = [];
        /* tslint:enable:no-any */
    }
    get length() {
        return this.collection.length;
    }
    remove(item) {
        this.collection = this.collection.filter((a) => (a.name !== item.name));
    }
    push(item) {
        if (item != null && item !== undefined) {
            this.collection.push(item);
        }
        return 1;
    }
    getItem(index) {
        if (this.collection.length > index) {
            return this.collection[index];
        }
        return null;
    }
    indexOf(item) {
        return this.collection.indexOf(item);
    }
    contains(item) {
        let index = this.collection.indexOf(item);
        return index > -1 && index < this.collection.length;
    }
    clear() {
        while (this.collection.length > 0) {
            this.collection.pop();
        }
    }
    findByName(name, type) {
        let returnStyle;
        for (let value of this.collection) {
            if (value.name === name) {
                returnStyle = value;
                if (!isNullOrUndefined(type) && value.type === type) {
                    returnStyle = value;
                }
            }
        }
        return returnStyle;
    }
    getStyleNames(type) {
        return this.collection.filter((a) => (a.type === type)).map((a) => { return a.name; });
    }
    /* tslint:disable:no-any */
    getStyles(type) {
        let styles = this.collection.filter((a) => (a.type === type)).map((a) => { return a; });
        let styleObjects = [];
        for (let style of styles) {
            let returnStyle = {};
            let returnStyleObject = {};
            returnStyleObject.characterFormat = {};
            HelperMethods.writeCharacterFormat(returnStyleObject.characterFormat, true, style.characterFormat);
            returnStyle.name = style.name;
            returnStyle.style = JSON.stringify(returnStyleObject);
            styleObjects.push(returnStyle);
        }
        return styleObjects;
    }
}

/**
 * @private
 */
class WBorder {
    constructor(node) {
        this.uniqueBorderFormat = undefined;
        this.ownerBase = undefined;
        this.ownerBase = node;
    }
    get color() {
        return this.getPropertyValue('color');
    }
    set color(value) {
        this.setPropertyValue('color', value);
    }
    get lineStyle() {
        return this.getPropertyValue('lineStyle');
    }
    set lineStyle(value) {
        this.setPropertyValue('lineStyle', value);
    }
    get lineWidth() {
        return this.getPropertyValue('lineWidth');
    }
    set lineWidth(value) {
        this.setPropertyValue('lineWidth', value);
    }
    get shadow() {
        return this.getPropertyValue('shadow');
    }
    set shadow(value) {
        this.setPropertyValue('shadow', value);
    }
    get space() {
        return this.getPropertyValue('space');
    }
    set space(value) {
        this.setPropertyValue('space', value);
    }
    get hasNoneStyle() {
        return this.getPropertyValue('hasNoneStyle');
    }
    set hasNoneStyle(value) {
        this.setPropertyValue('hasNoneStyle', value);
    }
    getPropertyValue(property) {
        let hasValue = this.hasValue(property);
        if (hasValue) {
            let propertyType = WUniqueFormat.getPropertyType(WBorder.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueBorderFormat) && this.uniqueBorderFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueBorderFormat.propertiesHash.get(propertyType);
            }
        }
        return WBorder.getPropertyDefaultValue(property);
    }
    setPropertyValue(property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WBorder.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueBorderFormat)) {
            this.initializeUniqueBorder(property, value);
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueBorderFormat.uniqueFormatType, property);
            if (this.uniqueBorderFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueBorderFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            this.uniqueBorderFormat = WBorder.uniqueBorderFormats.updateUniqueFormat(this.uniqueBorderFormat, property, value);
        }
    }
    initializeUniqueBorder(property, propValue) {
        let uniqueBorderFormatTemp = new Dictionary();
        this.addUniqueBorderFormat('color', property, propValue, uniqueBorderFormatTemp);
        this.addUniqueBorderFormat('lineStyle', property, propValue, uniqueBorderFormatTemp);
        this.addUniqueBorderFormat('lineWidth', property, propValue, uniqueBorderFormatTemp);
        this.addUniqueBorderFormat('shadow', property, propValue, uniqueBorderFormatTemp);
        this.addUniqueBorderFormat('space', property, propValue, uniqueBorderFormatTemp);
        this.addUniqueBorderFormat('hasNoneStyle', property, propValue, uniqueBorderFormatTemp);
        this.uniqueBorderFormat = WBorder.uniqueBorderFormats.addUniqueFormat(uniqueBorderFormatTemp, WBorder.uniqueFormatType);
    }
    // tslint:disable-next-line:max-line-length
    addUniqueBorderFormat(property, modifiedProperty, propValue, uniqueBorderFormatTemp) {
        let propertyType;
        propertyType = WUniqueFormat.getPropertyType(WBorder.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueBorderFormatTemp.add(propertyType, propValue);
        }
        else {
            uniqueBorderFormatTemp.add(propertyType, WBorder.getPropertyDefaultValue(property));
        }
    }
    static getPropertyDefaultValue(property) {
        let value = undefined;
        switch (property) {
            case 'color':
                value = '#000000';
                break;
            case 'lineStyle':
                value = 'None';
                break;
            case 'lineWidth':
                value = 0;
                break;
            case 'shadow':
                value = false;
                break;
            case 'space':
                value = 0;
                break;
            case 'hasNoneStyle':
                value = false;
                break;
        }
        return value;
    }
    getLineWidth() {
        /* tslint:disable */
        switch (this.lineStyle) {
            case 'None':
            case 'Cleared':
                return 0;
            case 'Triple':
            case 'Double':
            case 'ThinThickSmallGap':
            case 'ThickThinSmallGap':
            case 'ThinThickThinSmallGap':
            case 'ThinThickMediumGap':
            case 'ThickThinMediumGap':
            case 'ThinThickThinMediumGap':
            case 'ThinThickLargeGap':
            case 'ThickThinLargeGap':
            case 'ThinThickThinLargeGap':
            case 'Emboss3D':
            case 'Engrave3D':
                {
                    let lineArray = this.getBorderLineWidthArray(this.lineStyle, this.lineWidth);
                    let width = 0;
                    for (let i = 0; i < lineArray.length; i++) {
                        width += lineArray[i];
                    }
                    return width;
                }
            case 'Single':
            case 'DashLargeGap':
            case 'DashSmallGap':
            case 'Dot':
            case 'DashDot':
            case 'DashDotDot':
            case 'Thick':
                return this.lineWidth;
            case 'SingleWavy':
                return (this.lineWidth === 1.5 ? 3 : 2.5); //Double wave border only draw with the fixed width
            case 'DoubleWavy':
                return (6.75); //Double wave border only draw with the fixed width
            case 'DashDotStroked':
            case 'Outset':
                return this.lineWidth;
        }
        return this.lineWidth;
        /* tslint:enable */
    }
    getBorderLineWidthArray(lineStyle, lineWidth) {
        let borderLineArray = [lineWidth];
        switch (lineStyle) {
            case 'Double':
                borderLineArray = [1, 1, 1];
                break;
            case 'ThinThickSmallGap':
                borderLineArray = [1, -0.75, -0.75];
                break;
            case 'ThickThinSmallGap':
                borderLineArray = [-0.75, -0.75, 1];
                break;
            case 'ThinThickMediumGap':
                borderLineArray = [1, 0.5, 0.5];
                break;
            case 'ThickThinMediumGap':
                borderLineArray = [0.5, 0.5, 1];
                break;
            case 'ThinThickLargeGap':
                borderLineArray = [-1.5, 1, -0.75];
                break;
            case 'ThickThinLargeGap':
                borderLineArray = [-0.75, 1, -1.5];
                break;
            case 'Triple':
                borderLineArray = [1, 1, 1, 1, 1];
                break;
            case 'ThinThickThinSmallGap':
                borderLineArray = [-0.75, -0.75, 1, -0.75, -0.75];
                break;
            case 'ThinThickThinMediumGap':
                borderLineArray = [0.5, 0.5, 1, 0.5, 0.5];
                break;
            case 'ThinThickThinLargeGap':
                borderLineArray = [-0.75, 1, -1.5, 1, -0.75];
                break;
            case 'Emboss3D':
            case 'Engrave3D':
                borderLineArray = [0.25, 0, 1, 0, 0.25];
                break;
        }
        if (borderLineArray.length === 1) {
            return [lineWidth];
        }
        for (let i = 0; i < borderLineArray.length; i++) {
            if (borderLineArray[i] >= 0) {
                borderLineArray[i] = borderLineArray[i] * lineWidth;
            }
            else {
                borderLineArray[i] = Math.abs(borderLineArray[i]);
            }
        }
        return borderLineArray;
    }
    getBorderWeight() {
        let weight = 0;
        let numberOfLines = this.getNumberOfLines();
        let borderNumber = this.getBorderNumber();
        switch (this.lineStyle) {
            case 'Single':
            case 'DashSmallGap':
            case 'DashDot':
            case 'DashDotDot':
            case 'Double':
            case 'Triple':
            case 'ThinThickSmallGap':
            case 'ThickThinSmallGap':
            case 'ThinThickThinSmallGap':
            case 'ThinThickMediumGap':
            case 'ThickThinMediumGap':
            case 'ThinThickThinMediumGap':
            case 'ThinThickLargeGap':
            case 'ThickThinLargeGap':
            case 'ThinThickThinLargeGap':
            case 'SingleWavy':
            case 'DoubleWavy':
            case 'DashDotStroked':
            case 'Emboss3D':
            case 'Engrave3D':
            case 'Outset':
            case 'Inset':
            case 'Thick':
                weight = numberOfLines * borderNumber;
                break;
            case 'Dot':
            case 'DashLargeGap':
                weight = 1;
                break;
        }
        return weight;
    }
    getBorderNumber() {
        let borderNumber = 0;
        switch (this.lineStyle) {
            case 'Single':
                borderNumber = 1;
                break;
            case 'Thick':
                borderNumber = 2;
                break;
            case 'Double':
                borderNumber = 3;
                break;
            case 'Dot':
                borderNumber = 4;
                break;
            case 'DashLargeGap'://dashed.
                borderNumber = 5;
                break;
            case 'DashDot':
                borderNumber = 6;
                break;
            case 'DashDotDot':
                borderNumber = 7;
                break;
            case 'Triple':
                borderNumber = 8;
                break;
            case 'ThinThickSmallGap':
                borderNumber = 9;
                break;
            case 'ThickThinSmallGap':
                borderNumber = 10;
                break;
            case 'ThinThickThinSmallGap':
                borderNumber = 11;
                break;
            case 'ThinThickMediumGap':
                borderNumber = 12;
                break;
            case 'ThickThinMediumGap':
                borderNumber = 13;
                break;
            case 'ThinThickThinMediumGap':
                borderNumber = 14;
                break;
            case 'ThinThickLargeGap':
                borderNumber = 15;
                break;
            case 'ThickThinLargeGap':
                borderNumber = 16;
                break;
            case 'ThinThickThinLargeGap':
                borderNumber = 17;
                break;
            case 'SingleWavy'://wave.
                borderNumber = 18;
                break;
            case 'DoubleWavy':
                borderNumber = 19;
                break;
            case 'DashSmallGap':
                borderNumber = 20;
                break;
            case 'DashDotStroked':
                borderNumber = 21;
                break;
            case 'Emboss3D':
                borderNumber = 22;
                break;
            case 'Engrave3D':
                borderNumber = 23;
                break;
            case 'Outset':
                borderNumber = 24;
                break;
            case 'Inset':
                borderNumber = 25;
                break;
        }
        return borderNumber;
    }
    getNumberOfLines() {
        //ToDo: Need to analyze more on this.
        let value = 0;
        switch (this.lineStyle) {
            case 'Single':
            case 'Dot':
            case 'DashSmallGap':
            case 'DashLargeGap':
            case 'DashDot':
            case 'DashDotDot':
                value = 1;
                break;
            case 'Double':
                value = 3;
                break;
            case 'Triple':
                value = 5;
                break;
            case 'ThinThickSmallGap':
                value = 3;
                break;
            case 'ThickThinSmallGap':
                value = 3;
                break;
            case 'ThinThickThinSmallGap':
                value = 5;
                break;
            case 'ThinThickMediumGap':
                value = 3;
                break;
            case 'ThickThinMediumGap':
                value = 3;
                break;
            case 'ThinThickThinMediumGap':
                value = 5;
                break;
            case 'ThinThickLargeGap':
                value = 3;
                break;
            case 'ThickThinLargeGap':
                value = 3;
                break;
            case 'ThinThickThinLargeGap':
                value = 5;
                break;
            case 'SingleWavy':
                value = 1;
                break;
            case 'DoubleWavy':
                value = 2;
                break;
            case 'DashDotStroked':
                value = 1;
                break;
            case 'Emboss3D':
            case 'Engrave3D':
                value = 3;
                break;
            case 'Outset':
            case 'Inset':
            case 'Thick':
                value = 1;
                break;
        }
        return value;
    }
    getPrecedence() {
        let value = 0;
        switch (this.lineStyle) {
            case 'Single':
                value = 1;
                break;
            case 'Thick':
                value = 2;
                break;
            case 'Double':
                value = 3;
                break;
            case 'Dot':
                value = 4;
                break;
            case 'DashLargeGap'://dashed.
                value = 5;
                break;
            case 'DashDot':
                value = 6;
                break;
            case 'DashDotDot':
                value = 7;
                break;
            case 'Triple':
                value = 8;
                break;
            case 'ThinThickSmallGap':
                value = 9;
                break;
            case 'ThickThinSmallGap':
                value = 10;
                break;
            case 'ThinThickThinSmallGap':
                value = 11;
                break;
            case 'ThinThickMediumGap':
                value = 12;
                break;
            case 'ThickThinMediumGap':
                value = 13;
                break;
            case 'ThinThickThinMediumGap':
                value = 14;
                break;
            case 'ThinThickLargeGap':
                value = 15;
                break;
            case 'ThickThinLargeGap':
                value = 16;
                break;
            case 'ThinThickThinLargeGap':
                value = 17;
                break;
            case 'SingleWavy'://wave.
                value = 18;
                break;
            case 'DoubleWavy':
                value = 19;
                break;
            case 'DashSmallGap':
                value = 20;
                break;
            case 'DashDotStroked':
                value = 21;
                break;
            case 'Emboss3D':
                value = 22;
                break;
            case 'Engrave3D':
                value = 23;
                break;
            case 'Outset':
                value = 24;
                break;
            case 'Inset':
                value = 25;
                break;
        }
        return value;
    }
    hasValue(property) {
        if (!isNullOrUndefined(this.uniqueBorderFormat)) {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueBorderFormat.uniqueFormatType, property);
            return this.uniqueBorderFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    }
    cloneFormat() {
        let border = new WBorder(undefined);
        border.color = this.color;
        border.lineStyle = this.lineStyle;
        border.lineWidth = this.lineWidth;
        border.shadow = this.shadow;
        border.space = this.space;
        return border;
    }
    destroy() {
        if (!isNullOrUndefined(this.uniqueBorderFormat)) {
            WBorder.uniqueBorderFormats.remove(this.uniqueBorderFormat);
        }
        this.uniqueBorderFormat = undefined;
    }
    copyFormat(border) {
        if (!isNullOrUndefined(border) && !isNullOrUndefined(border.uniqueBorderFormat)) {
            this.color = border.color;
            this.lineStyle = border.lineStyle;
            this.lineWidth = border.lineWidth;
            this.shadow = border.shadow;
            this.space = border.space;
        }
    }
    static clear() {
        this.uniqueBorderFormats.clear();
    }
}
WBorder.uniqueBorderFormats = new WUniqueFormats();
WBorder.uniqueFormatType = 1;

/**
 * @private
 */
class WBorders {
    constructor(node) {
        this.leftIn = new WBorder(this);
        this.rightIn = new WBorder(this);
        this.topIn = new WBorder(this);
        this.bottomIn = new WBorder(this);
        this.horizontalIn = new WBorder(this);
        this.verticalIn = new WBorder(this);
        this.diagonalUpIn = new WBorder(this);
        this.diagonalDownIn = new WBorder(this);
        this.lineWidthIn = 0;
        this.ownerBase = node;
    }
    get left() {
        return this.leftIn;
    }
    set left(value) {
        this.leftIn = value;
    }
    get right() {
        return this.rightIn;
    }
    set right(value) {
        this.rightIn = value;
    }
    get top() {
        return this.topIn;
    }
    set top(value) {
        this.topIn = value;
    }
    get bottom() {
        return this.bottomIn;
    }
    set bottom(value) {
        this.bottomIn = value;
    }
    get horizontal() {
        return this.horizontalIn;
    }
    set horizontal(value) {
        this.horizontalIn = value;
    }
    get vertical() {
        return this.verticalIn;
    }
    set vertical(value) {
        this.verticalIn = value;
    }
    get diagonalUp() {
        return this.diagonalUpIn;
    }
    set diagonalUp(value) {
        this.diagonalUpIn = value;
    }
    get diagonalDown() {
        return this.diagonalDownIn;
    }
    set diagonalDown(value) {
        this.diagonalDownIn = value;
    }
    destroy() {
        if (!isNullOrUndefined(this.left)) {
            this.left.destroy();
        }
        if (!isNullOrUndefined(this.top)) {
            this.top.destroy();
        }
        if (!isNullOrUndefined(this.bottom)) {
            this.bottom.destroy();
        }
        if (!isNullOrUndefined(this.right)) {
            this.right.destroy();
        }
        if (!isNullOrUndefined(this.horizontal)) {
            this.horizontal.destroy();
        }
        if (!isNullOrUndefined(this.vertical)) {
            this.vertical.destroy();
        }
        if (!isNullOrUndefined(this.diagonalDown)) {
            this.diagonalDown.destroy();
        }
        if (!isNullOrUndefined(this.diagonalUp)) {
            this.diagonalUp.destroy();
        }
        this.topIn = undefined;
        this.bottomIn = undefined;
        this.leftIn = undefined;
        this.rightIn = undefined;
        this.horizontalIn = undefined;
        this.verticalIn = undefined;
        this.diagonalDownIn = undefined;
        this.diagonalUpIn = undefined;
        this.lineWidthIn = undefined;
        this.valueIn = undefined;
    }
    cloneFormat() {
        let borders = new WBorders(undefined);
        borders.top = isNullOrUndefined(this.top) ? undefined : this.top.cloneFormat();
        borders.bottom = isNullOrUndefined(this.bottom) ? undefined : this.bottom.cloneFormat();
        borders.left = isNullOrUndefined(this.left) ? undefined : this.left.cloneFormat();
        borders.right = isNullOrUndefined(this.right) ? undefined : this.right.cloneFormat();
        borders.horizontal = isNullOrUndefined(this.horizontal) ? undefined : this.horizontal.cloneFormat();
        borders.vertical = isNullOrUndefined(this.vertical) ? undefined : this.vertical.cloneFormat();
        borders.diagonalUp = isNullOrUndefined(this.diagonalUp) ? undefined : this.diagonalUp.cloneFormat();
        borders.diagonalDown = isNullOrUndefined(this.diagonalDown) ? undefined : this.diagonalDown.cloneFormat();
        return borders;
    }
    copyFormat(borders) {
        if (!isNullOrUndefined(borders.left) && borders.left instanceof WBorder) {
            this.left = new WBorder(this);
            this.left.copyFormat(borders.left);
        }
        if (!isNullOrUndefined(borders.right) && borders.right instanceof WBorder) {
            this.right = new WBorder(this);
            this.right.copyFormat(borders.right);
        }
        if (!isNullOrUndefined(borders.top) && borders.top instanceof WBorder) {
            this.top = new WBorder(this);
            this.top.copyFormat(borders.top);
        }
        if (!isNullOrUndefined(borders.bottom) && borders.bottom instanceof WBorder) {
            this.bottom = new WBorder(this);
            this.bottom.copyFormat(borders.bottom);
        }
        if (!isNullOrUndefined(borders.horizontal) && borders.horizontal instanceof WBorder) {
            this.horizontal = new WBorder(this);
            this.horizontal.copyFormat(borders.horizontal);
        }
        if (!isNullOrUndefined(borders.vertical) && borders.vertical instanceof WBorder) {
            this.vertical = new WBorder(this);
            this.vertical.copyFormat(borders.vertical);
        }
        if (!isNullOrUndefined(borders.diagonalDown) && borders.diagonalDown instanceof WBorder) {
            this.diagonalDown = new WBorder(this);
            this.diagonalDown.copyFormat(borders.diagonalDown);
        }
        if (!isNullOrUndefined(borders.diagonalUp) && borders.diagonalUp instanceof WBorder) {
            this.diagonalUp = new WBorder(this);
            this.diagonalUp.copyFormat(borders.diagonalUp);
        }
    }
}

/**
 * @private
 */
class WShading {
    constructor(node) {
        this.uniqueShadingFormat = undefined;
        this.ownerBase = undefined;
        this.ownerBase = node;
    }
    get backgroundColor() {
        return this.getPropertyValue('backgroundColor');
    }
    set backgroundColor(value) {
        this.setPropertyValue('backgroundColor', value);
    }
    get foregroundColor() {
        return this.getPropertyValue('foregroundColor');
    }
    set foregroundColor(value) {
        this.setPropertyValue('foregroundColor', value);
    }
    get textureStyle() {
        return this.getPropertyValue('textureStyle');
    }
    set textureStyle(value) {
        this.setPropertyValue('textureStyle', value);
    }
    getPropertyValue(property) {
        let hasValue = this.hasValue(property);
        if (hasValue) {
            let propertyType = WUniqueFormat.getPropertyType(WShading.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueShadingFormat) && this.uniqueShadingFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueShadingFormat.propertiesHash.get(propertyType);
            }
        }
        return WShading.getPropertyDefaultValue(property);
    }
    setPropertyValue(property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WShading.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueShadingFormat)) {
            this.initializeUniqueShading(property, value);
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueShadingFormat.uniqueFormatType, property);
            if (this.uniqueShadingFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueShadingFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            this.uniqueShadingFormat = WShading.uniqueShadingFormats.updateUniqueFormat(this.uniqueShadingFormat, property, value);
        }
    }
    static getPropertyDefaultValue(property) {
        let value = undefined;
        switch (property) {
            case 'backgroundColor':
                value = '#ffffff';
                break;
            case 'foregroundColor':
                value = 'empty';
                break;
            case 'textureStyle':
                value = 'TextureNone';
                break;
        }
        return value;
    }
    initializeUniqueShading(property, propValue) {
        let uniqueShadingTemp = new Dictionary();
        this.addUniqueShading('backgroundColor', property, propValue, uniqueShadingTemp);
        this.addUniqueShading('foregroundColor', property, propValue, uniqueShadingTemp);
        this.addUniqueShading('textureStyle', property, propValue, uniqueShadingTemp);
        // tslint:disable-next-line:max-line-length        
        this.uniqueShadingFormat = WShading.uniqueShadingFormats.addUniqueFormat(uniqueShadingTemp, WShading.uniqueFormatType);
    }
    // tslint:disable-next-line:max-line-length
    addUniqueShading(property, modifiedProperty, propValue, uniqueShadingTemp) {
        let propertyType;
        propertyType = WUniqueFormat.getPropertyType(WShading.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueShadingTemp.add(propertyType, propValue);
        }
        else {
            uniqueShadingTemp.add(propertyType, WShading.getPropertyDefaultValue(property));
        }
    }
    destroy() {
        if (!isNullOrUndefined(this.uniqueShadingFormat)) {
            WShading.uniqueShadingFormats.remove(this.uniqueShadingFormat);
        }
        this.uniqueShadingFormat = undefined;
    }
    cloneFormat() {
        let shading = new WShading(undefined);
        shading.backgroundColor = this.backgroundColor;
        shading.foregroundColor = this.foregroundColor;
        shading.textureStyle = this.textureStyle;
        return shading;
    }
    copyFormat(shading) {
        if (!isNullOrUndefined(shading) && !isNullOrUndefined(shading.uniqueShadingFormat)) {
            this.backgroundColor = shading.backgroundColor;
            this.foregroundColor = shading.foregroundColor;
            this.textureStyle = shading.textureStyle;
        }
    }
    hasValue(property) {
        if (!isNullOrUndefined(this.uniqueShadingFormat)) {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueShadingFormat.uniqueFormatType, property);
            return this.uniqueShadingFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    }
    static clear() {
        this.uniqueShadingFormats.clear();
    }
}
WShading.uniqueShadingFormats = new WUniqueFormats();
WShading.uniqueFormatType = 5;

/**
 * @private
 */
class WTableFormat {
    constructor(owner) {
        this.uniqueTableFormat = undefined;
        this.borders = new WBorders(this);
        this.shading = new WShading(this);
        this.ownerBase = undefined;
        this.ownerBase = owner;
        this.assignTableMarginValue(5.4, 0, 5.4, 0);
    }
    get cellSpacing() {
        return this.getPropertyValue('cellSpacing');
    }
    set cellSpacing(value) {
        if (value < 0 || value > 264.6) {
            throw new RangeError('The measurement must be between 0 px and 264.6 px.');
        }
        this.setPropertyValue('cellSpacing', value);
    }
    get leftMargin() {
        return this.getPropertyValue('leftMargin');
    }
    set leftMargin(value) {
        this.setPropertyValue('leftMargin', value);
    }
    get topMargin() {
        return this.getPropertyValue('topMargin');
    }
    set topMargin(value) {
        this.setPropertyValue('topMargin', value);
    }
    get rightMargin() {
        return this.getPropertyValue('rightMargin');
    }
    set rightMargin(value) {
        this.setPropertyValue('rightMargin', value);
    }
    get bottomMargin() {
        return this.getPropertyValue('bottomMargin');
    }
    set bottomMargin(value) {
        this.setPropertyValue('bottomMargin', value);
    }
    get leftIndent() {
        return this.getPropertyValue('leftIndent');
    }
    set leftIndent(value) {
        if (value < -1440 || value > 1440) {
            throw new RangeError('The measurement must be between -1440 px and 1440 px.');
        }
        this.setPropertyValue('leftIndent', value);
    }
    get tableAlignment() {
        return this.getPropertyValue('tableAlignment');
    }
    set tableAlignment(value) {
        this.setPropertyValue('tableAlignment', value);
    }
    get preferredWidth() {
        return this.getPropertyValue('preferredWidth');
    }
    set preferredWidth(value) {
        this.setPropertyValue('preferredWidth', value);
    }
    get preferredWidthType() {
        return this.getPropertyValue('preferredWidthType');
    }
    set preferredWidthType(value) {
        this.setPropertyValue('preferredWidthType', value);
    }
    getPropertyValue(property) {
        let hasValue = this.hasValue(property);
        if (hasValue) {
            let propertyType = WUniqueFormat.getPropertyType(WTableFormat.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueTableFormat) && this.uniqueTableFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueTableFormat.propertiesHash.get(propertyType);
            }
        }
        return WTableFormat.getPropertyDefaultValue(property);
    }
    setPropertyValue(property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WTableFormat.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueTableFormat)) {
            this.initializeUniqueTableFormat(property, value);
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueTableFormat.uniqueFormatType, property);
            if (this.uniqueTableFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueTableFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            this.uniqueTableFormat = WTableFormat.uniqueTableFormats.updateUniqueFormat(this.uniqueTableFormat, property, value);
        }
    }
    initializeUniqueTableFormat(property, propValue) {
        let uniqueTableFormatTemp = new Dictionary();
        this.addUniqueTableFormat('cellSpacing', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('leftMargin', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('topMargin', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('bottomMargin', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('rightMargin', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('leftIndent', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('tableAlignment', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('preferredWidth', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('preferredWidthType', property, propValue, uniqueTableFormatTemp);
        this.uniqueTableFormat = WTableFormat.uniqueTableFormats.addUniqueFormat(uniqueTableFormatTemp, WTableFormat.uniqueFormatType);
    }
    // tslint:disable-next-line:max-line-length
    addUniqueTableFormat(property, modifiedProperty, propValue, uniqueTableFormatTemp) {
        let propertyType;
        propertyType = WUniqueFormat.getPropertyType(WTableFormat.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueTableFormatTemp.add(propertyType, propValue);
        }
    }
    static getPropertyDefaultValue(property) {
        let value = undefined;
        switch (property) {
            case 'cellSpacing':
                value = 0;
                break;
            case 'leftMargin':
                value = 5.4;
                break;
            case 'topMargin':
                value = 0;
                break;
            case 'bottomMargin':
                value = 0;
                break;
            case 'rightMargin':
                value = 5.4;
                break;
            case 'leftIndent':
                value = 0;
                break;
            case 'tableAlignment':
                value = 'Left';
                break;
            case 'preferredWidth':
                value = 0;
                break;
            case 'preferredWidthType':
                value = 'Point';
                break;
        }
        return value;
    }
    assignTableMarginValue(left, top, right, bottom) {
        this.leftMargin = left;
        this.topMargin = top;
        this.rightMargin = right;
        this.bottomMargin = bottom;
    }
    initializeTableBorders() {
        this.borders.left.lineStyle = 'Single';
        this.borders.left.lineWidth = 0.5;
        this.borders.right.lineStyle = 'Single';
        this.borders.right.lineWidth = 0.5;
        this.borders.top.lineStyle = 'Single';
        this.borders.top.lineWidth = 0.5;
        this.borders.bottom.lineStyle = 'Single';
        this.borders.bottom.lineWidth = 0.5;
        this.borders.horizontal.lineStyle = 'Single';
        this.borders.horizontal.lineWidth = 0.5;
        this.borders.vertical.lineStyle = 'Single';
        this.borders.vertical.lineWidth = 0.5;
    }
    destroy() {
        if (!isNullOrUndefined(this.borders)) {
            this.borders.destroy();
        }
        if (!isNullOrUndefined(this.shading)) {
            this.shading.destroy();
        }
        if (!isNullOrUndefined(this.uniqueTableFormat)) {
            WTableFormat.uniqueTableFormats.remove(this.uniqueTableFormat);
        }
        this.uniqueTableFormat = undefined;
        this.borders = undefined;
        this.shading = undefined;
    }
    cloneFormat() {
        let tableFormat = new WTableFormat(undefined);
        tableFormat.leftIndent = this.leftIndent;
        tableFormat.tableAlignment = this.tableAlignment;
        tableFormat.cellSpacing = this.cellSpacing;
        tableFormat.leftMargin = this.leftMargin;
        tableFormat.rightMargin = this.rightMargin;
        tableFormat.topMargin = this.topMargin;
        tableFormat.bottomMargin = this.bottomMargin;
        tableFormat.preferredWidth = this.preferredWidth;
        tableFormat.preferredWidthType = this.preferredWidthType;
        tableFormat.borders = isNullOrUndefined(this.borders) ? undefined : this.borders.cloneFormat();
        tableFormat.shading = isNullOrUndefined(this.shading) ? undefined : this.shading.cloneFormat();
        return tableFormat;
    }
    hasValue(property) {
        if (!isNullOrUndefined(this.uniqueTableFormat)) {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueTableFormat.uniqueFormatType, property);
            return this.uniqueTableFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    }
    copyFormat(format) {
        if (!isNullOrUndefined(format)) {
            if (!isNullOrUndefined(format.uniqueTableFormat)) {
                this.cellSpacing = format.cellSpacing;
                this.leftMargin = format.leftMargin;
                this.topMargin = format.topMargin;
                this.rightMargin = format.rightMargin;
                this.bottomMargin = format.bottomMargin;
                this.leftIndent = format.leftIndent;
                this.tableAlignment = format.tableAlignment;
                this.preferredWidth = format.preferredWidth;
                this.preferredWidthType = format.preferredWidthType;
            }
            if (!isNullOrUndefined(format.borders)) {
                this.borders = new WBorders(this);
                this.borders.copyFormat(format.borders);
            }
            if (!isNullOrUndefined(format.shading)) {
                this.shading = new WShading(this);
                this.shading.copyFormat(format.shading);
            }
        }
    }
    static clear() {
        this.uniqueTableFormats.clear();
    }
}
WTableFormat.uniqueTableFormats = new WUniqueFormats();
WTableFormat.uniqueFormatType = 8;

/**
 * @private
 */
class WRowFormat {
    constructor(node) {
        this.uniqueRowFormat = undefined;
        /**
         * @private
         */
        this.borders = new WBorders(this);
        /**
         * @private
         */
        this.ownerBase = undefined;
        /**
         * @private
         */
        this.beforeWidth = 0;
        /**
         * @private
         */
        this.afterWidth = 0;
        this.ownerBase = node;
    }
    get gridBefore() {
        return this.getPropertyValue('gridBefore');
    }
    set gridBefore(value) {
        this.setPropertyValue('gridBefore', value);
    }
    get gridBeforeWidth() {
        return this.getPropertyValue('gridBeforeWidth');
    }
    set gridBeforeWidth(value) {
        this.setPropertyValue('gridBeforeWidth', value);
    }
    get gridBeforeWidthType() {
        return this.getPropertyValue('gridBeforeWidthType');
    }
    set gridBeforeWidthType(value) {
        this.setPropertyValue('gridBeforeWidthType', value);
    }
    get gridAfter() {
        return this.getPropertyValue('gridAfter');
    }
    set gridAfter(value) {
        this.setPropertyValue('gridAfter', value);
    }
    get gridAfterWidth() {
        return this.getPropertyValue('gridAfterWidth');
    }
    set gridAfterWidth(value) {
        this.setPropertyValue('gridAfterWidth', value);
    }
    get gridAfterWidthType() {
        return this.getPropertyValue('gridAfterWidthType');
    }
    set gridAfterWidthType(value) {
        this.setPropertyValue('gridAfterWidthType', value);
    }
    get allowBreakAcrossPages() {
        return this.getPropertyValue('allowBreakAcrossPages');
    }
    set allowBreakAcrossPages(value) {
        this.setPropertyValue('allowBreakAcrossPages', value);
    }
    get isHeader() {
        return this.getPropertyValue('isHeader');
    }
    set isHeader(value) {
        this.setPropertyValue('isHeader', value);
    }
    get height() {
        return this.getPropertyValue('height');
    }
    set height(value) {
        if (value === 0 && (this.heightType === 'AtLeast' || this.heightType === 'Exactly')) {
            value = 1;
        }
        else if (this.heightType === 'Auto') {
            value = 0;
        }
        this.setPropertyValue('height', value);
    }
    get heightType() {
        return this.getPropertyValue('heightType');
    }
    set heightType(value) {
        if (value === 'AtLeast' || value === 'Exactly') {
            this.height = 1;
        }
        else {
            this.height = 0;
        }
        this.setPropertyValue('heightType', value);
    }
    getPropertyValue(property) {
        let hasValue = this.hasValue(property);
        if (hasValue) {
            let propertyType = WUniqueFormat.getPropertyType(WRowFormat.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueRowFormat) && this.uniqueRowFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueRowFormat.propertiesHash.get(propertyType);
            }
        }
        return WRowFormat.getPropertyDefaultValue(property);
    }
    setPropertyValue(property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WRowFormat.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueRowFormat)) {
            this.initializeUniqueRowFormat(property, value);
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueRowFormat.uniqueFormatType, property);
            if (this.uniqueRowFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueRowFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            this.uniqueRowFormat = WRowFormat.uniqueRowFormats.updateUniqueFormat(this.uniqueRowFormat, property, value);
        }
    }
    initializeUniqueRowFormat(property, propValue) {
        let uniqueRowFormatTemp = new Dictionary();
        this.addUniqueRowFormat('allowBreakAcrossPages', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('isHeader', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('height', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('heightType', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('gridBefore', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('gridBeforeWidth', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('gridBeforeWidthType', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('gridAfter', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('gridAfterWidth', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('gridgridAfterWidth', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('gridBeforeWidthType', property, propValue, uniqueRowFormatTemp);
        this.uniqueRowFormat = WRowFormat.uniqueRowFormats.addUniqueFormat(uniqueRowFormatTemp, WRowFormat.uniqueFormatType);
    }
    // tslint:disable-next-line:max-line-length
    addUniqueRowFormat(property, modifiedProperty, propValue, uniqueRowFormatTemp) {
        let propertyType;
        propertyType = WUniqueFormat.getPropertyType(WRowFormat.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueRowFormatTemp.add(propertyType, propValue);
        }
    }
    static getPropertyDefaultValue(property) {
        let value = undefined;
        switch (property) {
            case 'allowBreakAcrossPages':
                value = true;
                break;
            case 'isHeader':
                value = false;
                break;
            case 'height':
                value = 0;
                break;
            case 'heightType':
                value = 'Auto';
                break;
            case 'gridBefore':
                value = 0;
                break;
            case 'gridBeforeWidth':
                value = 0;
                break;
            case 'gridBeforeWidthType':
                value = 'Point';
                break;
            case 'gridAfter':
                value = 0;
                break;
            case 'gridAfterWidth':
                value = 0;
                break;
            case 'gridAfterWidthType':
                value = 'Point';
                break;
        }
        return value;
    }
    cloneFormat() {
        let format = new WRowFormat();
        format.allowBreakAcrossPages = this.allowBreakAcrossPages;
        format.heightType = this.heightType;
        format.height = this.height;
        format.isHeader = this.isHeader;
        format.gridBefore = this.gridBefore;
        format.gridBeforeWidth = this.gridBeforeWidth;
        format.gridBeforeWidthType = this.gridBeforeWidthType;
        format.gridAfter = this.gridAfter;
        format.gridAfterWidth = this.gridAfterWidth;
        format.gridAfterWidthType = this.gridAfterWidthType;
        return format;
    }
    hasValue(property) {
        if (!isNullOrUndefined(this.uniqueRowFormat)) {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueRowFormat.uniqueFormatType, property);
            return this.uniqueRowFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    }
    copyFormat(format) {
        if (!isNullOrUndefined(format)) {
            if (!isNullOrUndefined(format.uniqueRowFormat)) {
                this.allowBreakAcrossPages = format.allowBreakAcrossPages;
                this.isHeader = format.isHeader;
                this.heightType = format.heightType;
                this.height = format.height;
                this.gridBefore = format.gridBefore;
                this.gridBeforeWidth = format.gridBeforeWidth;
                this.gridBeforeWidthType = format.gridBeforeWidthType;
                this.gridAfter = format.gridAfter;
                this.gridAfterWidth = format.gridAfterWidth;
                this.gridAfterWidthType = format.gridAfterWidthType;
            }
            if (!isNullOrUndefined(format.borders)) {
                this.borders = new WBorders(this);
                this.borders.ownerBase = format;
                this.borders.copyFormat(format.borders);
            }
        }
    }
    destroy() {
        if (!isNullOrUndefined(this.borders)) {
            this.borders.destroy();
        }
        if (!isNullOrUndefined(this.uniqueRowFormat)) {
            WRowFormat.uniqueRowFormats.remove(this.uniqueRowFormat);
        }
        this.beforeWidth = undefined;
        this.afterWidth = undefined;
        this.borders = undefined;
        this.uniqueRowFormat = undefined;
    }
    static clear() {
        this.uniqueRowFormats.clear();
    }
}
WRowFormat.uniqueRowFormats = new WUniqueFormats();
WRowFormat.uniqueFormatType = 6;

/**
 * @private
 */
class WCellFormat {
    constructor(node) {
        this.uniqueCellFormat = undefined;
        this.borders = new WBorders(this);
        this.shading = new WShading(this);
        this.ownerBase = node;
        this.borders = new WBorders(this);
        this.shading = new WShading(this);
    }
    get leftMargin() {
        return this.getPropertyValue('leftMargin');
    }
    set leftMargin(value) {
        this.setPropertyValue('leftMargin', value);
    }
    get rightMargin() {
        return this.getPropertyValue('rightMargin');
    }
    set rightMargin(value) {
        this.setPropertyValue('rightMargin', value);
    }
    get topMargin() {
        return this.getPropertyValue('topMargin');
    }
    set topMargin(value) {
        this.setPropertyValue('topMargin', value);
    }
    get bottomMargin() {
        return this.getPropertyValue('bottomMargin');
    }
    set bottomMargin(value) {
        this.setPropertyValue('bottomMargin', value);
    }
    get cellWidth() {
        return this.getPropertyValue('cellWidth');
    }
    set cellWidth(value) {
        this.setPropertyValue('cellWidth', value);
    }
    get columnSpan() {
        return this.getPropertyValue('columnSpan');
    }
    set columnSpan(value) {
        this.setPropertyValue('columnSpan', value);
    }
    get rowSpan() {
        return this.getPropertyValue('rowSpan');
    }
    set rowSpan(value) {
        this.setPropertyValue('rowSpan', value);
    }
    get preferredWidth() {
        return this.getPropertyValue('preferredWidth');
    }
    set preferredWidth(value) {
        this.setPropertyValue('preferredWidth', value);
    }
    get verticalAlignment() {
        return this.getPropertyValue('verticalAlignment');
    }
    set verticalAlignment(value) {
        this.setPropertyValue('verticalAlignment', value);
    }
    get preferredWidthType() {
        return this.getPropertyValue('preferredWidthType');
    }
    set preferredWidthType(value) {
        this.setPropertyValue('preferredWidthType', value);
    }
    getPropertyValue(property) {
        let hasValue = this.hasValue(property);
        if (hasValue) {
            let propertyType = WUniqueFormat.getPropertyType(WCellFormat.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueCellFormat) && this.uniqueCellFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueCellFormat.propertiesHash.get(propertyType);
            }
        }
        return WCellFormat.getPropertyDefaultValue(property);
    }
    setPropertyValue(property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WCellFormat.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueCellFormat)) {
            this.initializeUniqueCellFormat(property, value);
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueCellFormat.uniqueFormatType, property);
            if (this.uniqueCellFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueCellFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            this.uniqueCellFormat = WCellFormat.uniqueCellFormats.updateUniqueFormat(this.uniqueCellFormat, property, value);
        }
    }
    initializeUniqueCellFormat(property, propValue) {
        let uniqueCellFormatTemp = new Dictionary();
        this.addUniqueCellFormat('leftMargin', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('topMargin', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('bottomMargin', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('rightMargin', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('cellWidth', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('columnSpan', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('rowSpan', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('preferredWidth', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('verticalAlignment', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('preferredWidthType', property, propValue, uniqueCellFormatTemp);
        this.uniqueCellFormat = WCellFormat.uniqueCellFormats.addUniqueFormat(uniqueCellFormatTemp, WCellFormat.uniqueFormatType);
    }
    // tslint:disable-next-line:max-line-length
    addUniqueCellFormat(property, modifiedProperty, propValue, uniqueCellFormatTemp) {
        let propertyType;
        propertyType = WUniqueFormat.getPropertyType(WCellFormat.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueCellFormatTemp.add(propertyType, propValue);
        }
    }
    static getPropertyDefaultValue(property) {
        let value = undefined;
        switch (property) {
            case 'leftMargin':
                value = undefined;
                break;
            case 'topMargin':
                value = undefined;
                break;
            case 'bottomMargin':
                value = undefined;
                break;
            case 'rightMargin':
                value = undefined;
                break;
            case 'cellWidth':
                value = 0;
                break;
            case 'columnSpan':
                value = 1;
                break;
            case 'rowSpan':
                value = 1;
                break;
            case 'preferredWidth':
                value = 0;
                break;
            case 'verticalAlignment':
                value = 'Top';
                break;
            case 'preferredWidthType':
                value = 'Point';
                break;
        }
        return value;
    }
    containsMargins() {
        return (!isNullOrUndefined(this.leftMargin)
            || !isNullOrUndefined(this.rightMargin)
            || !isNullOrUndefined(this.bottomMargin)
            || !isNullOrUndefined(this.topMargin));
    }
    destroy() {
        if (!isNullOrUndefined(this.borders)) {
            this.borders.destroy();
        }
        if (!isNullOrUndefined(this.shading)) {
            this.shading.destroy();
        }
        if (!isNullOrUndefined(this.uniqueCellFormat)) {
            WCellFormat.uniqueCellFormats.remove(this.uniqueCellFormat);
        }
        this.uniqueCellFormat = undefined;
        this.borders = undefined;
        this.shading = undefined;
    }
    cloneFormat() {
        let format = new WCellFormat(undefined);
        format.verticalAlignment = this.verticalAlignment;
        format.leftMargin = this.leftMargin;
        format.rightMargin = this.rightMargin;
        format.topMargin = this.topMargin;
        format.bottomMargin = this.bottomMargin;
        format.preferredWidth = this.preferredWidth;
        format.preferredWidthType = this.preferredWidthType;
        format.cellWidth = this.cellWidth;
        format.borders = isNullOrUndefined(this.borders) ? undefined : this.borders.cloneFormat();
        format.shading = isNullOrUndefined(this.shading) ? undefined : this.shading.cloneFormat();
        return format;
    }
    hasValue(property) {
        if (!isNullOrUndefined(this.uniqueCellFormat)) {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueCellFormat.uniqueFormatType, property);
            return this.uniqueCellFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    }
    copyFormat(format) {
        if (!isNullOrUndefined(format)) {
            if (!isNullOrUndefined(format.uniqueCellFormat)) {
                this.cellWidth = format.cellWidth;
                this.leftMargin = format.leftMargin;
                this.topMargin = format.topMargin;
                this.rightMargin = format.rightMargin;
                this.bottomMargin = format.bottomMargin;
                this.preferredWidth = format.preferredWidth;
                this.columnSpan = format.columnSpan;
                this.rowSpan = format.rowSpan;
                this.preferredWidthType = format.preferredWidthType;
                this.verticalAlignment = format.verticalAlignment;
            }
            if (!isNullOrUndefined(format.shading)) {
                this.shading = new WShading(this);
                this.shading.copyFormat(format.shading);
            }
            if (!isNullOrUndefined(format.borders)) {
                this.borders = new WBorders(this);
                this.borders.copyFormat(format.borders);
            }
        }
    }
    static clear() {
        this.uniqueCellFormats.clear();
    }
}
WCellFormat.uniqueCellFormats = new WUniqueFormats();
WCellFormat.uniqueFormatType = 4;

/**
 * Formats Modules
 */

/**
 * @private
 */
class Rect {
    /**
     * @private
     */
    get right() {
        return this.x + this.width;
    }
    /**
     * @private
     */
    get bottom() {
        return this.y + this.height;
    }
    constructor(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
}
/**
 * @private
 */
class Margin {
    constructor(leftMargin, topMargin, rightMargin, bottomMargin) {
        this.left = leftMargin;
        this.top = topMargin;
        this.right = rightMargin;
        this.bottom = bottomMargin;
    }
    /**
     * @private
     */
    clone() {
        return new Margin(this.left, this.top, this.right, this.bottom);
    }
    /**
     * @private
     */
    destroy() {
        this.left = undefined;
        this.right = undefined;
        this.top = undefined;
        this.bottom = undefined;
    }
}
/**
 * @private
 */
class Widget {
    constructor() {
        /**
         * @private
         */
        this.childWidgets = [];
        /**
         * @private
         */
        this.x = 0;
        /**
         * @private
         */
        this.y = 0;
        /**
         * @private
         */
        this.width = 0;
        /**
         * @private
         */
        this.height = 0;
        /**
         * @private
         */
        this.index = 0;
    }
    /**
     * @private
     */
    get indexInOwner() {
        if (this instanceof BodyWidget && this.page) {
            return this.page.bodyWidgets.indexOf(this);
        }
        else if (this.containerWidget && this.containerWidget.childWidgets) {
            return this.containerWidget.childWidgets.indexOf(this);
        }
        return -1;
    }
    /**
     * @private
     */
    get firstChild() {
        return this.childWidgets.length > 0 ? this.childWidgets[0] : undefined;
    }
    /**
     * @private
     */
    get lastChild() {
        if (this.childWidgets) {
            return this.childWidgets.length > 0 ?
                this.childWidgets[this.childWidgets.length - 1] : undefined;
        }
        return undefined;
    }
    /**
     * @private
     */
    get previousWidget() {
        let widget = this;
        let index = this.indexInOwner;
        if (widget instanceof BodyWidget) {
            widget = index > 0 ? widget.page.bodyWidgets[index - 1] : undefined;
        }
        else {
            widget = index > 0 ? widget.containerWidget.childWidgets[index - 1] : undefined;
        }
        return widget;
    }
    /**
     * @private
     */
    get nextWidget() {
        let widget = this;
        let index = this.indexInOwner;
        if (index === -1) {
            return undefined;
        }
        if (widget instanceof BodyWidget) {
            widget = index < widget.page.bodyWidgets.length - 1 ?
                widget.page.bodyWidgets[index + 1] : undefined;
        }
        else {
            widget = index < widget.containerWidget.childWidgets.length - 1 ?
                widget.containerWidget.childWidgets[index + 1] : undefined;
        }
        return widget;
    }
    /**
     * @private
     */
    get previousRenderedWidget() {
        let widget = this;
        let index = this.indexInOwner;
        if (index < 0) {
            return undefined;
        }
        if (widget instanceof BodyWidget) {
            if (index > 0) {
                widget = widget.page.bodyWidgets[index - 1];
            }
            else {
                let page = widget.page.previousPage;
                widget = page && page.bodyWidgets.length > 0 ? page.bodyWidgets[page.bodyWidgets.length - 1] : undefined;
            }
        }
        else {
            if (index > 0) {
                widget = widget.containerWidget.childWidgets[index - 1];
            }
            else {
                let previousContainer = undefined;
                if (widget.containerWidget instanceof TableCellWidget) {
                    previousContainer = widget.containerWidget.getPreviousSplitWidget();
                }
                else if (!(widget.containerWidget instanceof TableRowWidget
                    || widget.containerWidget instanceof HeaderFooterWidget)) {
                    // Since cells are lay outed left to right, we should not navigate to previous row.
                    previousContainer = widget.containerWidget.previousRenderedWidget;
                }
                while (previousContainer && previousContainer.childWidgets.length === 0) {
                    previousContainer = previousContainer.previousRenderedWidget;
                    if (isNullOrUndefined(previousContainer)) {
                        break;
                    }
                }
                widget = previousContainer && previousContainer.constructor === widget.containerWidget.constructor ?
                    previousContainer.lastChild : undefined;
            }
        }
        return widget;
    }
    /**
     * @private
     */
    get nextRenderedWidget() {
        let widget = this;
        let index = this.indexInOwner;
        if (index < 0) {
            return undefined;
        }
        if (widget instanceof BodyWidget) {
            if (index < widget.page.bodyWidgets.length - 1) {
                widget = widget.page.bodyWidgets[index + 1];
            }
            else {
                let page = widget.page.nextPage;
                widget = page && page.bodyWidgets.length > 0 ? page.bodyWidgets[0] : undefined;
            }
        }
        else {
            if (index < widget.containerWidget.childWidgets.length - 1) {
                widget = widget.containerWidget.childWidgets[index + 1];
            }
            else {
                let nextContainer = undefined;
                if (widget.containerWidget instanceof TableCellWidget) {
                    nextContainer = widget.containerWidget.getNextSplitWidget();
                }
                else if (!(widget.containerWidget instanceof TableRowWidget
                    || widget.containerWidget instanceof HeaderFooterWidget)) {
                    // Since cells are lay outed left to right, we should not navigate to next row.
                    nextContainer = widget.containerWidget.nextRenderedWidget;
                }
                while (nextContainer && nextContainer.childWidgets.length === 0 && !(nextContainer instanceof TableCellWidget)) {
                    nextContainer = nextContainer.nextRenderedWidget;
                    if (isNullOrUndefined(nextContainer)) {
                        break;
                    }
                }
                widget = nextContainer && nextContainer.constructor === widget.containerWidget.constructor ?
                    nextContainer.firstChild : undefined;
            }
        }
        return widget;
    }
    /**
     * @private
     */
    get previousSplitWidget() {
        let widget = this;
        if (widget instanceof TableCellWidget) {
            return widget.getPreviousSplitWidget();
        }
        else {
            let previous = widget.previousRenderedWidget;
            if (widget instanceof BodyWidget && previous instanceof BodyWidget && widget.equals(previous)) {
                return previous;
            }
            else if (previous instanceof BlockWidget && widget.index === previous.index && widget.equals(previous)) {
                return previous;
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    get nextSplitWidget() {
        let widget = this;
        if (widget instanceof TableCellWidget) {
            return widget.getNextSplitWidget();
        }
        else {
            let next = widget.nextRenderedWidget;
            if (widget instanceof BodyWidget && next instanceof BodyWidget && widget.equals(next)) {
                return next;
            }
            else if (next instanceof BlockWidget && widget.index === next.index && widget.equals(next)) {
                return next;
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    getPreviousSplitWidgets() {
        let widgets = [];
        let widget = this.previousSplitWidget;
        while (widget) {
            widgets.unshift(widget);
            widget = widget.previousSplitWidget;
        }
        return widgets;
    }
    /**
     * @private
     */
    getSplitWidgets() {
        let widgets = this.getPreviousSplitWidgets();
        let widget = this;
        while (widget) {
            widgets.push(widget);
            widget = widget.nextSplitWidget;
        }
        return widgets;
    }
    /**
     * @private
     */
    combineWidget(viewer) {
        let root = this;
        let widgets = this.getSplitWidgets();
        if (widgets.length > 1) {
            root = widgets.shift();
            while (widgets.length > 0) {
                let splitWidget = widgets.shift();
                root.combine(splitWidget, viewer);
            }
        }
        if (root instanceof TableWidget) {
            root.combineRows(viewer);
        }
        return root;
    }
    combine(widget, viewer) {
        if (widget.childWidgets.length > 0) {
            let lastChild = this.lastChild;
            if (lastChild instanceof TableWidget) {
                lastChild.combineWidget(viewer);
            }
            else {
                let firstChild = widget.firstChild;
                if (!(widget instanceof TableWidget) && lastChild instanceof Widget && firstChild instanceof Widget &&
                    lastChild.index === firstChild.index) {
                    lastChild.combine(widget.childWidgets.shift(), viewer);
                }
            }
            this.addWidgets(widget.childWidgets);
            widget.childWidgets = [];
        }
        widget.destroyInternal(viewer);
    }
    /**
     * @private
     */
    addWidgets(childWidgets) {
        while (childWidgets.length > 0) {
            let widget = childWidgets.shift();
            if (widget instanceof LineWidget && this instanceof ParagraphWidget) {
                widget.paragraph = this;
                this.height += widget.height;
            }
            else if (widget instanceof Widget) {
                let lastChild = this.lastChild;
                widget.containerWidget = this;
                widget.y = lastChild instanceof Widget ? lastChild.y + lastChild.height : this.y;
                this.height += widget.height;
            }
            this.childWidgets.push(widget);
        }
    }
    /**
     * @private
     */
    removeChild(index) {
        if (index > -1 && index < this.childWidgets.length) {
            this.childWidgets.splice(index, 1);
        }
    }
    /**
     * @private
     */
    destroy() {
        if (this.childWidgets) {
            while (this.childWidgets.length > 0) {
                let child = this.childWidgets.pop();
                if (child instanceof LineWidget || child instanceof Widget) {
                    child.destroy();
                }
            }
        }
        this.childWidgets = undefined;
        if (this.containerWidget) {
            this.containerWidget.removeChild(this.indexInOwner);
        }
        this.containerWidget = undefined;
        // if (this.margin) {
        //     this.margin.destroy();
        // }
        this.margin = undefined;
        this.x = undefined;
        this.y = undefined;
        this.width = undefined;
        this.height = undefined;
        this.index = undefined;
    }
}
/**
 * @private
 */
class BlockContainer extends Widget {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.sectionFormatIn = undefined;
    }
    /**
     * @private
     */
    get sectionFormat() {
        let container = this;
        if (container instanceof BodyWidget) {
            return container.sectionFormatIn;
        }
        else if (container.page) {
            return container.page.bodyWidgets[0].sectionFormat;
        }
        return undefined;
    }
    /**
     * @private
     */
    set sectionFormat(value) {
        if (this instanceof BodyWidget) {
            this.sectionFormatIn = value;
        }
    }
    /**
     * @private
     */
    get sectionIndex() {
        let container = this;
        let index = 0;
        if (container instanceof BodyWidget) {
            index = container.index;
        }
        else if (container.page) {
            index = container.page.bodyWidgets[0].index;
        }
        return index;
    }
    /**
     * @private
     */
    getHierarchicalIndex(hierarchicalIndex) {
        let viewer = undefined;
        let node = this;
        if (node instanceof BodyWidget) {
            hierarchicalIndex = node.index + ';' + hierarchicalIndex;
        }
        else {
            if (node.headerFooterType.indexOf('Header') !== -1) {
                hierarchicalIndex = 'H' + ';' + hierarchicalIndex;
            }
            else {
                hierarchicalIndex = 'F' + ';' + hierarchicalIndex;
            }
        }
        if (!isNullOrUndefined(node.page)) {
            viewer = this.page.viewer;
            let pageIndex = viewer.pages.indexOf(this.page);
            return pageIndex + ';' + hierarchicalIndex;
        }
        return hierarchicalIndex;
    }
}
/**
 * @private
 */
class BodyWidget extends BlockContainer {
    /**
     * Initialize the constructor of BodyWidget
     */
    constructor() {
        super();
    }
    /**
     * @private
     */
    equals(widget) {
        return widget instanceof BodyWidget && widget.sectionFormat === this.sectionFormat;
    }
    /**
     * @private
     */
    getHierarchicalIndex(hierarchicalIndex) {
        let viewer = undefined;
        let node = this;
        hierarchicalIndex = node.index + ';' + hierarchicalIndex;
        if (!isNullOrUndefined(node.page)) {
            viewer = this.page.viewer;
            let pageIndex = viewer.pages.indexOf(this.page);
            return pageIndex + ';' + hierarchicalIndex;
        }
        return hierarchicalIndex;
    }
    /**
     * @private
     */
    getTableCellWidget(touchPoint) {
        for (let i = 0; i < this.childWidgets.length; i++) {
            if (this.childWidgets[i].y <= touchPoint.y
                && (this.childWidgets[i].y + this.childWidgets[i].height) >= touchPoint.y) {
                return this.childWidgets[i].getTableCellWidget(touchPoint);
            }
        }
        let tableCellWidget = undefined;
        if (this.childWidgets.length > 0) {
            if (this.childWidgets[0].y <= touchPoint.y) {
                tableCellWidget = this.childWidgets[this.childWidgets.length - 1].getTableCellWidget(touchPoint);
            }
            else {
                tableCellWidget = this.childWidgets[0].getTableCellWidget(touchPoint);
            }
        }
        return tableCellWidget;
    }
    /**
     * @private
     */
    destroyInternal(viewer) {
        let height = this.height;
        if (!isNullOrUndefined(this.childWidgets)) {
            for (let n = 0; n < this.childWidgets.length; n++) {
                let chilgWidget = this.childWidgets[n];
                if (chilgWidget instanceof ParagraphWidget) {
                    chilgWidget.destroyInternal(viewer);
                }
                else {
                    chilgWidget.destroyInternal(viewer);
                }
                if (isNullOrUndefined(this.childWidgets)) {
                    break;
                }
                n--;
            }
            this.childWidgets = undefined;
        }
        // if (this instanceof HeaderFooterWidget && ((this as HeaderFooterWidget).currentNode ))) {
        //     if (((this as HeaderFooterWidget).currentNode as WHeaderFooter).layoutedWidgets )) {
        //         let index: number = ((this as HeaderFooterWidget).currentNode as WHeaderFooter).layoutedWidgets.indexOf(this);
        //         ((this as HeaderFooterWidget).currentNode as WHeaderFooter).layoutedWidgets.splice(index, 1);
        //     }
        //     this.currentNode = undefined;
        /* tslint:disable: one-line */
        if (!isNullOrUndefined(this.page)) {
            let index = this.indexInOwner;
            if (this.indexInOwner > -1) {
                this.page.bodyWidgets.splice(index, 1);
                if (this.page.bodyWidgets.length === 0) {
                    this.page.destroy();
                    // }
                }
                else if ((this instanceof HeaderFooterWidget)
                    && this.page.headerWidget === this) {
                    this.page.headerWidget = undefined;
                }
                else if ((this instanceof HeaderFooterWidget)
                    && this.page.footerWidget === this) {
                    this.page.footerWidget = undefined;
                }
                this.page = undefined;
            }
        }
        this.destroy();
    }
    /**
     * @private
     */
    destroy() {
        // if (this.sectionFormat) {
        //     this.sectionFormat.destroy();
        // }
        this.sectionFormat = undefined;
        this.page = undefined;
        super.destroy();
    }
}
/**
 * @private
 */
class HeaderFooterWidget extends BlockContainer {
    constructor(type) {
        super();
        this.headerFooterType = type;
    }
    /**
     * @private
     */
    getTableCellWidget(point) {
        return undefined;
    }
    /**
     * @private
     */
    equals(widget) {
        // Todo: Need to work
        return widget instanceof HeaderFooterWidget
            && widget.containerWidget === this.containerWidget;
    }
    /**
     * @private
     */
    clone() {
        let headerFooter = new HeaderFooterWidget(this.headerFooterType);
        for (let i = 0; i < this.childWidgets.length; i++) {
            let block = this.childWidgets[i].clone();
            headerFooter.childWidgets.push(block);
            block.index = i;
            block.containerWidget = headerFooter;
        }
        headerFooter.x = this.x;
        headerFooter.y = this.y;
        headerFooter.height = 0;
        headerFooter.width = 0;
        return headerFooter;
    }
    /**
     * @private
     */
    destroyInternal(viewer) {
        this.page = undefined;
        super.destroy();
    }
}
/**
 * @private
 */
class BlockWidget extends Widget {
    /**
     * @private
     */
    get bodyWidget() {
        let widget = this;
        while (widget.containerWidget) {
            if (widget.containerWidget instanceof BlockContainer) {
                return widget.containerWidget;
            }
            widget = widget.containerWidget;
        }
        return undefined;
    }
    /**
     * @private
     */
    get leftIndent() {
        let blockAdv = this;
        if (blockAdv instanceof ParagraphWidget && blockAdv.paragraphFormat instanceof WParagraphFormat) {
            return blockAdv.paragraphFormat.leftIndent;
        }
        else if (blockAdv instanceof TableWidget && blockAdv.tableFormat instanceof WTableFormat) {
            return blockAdv.tableFormat.leftIndent;
        }
        return 0;
    }
    /**
     * @private
     */
    get rightIndent() {
        let blockAdv = this;
        if (blockAdv instanceof ParagraphWidget && blockAdv.paragraphFormat instanceof WParagraphFormat) {
            return blockAdv.paragraphFormat.rightIndent;
        }
        return 0;
    }
    /**
     * @private
     */
    get isInsideTable() {
        return this.containerWidget instanceof TableCellWidget;
    }
    /**
     * @private
     */
    get isInHeaderFooter() {
        return this.bodyWidget instanceof HeaderFooterWidget;
    }
    /**
     * @private
     */
    get associatedCell() {
        if (this.containerWidget instanceof TableCellWidget) {
            return this.containerWidget;
        }
        return undefined;
    }
    /**
     * Check whether the paragraph contains only page break.
     * @private
     */
    isPageBreak() {
        let isPageBreak = false;
        if (this instanceof ParagraphWidget) {
            let paragraph = this;
            if (paragraph != null && paragraph.childWidgets.length === 1 &&
                paragraph.firstChild.children.length === 1) {
                let pageBreak = paragraph.firstChild.children[0];
                isPageBreak = pageBreak.isPageBreak;
            }
        }
        return isPageBreak;
    }
    /**
     * @private
     */
    getHierarchicalIndex(hierarchicalIndex) {
        let node = this;
        hierarchicalIndex = node.containerWidget.childWidgets.indexOf(node) + ';' + hierarchicalIndex;
        if (!isNullOrUndefined(node.containerWidget)) {
            if (node.containerWidget instanceof BlockWidget) {
                return node.containerWidget.getHierarchicalIndex(hierarchicalIndex);
            }
            else if (node.containerWidget instanceof BlockContainer) {
                hierarchicalIndex = node.containerWidget.getHierarchicalIndex(hierarchicalIndex);
            }
        }
        return hierarchicalIndex;
    }
    /**
     * @private
     */
    getIndex() {
        if (this instanceof ParagraphWidget || this instanceof TableWidget) {
            return this.containerWidget.childWidgets.indexOf(this);
        }
        else if (this instanceof TableRowWidget) {
            return this.ownerTable.childWidgets.indexOf(this);
        }
        else if (this instanceof TableCellWidget) {
            return this.ownerRow.childWidgets.indexOf(this);
        }
        return 0;
    }
    /**
     * @private
     */
    getContainerWidth() {
        if (this.isInsideTable) {
            return this.associatedCell.cellFormat.cellWidth - (this.associatedCell.margin.left + this.associatedCell.margin.right);
        }
        else {
            let bodyWidget = this.bodyWidget;
            let sectionFormat = bodyWidget.sectionFormat;
            return sectionFormat.pageWidth - (sectionFormat.leftMargin + sectionFormat.rightMargin);
        }
    }
}
/**
 * @private
 */
class ParagraphWidget extends BlockWidget {
    /**
     * @private
     */
    get isEndsWithPageBreak() {
        if (this.childWidgets.length > 0) {
            return this.lastChild.isEndsWithPageBreak;
        }
        return false;
    }
    /**
     * Initialize the constructor of ParagraphWidget
     */
    constructor() {
        super();
        this.paragraphFormat = new WParagraphFormat(this);
        this.characterFormat = new WCharacterFormat(this);
    }
    /**
     * @private
     */
    equals(widget) {
        return widget instanceof ParagraphWidget && widget.paragraphFormat === this.paragraphFormat;
    }
    /**
     * @private
     */
    isEmpty() {
        if (isNullOrUndefined(this.childWidgets) || this.childWidgets.length === 0) {
            return true;
        }
        for (let j = 0; j < this.childWidgets.length; j++) {
            let inlineElement = this.childWidgets[j];
            for (let i = 0; i < inlineElement.children.length; i++) {
                let inline = inlineElement.children[i];
                if (inline.length === 0) {
                    continue;
                }
                if (inline instanceof TextElementBox || inline instanceof ImageElementBox || inline instanceof BookmarkElementBox
                    || (inline instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(inline))) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * @private
     */
    getInline(offset, indexInInline) {
        let inline = undefined;
        let count = 0;
        let isStarted = false;
        let splittedWidget = this.getSplitWidgets();
        for (let k = 0; k < splittedWidget.length; k++) {
            let widget = splittedWidget[k];
            for (let j = 0; j < widget.childWidgets.length; j++) {
                let line = widget.childWidgets[j];
                for (let i = 0; i < line.children.length; i++) {
                    inline = line.children[i];
                    if (inline instanceof ListTextElementBox) {
                        continue;
                    }
                    if (!isStarted && (inline instanceof TextElementBox || inline instanceof ImageElementBox
                        || inline instanceof BookmarkElementBox || inline instanceof FieldElementBox
                        && HelperMethods.isLinkedFieldCharacter(inline))) {
                        isStarted = true;
                    }
                    if (isStarted && offset <= count + inline.length) {
                        indexInInline = (offset - count);
                        return { 'element': inline, 'index': indexInInline };
                    }
                    count += inline.length;
                }
            }
        }
        if (offset > count) {
            indexInInline = isNullOrUndefined(inline) ? offset : inline.length;
        }
        return { 'element': inline, 'index': indexInInline };
    }
    /**
     * @private
     */
    getLength() {
        let length = 0;
        for (let j = 0; j < this.childWidgets.length; j++) {
            let line = this.childWidgets[j];
            for (let i = 0; i < line.children.length; i++) {
                let element = line.children[i];
                if (element instanceof ListTextElementBox) {
                    continue;
                }
                length += element.length;
            }
        }
        return length;
    }
    /**
     * @private
     */
    getTableCellWidget(point) {
        return undefined;
    }
    /**
     * @private
     */
    clone() {
        let paragraph = new ParagraphWidget();
        paragraph.paragraphFormat.copyFormat(this.paragraphFormat);
        paragraph.characterFormat.copyFormat(this.characterFormat);
        for (let i = 0; i < this.childWidgets.length; i++) {
            let line = this.childWidgets[i];
            let cloneLine = line.clone();
            paragraph.childWidgets.push(cloneLine);
            cloneLine.paragraph = paragraph;
        }
        paragraph.x = this.x;
        paragraph.y = this.y;
        paragraph.height = this.height;
        paragraph.width = this.width;
        return paragraph;
    }
    /**
     * @private
     */
    destroyInternal(viewer) {
        let height = this.height;
        if (!isNullOrUndefined(this.childWidgets)) {
            for (let i = 0; i < this.childWidgets.length; i++) {
                let widget = this.childWidgets[i];
                widget.destroy();
                if (this.childWidgets.length === 1 && isNullOrUndefined(this.childWidgets[0].children)) {
                    this.childWidgets = undefined;
                }
                if (isNullOrUndefined(this.childWidgets)) {
                    break;
                }
                i--;
            }
            this.childWidgets = undefined;
        }
        if (!isNullOrUndefined(this.containerWidget) && !isNullOrUndefined(this.containerWidget.childWidgets)
            && this.containerWidget.childWidgets.indexOf(this) !== -1) {
            this.containerWidget.childWidgets.splice(this.containerWidget.childWidgets.indexOf(this), 1);
            this.containerWidget.height -= height;
            // if ((isNullOrUndefined(this.containerWidget.childWidgets) || this.containerWidget.childWidgets.length === 0)
            //     && this.containerWidget instanceof BodyWidget) {
            //     // (this.containerWidget as BodyWidget).destroyInternal(viewer);
            // }
            this.containerWidget = undefined;
        }
        this.destroy();
    }
    /**
     * @private
     */
    destroy() {
        // if (this.paragraphFormat) {
        //     this.paragraphFormat.destroy();
        // }
        this.paragraphFormat = undefined;
        // if (this.characterFormat) {
        //     this.characterFormat.destroy();
        // }
        this.characterFormat = undefined;
        super.destroy();
    }
}
/**
 * @private
 */
class TableWidget extends BlockWidget {
    constructor() {
        super();
        this.flags = 0;
        /**
         * @private
         */
        this.leftMargin = 0;
        /**
         * @private
         */
        this.topMargin = 0;
        /**
         * @private
         */
        this.rightMargin = 0;
        /**
         * @private
         */
        this.bottomMargin = 0;
        this.margin = new Margin(this.leftMargin, this.topMargin, this.rightMargin, this.bottomMargin);
        this.leftBorderWidth = 0;
        this.rightBorderWidth = 0;
        this.topBorderWidth = 0;
        this.bottomBorderWidth = 0;
        this.tableFormat = new WTableFormat(this);
        this.tableHolder = new WTableHolder();
        this.spannedRowCollection = new Dictionary();
    }
    /**
     * @private
     */
    get isGridUpdated() {
        return ((this.flags & 0x4) >> 2) !== 0;
    }
    /**
     * @private
     */
    set isGridUpdated(value) {
        this.flags = ((this.flags & 0xFB) | ((value ? 1 : 0) << 2));
    }
    /**
     * @private
     */
    get continueHeader() {
        return ((this.flags & 0x2) >> 1) !== 0;
    }
    /**
     * @private
     */
    set continueHeader(value) {
        this.flags = ((this.flags & 0xFD) | ((value ? 1 : 0) << 1));
    }
    /**
     * @private
     */
    get header() {
        return (this.flags & 0x1) !== 0;
    }
    /**
     * @private
     */
    set header(value) {
        this.flags = ((this.flags & 0xFE) | (value ? 1 : 0));
    }
    /**
     * @private
     */
    equals(widget) {
        return widget instanceof TableWidget && widget.tableFormat === this.tableFormat;
    }
    /**
     * @private
     */
    combineRows(viewer) {
        for (let i = 0; i < this.childWidgets.length; i++) {
            let row = this.childWidgets[i];
            if (row.childWidgets.length === 0) {
                row.destroy();
                i--;
            }
            else {
                row.combineCells(viewer);
            }
        }
    }
    /**
     * @private
     */
    contains(tableCell) {
        if (this.equals(tableCell.ownerTable)) {
            return true;
        }
        while (tableCell.ownerTable.isInsideTable) {
            if (this.equals(tableCell.ownerTable)) {
                return true;
            }
            tableCell = tableCell.ownerTable.associatedCell;
        }
        return this.equals(tableCell.ownerTable);
    }
    /**
     * @private
     */
    getOwnerWidth(isBasedOnViewer) {
        let width = this.getContainerWidth();
        // Left and right indents should be neglected.
        width = width - this.leftIndent - this.rightIndent;
        return width >= 0 ? width : 0;
    }
    getTableWidth() {
        let width = 0;
        for (let i = 0; i < this.childWidgets.length; i++) {
            let rowWidth = 0;
            let row = this.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                rowWidth += row.childWidgets[j].cellFormat.cellWidth;
            }
            if (width < rowWidth) {
                width = rowWidth;
            }
        }
        return width;
    }
    /**
     * @private
     */
    getTableClientWidth(clientWidth) {
        let tableWidth = clientWidth;
        if (this.tableFormat.preferredWidthType === 'Point'
            && this.tableFormat.preferredWidth > 0) {
            tableWidth = this.tableFormat.preferredWidth;
        }
        else {
            if (this.tableFormat.preferredWidthType === 'Percent'
                && this.tableFormat.preferredWidth > 0) {
                tableWidth = tableWidth * this.tableFormat.preferredWidth / 100;
            }
            else {
                //By default, if Table preferred widthType is auto , width is set based on ClientWidth and type is set as 'Point'
                this.tableFormat.preferredWidthType = 'Point';
                this.tableFormat.preferredWidth = tableWidth;
            }
        }
        return tableWidth;
    }
    /**
     * @private
     */
    getCellWidth(preferredWidth, preferredWidthType, containerWidth, cell) {
        let cellWidth = preferredWidth;
        if (preferredWidthType === 'Percent') {
            cellWidth = (preferredWidth * containerWidth) / 100;
        }
        else if (preferredWidthType === 'Point') {
            cellWidth = preferredWidth;
        }
        else if (!isNullOrUndefined(cell)) {
            cellWidth = cell.getMinimumPreferredWidth();
        }
        return cellWidth;
    }
    /**
     * @private
     */
    fitCellsToClientArea(clientWidth) {
        let tableWidth = this.getTableWidth();
        let factor = clientWidth / tableWidth;
        for (let i = 0; i < this.childWidgets.length; i++) {
            let row = this.childWidgets[i];
            row.rowFormat.gridAfterWidth *= factor;
            row.rowFormat.gridBeforeWidth *= factor;
            for (let j = 0; j < row.childWidgets.length; j++) {
                row.childWidgets[j].cellFormat.cellWidth *= factor;
            }
        }
    }
    /**
     * @private
     */
    getTableCellWidget(point) {
        let tableCellWidget = undefined;
        for (let i = 0; i < this.childWidgets.length; i++) {
            if (this.childWidgets[i].y <= point.y
                && (this.childWidgets[i].y + this.childWidgets[i].height) >= point.y) {
                tableCellWidget = this.childWidgets[i].getTableCellWidget(point);
                break;
            }
        }
        return tableCellWidget;
    }
    /**
     * @private
     */
    //tslint:disable: max-func-body-length
    calculateGrid() {
        let tempGrid = [];
        let spannedCells = [];
        let containerWidth = this.getOwnerWidth(true);
        let tableWidth = this.getTableClientWidth(containerWidth);
        this.tableCellInfo = new Dictionary();
        for (let i = 0; i < this.childWidgets.length; i++) {
            let row = this.childWidgets[i];
            let rowCellInfo = new Dictionary();
            let rowFormat = row.rowFormat;
            let cellWidth = 0;
            let columnSpan = row.rowFormat.gridBefore;
            let currOffset = 0;
            if (tempGrid.indexOf(currOffset) < 0) {
                tempGrid.push(currOffset);
            }
            //Converts the row grid before width from point to twips point by 15 factor.
            cellWidth = this.getCellWidth(rowFormat.gridBeforeWidth, rowFormat.gridBeforeWidthType, tableWidth, null);
            currOffset += cellWidth;
            let startOffset = Math.round(currOffset);
            if (tempGrid.indexOf(startOffset) < 0) {
                tempGrid.push(startOffset);
            }
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                for (let k = 0; k < spannedCells.length; k++) {
                    if (spannedCells[k].columnIndex < columnSpan) {
                        continue;
                    }
                    let rowSpan = spannedCells[k].cellFormat.rowSpan;
                    let removeSpannedCell = true;
                    if (spannedCells[k].columnIndex > columnSpan) {
                        {
                            removeSpannedCell = false;
                            // If the cell is the last cell in the row and the row has grid after value..
                            if (j === row.childWidgets.length - 1 && row.rowFormat.gridAfter > 0) {
                                // tslint:disable-next-line:max-line-length
                                cellWidth = this.getCellWidth(spannedCells[k].cellFormat.preferredWidth, spannedCells[k].cellFormat.preferredWidthType, tableWidth, null);
                                currOffset += cellWidth;
                            }
                        }
                    }
                    else {
                        // If the table gird alone calculted then column index of the rowspanned cell will be directly taken. 
                        // If the gird calculation is done from the UI level opearations such as resizing then table holder 
                        // will have the columns at that time we can get the column index from the table holder.
                        //Converts the cell width from point to twips point by 15 factor.
                        // tslint:disable-next-line:max-line-length
                        cellWidth = this.getCellWidth(spannedCells[k].cellFormat.preferredWidth, spannedCells[k].cellFormat.preferredWidthType, tableWidth, null);
                        currOffset += cellWidth;
                        columnSpan = spannedCells[k].columnIndex + spannedCells[k].cellFormat.columnSpan;
                    }
                    if (!removeSpannedCell && j === row.childWidgets.length - 1) {
                        removeSpannedCell = true;
                    }
                    if (removeSpannedCell && i - spannedCells[k].ownerRow.rowIndex === rowSpan - 1) {
                        spannedCells.splice(k, 1);
                        k--;
                    }
                }
                // At the start of each row, we will process the row spanned cells to get the start column index.
                // To calculate grid properly, we need the items in the spanned cells collection in the order of their column index
                if (cell.cellFormat.rowSpan > 1) {
                    if (spannedCells.length === 0 || spannedCells[spannedCells.length - 1].columnIndex <= columnSpan) {
                        spannedCells.push(cell);
                    }
                    else {
                        for (let m = spannedCells.length; m > 0; m--) {
                            if (spannedCells[m - 1].columnIndex > columnSpan) {
                                spannedCells.splice(m - 1, 0, cell);
                            }
                        }
                    }
                }
                // Add start offset of each cell based on its index
                if (!rowCellInfo.containsKey(cell.cellIndex)) {
                    rowCellInfo.add(cell.cellIndex, Math.round(currOffset - startOffset));
                }
                columnSpan += cell.cellFormat.columnSpan;
                //Converts the cell width from pixel to twips point by 15 factor.
                cellWidth = this.getCellWidth(cell.cellFormat.preferredWidth, cell.cellFormat.preferredWidthType, tableWidth, null);
                currOffset += cellWidth;
                let offset = Math.round(currOffset);
                if (tempGrid.indexOf(offset) < 0) {
                    tempGrid.push(offset);
                }
                if (j === row.childWidgets.length - 1 && rowFormat.gridAfter > 0) {
                    cellWidth = this.getCellWidth(rowFormat.gridAfterWidth, 'Point', tableWidth, null);
                    currOffset += cellWidth;
                    if (tempGrid.indexOf(Math.round(currOffset)) < 0) {
                        tempGrid.push(Math.round(currOffset));
                    }
                    columnSpan += rowFormat.gridAfter;
                }
                // Add rowindex and its cells info for each row
                if (!this.tableCellInfo.containsKey(row.rowIndex)) {
                    this.tableCellInfo.add(row.rowIndex, rowCellInfo);
                }
            }
        }
        tempGrid.sort((a, b) => { return a - b; });
        if (tempGrid.length - 1 !== this.tableHolder.columns.length) {
            this.updateColumnSpans(tempGrid, tableWidth);
        }
        this.tableCellInfo.clear();
        this.tableCellInfo = undefined;
    }
    updateColumnSpans(tempGrid, containerWidth) {
        for (let i = 0; i < this.childWidgets.length; i++) {
            let row = this.childWidgets[i];
            if (row.rowFormat.gridBeforeWidth >= 0) {
                row.rowFormat.gridBefore = row.getGridCount(tempGrid, undefined, -1, containerWidth);
            }
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                let columnSpan = row.getGridCount(tempGrid, cell, cell.getIndex(), containerWidth);
                if (columnSpan > 0 && cell.cellFormat.columnSpan !== columnSpan) {
                    cell.cellFormat.columnSpan = columnSpan;
                }
            }
            if (row.rowFormat.gridAfterWidth >= 0) {
                row.rowFormat.gridAfter = row.getGridCount(tempGrid, undefined, row.childWidgets.length, containerWidth);
            }
        }
    }
    /**
     * @private
     */
    buildTableColumns() {
        if (this.isGridUpdated) {
            return;
        }
        // Clear existing columns in order to start creating columns freshly.
        this.tableHolder.resetColumns();
        let containerWidth = 0;
        let tableWidth = 0;
        let rowSpannedCells = [];
        let isAutoWidth = this.tableFormat.preferredWidthType === 'Auto';
        // For continuous layout, window width should be considered. 
        // If preferred width exceeds this limit, it can take upto maximum of 2112 pixels (1584 points will be assigned by Microsoft Word).
        containerWidth = this.getOwnerWidth(true);
        tableWidth = this.getTableClientWidth(containerWidth);
        for (let i = 0; i < this.childWidgets.length; i++) {
            let row = this.childWidgets[i];
            let rowFormat = row.rowFormat;
            let columnSpan = 0;
            let cellWidth = 0;
            let offset = 0;
            if (rowFormat.gridBefore > 0) {
                cellWidth = this.getCellWidth(rowFormat.gridBeforeWidth, row.rowFormat.gridAfterWidthType, tableWidth, null);
                this.tableHolder.addColumns(columnSpan, columnSpan = rowFormat.gridBefore, cellWidth, cellWidth, offset = cellWidth);
            }
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                if (rowSpannedCells.length === 0) {
                    cell.columnIndex = columnSpan;
                }
                for (let k = 0; k < rowSpannedCells.length; k++) {
                    let rowSpannedCell = rowSpannedCells[k];
                    if (rowSpannedCell.columnIndex < columnSpan) {
                        cell.columnIndex = columnSpan;
                        continue;
                    }
                    let rowSpan = 1;
                    let removeSpannedCell = true;
                    rowSpan = rowSpannedCell.cellFormat.rowSpan;
                    if (rowSpannedCell.columnIndex > columnSpan) {
                        cell.columnIndex = columnSpan;
                        removeSpannedCell = false;
                    }
                    else {
                        // tslint:disable-next-line:max-line-length
                        cellWidth = this.getCellWidth(rowSpannedCell.cellFormat.preferredWidth, rowSpannedCell.cellFormat.preferredWidthType, tableWidth, rowSpannedCell);
                        let minWidth = rowSpannedCell.getMinimumPreferredWidth();
                        // If the table gird alone calculted then column index of the rowspanned cell will be directly taken. 
                        // tslint:disable-next-line:max-line-length
                        // If the gird calculation is done from the UI level opearations such as resizing then table holder will have the columns at that time we can get the column index from the table holder.
                        // tslint:disable-next-line:max-line-length
                        if (this.tableHolder.columns.length > 0) {
                            this.tableHolder.addColumns(columnSpan, columnSpan = this.tableHolder.columns.indexOf(rowSpannedCell.ownerColumn) + rowSpannedCell.cellFormat.columnSpan, cellWidth, minWidth, offset += cellWidth);
                            cell.columnIndex = columnSpan;
                        }
                        else {
                            // tslint:disable-next-line:max-line-length
                            this.tableHolder.addColumns(columnSpan, columnSpan = rowSpannedCell.columnIndex + rowSpannedCell.cellFormat.columnSpan, cellWidth, minWidth, offset += cellWidth);
                            cell.columnIndex = columnSpan;
                        }
                    }
                    if (!removeSpannedCell && j === row.childWidgets.length - 1) {
                        removeSpannedCell = true;
                    }
                    if (removeSpannedCell && i - rowSpannedCell.ownerRow.rowIndex === rowSpan - 1) {
                        rowSpannedCells.splice(k, 1);
                        k--;
                    }
                }
                // At the start of each row, we will process the row spanned cells to get the start column index.
                // To calculate grid properly, we need the items in the spanned cells collection in the order of their column index
                if (cell.cellFormat.rowSpan > 1) {
                    if (rowSpannedCells.length === 0 || rowSpannedCells[rowSpannedCells.length - 1].columnIndex <= columnSpan) {
                        rowSpannedCells.push(cell);
                    }
                    else {
                        for (let m = rowSpannedCells.length; m > 0; m--) {
                            if (rowSpannedCells[m - 1].columnIndex > columnSpan) {
                                rowSpannedCells.splice(m - 1, 0, cell);
                            }
                        }
                    }
                }
                cellWidth = this.getCellWidth(cell.cellFormat.preferredWidth, cell.cellFormat.preferredWidthType, tableWidth, cell);
                let minWidth = cell.getMinimumPreferredWidth();
                this.tableHolder.addColumns(columnSpan, columnSpan += cell.cellFormat.columnSpan, cellWidth, minWidth, offset += cellWidth);
                if (j === row.childWidgets.length - 1 && rowFormat.gridAfterWidth > 0) {
                    cellWidth = this.getCellWidth(rowFormat.gridAfterWidth, 'Point', tableWidth, null);
                    this.tableHolder.addColumns(columnSpan, columnSpan += rowFormat.gridAfter, cellWidth, cellWidth, offset += cellWidth);
                }
            }
        }
        this.tableHolder.validateColumnWidths();
        // Fits the column width based on preferred width. i.e. Fixed layout.
        this.tableHolder.fitColumns(containerWidth, tableWidth, isAutoWidth);
        //Sets the width to cells
        this.setWidthToCells(tableWidth, isAutoWidth);
    }
    /**
     * @private
     */
    setWidthToCells(tableWidth, isAutoWidth) {
        for (let i = 0; i < this.childWidgets.length; i++) {
            let rw = this.childWidgets[i];
            let rowFormat = rw.rowFormat;
            if (rowFormat.gridBefore > 0) {
                rowFormat.beforeWidth = this.tableHolder.getCellWidth(0, rowFormat.gridBefore, tableWidth, isAutoWidth);
            }
            for (let j = 0; j < rw.childWidgets.length; j++) {
                let cell = rw.childWidgets[j];
                // tslint:disable-next-line:max-line-length
                cell.cellFormat.cellWidth = this.tableHolder.getCellWidth(cell.columnIndex, cell.cellFormat.columnSpan, tableWidth, isAutoWidth);
                //By default, if cell preferred widthType is auto , width set based on table width and type is changed to 'Point'
                if (cell.cellFormat.preferredWidthType !== 'Percent') {
                    cell.cellFormat.preferredWidth = cell.cellFormat.cellWidth;
                    cell.cellFormat.preferredWidthType = 'Point';
                }
            }
            if (rowFormat.gridAfter > 0) {
                rowFormat.afterWidth = this.tableHolder.getCellWidth(0, rowFormat.gridAfter, tableWidth, isAutoWidth);
            }
        }
    }
    /**
     * @private
     */
    getMaxRowWidth(clientWidth) {
        let width = 0;
        for (let i = 0; i < this.childWidgets.length; i++) {
            let row = this.childWidgets[i];
            let rowWidth = 0;
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                rowWidth += this.getCellWidth(cell.cellFormat.preferredWidth, cell.cellFormat.preferredWidthType, clientWidth, cell);
            }
            if (width < rowWidth) {
                width = rowWidth;
            }
        }
        return width;
    }
    /**
     * @private
     */
    updateWidth(dragValue) {
        let totalPreferredWidth = this.tableHolder.getTotalWidth();
        let containerWidth = this.getTableClientWidth(this.getOwnerWidth(true));
        if (containerWidth <= totalPreferredWidth) {
            if (this.tableFormat.preferredWidthType === 'Auto') {
                this.tableFormat.preferredWidthType = 'Point';
            }
        }
        if (this.tableFormat.preferredWidthType !== 'Auto') {
            if (this.tableFormat.preferredWidthType === 'Point') {
                this.tableFormat.preferredWidth = this.getMaxRowWidth(containerWidth);
            }
            // else
            // {   //ToDo:Need to anzlyze more the Percentage calculation for table width.
            //     let value:number = ConvertPixelToPercent(GetMaxRowWidth(containerWidth));
            //     this.tableFormat.preferredWidth = value;
            // }
        }
    }
    /**
     * @private
     */
    convertPointToPercent(tablePreferredWidth, ownerWidth) {
        let value = 0;
        value = (tablePreferredWidth / ownerWidth) * 100;
        value = Math.round(value);
        return value < 100 ? value : 100; // The value should be lesser than or equal to 100%;
    }
    /**
     * @private
     */
    clone() {
        let table = new TableWidget();
        table.tableHolder = this.tableHolder.clone();
        table.tableFormat.copyFormat(this.tableFormat);
        for (let i = 0; i < this.childWidgets.length; i++) {
            let row = this.childWidgets[i].clone();
            table.childWidgets.push(row);
            row.containerWidget = table;
            row.index = i;
        }
        table.x = this.x;
        table.y = this.y;
        table.height = this.height;
        table.width = this.width;
        table.containerWidget = this.containerWidget;
        return table;
    }
    /**
     * @private
     */
    static getTableOf(node) {
        if (node instanceof WBorders) {
            let row = TableRowWidget.getRowOf(node);
            if (!isNullOrUndefined(row)) {
                return row.ownerTable;
            }
            else if (node.ownerBase instanceof WTableFormat && node.ownerBase.ownerBase instanceof TableWidget) {
                return node.ownerBase.ownerBase;
            }
            else {
                return undefined;
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    fitChildToClientArea() {
        let clientWidth = this.getContainerWidth();
        if (Math.round(clientWidth) < Math.round(this.getTableWidth())) {
            this.fitCellsToClientArea(clientWidth);
        }
        for (let i = 0; i < this.childWidgets.length; i++) {
            let row = this.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                for (let k = 0; k < cell.childWidgets.length; k++) {
                    if (cell.childWidgets[k] instanceof TableWidget) {
                        cell.childWidgets[k].fitChildToClientArea();
                    }
                }
            }
        }
    }
    /**
     * @private
     */
    getColumnCellsForSelection(startCell, endCell) {
        let cells = [];
        let start = startCell.columnIndex;
        let end = endCell.columnIndex + endCell.cellFormat.columnSpan;
        for (let i = 0; i < this.childWidgets.length; i++) {
            let row = this.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                let columnIndex = cell.columnIndex;
                let columnSpan = cell.cellFormat.columnSpan;
                if ((columnIndex + columnSpan > start && columnIndex + columnSpan < end) || (columnIndex > start && columnIndex < end)) {
                    if (cells.indexOf(cell) < 0) {
                        cells.push(cell);
                    }
                }
                else if ((columnIndex > start && columnIndex < end && columnIndex + columnSpan < end)
                    || (columnIndex < start && columnIndex + columnSpan > end)) {
                    if (cells.indexOf(cell) < 0) {
                        cells.push(cell);
                    }
                }
                else if (columnIndex === start || columnIndex + columnSpan === end) {
                    if (cells.indexOf(cell) < 0) {
                        cells.push(cell);
                    }
                }
            }
        }
        return cells;
    }
    /**
     * Splits width equally for all the cells.
     * @param tableClientWidth
     * @private
     */
    splitWidthToTableCells(tableClientWidth) {
        for (let row = 0; row < this.childWidgets.length; row++) {
            this.childWidgets[row].splitWidthToRowCells(tableClientWidth);
        }
    }
    /**
     * @private
     */
    insertTableRowsInternal(tableRows, startIndex) {
        for (let i = 0; i < tableRows.length; i++) {
            let row = tableRows.splice(i, 1)[0];
            row.containerWidget = this;
            this.childWidgets.splice(startIndex, 0, row);
            i--;
        }
        this.updateRowIndex(startIndex);
        this.isGridUpdated = false;
        this.buildTableColumns();
        this.isGridUpdated = true;
    }
    /**
     * @private
     */
    updateRowIndex(startIndex) {
        for (let i = startIndex; i < this.childWidgets.length; i++) {
            let row = this.childWidgets[i];
            row.index = i;
            for (let j = 0; j < row.childWidgets.length; j++) {
                row.childWidgets[j].index = j;
                row.childWidgets[j].rowIndex = row.rowIndex;
            }
            startIndex++;
        }
    }
    /**
     * @private
     */
    getCellStartOffset(cell) {
        let offset = 0;
        if (cell && this.tableCellInfo) {
            if (this.tableCellInfo.containsKey(cell.ownerRow.rowIndex)) {
                let rowCellInfo = this.tableCellInfo.get(cell.ownerRow.rowIndex);
                if (rowCellInfo.containsKey(cell.cellIndex)) {
                    offset = rowCellInfo.get(cell.cellIndex);
                }
            }
        }
        return offset;
    }
    /**
     * @private
     */
    destroyInternal(viewer) {
        let height = this.height;
        if (!isNullOrUndefined(this.childWidgets)) {
            for (let j = 0; j < this.childWidgets.length; j++) {
                let widget = undefined;
                let childWidget = this.childWidgets[j];
                widget = childWidget;
                if (!isNullOrUndefined(widget)) {
                    widget.destroyInternal(viewer);
                }
                if (isNullOrUndefined(this.childWidgets)) {
                    break;
                }
                j--;
            }
            this.childWidgets = undefined;
        }
        if (!isNullOrUndefined(this.containerWidget)) {
            if (!isNullOrUndefined(this.containerWidget.childWidgets)) {
                if (this.containerWidget.childWidgets.indexOf(this) !== -1) {
                    this.containerWidget.childWidgets.splice(this.containerWidget.childWidgets.indexOf(this), 1);
                }
                this.containerWidget.height -= height;
                // if ((isNullOrUndefined(this.containerWidget.childWidgets) || this.containerWidget.childWidgets.length === 0)
                //     && this.containerWidget instanceof BodyWidget) {
                //     // (this.containerWidget as BodyWidget).destroyInternal(viewer);
                // }
            }
            this.containerWidget = undefined;
        }
        this.destroy();
    }
    /**
     * @private
     */
    destroy() {
        // if (this.tableFormat) {
        //     this.tableFormat.destroy();
        // }
        this.tableFormat = undefined;
        // if (this.spannedRowCollection) {
        //     this.spannedRowCollection.destroy();
        // }
        this.spannedRowCollection = undefined;
        this.tableGrids = [];
        this.tableGrids = undefined;
        // if (this.tableHolder) {
        //     this.tableHolder.destroy();
        // }
        this.tableHolder = undefined;
        this.flags = undefined;
        this.leftMargin = undefined;
        this.topMargin = undefined;
        this.rightMargin = undefined;
        this.bottomMargin = undefined;
        this.headerHeight = undefined;
        this.description = undefined;
        this.title = undefined;
        super.destroy();
    }
}
/**
 * @private
 */
class TableRowWidget extends BlockWidget {
    constructor() {
        super();
        /**
         * @private
         */
        this.spannedRowCollection = [];
        this.topBorderWidth = 0;
        this.bottomBorderWidth = 0;
        this.rowFormat = new WRowFormat(this);
    }
    /**
     * @private
     */
    get rowIndex() {
        if (this.containerWidget) {
            return this.containerWidget.childWidgets.indexOf(this);
        }
        return -1;
    }
    /**
     * @private
     */
    get ownerTable() {
        if (this.containerWidget instanceof TableWidget) {
            return this.containerWidget;
        }
        return undefined;
    }
    /**
     * @private
     */
    get nextRow() {
        let index = this.indexInOwner;
        if (index > -1 && index < this.ownerTable.childWidgets.length - 1) {
            return this.ownerTable.childWidgets[index + 1];
        }
        return undefined;
    }
    /**
     * @private
     */
    equals(widget) {
        return widget instanceof TableRowWidget && widget.rowFormat === this.rowFormat;
    }
    /**
     * @private
     */
    combineCells(viewer) {
        for (let i = 0; i < this.childWidgets.length; i++) {
            let cell = this.childWidgets[i];
            cell.combineWidget(viewer);
            if (cell.cellFormat.rowSpan === 1) {
                let cellHeight = cell.height + cell.margin.top + cell.margin.bottom;
                if ((this.height - this.ownerTable.tableFormat.cellSpacing) < cell.height) {
                    this.height = this.ownerTable.tableFormat.cellSpacing + cell.height;
                }
            }
        }
    }
    /**
     * @private
     */
    static getRowOf(node) {
        if (node instanceof WBorders) {
            let cell = TableCellWidget.getCellOf(node);
            if (!isNullOrUndefined(cell)) {
                return cell.ownerRow;
            }
            else if (node.ownerBase instanceof WRowFormat && node.ownerBase.ownerBase instanceof TableRowWidget) {
                return node.ownerBase.ownerBase;
            }
            else {
                return undefined;
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    getCell(rowIndex, cellIndex) {
        for (let i = 0; i < this.childWidgets.length; i++) {
            let cell = this.childWidgets[i];
            if (cell.rowIndex === rowIndex && cell.index === cellIndex) {
                return cell;
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    splitWidthToRowCells(tableClientWidth) {
        let cells = this.childWidgets;
        let cellWidth = tableClientWidth / cells.length;
        for (let cell = 0; cell < cells.length; cell++) {
            cells[cell].cellFormat.preferredWidth = cellWidth;
        }
    }
    /**
     * @private
     */
    getGridCount(tableGrid, cell, index, containerWidth) {
        let prevOffset = 0;
        let width = 0;
        let ownerTable = this.ownerTable;
        let rowFormat = this.rowFormat;
        if (index === -1) {
            width = ownerTable.getCellWidth(rowFormat.gridBeforeWidth, rowFormat.gridBeforeWidthType, containerWidth, null);
        }
        else {
            prevOffset += ownerTable.getCellWidth(rowFormat.gridBeforeWidth, rowFormat.gridBeforeWidthType, containerWidth, null);
            if (index >= 0) {
                prevOffset += ownerTable.getCellStartOffset(cell);
            }
            if (index < this.childWidgets.length) {
                width = ownerTable.getCellWidth(cell.cellFormat.preferredWidth, cell.cellFormat.preferredWidthType, containerWidth, null);
            }
            else {
                width = ownerTable.getCellWidth(rowFormat.gridAfterWidth, rowFormat.gridAfterWidthType, containerWidth, null);
            }
        }
        let gridStartIndex = this.getOffsetIndex(tableGrid, prevOffset);
        let gridEndIndex = this.getOffsetIndex(tableGrid, prevOffset + width);
        return gridEndIndex - gridStartIndex;
    }
    getOffsetIndex(tableGrid, offset) {
        offset = Math.round(offset);
        let index = 0;
        if (tableGrid.indexOf(offset) >= 0) {
            index = tableGrid.indexOf(offset);
        }
        else {
            for (let i = 0; i < tableGrid.length; i++) {
                if (tableGrid[i] > offset) {
                    return i;
                }
            }
            index = tableGrid.length - 1;
        }
        return index;
    }
    getCellOffset(index, containerWidth) {
        let prevOffset = 0;
        let ownerTable = this.ownerTable;
        for (let i = 0; i < this.childWidgets.length; i++) {
            let cellFormat = this.childWidgets[i].cellFormat;
            if (i === index) {
                break;
            }
            prevOffset += ownerTable.getCellWidth(cellFormat.preferredWidth, cellFormat.preferredWidthType, containerWidth, null);
        }
        return prevOffset;
    }
    /**
     * @private
     */
    updateRowBySpannedCells() {
        let rowSpannedCells = this.getPreviousRowSpannedCells();
        let currentRowIndex = this.rowIndex;
        for (let i = 0; i < rowSpannedCells.length; i++) {
            let spannedCell = rowSpannedCells[i];
            let rowSpanEnd = spannedCell.ownerRow.rowIndex + spannedCell.cellFormat.rowSpan - 1;
            // If current row is row span end or includes spanned cells. then, decrease the rowspan
            if (rowSpanEnd >= currentRowIndex) {
                spannedCell.cellFormat.rowSpan -= 1;
            }
        }
    }
    /**
     * @private
     */
    getPreviousRowSpannedCells(include) {
        let rowSpannedCells = [];
        let row = include ? this : this.previousWidget;
        while (!isNullOrUndefined(row)) {
            for (let i = 0; i < row.childWidgets.length; i++) {
                let cell = row.childWidgets[i];
                if (cell.cellFormat.rowSpan > 1) {
                    rowSpannedCells.splice(0, 0, cell);
                }
            }
            row = row.previousWidget;
        }
        return rowSpannedCells;
    }
    /**
     * @private
     */
    getTableCellWidget(point) {
        for (let i = 0; i < this.childWidgets.length; i++) {
            let x = Math.round(this.childWidgets[i].x);
            if (x - this.childWidgets[i].margin.left - 1 <= point.x
                && (x + this.childWidgets[i].width) >= point.x) {
                return this.childWidgets[i];
            }
            else if (i === this.childWidgets.length - 1
                && (this.childWidgets[i].x + this.childWidgets[i].width) + 1 <= point.x) {
                return this.childWidgets[i];
            }
        }
        let cellWidget = undefined;
        if (this.childWidgets.length > 0) {
            if (this.childWidgets[0].x <= point.x) {
                cellWidget = this.childWidgets[this.childWidgets.length - 1].getTableCellWidget(point);
            }
            else {
                cellWidget = this.childWidgets[0].getTableCellWidget(point);
            }
        }
        return cellWidget;
    }
    /**
     * @private
     */
    destroyInternal(viewer) {
        let height = this.height;
        if (!isNullOrUndefined(this.childWidgets)) {
            for (let i = 0; i < this.childWidgets.length; i++) {
                let widget = this.childWidgets[i];
                widget.destroyInternal(viewer);
                if (isNullOrUndefined(this.childWidgets)) {
                    break;
                }
                i--;
            }
            this.childWidgets = undefined;
        }
        if (!isNullOrUndefined(this.containerWidget)) {
            if (!isNullOrUndefined(this.containerWidget.childWidgets)) {
                this.containerWidget.childWidgets.splice(this.containerWidget.childWidgets.indexOf(this), 1);
                if ((isNullOrUndefined(this.containerWidget.childWidgets) || this.containerWidget.childWidgets.length === 0)
                    && this.containerWidget instanceof TableWidget) {
                    this.containerWidget.destroyInternal(viewer);
                }
                else if (this.containerWidget.containerWidget instanceof BodyWidget) {
                    this.containerWidget.containerWidget.height -= height;
                }
                this.containerWidget.height -= height;
            }
        }
        this.destroy();
    }
    /**
     * @private
     */
    clone() {
        let row = new TableRowWidget();
        row.rowFormat.copyFormat(this.rowFormat);
        row.topBorderWidth = this.topBorderWidth;
        row.bottomBorderWidth = this.bottomBorderWidth;
        for (let i = 0; i < this.childWidgets.length; i++) {
            let cell = this.childWidgets[i].clone();
            row.childWidgets.push(cell);
            cell.containerWidget = row;
            cell.index = i;
            cell.rowIndex = this.rowIndex;
        }
        row.x = this.x;
        row.y = this.y;
        row.height = this.height;
        row.width = this.width;
        return row;
    }
    /**
     * @private
     */
    destroy() {
        // if (this.rowFormat) {
        //     this.rowFormat.destroy();
        // }
        this.rowFormat = undefined;
        this.rowFormat = undefined;
        this.spannedRowCollection = [];
        this.spannedRowCollection = undefined;
        this.topBorderWidth = undefined;
        this.bottomBorderWidth = undefined;
        super.destroy();
    }
}
/**
 * @private
 */
class TableCellWidget extends BlockWidget {
    constructor() {
        super();
        /**
         * @private
         */
        this.rowIndex = -1;
        this.margin = new Margin(this.leftMargin, this.topMargin, this.rightMargin, this.bottomMargin);
        this.leftBorderWidth = 0;
        this.rightBorderWidth = 0;
        this.cellFormat = new WCellFormat(this);
    }
    /**
     * @private
     */
    get ownerColumn() {
        return this.ownerTable.tableHolder.columns[this.columnIndex];
    }
    /**
     * @private
     */
    get leftMargin() {
        if (this.cellFormat && this.cellFormat.containsMargins()) {
            return this.cellFormat.leftMargin;
        }
        else if (!isNullOrUndefined(this.ownerTable) && !isNullOrUndefined(this.ownerTable.tableFormat)) {
            return this.ownerTable.tableFormat.leftMargin;
        }
        else {
            return 0;
        }
    }
    /**
     * @private
     */
    get topMargin() {
        if (this.cellFormat && this.cellFormat.containsMargins()) {
            return this.cellFormat.topMargin;
        }
        else if (!isNullOrUndefined(this.ownerTable) && !isNullOrUndefined(this.ownerTable.tableFormat)) {
            return this.ownerTable.tableFormat.topMargin;
        }
        else {
            return 0;
        }
    }
    /**
     * @private
     */
    get rightMargin() {
        if (this.cellFormat && this.cellFormat.containsMargins()) {
            return this.cellFormat.rightMargin;
        }
        else if (!isNullOrUndefined(this.ownerTable) && !isNullOrUndefined(this.ownerTable.tableFormat)) {
            return this.ownerTable.tableFormat.rightMargin;
        }
        else {
            return 0;
        }
    }
    /**
     * @private
     */
    get bottomMargin() {
        if (this.cellFormat && this.cellFormat.containsMargins()) {
            return this.cellFormat.bottomMargin;
        }
        else if (!isNullOrUndefined(this.ownerTable) && !isNullOrUndefined(this.ownerTable.tableFormat)) {
            return this.ownerTable.tableFormat.bottomMargin;
        }
        else {
            return 0;
        }
    }
    /**
     * @private
     */
    get cellIndex() {
        if (this.ownerRow) {
            return this.ownerRow.childWidgets.indexOf(this);
        }
        return -1;
    }
    /**
     * @private
     */
    get ownerTable() {
        if (this.containerWidget instanceof TableRowWidget) {
            return this.containerWidget.ownerTable;
        }
        return undefined;
    }
    /**
     * @private
     */
    get ownerRow() {
        return this.containerWidget;
    }
    /**
     * @private
     */
    equals(widget) {
        return widget instanceof TableCellWidget && widget.cellFormat === this.cellFormat;
    }
    /**
     * @private
     */
    getContainerTable() {
        let table = this.ownerTable;
        while (table instanceof TableWidget && table.associatedCell instanceof TableCellWidget) {
            table = table.associatedCell.getContainerTable();
        }
        return table;
    }
    /**
     * @private
     */
    getPreviousSplitWidget() {
        if (this.containerWidget instanceof TableRowWidget) {
            let row = this.containerWidget;
            do {
                row = row.previousRenderedWidget;
                if (isNullOrUndefined(row) || row.index < this.rowIndex) {
                    break;
                }
                let previousCell = row.getCell(this.rowIndex, this.index);
                if (previousCell && this.equals(previousCell)) {
                    return previousCell;
                }
            } while (row);
        }
        return undefined;
    }
    /**
     * @private
     */
    getNextSplitWidget() {
        let rowSpan = this.cellFormat.rowSpan;
        if (this.containerWidget instanceof TableRowWidget) {
            let row = this.containerWidget;
            do {
                row = row.nextRenderedWidget;
                if (isNullOrUndefined(row) || row.index > this.rowIndex + rowSpan) {
                    break;
                }
                let nextCell = row.getCell(this.rowIndex, this.index);
                if (nextCell && this.equals(nextCell)) {
                    return nextCell;
                }
            } while (row);
        }
        return undefined;
    }
    /**
     * @private
     */
    getTableCellWidget(point) {
        for (let i = 0; i < this.childWidgets.length; i++) {
            if (this.childWidgets[i].y <= point.y
                && (this.childWidgets[i].y + this.childWidgets[i].height) >= point.y) {
                return this.childWidgets[i].getTableCellWidget(point);
            }
        }
        let tableCellWidget = undefined;
        if (this.childWidgets.length > 0) {
            if (this.childWidgets[0].y <= point.y) {
                tableCellWidget = this.childWidgets[this.childWidgets.length - 1].getTableCellWidget(point);
            }
            else {
                tableCellWidget = this.childWidgets[0].getTableCellWidget(point);
            }
        }
        return tableCellWidget;
    }
    /**
     * @private
     */
    updateWidth(preferredWidth) {
        if (this.cellFormat.preferredWidthType === 'Auto') {
            this.cellFormat.preferredWidth = preferredWidth;
            this.cellFormat.preferredWidthType = 'Point';
        }
        else if (this.cellFormat.preferredWidthType === 'Point') {
            this.cellFormat.preferredWidth = preferredWidth;
        }
        else if (this.cellFormat.preferredWidthType === 'Percent') {
            this.cellFormat.preferredWidth = this.convertPointToPercent(preferredWidth);
        }
        this.cellFormat.cellWidth = preferredWidth;
    }
    /**
     * @private
     */
    convertPointToPercent(cellPreferredWidth) {
        let value = 0;
        let clientWidth = this.ownerTable.getOwnerWidth(true);
        let tableWidth = this.ownerTable.getTableClientWidth(clientWidth);
        value = (cellPreferredWidth / tableWidth) * 100;
        value = Math.round(value);
        return value < 100 ? value : 100; // The value should be lesser than or equal to 100%;
    }
    /**
     * @private
     */
    static getCellLeftBorder(tableCell) {
        let leftBorder = undefined;
        let cellBorder = tableCell.cellFormat.borders;
        let rowBorders = !isNullOrUndefined(tableCell.ownerRow) ? tableCell.ownerRow.rowFormat.borders : undefined;
        let tableBorders = !isNullOrUndefined(tableCell.ownerTable) ? tableCell.ownerTable.tableFormat.borders : undefined;
        if (!isNullOrUndefined(cellBorder.left)) {
            leftBorder = cellBorder.left;
        }
        if (isNullOrUndefined(leftBorder)) {
            leftBorder = tableCell.getLeftBorderToRenderByHierarchy(leftBorder, rowBorders, tableBorders);
        }
        if (tableCell.ownerTable.tableFormat.cellSpacing > 0) {
            leftBorder = tableCell.getLeftBorderToRenderByHierarchy(leftBorder, rowBorders, tableBorders);
        }
        else {
            let prevCell = undefined;
            if (!isNullOrUndefined(tableCell.previousWidget)) {
                // if the border is shared then choose the border based on Conflict Resolution algorithm.
                prevCell = tableCell.previousWidget;
            }
            else if ((tableCell.cellFormat.columnSpan > 1 || tableCell.columnIndex > 1) && tableCell.ownerRow.rowIndex > 0) {
                let previousRow = tableCell.ownerRow.previousWidget;
                while (!isNullOrUndefined(previousRow) && previousRow.childWidgets.length > 0) {
                    for (let i = 0; i < previousRow.childWidgets.length; i++) {
                        let prevRowCell = previousRow.childWidgets[i];
                        if (prevRowCell.columnIndex + prevRowCell.cellFormat.columnSpan === tableCell.columnIndex) {
                            prevCell = previousRow.childWidgets[i];
                            break;
                        }
                    }
                    if (!isNullOrUndefined(prevCell)) {
                        break;
                    }
                    previousRow = previousRow.previousWidget;
                }
            }
            leftBorder = tableCell.getPreviousCellLeftBorder(leftBorder, prevCell);
        }
        if (isNullOrUndefined(leftBorder)) {
            leftBorder = new WBorder(tableCell.cellFormat.borders);
        }
        return leftBorder;
    }
    /**
     * @private
     */
    getLeftBorderWidth() {
        let borderWidth = 0;
        //let ownerTable = this.ownerTable;
        //Added null condition check for asynchronous loading.
        // if (this.cellFormat !== null && this.cellFormat.borders !== null) {
        // update the margins values respect to layouting of borders.
        //For normal table cells only left border is rendred. for last cell left and right border is rendred.
        // this border widths are not included in margins.
        //     boderWidth = this.cellFormat.borders.GetRightBorderToRender(this).GetLineWidth();
        //need to render rightBorder specifically for all the cells when the cellSpacing is greater than zero or for last cell of each row.
        // }
        return borderWidth;
    }
    /**
     * @private
     */
    getRightBorderWidth() {
        let borderWidth = 0;
        let ownerTable = this.ownerTable;
        //Added null condition check for asynchronous loading.
        // if (this.cellFormat !== null && this.cellFormat.borders !== null) {
        ///need to render right border specifically for all the cells when the cell spacing is 
        //greater than zero or for last cell of each row.
        //     let isLastCell: boolean = false;
        //     isLastCell = this.cellIndex === 0;
        //     if (ownerTable.tableFormat.cellSpacing > 0 || isLastCell) {
        //         boderWidth = this.cellFormat.borders.getLeftBorderToRender(this).GetLineWidth();
        //     }
        // }
        return borderWidth;
    }
    /**
     * @private
     */
    getCellSpacing() {
        let actualCellSpacing = this.ownerTable && this.ownerTable.tableFormat ? this.ownerTable.tableFormat.cellSpacing : 0;
        let cellSpacingToLayout = actualCellSpacing;
        // Considers the left, right margins and border widths(only available for Layouted table) for Minimum width.
        if (this.ownerRow.childWidgets.length === 1) {
            cellSpacingToLayout = actualCellSpacing * 2;
        }
        else if (this.cellIndex === 0 || this.cellIndex === this.ownerRow.childWidgets.length - 1) {
            cellSpacingToLayout = actualCellSpacing + (actualCellSpacing / 2);
        }
        else {
            cellSpacingToLayout = actualCellSpacing;
        }
        return cellSpacingToLayout;
    }
    /**
     * @private
     */
    getMinimumPreferredWidth() {
        let defaultWidth = 0;
        defaultWidth = this.leftMargin + this.rightMargin + this.getLeftBorderWidth() + this.getRightBorderWidth() + this.getCellSpacing();
        return defaultWidth;
    }
    /**
     * @private
     */
    getPreviousCellLeftBorder(leftBorder, previousCell) {
        // tslint:disable-next-line:max-line-length
        if ((isNullOrUndefined(previousCell) || (!isNullOrUndefined(leftBorder) && (leftBorder.lineStyle === 'None' && !leftBorder.hasNoneStyle)))) {
            if (!isNullOrUndefined(leftBorder) && !(leftBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getLeftBorderToRenderByHierarchy(leftBorder, TableRowWidget.getRowOf(leftBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(leftBorder.ownerBase).tableFormat.borders);
            }
        }
        else {
            let prevCellRightBorder = undefined;
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(previousCell.cellFormat.borders) && !isNullOrUndefined(previousCell.cellFormat.borders.right) && previousCell.cellFormat.borders.right.lineStyle !== 'None') {
                prevCellRightBorder = previousCell.cellFormat.borders.right;
            }
            if (!isNullOrUndefined(prevCellRightBorder) && prevCellRightBorder.lineStyle !== 'None') {
                return this.getBorderBasedOnPriority(prevCellRightBorder, leftBorder);
            }
            else if (!isNullOrUndefined(leftBorder) && !(leftBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getLeftBorderToRenderByHierarchy(leftBorder, TableRowWidget.getRowOf(leftBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(leftBorder.ownerBase).tableFormat.borders);
            }
        }
        return leftBorder;
    }
    /**
     * @private
     */
    getBorderBasedOnPriority(border, adjacentBorder) {
        // If the cell and its adjacent cell defined different borders then based on this algorithm the border choose to render.
        // Reference link :https://msdn.microsoft.com/en-us/library/office/documentformat.openxml.wordprocessing.tablecellborders.aspx
        if (isNullOrUndefined(border)) {
            return adjacentBorder;
        }
        else if (isNullOrUndefined(adjacentBorder)) {
            return border;
        }
        let borderWeight = border.getBorderWeight();
        let adjacentBorderWeight = adjacentBorder.getBorderWeight();
        //the border with higher wight  shall be displayed.
        if (borderWeight === adjacentBorderWeight) {
            //if the border is equal weight the based on the priority the border will be choosen to render.
            let borderPriority = border.getPrecedence();
            let adjacentBorderPriority = adjacentBorder.getPrecedence();
            if (borderPriority === adjacentBorderPriority) {
                //The color with the smaller brightness value shall be displayed.
                let borderColInRGB = this.convertHexToRGB(border.color);
                let R1 = borderColInRGB.r;
                let G1 = borderColInRGB.g;
                let B1 = borderColInRGB.b;
                let adjacentBorderColInRGB = this.convertHexToRGB(adjacentBorder.color);
                let R2 = adjacentBorderColInRGB.r;
                let G2 = adjacentBorderColInRGB.g;
                let B2 = adjacentBorderColInRGB.b;
                let borderBrightness = (R1 + B1 + (2 * G1));
                let adjacentBorderBrightness = (R2 + B2 + (2 * G2));
                if (borderBrightness === adjacentBorderBrightness) {
                    borderBrightness = (B1 + (2 * G1));
                    adjacentBorderBrightness = (B2 + (2 * G2));
                    if (borderBrightness === adjacentBorderBrightness) {
                        if (G1 === G2) {
                            return border;
                        }
                        else if (G1 > G2) {
                            return adjacentBorder;
                        }
                        else {
                            return border;
                        }
                    }
                    else if (borderBrightness > adjacentBorderBrightness) {
                        return adjacentBorder;
                    }
                    else {
                        return border;
                    }
                }
                else if (borderBrightness > adjacentBorderBrightness) {
                    return adjacentBorder;
                }
                else {
                    return border;
                }
            }
            else if (borderPriority > adjacentBorderPriority) {
                return border;
            }
            else {
                return adjacentBorder;
            }
        }
        else if (borderWeight > adjacentBorderWeight) {
            return border;
        }
        else {
            return adjacentBorder;
        }
    }
    /**
     * @private
     */
    getLeftBorderToRenderByHierarchy(leftBorder, rowBorders, tableBorders) {
        if (!isNullOrUndefined(leftBorder) && (leftBorder.lineStyle !== 'None' || (leftBorder.hasNoneStyle &&
            //If border defined with default values then border drawn based on hierarchy. 
            !(leftBorder.lineStyle === 'None' && leftBorder.lineWidth === 0 && leftBorder.color === '#000000')))) {
            return leftBorder;
            // tslint:disable-next-line:max-line-length
        }
        else if (!isNullOrUndefined(leftBorder) && (leftBorder.ownerBase instanceof WBorders) && TableCellWidget.getCellOf(leftBorder.ownerBase).columnIndex === 0) {
            if (!isNullOrUndefined(tableBorders) && !isNullOrUndefined(tableBorders.left)) {
                leftBorder = tableBorders.left;
            }
            return leftBorder;
        }
        else if (!isNullOrUndefined(rowBorders)
            && !isNullOrUndefined(rowBorders.vertical) && rowBorders.vertical.lineStyle !== 'None') {
            return leftBorder = rowBorders.vertical;
        }
        else if (!isNullOrUndefined(tableBorders)
            && !isNullOrUndefined(tableBorders.vertical) && tableBorders.vertical.lineStyle !== 'None') {
            return leftBorder = tableBorders.vertical;
        }
        else {
            return leftBorder;
        }
    }
    /**
     * @private
     */
    static getCellRightBorder(tableCell) {
        let rightBorder = undefined;
        let cellBorder = tableCell.cellFormat.borders;
        let rowBorders = !isNullOrUndefined(tableCell.ownerRow) ? tableCell.ownerRow.rowFormat.borders : undefined;
        let tableBorders = !isNullOrUndefined(tableCell.ownerTable) ? tableCell.ownerTable.tableFormat.borders : undefined;
        if (!isNullOrUndefined(cellBorder.right)) {
            rightBorder = cellBorder.right;
        }
        if (isNullOrUndefined(rightBorder)) {
            rightBorder = tableCell.getRightBorderToRenderByHierarchy(rightBorder, rowBorders, tableBorders);
        }
        if (tableCell.ownerTable.tableFormat.cellSpacing > 0) {
            rightBorder = tableCell.getRightBorderToRenderByHierarchy(rightBorder, rowBorders, tableBorders);
        }
        else {
            let nextCell = undefined;
            if (!isNullOrUndefined(tableCell.nextWidget)) {
                nextCell = tableCell.nextWidget;
            }
            // if the border is shared then choose the border based on Conflict Resolution algorithm.
            rightBorder = tableCell.getAdjacentCellRightBorder(rightBorder, nextCell);
        }
        if (isNullOrUndefined(rightBorder)) {
            rightBorder = new WBorder(tableCell.cellFormat.borders);
        }
        return rightBorder;
    }
    /**
     * @private
     */
    getAdjacentCellRightBorder(rightBorder, nextCell) {
        // tslint:disable-next-line:max-line-length
        if (isNullOrUndefined(nextCell) || (!isNullOrUndefined(rightBorder) && (rightBorder.lineStyle === 'None' && !rightBorder.hasNoneStyle))) {
            if (!isNullOrUndefined(rightBorder) && !(rightBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getRightBorderToRenderByHierarchy(rightBorder, TableRowWidget.getRowOf(rightBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(rightBorder.ownerBase).tableFormat.borders);
            }
        }
        else {
            let nextCellLeftBorder = undefined;
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(nextCell.cellFormat.borders) && !isNullOrUndefined(nextCell.cellFormat.borders.left) && nextCell.cellFormat.borders.left.lineStyle !== 'None') {
                nextCellLeftBorder = nextCell.cellFormat.borders.left;
            }
            if (!isNullOrUndefined(nextCellLeftBorder) && nextCellLeftBorder.lineStyle !== 'None') {
                return this.getBorderBasedOnPriority(rightBorder, nextCellLeftBorder);
            }
            else if (!isNullOrUndefined(rightBorder) && !(rightBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getRightBorderToRenderByHierarchy(rightBorder, TableRowWidget.getRowOf(rightBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(rightBorder.ownerBase).tableFormat.borders);
            }
        }
        return rightBorder;
    }
    /**
     * @private
     */
    getRightBorderToRenderByHierarchy(rightBorder, rowBorders, tableBorders) {
        if (!isNullOrUndefined(rightBorder) && (rightBorder.lineStyle !== 'None' || (rightBorder.hasNoneStyle &&
            //If border defined with default values then border drawn based on hierarchy. 
            !(rightBorder.lineStyle === 'None' && rightBorder.lineWidth === 0 && rightBorder.color === '#000000')))) {
            return rightBorder;
            // tslint:disable-next-line:max-line-length
        }
        else if (!isNullOrUndefined(rightBorder) && (rightBorder.ownerBase instanceof WBorders) && TableCellWidget.getCellOf(rightBorder.ownerBase).columnIndex === TableCellWidget.getCellOf(rightBorder.ownerBase).ownerRow.childWidgets.length - 1) {
            if (!isNullOrUndefined(tableBorders) && !isNullOrUndefined(tableBorders.right)) {
                rightBorder = tableBorders.right;
            }
            return rightBorder;
        }
        else if (!isNullOrUndefined(rowBorders)
            && !isNullOrUndefined(rowBorders.vertical) && rowBorders.vertical.lineStyle !== 'None') {
            return rightBorder = rowBorders.vertical;
        }
        else if (!isNullOrUndefined(tableBorders)
            && !isNullOrUndefined(tableBorders.vertical) && tableBorders.vertical.lineStyle !== 'None') {
            return rightBorder = tableBorders.vertical;
        }
        else {
            return rightBorder;
        }
    }
    /**
     * @private
     */
    static getCellTopBorder(tableCell) {
        let topBorder = undefined;
        let cellBorder = tableCell.cellFormat.borders;
        let rowBorders = !isNullOrUndefined(tableCell.ownerRow) ? tableCell.ownerRow.rowFormat.borders : undefined;
        let tableBorders = !isNullOrUndefined(tableCell.ownerTable) ? tableCell.ownerTable.tableFormat.borders : undefined;
        if (!isNullOrUndefined(cellBorder.top)) {
            topBorder = cellBorder.top;
        }
        if (isNullOrUndefined(topBorder)) {
            topBorder = tableCell.getTopBorderToRenderByHierarchy(topBorder, rowBorders, tableBorders);
        }
        if (tableCell.ownerTable.tableFormat.cellSpacing > 0) {
            topBorder = tableCell.getTopBorderToRenderByHierarchy(topBorder, rowBorders, tableBorders);
        }
        else {
            let prevTopCell = undefined;
            //ToDo: Need to analyze more to get the previous cell.
            let prevRow = tableCell.ownerRow.previousWidget;
            while (!isNullOrUndefined(prevRow) && prevRow.childWidgets.length > 0) {
                for (let i = 0; i < prevRow.childWidgets.length; i++) {
                    let prevRowCell = prevRow.childWidgets[i];
                    if (prevRowCell.columnIndex + prevRowCell.cellFormat.columnSpan - 1 >= tableCell.columnIndex) {
                        prevTopCell = prevRow.childWidgets[i];
                        break;
                    }
                }
                if (!isNullOrUndefined(prevTopCell)) {
                    break;
                }
                prevRow = prevRow.previousWidget;
                //If all the previous rows checked and the previous top cell is null
                // then TableCell previus row matched column index cell is taken for border calculation.
                if (isNullOrUndefined(prevRow) && isNullOrUndefined(prevTopCell)) {
                    prevRow = tableCell.ownerRow.previousWidget;
                    if (tableCell.columnIndex < prevRow.childWidgets.length) {
                        for (let i = 0; i < prevRow.childWidgets.length; i++) {
                            let prevRowCell = prevRow.childWidgets[i];
                            if (prevRowCell.columnIndex === tableCell.columnIndex) {
                                prevTopCell = prevRow.childWidgets[i];
                                break;
                            }
                        }
                        //If table cell Column index is greater than previous row cells count then last cell is taken as previous top cell.
                    }
                    else {
                        // tslint:disable-next-line:max-line-length
                        prevTopCell = tableCell.ownerRow.previousWidget.childWidgets[tableCell.ownerRow.previousWidget.childWidgets.length - 1];
                    }
                }
            }
            //If the border is shared then choose the border based on Conflict Resolution algorithm.
            topBorder = tableCell.getPreviousCellTopBorder(topBorder, prevTopCell);
        }
        if (isNullOrUndefined(topBorder)) {
            topBorder = new WBorder(tableCell.cellFormat.borders);
        }
        return topBorder;
    }
    /**
     * @private
     */
    getPreviousCellTopBorder(topBorder, previousTopCell) {
        // tslint:disable-next-line:max-line-length
        if (isNullOrUndefined(previousTopCell) || (!isNullOrUndefined(topBorder) && (topBorder.lineStyle === 'None' && !topBorder.hasNoneStyle))) {
            if (!isNullOrUndefined(topBorder) && !(topBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getTopBorderToRenderByHierarchy(topBorder, TableRowWidget.getRowOf(topBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(topBorder.ownerBase).tableFormat.borders);
            }
        }
        else {
            let prevTopCellBottomBorder = undefined;
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(previousTopCell.cellFormat.borders) && !isNullOrUndefined(previousTopCell.cellFormat.borders.bottom) && previousTopCell.cellFormat.borders.bottom.lineStyle !== 'None') {
                prevTopCellBottomBorder = previousTopCell.cellFormat.borders.bottom;
            }
            if (!isNullOrUndefined(prevTopCellBottomBorder) && prevTopCellBottomBorder.lineStyle !== 'None') {
                return this.getBorderBasedOnPriority(topBorder, prevTopCellBottomBorder);
            }
            else if (!isNullOrUndefined(topBorder) && !(topBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getTopBorderToRenderByHierarchy(topBorder, TableRowWidget.getRowOf(topBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(topBorder.ownerBase).tableFormat.borders);
            }
        }
        return topBorder;
    }
    /**
     * @private
     */
    getTopBorderToRenderByHierarchy(topBorder, rowBorders, tableBorders) {
        if (!isNullOrUndefined(topBorder) && (topBorder.lineStyle !== 'None' || (topBorder.hasNoneStyle &&
            //If border defined with default values then border drawn based on hierarchy. 
            !(topBorder.lineStyle === 'None' && topBorder.lineWidth === 0 && topBorder.color === '#000000')))) {
            return topBorder;
            // tslint:disable-next-line:max-line-length
        }
        else if (!isNullOrUndefined(topBorder) && (topBorder.ownerBase instanceof WBorders) && TableCellWidget.getCellOf(topBorder.ownerBase).ownerRow.rowIndex === 0) {
            if (!isNullOrUndefined(tableBorders) && !isNullOrUndefined(tableBorders.top)) {
                topBorder = tableBorders.top;
            }
            return topBorder;
        }
        else if (!isNullOrUndefined(rowBorders)
            && !isNullOrUndefined(rowBorders.horizontal) && rowBorders.horizontal.lineStyle !== 'None') {
            return topBorder = rowBorders.horizontal;
        }
        else if (!isNullOrUndefined(tableBorders)
            && !isNullOrUndefined(tableBorders.horizontal) && tableBorders.horizontal.lineStyle !== 'None') {
            return topBorder = tableBorders.horizontal;
        }
        else {
            return topBorder;
        }
    }
    /**
     * @private
     */
    static getCellBottomBorder(tableCell) {
        let bottomBorder = undefined;
        let cellBorder = tableCell.cellFormat.borders;
        let rowBorders = !isNullOrUndefined(tableCell.ownerRow) ? tableCell.ownerRow.rowFormat.borders : undefined;
        let tableBorders = !isNullOrUndefined(tableCell.ownerTable) ? tableCell.ownerTable.tableFormat.borders : undefined;
        if (!isNullOrUndefined(cellBorder.bottom)) {
            bottomBorder = cellBorder.bottom;
        }
        if (isNullOrUndefined(bottomBorder)) {
            // tslint:disable-next-line:max-line-length
            bottomBorder = tableCell.getBottomBorderToRenderByHierarchy(bottomBorder, rowBorders, tableBorders); // select the left border based on heirarchy.
        }
        if (tableCell.ownerTable.tableFormat.cellSpacing > 0) {
            bottomBorder = tableCell.getBottomBorderToRenderByHierarchy(bottomBorder, rowBorders, tableBorders);
        }
        else {
            let nextBottomCell = undefined;
            let nextRow = tableCell.ownerRow.nextWidget;
            if (!isNullOrUndefined(nextRow) && tableCell.columnIndex < nextRow.childWidgets.length) {
                nextBottomCell = nextRow.childWidgets[tableCell.columnIndex];
            }
            //If the border is shared then choose the border based on Conflict Resolution algorithm.
            bottomBorder = tableCell.getAdjacentCellBottomBorder(bottomBorder, nextBottomCell);
        }
        if (isNullOrUndefined(bottomBorder)) {
            bottomBorder = new WBorder(tableCell.cellFormat.borders);
        }
        return bottomBorder;
    }
    /**
     * @private
     */
    getAdjacentCellBottomBorder(bottomBorder, nextBottomCell) {
        // tslint:disable-next-line:max-line-length
        if (isNullOrUndefined(nextBottomCell) || (!isNullOrUndefined(bottomBorder) && (bottomBorder.lineStyle === 'None' && !bottomBorder.hasNoneStyle))) {
            if (!isNullOrUndefined(bottomBorder) && !(bottomBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getBottomBorderToRenderByHierarchy(bottomBorder, TableRowWidget.getRowOf(bottomBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(bottomBorder.ownerBase).tableFormat.borders);
            }
        }
        else {
            let prevBottomCellTopBorder = undefined;
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(nextBottomCell.cellFormat.borders) && !isNullOrUndefined(nextBottomCell.cellFormat.borders.top) && nextBottomCell.cellFormat.borders.top.lineStyle !== 'None') {
                prevBottomCellTopBorder = nextBottomCell.cellFormat.borders.top;
            }
            if (!isNullOrUndefined(prevBottomCellTopBorder) && prevBottomCellTopBorder.lineStyle !== 'None') {
                return this.getBorderBasedOnPriority(bottomBorder, prevBottomCellTopBorder);
            }
            else if (!isNullOrUndefined(bottomBorder) && !(bottomBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getBottomBorderToRenderByHierarchy(bottomBorder, TableRowWidget.getRowOf(bottomBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(bottomBorder.ownerBase).tableFormat.borders);
            }
        }
        return bottomBorder;
    }
    /**
     * @private
     */
    getBottomBorderToRenderByHierarchy(bottomBorder, rowBorders, tableBorders) {
        if (!isNullOrUndefined(bottomBorder) && (bottomBorder.lineStyle !== 'None' || (bottomBorder.hasNoneStyle &&
            //If border defined with default values then border drawn based on hierarchy. 
            !(bottomBorder.lineStyle === 'None' && bottomBorder.lineWidth === 0 && bottomBorder.color === '#000000')))) {
            return bottomBorder;
            // tslint:disable-next-line:max-line-length
        }
        else if (!isNullOrUndefined(bottomBorder) && (bottomBorder.ownerBase instanceof WBorders) && TableCellWidget.getCellOf(bottomBorder.ownerBase).ownerRow.rowIndex + TableCellWidget.getCellOf(bottomBorder.ownerBase).cellFormat.rowSpan === TableCellWidget.getCellOf(bottomBorder.ownerBase).ownerTable.childWidgets.length) {
            if (!isNullOrUndefined(tableBorders) && !isNullOrUndefined(tableBorders.bottom)) {
                bottomBorder = tableBorders.bottom;
            }
            return bottomBorder;
        }
        else if (!isNullOrUndefined(rowBorders)
            && !isNullOrUndefined(rowBorders.horizontal) && rowBorders.horizontal.lineStyle !== 'None') {
            return bottomBorder = rowBorders.horizontal;
        }
        else if (!isNullOrUndefined(tableBorders)
            && !isNullOrUndefined(tableBorders.horizontal) && tableBorders.horizontal.lineStyle !== 'None') {
            return bottomBorder = tableBorders.horizontal;
        }
        else {
            return bottomBorder;
        }
    }
    convertHexToRGB(colorCode) {
        if (colorCode) {
            colorCode = colorCode.replace(/[^0-9A-â€Œâ€‹F]/gi, ''); // To remove # from color code string.
            let colCodeNo = parseInt(colorCode, 16);
            let r = (colCodeNo >> 16) & 255;
            let g = (colCodeNo >> 8) & 255;
            let b = colCodeNo & 255;
            return { 'r': r, 'g': g, 'b': b };
        }
        return undefined;
    }
    /**
     * @private
     */
    static getCellOf(node) {
        if (node instanceof WBorders) {
            if (node.ownerBase instanceof WCellFormat && node.ownerBase.ownerBase instanceof TableCellWidget) {
                return node.ownerBase.ownerBase;
            }
            else {
                return undefined;
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    destroyInternal(viewer) {
        // let viewer: LayoutViewer = undefined;
        // let page: Page = this.getPage();
        // if (!isNullOrUndefined(page ))
        //     viewer = page.viewer;
        if (!isNullOrUndefined(this.childWidgets)) {
            for (let i = 0; i < this.childWidgets.length; i++) {
                let widget = this.childWidgets[i];
                if (widget instanceof ParagraphWidget) {
                    widget.destroyInternal(viewer);
                }
                else {
                    widget.destroyInternal(viewer);
                }
                i--;
            }
            this.childWidgets = undefined;
        }
        this.destroy();
    }
    /**
     * @private
     */
    clone() {
        let cell = new TableCellWidget();
        cell.cellFormat.copyFormat(this.cellFormat);
        for (let i = 0; i < this.childWidgets.length; i++) {
            let block = this.childWidgets[i].clone();
            cell.childWidgets.push(block);
            block.containerWidget = cell;
            block.index = i;
        }
        cell.leftBorderWidth = this.leftBorderWidth;
        cell.rightBorderWidth = this.rightBorderWidth;
        if (this.margin) {
            cell.margin = this.margin.clone();
        }
        cell.columnIndex = this.columnIndex;
        cell.x = this.x;
        cell.y = this.y;
        cell.height = this.height;
        cell.width = this.width;
        return cell;
    }
    /**
     * @private
     */
    destroy() {
        // if (this.cellFormat) {
        //     this.cellFormat.destroy();
        // }
        this.cellFormat = undefined;
        this.rowIndex = undefined;
        this.columnIndex = undefined;
        super.destroy();
    }
}
/**
 * @private
 */
class LineWidget {
    /**
     * Initialize the constructor of LineWidget
     */
    constructor(paragraphWidget) {
        /**
         * @private
         */
        this.children = [];
        /**
         * @private
         */
        this.x = 0;
        /**
         * @private
         */
        this.y = 0;
        /**
         * @private
         */
        this.width = 0;
        /**
         * @private
         */
        this.height = 0;
        this.paragraph = paragraphWidget;
    }
    /**
     * @private
     */
    get indexInOwner() {
        if (this.paragraph && this.paragraph.childWidgets) {
            return this.paragraph.childWidgets.indexOf(this);
        }
        return -1;
    }
    /**
     * @private
     */
    get nextLine() {
        let paragraph = this.paragraph;
        let lineIndex = this.indexInOwner;
        if (lineIndex <= paragraph.childWidgets.length - 2) {
            return paragraph.childWidgets[lineIndex + 1];
        }
        else if (paragraph.nextSplitWidget) {
            let line = paragraph.nextSplitWidget.firstChild;
            if (line instanceof LineWidget && line.paragraph.equals(this.paragraph)) {
                return line;
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    get previousLine() {
        let paragraph = this.paragraph;
        let lineIndex = this.indexInOwner;
        let splitParagraph = paragraph.previousSplitWidget;
        if (lineIndex > 0) {
            return paragraph.childWidgets[lineIndex - 1];
        }
        else if (splitParagraph instanceof ParagraphWidget) {
            let line = splitParagraph.lastChild;
            if (line instanceof LineWidget && line.paragraph.equals(this.paragraph)) {
                return line;
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    get isEndsWithPageBreak() {
        if (this.children.length > 0) {
            let lastElement = this.children[this.children.length - 1];
            if (lastElement instanceof TextElementBox) {
                return lastElement.isPageBreak;
            }
        }
        return false;
    }
    /**
     * @private
     */
    isFirstLine() {
        let index = this.indexInOwner;
        if (index > -1 && this.paragraph.previousSplitWidget === undefined) {
            return index === 0;
        }
        return false;
    }
    /**
     * @private
     */
    isLastLine() {
        let index = this.indexInOwner;
        if (index > -1 && this.paragraph.nextSplitWidget === undefined) {
            return index === this.paragraph.childWidgets.length - 1;
        }
        return false;
    }
    /**
     * @private
     */
    getOffset(inline, index) {
        if (isNullOrUndefined(inline)) {
            return index;
        }
        let textIndex = index;
        let line = inline.line;
        let lineIndex = inline.line.paragraph.childWidgets.indexOf(inline.line);
        for (let i = 0; i < line.children.length; i++) {
            let inlineElement = line.children[i];
            if (inline === inlineElement) {
                break;
            }
            if (inlineElement instanceof ListTextElementBox) {
                continue;
            }
            textIndex += inlineElement.length;
        }
        return textIndex;
    }
    /**
     * @private
     */
    getEndOffset() {
        let startOffset = 0;
        let count = 0;
        for (let i = 0; i < this.children.length; i++) {
            let inlineElement = this.children[i];
            if (inlineElement.length === 0) {
                continue;
            }
            if (inlineElement instanceof ListTextElementBox) {
                continue;
            }
            if (inlineElement instanceof TextElementBox || inlineElement instanceof ImageElementBox
                || inlineElement instanceof BookmarkElementBox || (inlineElement instanceof FieldElementBox
                && HelperMethods.isLinkedFieldCharacter(inlineElement))) {
                startOffset = count + inlineElement.length;
            }
            count += inlineElement.length;
        }
        return startOffset;
    }
    /**
     * @private
     */
    getInline(offset, indexInInline) {
        let inlineElement = undefined;
        let count = 0;
        let isStarted = false;
        if (this.children.length === 0) {
            if (this.previousLine) {
                let elementBox = this.previousLine.children[this.previousLine.children.length - 1];
                if (elementBox instanceof TextElementBox && elementBox.text === '\v') {
                    inlineElement = this.previousLine.children[this.previousLine.children.length - 1];
                    indexInInline = 1;
                    return { 'element': inlineElement, 'index': indexInInline };
                }
            }
        }
        for (let i = 0; i < this.children.length; i++) {
            inlineElement = this.children[i];
            if (inlineElement instanceof ListTextElementBox) {
                continue;
            }
            if (!isStarted && (inlineElement instanceof TextElementBox || inlineElement instanceof ImageElementBox
                || inlineElement instanceof BookmarkElementBox
                || inlineElement instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(inlineElement))) {
                isStarted = true;
            }
            if (isStarted && offset <= count + inlineElement.length) {
                indexInInline = (offset - count);
                return { 'element': inlineElement, 'index': indexInInline };
            }
            count += inlineElement.length;
        }
        if (offset > count) {
            indexInInline = isNullOrUndefined(inlineElement) ? offset : inlineElement.length;
        }
        return { 'element': inlineElement, 'index': indexInInline };
    }
    /**
     * @private
     */
    getHierarchicalIndex(hierarchicalIndex) {
        let node = this;
        hierarchicalIndex = node.paragraph.childWidgets.indexOf(node) + ';' + hierarchicalIndex;
        if (node.paragraph instanceof BlockWidget) {
            return node.paragraph.getHierarchicalIndex(hierarchicalIndex);
        }
        return hierarchicalIndex;
    }
    /**
     * @private
     */
    clone() {
        let line = new LineWidget(undefined);
        for (let j = 0; j < this.children.length; j++) {
            let element = this.children[j];
            let clone = element.clone();
            line.children.push(clone);
            clone.line = line;
        }
        line.width = this.width;
        line.height = this.height;
        return line;
    }
    /**
     * @private
     */
    destroy() {
        if (!isNullOrUndefined(this.children)) {
            for (let i = 0; i < this.children.length; i++) {
                this.children[i].destroy();
            }
            this.children = [];
        }
        this.children = undefined;
        if (this.paragraph) {
            this.paragraph.removeChild(this.indexInOwner);
        }
        this.paragraph = undefined;
        this.x = undefined;
        this.y = undefined;
        this.width = undefined;
        this.height = undefined;
    }
}
/**
 * @private
 */
class ElementBox {
    /**
     * Initialize the constructor of ElementBox
     */
    constructor() {
        /**
         * @private
         */
        this.x = 0;
        /**
         * @private
         */
        this.y = 0;
        /**
         * @private
         */
        this.width = 0;
        /**
         * @private
         */
        this.height = 0;
        /**
         * @private
         */
        this.margin = new Margin(0, 0, 0, 0);
        /**
         * @private
         */
        this.characterFormat = undefined;
        this.characterFormat = new WCharacterFormat(this);
        this.margin = new Margin(0, 0, 0, 0);
    }
    /**
     * @private
     */
    get isPageBreak() {
        if (this instanceof TextElementBox) {
            return this.text === '\f';
        }
        return false;
    }
    /**
     * @private
     */
    linkFieldCharacter(viewer) {
        if (!(this instanceof FieldElementBox)) {
            return;
        }
        if (this.fieldType === 0) {
            let fieldBegin = this;
            if (isNullOrUndefined(fieldBegin.fieldEnd)) {
                this.linkFieldTraversingForward(this.line, fieldBegin, fieldBegin);
                if (viewer.fields.indexOf(fieldBegin) === -1) {
                    viewer.fields.push(fieldBegin);
                }
            }
        }
        else if (this.fieldType === 2) {
            let fieldSeparator = this;
            //Links the field begin for the current separator.
            if (isNullOrUndefined(fieldSeparator.fieldBegin)) {
                this.linkFieldTraversingBackwardSeparator(this.line, fieldSeparator, fieldSeparator);
            }
            fieldSeparator.fieldBegin.fieldSeparator = fieldSeparator;
            if (!isNullOrUndefined(fieldSeparator.fieldBegin)) {
                //Links to field end traversing from field separator.
                let isFieldEnd = this.linkFieldTraversingForward(this.line, fieldSeparator.fieldBegin, fieldSeparator);
                if (isNullOrUndefined(fieldSeparator.fieldEnd) && isFieldEnd) {
                    fieldSeparator.fieldEnd = fieldSeparator.fieldBegin.fieldEnd;
                }
                if (fieldSeparator.fieldEnd) {
                    fieldSeparator.fieldEnd.fieldSeparator = fieldSeparator;
                }
            }
        }
        else {
            let fieldEnd = this;
            //Links the field begin and separator for the current end.
            if (isNullOrUndefined(fieldEnd.fieldBegin)) {
                this.linkFieldTraversingBackward(this.line, fieldEnd, fieldEnd);
            }
        }
    }
    /**
     * @private
     */
    linkFieldTraversingBackward(line, fieldEnd, previousNode) {
        let k = line.children.length - 1;
        if (line.children.indexOf(previousNode) > -1) {
            k = line.children.indexOf(previousNode) - 1;
        }
        for (let j = k; j >= 0; j--) {
            let childNode = line.children[j];
            if (childNode instanceof FieldElementBox) {
                if (childNode.fieldType === 0) {
                    if (isNullOrUndefined(childNode.fieldEnd)) {
                        fieldEnd.fieldBegin = childNode;
                        if (isNullOrUndefined(childNode.fieldEnd)) {
                            childNode.fieldEnd = fieldEnd;
                        }
                        if (fieldEnd.fieldSeparator && isNullOrUndefined(fieldEnd.fieldSeparator.fieldBegin)) {
                            fieldEnd.fieldSeparator.fieldBegin = childNode;
                            if (isNullOrUndefined(childNode.fieldSeparator)) {
                                childNode.fieldSeparator = fieldEnd.fieldSeparator;
                            }
                        }
                    }
                    return !isNullOrUndefined(fieldEnd.fieldBegin);
                }
                else if (childNode.fieldType === 2 && isNullOrUndefined(childNode.fieldEnd)) {
                    fieldEnd.fieldSeparator = childNode;
                    childNode.fieldEnd = fieldEnd;
                    if (!isNullOrUndefined(childNode.fieldBegin)) {
                        fieldEnd.fieldBegin = childNode.fieldBegin;
                    }
                }
            }
        }
        if (line.previousLine) {
            this.linkFieldTraversingBackward(line.previousLine, fieldEnd, this);
        }
        else if (line.paragraph.previousRenderedWidget instanceof ParagraphWidget) {
            let prevParagraph = line.paragraph.previousRenderedWidget;
            // tslint:disable-next-line:max-line-length
            this.linkFieldTraversingBackward(prevParagraph.childWidgets[prevParagraph.childWidgets.length - 1], fieldEnd, this);
        }
        return true;
    }
    /**
     * @private
     */
    linkFieldTraversingForward(line, fieldBegin, previousNode) {
        let i = 0;
        if (line.children.indexOf(previousNode) > -1) {
            i = line.children.indexOf(previousNode) + 1;
        }
        for (let j = i; j < line.children.length; j++) {
            let node = line.children[j];
            if (node instanceof FieldElementBox) {
                if (node.fieldType === 1) {
                    if (isNullOrUndefined(node.fieldBegin)) {
                        fieldBegin.fieldEnd = node;
                    }
                    if (fieldBegin.fieldEnd && isNullOrUndefined(fieldBegin.fieldEnd.fieldBegin)) {
                        fieldBegin.fieldEnd.fieldBegin = fieldBegin;
                    }
                    return true;
                }
                else if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
                    if (node.fieldType === 2 && isNullOrUndefined(node.fieldBegin)) {
                        fieldBegin.fieldSeparator = node;
                        if (!isNullOrUndefined(node.fieldEnd)) {
                            fieldBegin.fieldEnd = node.fieldEnd;
                            return true;
                        }
                    }
                    else {
                        return false;
                    }
                }
            }
        }
        if (line.nextLine) {
            this.linkFieldTraversingForward(line.nextLine, fieldBegin, this);
        }
        else if (line.paragraph.nextRenderedWidget instanceof ParagraphWidget) {
            this.linkFieldTraversingForward(line.paragraph.nextRenderedWidget.childWidgets[0], fieldBegin, this);
        }
        return true;
    }
    /**
     * @private
     */
    linkFieldTraversingBackwardSeparator(line, fieldSeparator, previousNode) {
        let index = line.children.length - 1;
        if (line.children.indexOf(previousNode) > -1) {
            index = line.children.indexOf(previousNode) - 1;
        }
        for (let i = index; i >= 0; i--) {
            let childElement = line.children[i];
            if (childElement instanceof FieldElementBox) {
                if (childElement instanceof FieldElementBox && childElement.fieldType === 0) {
                    if (isNullOrUndefined(childElement.fieldSeparator)) {
                        fieldSeparator.fieldBegin = childElement;
                    }
                    return !isNullOrUndefined(fieldSeparator.fieldBegin);
                }
            }
        }
        if (line.previousLine) {
            this.linkFieldTraversingBackwardSeparator(line.previousLine, fieldSeparator, this);
        }
        else if (line.paragraph.nextRenderedWidget instanceof ParagraphWidget) {
            // tslint:disable-next-line:max-line-length
            line = line.paragraph.previousRenderedWidget.childWidgets[line.paragraph.previousRenderedWidget.childWidgets.length - 1];
            this.linkFieldTraversingBackwardSeparator(line, fieldSeparator, this);
        }
        else {
            return true;
        }
        return true;
    }
    /**
     * @private
     */
    get length() {
        return this.getLength();
    }
    /**
     * @private
     */
    get indexInOwner() {
        return this.line instanceof LineWidget && this.line.children ? this.line.children.indexOf(this) : -1;
    }
    /**
     * @private
     */
    get previousElement() {
        let index = this.indexInOwner;
        if (index > 0 && index < this.line.children.length) {
            return this.line.children[index - 1];
        }
        return undefined;
    }
    /**
     * @private
     */
    get nextElement() {
        let index = this.indexInOwner;
        if (index > -1 && index < this.line.children.length - 1) {
            return this.line.children[index + 1];
        }
        return undefined;
    }
    /**
     * @private
     */
    get nextNode() {
        let index = this.line.children.indexOf(this);
        let lineIndex = this.line.paragraph.childWidgets.indexOf(this.line);
        if (index < this.line.children.length - 1) {
            return this.line.children[index + 1];
        }
        else if (lineIndex < this.line.paragraph.childWidgets.length - 1) {
            return this.line.paragraph.childWidgets[lineIndex + 1].children[0];
        }
        return undefined;
    }
    /**
     * @private
     */
    get previousNode() {
        let index = this.line.children.indexOf(this);
        let lineIndex = this.line.paragraph.childWidgets.indexOf(this.line);
        if (index > 0) {
            return this.line.children[index - 1];
        }
        else if (lineIndex > 0) {
            let lineWidget = this.line.paragraph.childWidgets[lineIndex - 1];
            return lineWidget.children[lineWidget.children.length - 1];
        }
        return undefined;
    }
    /**
     * @private
     */
    get paragraph() {
        if (this.line) {
            return this.line.paragraph;
        }
        return undefined;
    }
    /**
     * @private
     */
    destroy() {
        if (!isNullOrUndefined(this.line) && this.line.children && this.line.children.indexOf(this) > -1) {
            let index = this.line.children.indexOf(this);
            this.line.children.splice(index, 1);
        }
        this.line = undefined;
        if (this.characterFormat) {
            this.characterFormat.destroy();
        }
        this.characterFormat = undefined;
        if (this.margin) {
            this.margin.destroy();
        }
        this.margin = undefined;
        this.x = undefined;
        this.y = undefined;
        this.width = undefined;
        this.height = undefined;
    }
}
/**
 * @private
 */
ElementBox.objectCharacter = String.fromCharCode(65532);
/**
 * @private
 */
class FieldElementBox extends ElementBox {
    constructor(type) {
        super();
        /**
         * @private
         */
        this.fieldType = 0;
        /**
         * @private
         */
        this.hasFieldEnd = false;
        this.fieldBeginInternal = undefined;
        this.fieldSeparatorInternal = undefined;
        this.fieldEndInternal = undefined;
        this.fieldType = type;
    }
    get fieldBegin() {
        return this.fieldBeginInternal;
    }
    set fieldBegin(field) {
        this.fieldBeginInternal = field;
    }
    get fieldSeparator() {
        return this.fieldSeparatorInternal;
    }
    set fieldSeparator(field) {
        this.fieldSeparatorInternal = field;
    }
    get fieldEnd() {
        return this.fieldEndInternal;
    }
    set fieldEnd(field) {
        this.fieldEndInternal = field;
    }
    /**
     * @private
     */
    getLength() {
        return 1;
    }
    /**
     * @private
     */
    clone() {
        let field = new FieldElementBox(this.fieldType);
        field.characterFormat.copyFormat(this.characterFormat);
        if (this.margin) {
            field.margin = this.margin.clone();
        }
        field.width = this.width;
        field.height = this.height;
        return field;
    }
    /**
     * @private
     */
    destroy() {
        this.fieldType = undefined;
        this.hasFieldEnd = undefined;
        this.fieldBeginInternal = undefined;
        this.fieldEndInternal = undefined;
        this.fieldSeparatorInternal = undefined;
        super.destroy();
    }
}
/**
 * @private
 */
class TextElementBox extends ElementBox {
    constructor() {
        super();
        /**
         * @private
         */
        this.baselineOffset = 0;
        /**
         * @private
         */
        this.text = '';
    }
    /**
     * @private
     */
    getLength() {
        return this.text ? this.text.length : 0;
    }
    /**
     * @private
     */
    clone() {
        let span = new TextElementBox();
        span.characterFormat.copyFormat(this.characterFormat);
        span.text = this.text;
        if (this.margin) {
            span.margin = this.margin.clone();
        }
        span.width = this.width;
        span.height = this.height;
        return span;
    }
    /**
     * @private
     */
    destroy() {
        this.text = undefined;
        super.destroy();
    }
}
/**
 * @private
 */
class FieldTextElementBox extends TextElementBox {
    constructor() {
        super();
        this.fieldText = '';
    }
    get text() {
        return this.fieldText;
    }
    set text(value) {
        this.fieldText = value;
    }
    /**
     * @private
     */
    clone() {
        let span = new FieldTextElementBox();
        span.characterFormat.copyFormat(this.characterFormat);
        span.fieldBegin = this.fieldBegin;
        span.text = this.text;
        if (this.margin) {
            span.margin = this.margin.clone();
        }
        span.width = this.width;
        span.height = this.height;
        return span;
    }
}
/**
 * @private
 */
class TabElementBox extends TextElementBox {
    constructor() {
        super();
        /**
         * @private
         */
        this.tabText = '';
        /**
         * @private
         */
        this.tabLeader = 'None';
    }
    /**
     * @private
     */
    destroy() {
        this.tabText = undefined;
        this.tabLeader = undefined;
    }
    /**
     * @private
     */
    clone() {
        let span = new TabElementBox();
        span.characterFormat.copyFormat(this.characterFormat);
        span.tabText = this.tabText;
        span.tabLeader = this.tabLeader;
        span.text = this.text;
        if (this.margin) {
            span.margin = this.margin.clone();
        }
        span.width = this.width;
        span.height = this.height;
        return span;
    }
}
/**
 * @private
 */
class BookmarkElementBox extends ElementBox {
    constructor(type) {
        super();
        this.bookmarkTypeIn = 0;
        this.refereneceIn = undefined;
        this.nameIn = '';
        this.bookmarkTypeIn = type;
    }
    /**
     * @private
     */
    get bookmarkType() {
        return this.bookmarkTypeIn;
    }
    /**
     * @private
     */
    get name() {
        return this.nameIn;
    }
    /**
     * @private
     */
    set name(name) {
        this.nameIn = name;
    }
    /**
     * @private
     */
    get reference() {
        return this.refereneceIn;
    }
    /**
     * @private
     */
    set reference(reference) {
        this.refereneceIn = reference;
    }
    /**
     * @private
     */
    getLength() {
        return 1;
    }
    /**
     * @private
     */
    destroy() {
        this.name = undefined;
        this.reference = undefined;
        this.bookmarkTypeIn = undefined;
    }
    /**
     * Clones the bookmark element box.
     * @param element - book mark element
     */
    /**
     * @private
     */
    clone() {
        let span = new BookmarkElementBox(this.bookmarkType);
        span.name = this.name;
        span.reference = this.reference;
        if (this.margin) {
            span.margin = this.margin.clone();
        }
        span.width = this.width;
        span.height = this.height;
        return span;
    }
}
/**
 * @private
 */
class ImageElementBox extends ElementBox {
    constructor(isInlineImage) {
        super();
        this.imageStr = '';
        this.imgElement = undefined;
        this.isInlineImageIn = true;
        /**
         * @private
         */
        this.isMetaFile = false;
        this.isInlineImageIn = isInlineImage;
    }
    /**
     * @private
     */
    get isInlineImage() {
        return this.isInlineImageIn;
    }
    /**
     * @private
     */
    get element() {
        if (isNullOrUndefined(this.imgElement)) {
            this.imgElement = document.createElement('img');
        }
        return this.imgElement;
    }
    /**
     * @private
     */
    get length() {
        return 1;
    }
    /**
     * @private
     */
    get imageString() {
        return this.imageStr;
    }
    /**
     * @private
     */
    set imageString(value) {
        this.imageStr = value;
        if (!isNullOrUndefined(value)) {
            this.element.src = this.imageStr;
        }
    }
    /**
     * @private
     */
    getLength() {
        return 1;
    }
    /**
     * @private
     */
    clone() {
        let image = new ImageElementBox(this.isInlineImage);
        image.characterFormat.copyFormat(this.characterFormat);
        image.imageString = this.imageString;
        image.isMetaFile = this.isMetaFile;
        image.width = this.width;
        image.height = this.height;
        if (this.margin) {
            image.margin = this.margin.clone();
        }
        return image;
    }
    /**
     * @private
     */
    destroy() {
        this.imgElement = undefined;
        this.imageString = undefined;
        this.isInlineImageIn = undefined;
        super.destroy();
    }
}
/**
 * @private
 */
class ListTextElementBox extends ElementBox {
    constructor(listLevel, isListFollowCharacter) {
        super();
        /**
         * @private
         */
        this.baselineOffset = 0;
        /**
         * @private
         */
        this.isFollowCharacter = false;
        this.listLevel = listLevel;
        this.isFollowCharacter = isListFollowCharacter;
    }
    /**
     * @private
     */
    getLength() {
        return this.text ? this.text.length : 0;
    }
    /**
     * @private
     */
    clone() {
        let list = new ListTextElementBox(this.listLevel, this.isFollowCharacter);
        list.text = this.text;
        list.baselineOffset = this.baselineOffset;
        if (this.margin) {
            list.margin = this.margin.clone();
        }
        list.width = this.width;
        list.height = this.height;
        return list;
    }
    /**
     * @private
     */
    destroy() {
        this.text = undefined;
        super.destroy();
    }
}
/**
 * @private
 */
class Page {
    /**
     * Initialize the constructor of Page
     */
    constructor() {
        /**
         * Specifies the Bonding Rectangle
         * @private
         */
        this.boundingRectangle = new Rect(96, 96, 816, 1056);
        /**
         * @private
         */
        this.repeatHeaderRowTableWidget = false;
        /**
         * Specifies the bodyWidgets
         * @default []
         * @private
         */
        this.bodyWidgets = [];
        /**
         * @private
         */
        this.headerWidget = undefined;
        /**
         * @private
         */
        this.footerWidget = undefined;
        // let text: string = 'DocumentEditor';
    }
    /**
     * @private
     */
    get index() {
        if (this.viewer) {
            return this.viewer.pages.indexOf(this);
        }
        return -1;
    }
    /**
     * @private
     */
    get previousPage() {
        let index = this.index;
        if (index > 0) {
            return this.viewer.pages[index - 1];
        }
        return undefined;
    }
    /**
     * @private
     */
    get nextPage() {
        let index = this.index;
        if (index < this.viewer.pages.length - 1) {
            return this.viewer.pages[index + 1];
        }
        return undefined;
    }
    /**
     * @private
     */
    get sectionIndex() {
        if (this.bodyWidgets.length > 0) {
            return this.bodyWidgets[0].index;
        }
        return -1;
    }
    destroy() {
        if (this.headerWidget) {
            if (this.viewer && this.viewer.owner.editor) {
                this.viewer.owner.editor.removeFieldInWidget(this.headerWidget);
            }
            this.headerWidget.destroy();
        }
        this.headerWidget = undefined;
        if (this.footerWidget) {
            if (this.viewer && this.viewer.owner.editor) {
                this.viewer.owner.editor.removeFieldInWidget(this.footerWidget);
            }
            this.footerWidget.destroy();
        }
        this.footerWidget = undefined;
        this.bodyWidgets = [];
        this.bodyWidgets = undefined;
        if (!isNullOrUndefined(this.viewer)) {
            if (!isNullOrUndefined(this.viewer.pages)) {
                this.viewer.removePage(this);
            }
        }
        this.viewer = undefined;
    }
}
/**
 * @private
 */
class WTableHolder {
    constructor() {
        this.tableColumns = [];
        /**
         * @private
         */
        this.tableWidth = 0;
    }
    get columns() {
        return this.tableColumns;
    }
    /**
     * @private
     */
    resetColumns() {
        for (let i = 0; i < this.tableColumns.length; i++) {
            this.tableColumns[i].destroy();
        }
        this.tableColumns = [];
    }
    /**
     * @private
     */
    getPreviousSpannedCellWidth(previousColumnIndex, curColumnIndex) {
        let width = 0;
        for (let i = previousColumnIndex; i < curColumnIndex; i++) {
            width += this.tableColumns[i].preferredWidth;
        }
        return width;
    }
    /**
     * @private
     */
    addColumns(currentColumnIndex, columnSpan, width, minWidth, offset) {
        for (let i = this.columns.length; i < columnSpan; i++) {
            this.columns.push(new WColumn());
        }
        let availableWidth = 0;
        for (let j = currentColumnIndex; j < columnSpan; j++) {
            availableWidth += this.columns[j].preferredWidth;
        }
        // If width to add is greater than preferred width, then preferred width will be increased.
        // In case of Gridspan > 1, only last grid column width will be updated.
        let gridSpan = columnSpan - currentColumnIndex;
        if (!(gridSpan > 1) && availableWidth < width) {
            this.columns[columnSpan - 1].preferredWidth += (width - availableWidth);
        }
        if (minWidth > this.columns[columnSpan - 1].minWidth) {
            this.columns[columnSpan - 1].minWidth = minWidth;
        }
        if (offset > this.columns[columnSpan - 1].endOffset) {
            this.columns[columnSpan - 1].endOffset = offset;
        }
    }
    /**
     * @private
     */
    getTotalWidth() {
        let width = 0;
        for (let i = 0; i < this.columns.length; i++) {
            let column = this.columns[i];
            width += column.preferredWidth;
        }
        return width;
    }
    /**
     * @private
     */
    isFitColumns(containerWidth, preferredTableWidth, isAutoWidth) {
        // Gets total preferred width.
        let totalColumnWidth = this.getTotalWidth();
        // If auto table width, based on total column widths, minimum value will be updated.
        if (isAutoWidth) {
            this.tableWidth = preferredTableWidth > totalColumnWidth ? totalColumnWidth : preferredTableWidth;
        }
        else {
            this.tableWidth = preferredTableWidth;
        }
        // If total columns width doesn't match table width, then all grid column widths will be updated by even factor.
        // If totalColumnWidth < TableWidth, all grid columns are enlarged. Otherwise shrinked.
        if (totalColumnWidth !== this.tableWidth) {
            let factor = this.tableWidth / totalColumnWidth;
            factor = isNaN(factor) ? 1 : factor;
            for (let i = 0; i < this.columns.length; i++) {
                let column = this.columns[i];
                //column.PreferredWidth = factor * column.PreferredWidth;
                if (factor * column.preferredWidth < column.minWidth) {
                    return false;
                }
            }
            return true;
        }
        else {
            return true;
        }
    }
    /**
     * @private
     */
    fitColumns(containerWidth, preferredTableWidth, isAutoWidth) {
        // Gets total preferred width.
        let totalColumnWidth = this.getTotalWidth();
        // If auto table width, based on total column widths, minimum value will be updated.
        if (isAutoWidth) {
            this.tableWidth = preferredTableWidth > totalColumnWidth ? totalColumnWidth : preferredTableWidth;
        }
        else {
            this.tableWidth = preferredTableWidth;
        }
        // If total columns width doesn't match table width, then all grid column widths will be updated by even factor.
        // If totalColumnWidth < TableWidth, all grid columns are enlarged. Otherwise shrinked.
        if (totalColumnWidth !== this.tableWidth) {
            let factor = this.tableWidth / totalColumnWidth;
            for (let i = 0; i < this.columns.length; i++) {
                let column = this.columns[i];
                column.preferredWidth = factor * column.preferredWidth;
            }
        }
    }
    /**
     * @private
     */
    getCellWidth(columnIndex, columnSpan, preferredTableWidth, isAutoWidth) {
        let width = 0;
        for (let i = 0; i < columnSpan; i++) {
            width += this.tableColumns[i + columnIndex].preferredWidth;
        }
        return width;
    }
    /**
     * @private
     */
    validateColumnWidths() {
        for (let i = 0; i < this.columns.length; i++) {
            if (i === 0) {
                if (this.columns[i].preferredWidth !== this.columns[i].endOffset) {
                    this.columns[i].preferredWidth = this.columns[i].endOffset;
                }
            }
            else {
                // If Previous column offset + current column preferred width is less than current column offset, 
                // Then current column preferred width is set to current column offset - previous column offset.
                if (this.columns[i - 1].endOffset + this.columns[i].preferredWidth < this.columns[i].endOffset) {
                    this.columns[i].preferredWidth = this.columns[i].endOffset - this.columns[i - 1].endOffset;
                }
            }
        }
    }
    /**
     * @private
     */
    clone() {
        let tableHolder = new WTableHolder();
        tableHolder.tableWidth = this.tableWidth;
        for (let i = 0; i < this.columns.length; i++) {
            tableHolder.columns.push(this.columns[i].clone());
        }
        return tableHolder;
    }
    /**
     * @private
     */
    destroy() {
        if (!isNullOrUndefined(this.tableColumns)) {
            for (let i = 0; i < this.tableColumns.length; i++) {
                let column = this.tableColumns[i];
                column.destroy();
            }
        }
        this.tableColumns = [];
        this.tableColumns = undefined;
        this.tableWidth = undefined;
    }
}
/**
 * @private
 */
class WColumn {
    constructor() {
        /**
         * @private
         */
        this.preferredWidth = 0;
        /**
         * @private
         */
        this.minWidth = 0;
        /**
         * @private
         */
        this.maxWidth = 0;
        /**
         * @private
         */
        this.endOffset = 0;
    }
    /**
     * @private
     */
    clone() {
        let column = new WColumn();
        column.preferredWidth = this.preferredWidth;
        column.minWidth = this.minWidth;
        column.maxWidth = this.maxWidth;
        return column;
    }
    /**
     * @private
     */
    destroy() {
        this.preferredWidth = undefined;
        this.minWidth = undefined;
        this.maxWidth = undefined;
    }
}

const CONTEXTMENU_COPY = '_contextmenu_copy';
const CONTEXTMENU_CUT = '_contextmenu_cut';
const CONTEXTMENU_PASTE = '_contextmenu_paste';
const CONTEXTMENU_UPDATE_FIELD = '_contextmenu_update_field';
const CONTEXTMENU_EDIT_FIELD = '_contextmenu_edit_field';
const CONTEXTMENU_HYPERLINK = '_contextmenu_hyperlink';
const CONTEXTMENU_OPEN_HYPERLINK = '_contextmenu_open_hyperlink';
const CONTEXTMENU_COPY_HYPERLINK = '_contextmenu_copy_hyperlink';
const CONTEXTMENU_REMOVE_HYPERLINK = '_contextmenu_remove_hyperlink';
const CONTEXTMENU_EDIT_HYPERLINK = '_contextmenu_edit_hyperlink';
const CONTEXTMENU_FONT_DIALOG = '_contextmenu_font_dialog';
const CONTEXTMENU_PARAGRAPH = '_contextmenu_paragraph_dialog';
const CONTEXTMENU_TABLE = '_contextmenu_table_dialog';
const CONTEXTMENU_INSERT_TABLE = '_contextmenu_insert_table';
const CONTEXTMENU_DELETE_TABLE = '_contextmenu_delete_table';
const CONTEXTMENU_INSERT_ABOVE = '_contextmenu_insert_above';
const CONTEXTMENU_INSERT_BELOW = '_contextmenu_insert_below';
const CONTEXTMENU_INSERT_RIGHT = '_contextmenu_insert_right';
const CONTEXTMENU_INSERT_LEFT = '_contextmenu_insert_left';
const CONTEXTMENU_COMPLETE_DELETE_TABLE = '_contextmenu_complete_table_delete';
const CONTEXTMENU_DELETE_ROW = '_contextmenu_delete_row';
const CONTEXTMENU_DELETE_COLUMN = '_contextmenu_delete_column';
const CONTEXTMENU_MERGE_CELL = '_contextmenu_merge_cell';
const CONTEXTMENU_CONTINUE_NUMBERING = '_contextmenu_continue_numbering';
const CONTEXTMENU_RESTART_AT = '_contextmenu_restart_at';
/**
 * Context Menu class
 */
class ContextMenu$1 {
    /**
     * @private
     */
    constructor(viewer) {
        /**
         * @private
         */
        this.contextMenuInstance = undefined;
        /**
         * Handles on context menu key pressed.
         * @param  {PointerEvent} event
         * @private
         */
        this.onContextMenuInternal = (event) => {
            if (this.showHideElements(this.viewer.selection)) {
                this.contextMenuInstance.open(event.y, event.x);
                event.preventDefault();
            }
        };
        this.viewer = viewer;
        let locale = new L10n('documenteditor', this.viewer.owner.defaultLocale);
        locale.setLocale(this.viewer.owner.locale);
        setCulture(this.viewer.owner.locale);
        this.initContextMenu(locale);
    }
    /**
     * Gets module name.
     */
    getModuleName() {
        return 'ContextMenu';
    }
    /**
     * Initialize context menu.
     * @param localValue Localize value.
     * @private
     */
    // tslint:disable:max-func-body-length
    initContextMenu(localValue) {
        let id = this.viewer.owner.element.id;
        this.contextMenu = document.createElement('div');
        this.contextMenu.id = this.viewer.owner.containerId + 'e-de-contextmenu';
        document.body.appendChild(this.contextMenu);
        let ul = document.createElement('ul');
        ul.style.width = 'auto';
        ul.id = this.viewer.owner.containerId + 'e-de-contextmenu-list';
        ul.style.listStyle = 'none';
        ul.style.margin = '0px';
        ul.style.padding = '0px';
        ul.style.maxHeight = 'auto';
        ul.oncontextmenu = this.disableBrowserContextmenu;
        this.contextMenu.appendChild(ul);
        let menuItems = [
            {
                text: localValue.getConstant('Cut'),
                iconCss: 'e-icons e-de-cut',
                id: id + CONTEXTMENU_CUT
            },
            {
                text: localValue.getConstant('Copy'),
                iconCss: 'e-icons e-de-copy',
                id: id + CONTEXTMENU_COPY
            },
            {
                text: localValue.getConstant('Paste'),
                iconCss: 'e-icons e-de-paste',
                id: id + CONTEXTMENU_PASTE
            },
            {
                separator: true
            },
            {
                text: localValue.getConstant('Update Field'),
                iconCss: 'e-icons e-de-update_field',
                id: id + CONTEXTMENU_UPDATE_FIELD
            },
            {
                text: localValue.getConstant('Edit Field'),
                iconCss: 'e-icons e-de-edit_field',
                id: id + CONTEXTMENU_EDIT_FIELD
            },
            {
                text: localValue.getConstant('Continue Numbering'),
                iconCss: 'e-icons e-de-continue-numbering',
                id: id + CONTEXTMENU_CONTINUE_NUMBERING
            },
            {
                text: localValue.getConstant('Restart At') + ' 1',
                iconCss: 'e-icons e-de-restart-at',
                id: id + CONTEXTMENU_RESTART_AT
            },
            {
                separator: true
            },
            {
                text: localValue.getConstant('Hyperlink'),
                iconCss: 'e-icons e-de-insertlink',
                id: id + CONTEXTMENU_HYPERLINK
            },
            {
                text: localValue.getConstant('Edit Hyperlink') + '...',
                iconCss: 'e-icons e-de-edit-hyperlink',
                id: id + CONTEXTMENU_EDIT_HYPERLINK
            },
            {
                text: localValue.getConstant('Open Hyperlink'),
                iconCss: 'e-icons e-de-open-hyperlink',
                id: id + CONTEXTMENU_OPEN_HYPERLINK
            },
            {
                text: localValue.getConstant('Copy Hyperlink'),
                iconCss: 'e-icons e-de-copy-hyperlink',
                id: id + CONTEXTMENU_COPY_HYPERLINK
            },
            {
                text: localValue.getConstant('Remove Hyperlink'),
                iconCss: 'e-icons e-de-remove-hyperlink',
                id: id + CONTEXTMENU_REMOVE_HYPERLINK
            },
            {
                separator: true
            },
            {
                text: localValue.getConstant('Font'),
                iconCss: 'e-icons e-de-fonts',
                id: id + CONTEXTMENU_FONT_DIALOG
            },
            {
                text: localValue.getConstant('Paragraph'),
                iconCss: 'e-icons e-de-paragraph',
                id: id + CONTEXTMENU_PARAGRAPH
            },
            {
                separator: true,
            },
            {
                text: localValue.getConstant('Table Properties'),
                id: id + CONTEXTMENU_TABLE,
                iconCss: 'e-icons e-de-table'
            },
            {
                text: localValue.getConstant('Merge Cells'),
                id: id + CONTEXTMENU_MERGE_CELL,
                iconCss: 'e-icons e-de-icon-table-merge-cells'
            },
            {
                text: localValue.getConstant('Insert'),
                id: id + CONTEXTMENU_INSERT_TABLE,
                iconCss: 'e-icons',
                items: [
                    {
                        text: localValue.getConstant('Insert Above'),
                        id: id + CONTEXTMENU_INSERT_ABOVE,
                        iconCss: 'e-icons e-de-insertabove'
                    },
                    {
                        text: localValue.getConstant('Insert Below'),
                        id: id + CONTEXTMENU_INSERT_BELOW,
                        iconCss: 'e-icons e-de-insertbelow'
                    },
                    {
                        text: localValue.getConstant('Insert Left'),
                        id: id + CONTEXTMENU_INSERT_LEFT,
                        iconCss: 'e-icons e-de-insertleft'
                    },
                    {
                        text: localValue.getConstant('Insert Right'),
                        id: id + CONTEXTMENU_INSERT_RIGHT,
                        iconCss: 'e-icons e-de-insertright'
                    }
                ]
            },
            {
                text: localValue.getConstant('Delete'),
                id: id + CONTEXTMENU_DELETE_TABLE,
                iconCss: 'e-icons',
                items: [
                    {
                        text: localValue.getConstant('Delete Table'),
                        id: id + CONTEXTMENU_COMPLETE_DELETE_TABLE,
                        iconCss: 'e-icons e-de-delete-table'
                    },
                    {
                        text: localValue.getConstant('Delete Row'),
                        id: id + CONTEXTMENU_DELETE_ROW,
                        iconCss: 'e-icons e-de-deleterow'
                    },
                    {
                        text: localValue.getConstant('Delete Column'),
                        id: id + CONTEXTMENU_DELETE_COLUMN,
                        iconCss: 'e-icons e-de-deletecolumn'
                    }
                ]
            },
        ];
        let menuOptions = {
            target: '#' + this.viewer.owner.containerId + 'e-de-contextmenu',
            items: menuItems,
            select: (args) => {
                let item = args.element.id;
                this.handleContextMenuItem(item);
            },
        };
        this.contextMenuInstance = new ContextMenu(menuOptions, '#' + this.viewer.owner.containerId + 'e-de-contextmenu-list');
        this.contextMenuInstance.beforeOpen = () => {
            if (this.viewer && this.viewer.selection) {
                classList(this.viewer.selection.caret, [], ['e-de-cursor-animation']);
                this.viewer.selection.showCaret();
            }
        };
        this.contextMenuInstance.onClose = () => {
            if (this.viewer && this.viewer.selection) {
                classList(this.viewer.selection.caret, ['e-de-cursor-animation'], []);
                this.viewer.updateFocus();
            }
        };
    }
    /**
     * Disable browser context menu.
     */
    disableBrowserContextmenu() {
        return false;
    }
    /**
     * Handles context menu items.
     * @param  {string} item Specifies which item is selected.
     * @private
     */
    handleContextMenuItem(item) {
        let id = this.viewer.owner.element.id;
        switch (item) {
            case id + CONTEXTMENU_COPY:
                this.viewer.selection.copy();
                break;
            case id + CONTEXTMENU_CUT:
                this.viewer.owner.editor.cut();
                break;
            case id + CONTEXTMENU_PASTE:
                if (!this.viewer.owner.isReadOnlyMode) {
                    this.viewer.owner.editorModule.pasteInternal(undefined);
                }
                break;
            case id + CONTEXTMENU_UPDATE_FIELD:
                if (!this.viewer.owner.isReadOnlyMode) {
                    this.viewer.owner.editorModule.updateToc();
                }
                break;
            case id + CONTEXTMENU_EDIT_FIELD:
                if (!this.viewer.owner.isReadOnlyMode) {
                    this.viewer.owner.tableOfContentsDialogModule.show();
                }
                break;
            case id + CONTEXTMENU_FONT_DIALOG:
                if (this.viewer.owner.fontDialogModule) {
                    this.viewer.owner.fontDialogModule.showFontDialog();
                }
                break;
            case id + CONTEXTMENU_OPEN_HYPERLINK:
                this.viewer.selection.navigateHyperlink();
                break;
            case id + CONTEXTMENU_COPY_HYPERLINK:
                this.viewer.selection.copyHyperlink();
                break;
            case id + CONTEXTMENU_EDIT_HYPERLINK:
            case id + CONTEXTMENU_HYPERLINK:
                if (this.viewer.owner.hyperlinkDialogModule) {
                    this.viewer.owner.hyperlinkDialogModule.show();
                }
                break;
            case id + CONTEXTMENU_REMOVE_HYPERLINK:
                this.viewer.owner.editor.removeHyperlink();
                break;
            case id + CONTEXTMENU_PARAGRAPH:
                if (this.viewer.owner.paragraphDialogModule) {
                    this.viewer.owner.paragraphDialogModule.show();
                }
                break;
            case id + CONTEXTMENU_TABLE:
                this.viewer.owner.tablePropertiesDialogModule.show();
                break;
            case id + CONTEXTMENU_MERGE_CELL:
                this.viewer.owner.editor.mergeCells();
                break;
            case id + CONTEXTMENU_INSERT_ABOVE:
                this.viewer.owner.editor.insertRow(true);
                break;
            case id + CONTEXTMENU_INSERT_BELOW:
                this.viewer.owner.editor.insertRow(false);
                break;
            case id + CONTEXTMENU_INSERT_LEFT:
                this.viewer.owner.editor.insertColumn(true);
                break;
            case id + CONTEXTMENU_INSERT_RIGHT:
                this.viewer.owner.editor.insertColumn(false);
                break;
            case id + CONTEXTMENU_COMPLETE_DELETE_TABLE:
                this.viewer.owner.editor.deleteTable();
                break;
            case id + CONTEXTMENU_DELETE_ROW:
                this.viewer.owner.editor.deleteRow();
                break;
            case id + CONTEXTMENU_DELETE_COLUMN:
                this.viewer.owner.editor.deleteColumn();
                break;
            case id + CONTEXTMENU_CONTINUE_NUMBERING:
                this.viewer.owner.editorModule.applyContinueNumbering(this.viewer.selection);
                break;
            case id + CONTEXTMENU_RESTART_AT:
                this.viewer.owner.editorModule.applyRestartNumbering(this.viewer.selection);
                break;
        }
    }
    showHideElements(selection) {
        let owner = this.viewer.owner;
        let id = owner.element.id;
        let copy = document.getElementById(id + CONTEXTMENU_COPY);
        let cut = document.getElementById(id + CONTEXTMENU_CUT);
        let paste = document.getElementById(id + CONTEXTMENU_PASTE);
        let updateField = document.getElementById(id + CONTEXTMENU_UPDATE_FIELD);
        let editField = document.getElementById(id + CONTEXTMENU_EDIT_FIELD);
        let font = document.getElementById(id + CONTEXTMENU_FONT_DIALOG);
        let paragraph = document.getElementById(id + CONTEXTMENU_PARAGRAPH);
        let tableProperties = document.getElementById(id + CONTEXTMENU_TABLE);
        let insertTable = document.getElementById(id + CONTEXTMENU_INSERT_TABLE);
        let deleteTable = document.getElementById(id + CONTEXTMENU_DELETE_TABLE);
        let mergeCells = document.getElementById(id + CONTEXTMENU_MERGE_CELL);
        let hyperlink = document.getElementById(id + CONTEXTMENU_HYPERLINK);
        let openHyperlink = document.getElementById(id + CONTEXTMENU_OPEN_HYPERLINK);
        let editHyperlink = document.getElementById(id + CONTEXTMENU_EDIT_HYPERLINK);
        let copyHyperlink = document.getElementById(id + CONTEXTMENU_COPY_HYPERLINK);
        let removeHyperlink = document.getElementById(id + CONTEXTMENU_REMOVE_HYPERLINK);
        let continueNumbering = document.getElementById(id + CONTEXTMENU_CONTINUE_NUMBERING);
        let restartAt = document.getElementById(id + CONTEXTMENU_RESTART_AT);
        cut.style.display = 'none';
        paste.style.display = 'none';
        paste.nextSibling.style.display = 'none';
        hyperlink.style.display = 'none';
        openHyperlink.style.display = 'none';
        copyHyperlink.style.display = 'none';
        editHyperlink.style.display = 'none';
        removeHyperlink.style.display = 'none';
        removeHyperlink.nextSibling.style.display = 'none';
        mergeCells.style.display = 'none';
        font.style.display = 'none';
        paragraph.style.display = 'none';
        paragraph.nextSibling.style.display = 'none';
        insertTable.style.display = 'none';
        deleteTable.style.display = 'none';
        tableProperties.style.display = 'none';
        updateField.style.display = 'none';
        editField.style.display = 'none';
        continueNumbering.style.display = 'none';
        restartAt.style.display = 'none';
        restartAt.nextSibling.style.display = 'none';
        if (isNullOrUndefined(selection)) {
            return false;
        }
        selection.hideToolTip();
        if (selection.isEmpty) {
            cut.classList.add('e-disabled');
            copy.classList.add('e-disabled');
        }
        else {
            cut.classList.remove('e-disabled');
            copy.classList.remove('e-disabled');
        }
        if (owner.isReadOnlyMode) {
            return true;
        }
        cut.style.display = 'block';
        paste.style.display = 'block';
        paste.nextSibling.style.display = 'block';
        insertTable.classList.add('e-blankicon');
        deleteTable.classList.add('e-blankicon');
        updateField.classList.add('e-blankicon');
        editField.classList.add('e-blankicon');
        if (owner.enableLocalPaste && !isNullOrUndefined(owner.editor.copiedData)) {
            paste.classList.remove('e-disabled');
        }
        else {
            paste.classList.add('e-disabled');
        }
        if (selection.contextType === 'TableOfContents') {
            updateField.style.display = 'block';
            editField.style.display = 'block';
            restartAt.nextSibling.style.display = 'block';
        }
        else {
            let start = selection.start;
            let end = selection.end;
            if (selection.contextType === 'List'
                && owner.editorModule.getListLevel(start.paragraph).listLevelPattern !== 'Bullet') {
                continueNumbering.style.display = 'block';
                restartAt.style.display = 'block';
                restartAt.nextSibling.style.display = 'block';
            }
            let isCellOrRowSelected = start.paragraph.isInsideTable && (!end.paragraph.isInsideTable
                || start.paragraph.associatedCell !== end.paragraph.associatedCell
                || selection.isCellSelected(start.paragraph.associatedCell, start, end));
            if (isCellOrRowSelected) {
                hyperlink.classList.add('e-disabled');
            }
            else {
                if (hyperlink.classList.contains('e-disabled')) {
                    hyperlink.classList.remove('e-disabled');
                }
            }
            let field = selection.getHyperlinkField();
            if (field instanceof FieldElementBox && !selection.isImageField()) {
                openHyperlink.style.display = 'block';
                copyHyperlink.style.display = 'block';
                if (owner.hyperlinkDialogModule) {
                    editHyperlink.style.display = 'block';
                }
                removeHyperlink.style.display = 'block';
                removeHyperlink.nextSibling.style.display = 'block';
            }
            else {
                if (owner.hyperlinkDialogModule) {
                    hyperlink.style.display = 'block';
                }
            }
        }
        if (this.viewer.owner.selection.start.paragraph.isInsideTable
            && this.viewer.owner.selection.end.paragraph.isInsideTable) {
            paragraph.nextSibling.style.display = 'block';
            if (owner.tablePropertiesDialogModule) {
                tableProperties.style.display = 'block';
            }
            insertTable.style.display = 'block';
            deleteTable.style.display = 'block';
            if (this.viewer.owner.editor.canMergeCells()) {
                mergeCells.style.display = 'block';
            }
        }
        else {
            if (this.viewer.owner.fontDialogModule) {
                font.style.display = 'block';
                font.previousSibling.style.display = 'block';
            }
            if (this.viewer.owner.paragraphDialogModule) {
                paragraph.style.display = 'block';
            }
        }
        if (selection.contextType === 'Image') {
            font.style.display = 'none';
            paragraph.style.display = 'none';
            removeHyperlink.nextSibling.style.display = 'none';
        }
        return true;
    }
    /**
     * Disposes the internal objects which are maintained.
     * @private
     */
    destroy() {
        if (this.contextMenuInstance) {
            this.contextMenuInstance.destroy();
        }
        if (this.contextMenu) {
            if (this.contextMenu.parentElement) {
                this.contextMenu.parentElement.removeChild(this.contextMenu);
            }
            this.contextMenu.innerHTML = '';
        }
        this.contextMenu = undefined;
        this.contextMenuInstance = undefined;
    }
}

/**
 * @private
 */
class WAbstractList {
    constructor() {
        this.abstractListIdIn = -1;
        this.levels = [];
    }
    get abstractListId() {
        return this.abstractListIdIn;
    }
    set abstractListId(abstractListId) {
        this.abstractListIdIn = abstractListId;
    }
    destroy() {
        if (!isNullOrUndefined(this.levels)) {
            for (let i = 0; i < this.levels.length; i++) {
                let listLevel = this.levels[i];
                listLevel.destroy();
                this.levels.splice(this.levels.indexOf(listLevel), 1);
                i--;
            }
            this.levels = [];
        }
        this.levels = undefined;
    }
}

/**
 * @private
 */
class WListLevel {
    constructor(node) {
        this.uniqueListLevel = undefined;
        this.paragraphFormat = undefined;
        this.characterFormat = undefined;
        if (node instanceof WAbstractList) {
            this.ownerBase = node;
        }
        else {
            this.ownerBase = node;
        }
        this.characterFormat = new WCharacterFormat(undefined);
        this.paragraphFormat = new WParagraphFormat(undefined);
    }
    get listLevelPattern() {
        return this.getPropertyValue('listLevelPattern');
    }
    set listLevelPattern(listLevelPattern) {
        this.setPropertyValue('listLevelPattern', listLevelPattern);
    }
    get followCharacter() {
        return this.getPropertyValue('followCharacter');
    }
    set followCharacter(followCharacter) {
        this.setPropertyValue('followCharacter', followCharacter);
    }
    get startAt() {
        return this.getPropertyValue('startAt');
    }
    set startAt(startAt) {
        this.setPropertyValue('startAt', startAt);
    }
    get numberFormat() {
        return this.getPropertyValue('numberFormat');
    }
    set numberFormat(numberFormat) {
        this.setPropertyValue('numberFormat', numberFormat);
    }
    get restartLevel() {
        return this.getPropertyValue('restartLevel');
    }
    set restartLevel(restartLevel) {
        this.setPropertyValue('restartLevel', restartLevel);
    }
    getPropertyValue(property) {
        let propertyType = WUniqueFormat.getPropertyType(WListLevel.uniqueFormatType, property);
        if (!isNullOrUndefined(this.uniqueListLevel) && this.uniqueListLevel.propertiesHash.containsKey(propertyType)) {
            return this.uniqueListLevel.propertiesHash.get(propertyType);
        }
        return WListLevel.getPropertyDefaultValue(property);
    }
    setPropertyValue(property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WListLevel.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueListLevel)) {
            this.initializeUniqueWListLevel(property, value);
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueListLevel.uniqueFormatType, property);
            if (this.uniqueListLevel.propertiesHash.containsKey(propertyType) &&
                // tslint:disable-next-line:max-line-length
                this.uniqueListLevel.propertiesHash.get(propertyType) === value) {
                return;
            }
            // tslint:disable-next-line:max-line-length
            this.uniqueListLevel = WListLevel.uniqueListLevels.updateUniqueFormat(this.uniqueListLevel, property, value);
        }
    }
    initializeUniqueWListLevel(property, propValue) {
        let uniqueListLevelTemp = new Dictionary();
        this.addUniqueWListLevel('listLevelPattern', property, propValue, uniqueListLevelTemp);
        this.addUniqueWListLevel('startAt', property, propValue, uniqueListLevelTemp);
        this.addUniqueWListLevel('followCharacter', property, propValue, uniqueListLevelTemp);
        this.addUniqueWListLevel('numberFormat', property, propValue, uniqueListLevelTemp);
        this.addUniqueWListLevel('restartLevel', property, propValue, uniqueListLevelTemp);
        // tslint:disable-next-line:max-line-length    
        this.uniqueListLevel = WListLevel.uniqueListLevels.addUniqueFormat(uniqueListLevelTemp, WListLevel.uniqueFormatType);
    }
    // tslint:disable-next-line:max-line-length
    addUniqueWListLevel(property, modifiedProperty, propValue, uniqueCharFormatTemp) {
        let propertyType;
        propertyType = WUniqueFormat.getPropertyType(WListLevel.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueCharFormatTemp.add(propertyType, propValue);
        }
        else {
            uniqueCharFormatTemp.add(propertyType, WListLevel.getPropertyDefaultValue(property));
        }
    }
    static getPropertyDefaultValue(property) {
        let value = undefined;
        switch (property) {
            case 'listLevelPattern':
                value = 'Arabic';
                break;
            case 'startAt':
                value = 0;
                break;
            case 'followCharacter':
                value = 'Tab';
                break;
            case 'numberFormat':
                value = '';
                break;
            case 'restartLevel':
                value = 0;
                break;
        }
        return value;
    }
    destroy() {
        if (!isNullOrUndefined(this.characterFormat)) {
            this.characterFormat.destroy();
        }
        if (!isNullOrUndefined(this.paragraphFormat)) {
            this.paragraphFormat.destroy();
        }
        if (!isNullOrUndefined(this.uniqueListLevel)) {
            WListLevel.uniqueListLevels.remove(this.uniqueListLevel);
        }
        this.uniqueListLevel = undefined;
        this.characterFormat = undefined;
        this.paragraphFormat = undefined;
    }
    static clear() {
        this.uniqueListLevels.clear();
    }
}
WListLevel.dotBullet = '\uf0b7';
WListLevel.squareBullet = '\uf0a7'; //Symbol font \u25aa.
WListLevel.arrowBullet = '\u27a4';
WListLevel.circleBullet = '\uf06f' + '\u0020';
WListLevel.uniqueListLevels = new WUniqueFormats();
WListLevel.uniqueFormatType = 9;

/**
 * List implementation
 */

/**
 * @private
 */
class Layout {
    /**
     * viewer definition
     */
    constructor(viewer) {
        /**
         * @private
         */
        this.allowLayout = true;
        /**
         * @private
         */
        this.isInitialLoad = true;
        this.fieldBegin = undefined;
        this.maxTextHeight = 0;
        this.maxBaseline = 0;
        this.maxTextBaseline = 0;
        this.isFieldCode = false;
        this.viewer = viewer;
    }
    /**
     * @private
     */
    layout() {
        // Todo: Need to handle complete document layout(relayout).
        let page = this.viewer.pages[0];
        let body = page.bodyWidgets[0];
    }
    /**
     * Releases un-managed and - optionally - managed resources.
     */
    destroy() {
        this.viewer = undefined;
        this.value = undefined;
        this.allowLayout = undefined;
        this.isInitialLoad = undefined;
        this.fieldBegin = undefined;
        this.maxTextHeight = undefined;
        this.maxBaseline = undefined;
        this.maxTextBaseline = undefined;
        this.isFieldCode = undefined;
    }
    /**
     * Layouts the items
     * @private
     */
    layoutItems(sections) {
        let page;
        for (let i = 0; i < sections.length; i++) {
            let section = sections[i];
            page = this.viewer.createNewPage(section);
            this.addBodyWidget(this.viewer.clientActiveArea, section);
            if (this.viewer.pages.length > 1) {
                let pageIndex = 0;
                for (let i = 0; i < this.viewer.pages.length; i++) {
                    let prevPage = this.viewer.pages[i];
                    let prevSectionIndex = prevPage.sectionIndex;
                    let index = section.index;
                    if (prevSectionIndex > index || prevPage === page) {
                        break;
                    }
                    pageIndex++;
                }
                if (pageIndex < this.viewer.pages.length - 1) {
                    this.viewer.insertPage(pageIndex, page);
                }
            }
            this.layoutSection(section, 0, this.viewer);
        }
        this.updateFieldElements();
        this.viewer.updateScrollBars();
        this.isInitialLoad = false;
    }
    /**
     * Layouts the items
     * @param section
     * @param viewer
     * @private
     */
    layoutSection(section, index, viewer, ownerWidget) {
        let block = section.firstChild;
        let nextBlock;
        do {
            this.viewer.updateClientAreaForBlock(block, true);
            nextBlock = this.layoutBlock(block, index);
            index = 0;
            this.viewer.updateClientAreaForBlock(block, false);
            block = nextBlock;
        } while (block);
    }
    /**
     * Layouts the header footer items
     * @param section
     * @param viewer
     * @private
     */
    layoutHeaderFooter(section, viewer, page) {
        //Header layout
        let headerFooterWidget = viewer.getCurrentPageHeaderFooter(section, true);
        if (headerFooterWidget) {
            let header = headerFooterWidget.clone();
            header.page = page;
            viewer.updateHFClientArea(section.sectionFormat, true);
            page.headerWidget = this.layoutHeaderFooterItems(viewer, header);
            this.updateHeaderFooterToParent(header);
        }
        //Footer Layout
        headerFooterWidget = viewer.getCurrentPageHeaderFooter(section, false);
        if (headerFooterWidget) {
            let footer = headerFooterWidget.clone();
            footer.page = page;
            viewer.updateHFClientArea(section.sectionFormat, false);
            page.footerWidget = this.layoutHeaderFooterItems(viewer, footer);
            this.updateHeaderFooterToParent(footer);
        }
    }
    /**
     * @private
     */
    updateHeaderFooterToParent(node) {
        let sectionIndex = node.page.sectionIndex;
        let typeIndex = this.viewer.getHeaderFooter(node.headerFooterType);
        let clone = node.clone();
        this.viewer.headersFooters[sectionIndex][typeIndex] = clone;
        for (let j = 0; j < clone.childWidgets.length; j++) {
            let child = clone.childWidgets[j];
            if (child instanceof TableWidget) {
                this.clearTableWidget(child, false, true);
            }
        }
        return clone;
    }
    linkFieldInHeaderFooter(widget) {
        let firstChild = widget.firstChild;
        do {
            if (firstChild instanceof ParagraphWidget) {
                this.linkFieldInParagraph(firstChild);
            }
            else {
                this.linkFieldInTable(firstChild);
            }
            //tslint:disable:no-conditional-assignment
        } while (firstChild = firstChild.nextWidget);
    }
    /**
     * @private
     */
    linkFieldInParagraph(widget) {
        for (let j = 0; j < widget.childWidgets.length; j++) {
            let line = widget.childWidgets[j];
            for (let i = 0; i < line.children.length; i++) {
                let element = line.children[i];
                if (element instanceof FieldElementBox && element.fieldType !== 0) {
                    element.linkFieldCharacter(this.viewer);
                }
            }
        }
    }
    /**
     * @private
     */
    linkFieldInTable(widget) {
        for (let i = 0; i < widget.childWidgets.length; i++) {
            let row = widget.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                for (let k = 0; k < cell.childWidgets.length; k++) {
                    let block = cell.childWidgets[k];
                    if (block instanceof ParagraphWidget) {
                        this.linkFieldInParagraph(block);
                    }
                    else {
                        this.linkFieldInTable(block);
                    }
                }
            }
        }
    }
    /**
     * Layouts the header footer items.
     * @param viewer
     * @param hfModule
     * @private
     */
    layoutHeaderFooterItems(viewer, widget) {
        this.viewer.updateClientAreaLocation(widget, viewer.clientActiveArea);
        if (widget.childWidgets.length === 0) {
            let pargaraph = new ParagraphWidget();
            let line = new LineWidget(pargaraph);
            pargaraph.childWidgets.push(line);
            widget.childWidgets.push(pargaraph);
            pargaraph.containerWidget = widget;
        }
        this.linkFieldInHeaderFooter(widget);
        for (let i = 0; i < widget.childWidgets.length; i++) {
            let block = widget.childWidgets[i];
            viewer.updateClientAreaForBlock(block, true);
            this.layoutBlock(block, 0);
            viewer.updateClientAreaForBlock(block, false);
        }
        let type = widget.headerFooterType;
        if (type === 'OddFooter' || type === 'EvenFooter' || type === 'FirstPageFooter') {
            this.shiftChildLocation(viewer.clientArea.y - viewer.clientActiveArea.y, widget);
        }
        return widget;
    }
    /**
     * Shifts the child location
     * @param shiftTop
     * @param bodyWidget
     */
    shiftChildLocation(shiftTop, bodyWidget) {
        let widgetTop = bodyWidget.y + shiftTop;
        let footerMaxHeight = bodyWidget.page.boundingRectangle.height - (bodyWidget.page.boundingRectangle.height / 100) * 40;
        widgetTop = Math.max(widgetTop, footerMaxHeight);
        shiftTop = widgetTop - bodyWidget.y;
        bodyWidget.y = widgetTop;
        for (let i = 0; i < bodyWidget.childWidgets.length; i++) {
            let childWidget = bodyWidget.childWidgets[i];
            if (childWidget instanceof ParagraphWidget) {
                childWidget.x = childWidget.x;
                childWidget.y = childWidget.y + shiftTop;
            }
            else {
                this.shiftChildLocationForTableWidget(childWidget, shiftTop);
            }
        }
    }
    /**
     * Shifts the child location for table widget.
     * @param tableWidget
     * @param shiftTop
     */
    shiftChildLocationForTableWidget(tableWidget, shiftTop) {
        tableWidget.y = tableWidget.y + shiftTop;
        for (let i = 0; i < tableWidget.childWidgets.length; i++) {
            let childWidget = tableWidget.childWidgets[i];
            if (childWidget instanceof TableRowWidget) {
                this.shiftChildLocationForTableRowWidget(childWidget, shiftTop);
            }
        }
    }
    /**
     * Shifts the child location for table row widget.
     * @param rowWidget
     * @param shiftTop
     */
    shiftChildLocationForTableRowWidget(rowWidget, shiftTop) {
        rowWidget.y = rowWidget.y + shiftTop;
        for (let i = 0; i < rowWidget.childWidgets.length; i++) {
            this.shiftChildLocationForTableCellWidget(rowWidget.childWidgets[i], shiftTop);
        }
    }
    /**
     * Shifts the child location for table cell widget.
     * @param cellWidget
     * @param shiftTop
     */
    shiftChildLocationForTableCellWidget(cellWidget, shiftTop) {
        cellWidget.y = cellWidget.y + shiftTop;
        for (let i = 0; i < cellWidget.childWidgets.length; i++) {
            if (cellWidget.childWidgets[i] instanceof ParagraphWidget) {
                cellWidget.childWidgets[i].x = cellWidget.childWidgets[i].x;
                cellWidget.childWidgets[i].y = cellWidget.childWidgets[i].y + shiftTop;
            }
            else {
                this.shiftChildLocationForTableWidget(cellWidget.childWidgets[i], shiftTop);
            }
        }
    }
    /**
     * Layouts specified block.
     * @param block
     * @private
     */
    layoutBlock(block, index, moveToLine) {
        let nextBlock;
        if (block instanceof ParagraphWidget) {
            nextBlock = this.layoutParagraph(block, index);
        }
        else {
            nextBlock = this.layoutTable(block, index);
        }
        return nextBlock.nextRenderedWidget;
    }
    /**
     * Adds paragraph widget.
     * @param area
     */
    addParagraphWidget(area, paragraphWidget) {
        if (paragraphWidget.isEmpty() && !isNullOrUndefined(paragraphWidget.paragraphFormat) &&
            (paragraphWidget.paragraphFormat.textAlignment === 'Center' || paragraphWidget.paragraphFormat.textAlignment === 'Right') &&
            paragraphWidget.paragraphFormat.listFormat.listId === -1) {
            let width = this.viewer.textHelper.getParagraphMarkWidth(paragraphWidget.characterFormat);
            let left = area.x;
            if (paragraphWidget.paragraphFormat.textAlignment === 'Center') {
                left += (area.width - width) / 2;
            }
            else {
                left += area.width - width;
            }
            paragraphWidget.width = width;
            paragraphWidget.x = left;
            paragraphWidget.y = area.y;
        }
        else {
            paragraphWidget.width = area.width;
            paragraphWidget.x = area.x;
            paragraphWidget.y = area.y;
        }
        return paragraphWidget;
    }
    /**
     * Adds line widget.
     * @param paragraph
     */
    addLineWidget(paragraphWidget) {
        let line = undefined;
        line = new LineWidget(paragraphWidget);
        line.width = paragraphWidget.width;
        paragraphWidget.childWidgets.push(line);
        line.paragraph = paragraphWidget;
        return line;
    }
    /**
     * Layouts specified paragraph.
     * @private
     * @param paragraph
     */
    layoutParagraph(paragraph, lineIndex) {
        this.addParagraphWidget(this.viewer.clientActiveArea, paragraph);
        this.layoutListItems(paragraph);
        if (paragraph.isEmpty()) {
            this.layoutEmptyLineWidget(paragraph, true);
        }
        else {
            let line = lineIndex < paragraph.childWidgets.length ?
                paragraph.childWidgets[lineIndex] : undefined;
            while (line instanceof LineWidget) {
                if (line.isFirstLine() && isNullOrUndefined(this.fieldBegin)) {
                    if (!isNullOrUndefined(paragraph.paragraphFormat)) {
                        // tslint:disable-next-line:max-line-length
                        let firstLineIndent = -HelperMethods.convertPointToPixel(paragraph.paragraphFormat.firstLineIndent);
                        this.viewer.updateClientWidth(firstLineIndent);
                    }
                }
                line = this.layoutLine(line, 0);
                paragraph = line.paragraph;
                line = line.nextLine;
            }
        }
        this.updateWidgetToPage(this.viewer, paragraph);
        return paragraph;
    }
    clearLineMeasures() {
        this.maxBaseline = 0;
        this.maxTextBaseline = 0;
        this.maxTextHeight = 0;
    }
    moveElementFromNextLine(line) {
        let nextLine = line.nextLine;
        while (nextLine instanceof LineWidget) {
            if (nextLine.children.length > 0) {
                let element = nextLine.children.splice(0, 1)[0];
                line.children.push(element);
                element.line = line;
                break;
            }
            else {
                if (nextLine.paragraph.childWidgets.length === 1) {
                    nextLine.paragraph.destroy();
                }
                else {
                    nextLine.destroy();
                }
                nextLine = line.nextLine;
            }
        }
    }
    layoutLine(line, count) {
        let paragraph = line.paragraph;
        if (line.children.length === 0) {
            this.moveElementFromNextLine(line);
        }
        let element = line.children[count];
        this.clearLineMeasures();
        while (element instanceof ElementBox) {
            this.layoutElement(element, paragraph);
            line = element.line;
            element = element.nextElement;
        }
        return line;
    }
    // tslint:disable:max-func-body-length
    layoutElement(element, paragraph) {
        let line = element.line;
        let text = '';
        let index = element.indexInOwner;
        if (element instanceof FieldElementBox) {
            if (element.fieldType === 0 && this.viewer.fields.indexOf(element) === -1) {
                this.viewer.fields.push(element);
            }
            this.layoutFieldCharacters(element);
            if (element.line.isLastLine() && isNullOrUndefined(element.nextNode) && !this.isFieldCode) {
                if (isNullOrUndefined(element.fieldSeparator)) {
                    this.layoutEmptyLineWidget(paragraph, false, element.line);
                }
                this.moveToNextLine(line);
            }
            else if (isNullOrUndefined(element.nextElement) && this.viewer.clientActiveArea.width > 0 && !element.line.isLastLine()) {
                this.moveElementFromNextLine(line);
            }
            else if (isNullOrUndefined(element.nextElement) && this.viewer.clientActiveArea.width === 0) {
                this.moveToNextLine(line);
                if (line.paragraph.lastChild === line && !isNullOrUndefined(line.nextLine) &&
                    this.viewer.clientActiveArea.height >= 0) {
                    this.moveFromNextPage(line);
                }
            }
            return;
        }
        if (element instanceof ListTextElementBox || this.isFieldCode || element instanceof BookmarkElementBox) {
            if (isNullOrUndefined(element.nextElement) && this.viewer.clientActiveArea.width > 0 && !element.line.isLastLine()) {
                this.moveElementFromNextLine(line);
            }
            if (element.line.isLastLine() && isNullOrUndefined(element.nextElement)) {
                if (this.hasValidElement(line.paragraph)) {
                    this.moveToNextLine(line);
                }
                else {
                    this.layoutEmptyLineWidget(line.paragraph, false, line, false);
                }
            }
            return;
        }
        let width = element.width;
        if (element instanceof FieldTextElementBox) {
            text = this.viewer.getFieldResult(element.fieldBegin, element.paragraph.bodyWidget.page);
            if (text !== '') {
                element.text = text;
            }
            else {
                text = element.text;
            }
        }
        else if (element instanceof TextElementBox) {
            this.checkAndSplitTabOrLineBreakCharacter(element.text, element);
            text = element.text;
        }
        // Here field code width and height update need to skipped based on the hidden property.
        if (element instanceof TextElementBox) {
            width = this.viewer.textHelper.getTextSize(element, element.characterFormat);
            if (element.text === '\t') {
                element.width = this.getTabWidth(paragraph, this.viewer, index, line, element);
            }
        }
        if (this.viewer instanceof PageLayoutViewer
            && this.viewer.clientActiveArea.height < element.height && this.viewer.clientActiveArea.y !== this.viewer.clientArea.y) {
            this.moveToNextPage(this.viewer, line);
            if (element instanceof FieldTextElementBox) {
                this.updateFieldText(element);
            }
            if (element.previousElement) {
                this.cutClientWidth(element.previousElement);
            }
        }
        if (width < this.viewer.clientActiveArea.width || !this.viewer.textWrap) {
            //Fits the text in current line.
            this.addElementToLine(paragraph, element);
            if (isNullOrUndefined(element.nextElement) && this.viewer.clientActiveArea.width > 0 && !element.line.isLastLine()) {
                this.moveElementFromNextLine(line);
            }
            else if (!element.line.isLastLine() && isNullOrUndefined(element.nextElement) && this.viewer.clientActiveArea.width === 0) {
                this.moveToNextLine(line);
                if (line.paragraph.lastChild === line && this.viewer.clientActiveArea.height >= 0) {
                    this.moveFromNextPage(line);
                }
            }
        }
        else if (element instanceof TextElementBox) {
            if (element.text === '\t') {
                let currentLine = element.line;
                this.addSplittedLineWidget(currentLine, currentLine.children.indexOf(element));
                this.moveToNextLine(currentLine);
                // Recalculates tab width based on new client active area X position
                element.width = this.getTabWidth(paragraph, this.viewer, index, line, element);
                this.addElementToLine(paragraph, element);
            }
            else {
                //Splits the text and arrange line by line, till end of text.
                do {
                    line = element.line;
                    this.splitTextForClientArea(line, element, element.text, element.width, element.characterFormat);
                    this.checkLineWidgetWithClientArea(line, element);
                    if (element instanceof FieldTextElementBox) {
                        this.updateFieldText(element);
                    }
                } while (element.line !== line && this.cutClientWidth(element));
            }
        }
        else {
            do {
                line = element.line;
                this.splitElementForClientArea(paragraph, element);
                this.checkLineWidgetWithClientArea(line, element);
                if (element instanceof FieldTextElementBox) {
                    this.updateFieldText(element);
                }
            } while (element.line !== line && this.cutClientWidth(element));
        }
        if (text === '\v' || text === '\f') {
            let elementIndex = line.children.indexOf(element);
            if (elementIndex > -1) {
                this.addSplittedLineWidget(line, elementIndex);
            }
        }
        if (element.line.isLastLine() && isNullOrUndefined(element.nextElement) || text === '\v' || text === '\f') {
            this.moveToNextLine(element.line);
            if (text === '\v' && isNullOrUndefined(element.nextNode)) {
                this.layoutEmptyLineWidget(paragraph, true, line, true);
            }
            else if (text === '\f') {
                if (isNullOrUndefined(element.nextNode)) {
                    this.moveToNextPage(this.viewer, element.line, true);
                }
                else {
                    this.moveToNextPage(this.viewer, element.line.nextLine, false);
                }
            }
        }
    }
    /**
     * Return true if paragraph has valid inline
     * @private
     */
    hasValidElement(paragraph) {
        let line = paragraph.firstChild;
        if (line && !isNullOrUndefined(this.viewer.selection)) {
            let elementBox = line.children[0];
            while (elementBox) {
                if (elementBox instanceof FieldElementBox) {
                    elementBox = this.viewer.selection.getNextValidElementForField(elementBox);
                    if (!elementBox.line.paragraph.equals(paragraph)) {
                        return false;
                    }
                }
                if (elementBox instanceof TextElementBox) {
                    return true;
                }
                elementBox = elementBox.nextNode;
            }
        }
        return false;
    }
    updateFieldText(element) {
        // tslint:disable-next-line:max-line-length
        let text = this.viewer.getFieldResult(element.fieldBegin, element.paragraph.bodyWidget.page);
        if (text !== '') {
            element.text = text;
            this.viewer.textHelper.getTextSize(element, element.characterFormat);
        }
    }
    checkLineWidgetWithClientArea(line, element) {
        if (line !== element.line || element.line === line && isNullOrUndefined(element.nextElement)
            && !element.line.isLastLine()) {
            this.moveToNextLine(line);
        }
        if (element.line !== line && this.viewer instanceof PageLayoutViewer
            && this.viewer.clientActiveArea.height < element.height &&
            this.viewer.clientActiveArea.y !== this.viewer.clientArea.y) {
            this.moveToNextPage(this.viewer, element.line);
        }
        else if (element.line === line && isNullOrUndefined(element.nextElement)
            && line.paragraph.lastChild === line && !line.isLastLine() && this.viewer.clientActiveArea.height >= 0) {
            this.moveFromNextPage(line);
        }
    }
    checkAndSplitTabOrLineBreakCharacter(text, element) {
        let char = ['\t', '\v', '\f'];
        let index = HelperMethods.indexOfAny(text, char);
        if (index > -1) {
            let character = text[index];
            if ((character === '\t' && text !== '\t') || (character === '\v' && text !== '\v')
                || (character === '\f' && text !== '\f')) {
                this.splitByLineBreakOrTab(this.viewer, element, index, character);
            }
        }
    }
    /**
     * @private
     */
    moveFromNextPage(line) {
        let nextLine = line.nextLine;
        if (nextLine && line.paragraph.childWidgets.indexOf(nextLine) === -1) {
            nextLine.paragraph.childWidgets.splice(nextLine.indexInOwner, 1);
            line.paragraph.childWidgets.push(nextLine);
            nextLine.paragraph = line.paragraph;
        }
    }
    cutClientWidth(currentElement) {
        this.clearLineMeasures();
        let line = currentElement.line;
        let width = 0;
        for (let i = 0; i < line.children.length; i++) {
            let element = line.children[i];
            width += element.width;
            if (currentElement === element) {
                break;
            }
        }
        let splitCurrentWidget = this.viewer.clientActiveArea.width - width < 0;
        if (!splitCurrentWidget) {
            this.viewer.cutFromLeft(this.viewer.clientActiveArea.x + width);
            if (currentElement.line.paragraph.paragraphFormat.textAlignment === 'Justify' &&
                currentElement instanceof TextElementBox) {
                this.splitTextElementWordByWord(currentElement);
            }
            if (isNullOrUndefined(currentElement.nextElement) && this.viewer.clientActiveArea.width > 0
                && !currentElement.line.isLastLine()) {
                this.moveElementFromNextLine(line);
            }
        }
        else if (currentElement.previousElement) {
            this.cutClientWidth(currentElement.previousElement);
        }
        return splitCurrentWidget;
    }
    layoutFieldCharacters(element) {
        if (element.fieldType === 0) {
            if (!this.isFieldCode && (!isNullOrUndefined(element.fieldEnd) || element.hasFieldEnd)) {
                this.viewer.fieldStacks.push(element);
                this.isFieldCode = true;
                element.hasFieldEnd = true;
            }
        }
        else if (this.viewer.fieldStacks.length > 0) {
            if (element.fieldType === 2) {
                let field = this.viewer.fieldStacks[this.viewer.fieldStacks.length - 1];
                if (field.fieldSeparator === element && (!isNullOrUndefined(field.fieldEnd) || field.hasFieldEnd)) {
                    this.isFieldCode = false;
                }
            }
            else {
                let field = this.viewer.fieldStacks[this.viewer.fieldStacks.length - 1];
                if (element === field.fieldEnd) {
                    this.viewer.fieldStacks.pop();
                    this.isFieldCode = false;
                }
            }
        }
    }
    /**
     * Layouts empty line widget.
     */
    // tslint:disable-next-line:max-line-length
    layoutEmptyLineWidget(paragraph, isEmptyLine, line, isShiftEnter) {
        isShiftEnter = isNullOrUndefined(isShiftEnter) ? false : isShiftEnter;
        //Calculate line height and descent based on formatting defined in paragraph.
        let paragraphMarkSize = this.viewer.textHelper.getParagraphMarkSize(paragraph.characterFormat);
        let maxHeight = paragraphMarkSize.Height;
        let beforeSpacing = this.getBeforeSpacing(paragraph);
        let lineWidget;
        if (paragraph.childWidgets.length > 0 && !isShiftEnter) {
            lineWidget = paragraph.childWidgets[0];
        }
        else {
            lineWidget = isEmptyLine ? this.addLineWidget(paragraph) : line;
        }
        //isNullOrUndefined(this.viewer.currentHeaderFooter) && 
        if (this.viewer instanceof PageLayoutViewer
            && this.viewer.clientActiveArea.height < beforeSpacing + maxHeight
            && this.viewer.clientActiveArea.y !== this.viewer.clientArea.y) {
            this.moveToNextPage(this.viewer, lineWidget);
        }
        //Gets line spacing.
        let lineSpacing = this.getLineSpacing(paragraph, maxHeight);
        let maxDescent = maxHeight - paragraphMarkSize.BaselineOffset;
        //Calculate the bottom position of current line - max height + line spacing.
        if (!isNaN(this.maxTextHeight)
            && maxHeight < this.maxTextHeight) {
            maxHeight = this.maxTextHeight;
            maxDescent = maxHeight - this.maxTextBaseline;
        }
        let topMargin = 0;
        let bottomMargin = 0;
        let leftMargin = 0;
        let height = maxHeight;
        let lineSpacingType = paragraph.paragraphFormat.lineSpacingType;
        if (lineSpacingType === 'Multiple') {
            if (lineSpacing > maxHeight) {
                bottomMargin += lineSpacing - maxHeight;
            }
            else {
                topMargin += lineSpacing - maxHeight;
            }
        }
        else if (lineSpacingType === 'Exactly') {
            topMargin += lineSpacing - (topMargin + height + bottomMargin);
        }
        else if (lineSpacing > topMargin + height + bottomMargin) {
            topMargin += lineSpacing - (topMargin + height + bottomMargin);
        }
        topMargin += beforeSpacing;
        bottomMargin += HelperMethods.convertPointToPixel(paragraph.paragraphFormat.afterSpacing);
        for (let i = 0; i < lineWidget.children.length; i++) {
            let element = lineWidget.children[i];
            if (element instanceof ListTextElementBox) {
                let textAlignment = paragraph.paragraphFormat.textAlignment;
                if (textAlignment === 'Right') {
                    leftMargin = this.viewer.clientArea.width - element.width;
                }
                else if (textAlignment === 'Center') {
                    leftMargin = (this.viewer.clientArea.width - element.width) / 2;
                }
                element.margin = new Margin(leftMargin, topMargin, 0, bottomMargin);
                element.line = lineWidget;
                lineWidget.height = topMargin + height + bottomMargin;
            }
        }
        lineWidget.height = topMargin + height + bottomMargin;
        this.viewer.cutFromTop(this.viewer.clientActiveArea.y + lineWidget.height);
        //Clears the previous line elements from collection.     
    }
    /**
     * @private
     */
    layoutListItems(paragraph) {
        if (!this.isFieldCode) {
            if (!isNullOrUndefined(paragraph.paragraphFormat)
                && !isNullOrUndefined(paragraph.paragraphFormat.listFormat)
                && !isNullOrUndefined(this.viewer.getListById(paragraph.paragraphFormat.listFormat.listId)) &&
                paragraph.paragraphFormat.listFormat.listLevelNumber >= 0
                && paragraph.paragraphFormat.listFormat.listLevelNumber < 9) {
                this.clearListElementBox(paragraph);
                this.layoutList(paragraph, this.viewer);
            }
            else if (paragraph.paragraphFormat.listFormat && paragraph.paragraphFormat.listFormat.listId === -1) {
                this.clearListElementBox(paragraph);
            }
        }
    }
    /**
     * Layouts list.
     * @param viewer
     */
    layoutList(paragraph, viewer) {
        let list = viewer.getListById(paragraph.paragraphFormat.listFormat.listId);
        viewer.updateClientWidth(-HelperMethods.convertPointToPixel(paragraph.paragraphFormat.firstLineIndent));
        let currentListLevel = this.getListLevel(list, paragraph.paragraphFormat.listFormat.listLevelNumber);
        // if (isNullOrUndefined(currentListLevel)) {
        //     return;
        // }
        let lineWidget = paragraph.childWidgets[0];
        if (isNullOrUndefined(lineWidget)) {
            lineWidget = new LineWidget(paragraph);
            paragraph.childWidgets.push(lineWidget);
        }
        let element = new ListTextElementBox(currentListLevel, false);
        element.line = lineWidget;
        if (currentListLevel.listLevelPattern === 'Bullet') {
            element.text = currentListLevel.numberFormat;
        }
        else {
            element.text = this.getListNumber(paragraph.paragraphFormat.listFormat);
        }
        viewer.textHelper.updateTextSize(element, paragraph);
        let moveToNextPage;
        if (this.viewer instanceof PageLayoutViewer
            && this.viewer.clientActiveArea.height < element.height && this.viewer.clientActiveArea.y !== this.viewer.clientArea.y) {
            moveToNextPage = true;
        }
        viewer.cutFromLeft(viewer.clientActiveArea.x + element.width);
        //Adds the text element to the line
        lineWidget.children.splice(0, 0, element);
        if (currentListLevel.followCharacter !== 'None') {
            element = new ListTextElementBox(currentListLevel, true);
            if (currentListLevel.followCharacter === 'Tab') {
                element.text = '\t';
                let index = lineWidget.children.indexOf(element);
                element.width = this.getTabWidth(paragraph, viewer, index, lineWidget, undefined);
            }
            else {
                element.text = ' ';
                viewer.textHelper.updateTextSize(element, paragraph);
            }
            viewer.cutFromLeft(viewer.clientActiveArea.x + element.width);
            //Adds the tabSpace to the line
            lineWidget.children.splice(1, 0, element);
            element.line = lineWidget;
        }
        if (moveToNextPage) {
            this.moveToNextPage(this.viewer, lineWidget);
            this.cutClientWidth(element);
            return;
        }
        if (currentListLevel.followCharacter !== 'None') {
            viewer.updateClientWidth(HelperMethods.convertPointToPixel(paragraph.paragraphFormat.firstLineIndent));
        }
    }
    /**
     * Adds body widget.
     * @param area
     * @param section
     * @private
     */
    addBodyWidget(area, widget) {
        let bodyWidget;
        if (widget) {
            bodyWidget = widget;
        }
        else {
            bodyWidget = new BodyWidget();
        }
        bodyWidget.width = area.width;
        bodyWidget.x = area.x;
        bodyWidget.y = area.y;
        // this.addSectionInDictionary(this.viewer, section, bodyWidget);
        return bodyWidget;
    }
    /**
     * Adds list level.
     * @param abstractList
     */
    addListLevels(abstractList) {
        for (let i = abstractList.levels.length; i < 9; i++) {
            let listLevel = new WListLevel(abstractList);
            let val = i % 3;
            if (abstractList.levels[0].listLevelPattern === 'Bullet') {
                listLevel.listLevelPattern = 'Bullet';
                listLevel.numberFormat = val === 0 ? '\uf0b7' : val === 1 ? '\uf0a7' : '\uf0d8';
                listLevel.characterFormat.fontFamily = listLevel.numberFormat === '\uf0a7' || '\uf0d8' ? 'Wingdings' : 'Symbol';
            }
            else {
                listLevel.listLevelPattern = this.getListLevelPattern(val);
                listLevel.numberFormat = '%' + (i + 1).toString() + '.';
                listLevel.startAt = 1;
                listLevel.restartLevel = i;
            }
            listLevel.paragraphFormat = new WParagraphFormat(undefined);
            listLevel.paragraphFormat.leftIndent = 48 * (i + 1);
            listLevel.paragraphFormat.firstLineIndent = -24;
            abstractList.levels.push(listLevel);
        }
    }
    addSplittedLineWidget(lineWidget, elementIndex, splittedElementBox) {
        let paragraph = lineWidget.paragraph;
        let movedElementBox = [];
        let lineIndex = paragraph.childWidgets.indexOf(lineWidget);
        if (!isNullOrUndefined(splittedElementBox)) {
            movedElementBox.push(splittedElementBox);
        }
        let newLineWidget = undefined;
        //Move Next element box to temp collection
        for (let i = elementIndex + 1; i < lineWidget.children.length; i++) {
            movedElementBox.push(lineWidget.children[i]);
        }
        if (movedElementBox.length > 0) {
            if (lineIndex === paragraph.childWidgets.length - 1) {
                newLineWidget = new LineWidget(paragraph);
            }
            else {
                newLineWidget = paragraph.childWidgets[lineIndex + 1];
            }
            for (let j = 0; j < movedElementBox.length; j++) {
                movedElementBox[j].line = newLineWidget;
            }
            lineWidget.children.splice(elementIndex + 1, lineWidget.children.length - 1);
            newLineWidget.children = movedElementBox.concat(newLineWidget.children);
            if (paragraph.childWidgets.indexOf(newLineWidget) === -1) {
                paragraph.childWidgets.splice(lineIndex + 1, 0, newLineWidget);
            }
        }
    }
    /**
     * Adds element to line.
     * @param element
     */
    addElementToLine(paragraph, element) {
        this.viewer.cutFromLeft(this.viewer.clientActiveArea.x + element.width);
        if (paragraph.paragraphFormat.textAlignment === 'Justify' && element instanceof TextElementBox) {
            this.splitTextElementWordByWord(element);
        }
    }
    /**
     * Splits element for client area.
     * @param element
     */
    splitElementForClientArea(paragraph, element) {
        let line = element.line;
        if (element.line.children.length > 0) {
            let previousElement = element.previousElement;
            let index = element.indexInOwner;
            // if line widget contain only single image element box need to skip this from splitting
            // else move element to next line
            if (element.line.children.length > 1) {
                if (previousElement && this.viewer.clientActiveArea.x !== this.viewer.clientArea.x) {
                    index -= 1;
                }
            }
            this.addSplittedLineWidget(element.line, index);
        }
    }
    /**
     * Splits by word
     * @param elementBox
     * @param text
     * @param width
     * @param characterFormat
     */
    // tslint:disable-next-line:max-line-length
    splitByWord(lineWidget, paragraph, elementBox, text, width, characterFormat) {
        let index = this.getSplitIndexByWord(this.viewer.clientActiveArea.width, text, width, characterFormat);
        if (index > 0 && index < elementBox.length) {
            let indexOf = lineWidget.children.indexOf(elementBox);
            let lineIndex = paragraph.childWidgets.indexOf(lineWidget);
            let splittedElementBox = new TextElementBox();
            text = text.substring(index);
            splittedElementBox.text = text;
            if (text[0] === ' ') {
                let prevLength = text.length;
                text = HelperMethods.trimStart(text); //To trim white space at starting of the text.
                index += prevLength - text.length;
            }
            splittedElementBox.characterFormat.copyFormat(elementBox.characterFormat);
            splittedElementBox.width = this.viewer.textHelper.getWidth(splittedElementBox.text, characterFormat);
            elementBox.text = elementBox.text.substr(0, index);
            elementBox.width -= splittedElementBox.width;
            splittedElementBox.height = elementBox.height;
            splittedElementBox.baselineOffset = elementBox.baselineOffset;
            this.addSplittedLineWidget(lineWidget, indexOf, splittedElementBox);
            this.addElementToLine(paragraph, elementBox);
            if (elementBox.width === 0) {
                lineWidget.children.splice(indexOf, 1);
            }
        }
    }
    /**
     * Splits by character.
     * @param textElement
     * @param text
     * @param width
     * @param characterFormat
     */
    // tslint:disable-next-line:max-line-length
    splitByCharacter(lineWidget, textElement, text, width, characterFormat) {
        let paragraph = lineWidget.paragraph;
        // tslint:disable-next-line:max-line-length
        let index = this.getTextSplitIndexByCharacter(this.viewer.clientArea.width, this.viewer.clientActiveArea.width, text, width, characterFormat);
        let splitWidth = 0;
        if (index < textElement.length) {
            splitWidth = this.viewer.textHelper.measureTextExcludingSpaceAtEnd(text.substring(0, index), characterFormat);
            text = text.substring(index);
        }
        if (splitWidth > this.viewer.clientActiveArea.width && textElement.indexInOwner > 0) {
            this.addSplittedLineWidget(lineWidget, textElement.indexInOwner - 1);
            return;
        }
        let indexOf = lineWidget.children.indexOf(textElement);
        if (index < textElement.length) {
            let lineIndex = paragraph.childWidgets.indexOf(lineWidget);
            let splittedElement = new TextElementBox();
            splittedElement.text = text;
            textElement.text = textElement.text.substr(0, index);
            splittedElement.characterFormat.copyFormat(textElement.characterFormat);
            splittedElement.width = this.viewer.textHelper.getWidth(splittedElement.text, characterFormat);
            textElement.width -= splittedElement.width;
            splittedElement.height = textElement.height;
            splittedElement.baselineOffset = textElement.baselineOffset;
            lineWidget.children.splice(textElement.indexInOwner + 1, 0, splittedElement);
            this.addSplittedLineWidget(lineWidget, indexOf);
            this.addElementToLine(paragraph, textElement);
            if (textElement.width === 0) {
                lineWidget.children.splice(indexOf, 1);
            }
        }
        else {
            //Adds the last text element on inline to line elements collection. 
            this.addSplittedLineWidget(lineWidget, indexOf);
            this.addElementToLine(paragraph, textElement);
        }
    }
    /**
     * Splits text element word by word.
     * @param textElement
     */
    splitTextElementWordByWord(textElement) {
        let lineWidget = textElement.line;
        let indexOf = lineWidget.children.indexOf(textElement);
        let text = textElement.text;
        let format;
        let characterUptoWs = text.trim().indexOf(' ');
        if (characterUptoWs >= 0) {
            lineWidget.children.splice(indexOf, 1);
            format = textElement.characterFormat;
            let fontSize = format.fontSize;
            let index = textElement.length - HelperMethods.trimStart(text).length; //Trim start
            while (index < textElement.length) {
                index = this.getTextIndexAfterSpace(text, index);
                if (index === 0 || index === textElement.length) {
                    break;
                }
                if (index < textElement.length) {
                    let splittedElement = new TextElementBox();
                    let splittedText = text.substring(0, index);
                    text = text.substring(index);
                    if (text.substring(0, 1) === ' ') {
                        // start of the text is trimmed and its length is reduced from text length.                        
                        index += text.length - HelperMethods.trimStart(text).length;
                    }
                    splittedElement.text = splittedText;
                    splittedElement.characterFormat.copyFormat(textElement.characterFormat);
                    splittedElement.line = lineWidget;
                    splittedElement.width = this.viewer.textHelper.getWidth(splittedElement.text, format);
                    splittedElement.height = textElement.height;
                    splittedElement.baselineOffset = textElement.baselineOffset;
                    lineWidget.children.splice(indexOf, 0, splittedElement);
                    textElement.text = text;
                    textElement.width -= splittedElement.width;
                    if (textElement.width === 0) {
                        lineWidget.children.splice(lineWidget.children.indexOf(textElement), 1);
                    }
                    index = 0;
                    indexOf++;
                }
            }
            textElement.text = text;
            lineWidget.children.splice(indexOf, 0, textElement);
        }
    }
    /**
     * Splits text for client area.
     * @param element
     * @param text
     * @param width
     * @param characterFormat
     */
    // tslint:disable-next-line:max-line-length
    splitTextForClientArea(lineWidget, element, text, width, characterFormat) {
        let paragraph = lineWidget.paragraph;
        let isSplitByWord = true;
        let index = -1;
        if (!(text.substring(0, 1) === ' ')) {
            let textWidth = width;
            let characterUptoWS = 0;
            characterUptoWS = HelperMethods.trimEnd(text).indexOf(' ') + 1;
            index = characterUptoWS;
            //Checks whether text not starts with white space. If starts with white space, no need to check previous text blocks.
            if (index > 0) {
                textWidth = this.viewer.textHelper.measureTextExcludingSpaceAtEnd(text.slice(0, index), characterFormat);
            }
            if (this.viewer.clientActiveArea.width < textWidth) {
                //Check and split the previous text elements to next line.            
                isSplitByWord = this.checkPreviousElement(lineWidget, lineWidget.children.indexOf(element), characterFormat);
                if (isSplitByWord) {
                    //lineWidget = paragraph.childWidgets[paragraph.childWidgets.indexOf(lineWidget) + 1] as LineWidget;
                    //isSplitByWord = textWidth <= this.viewer.clientActiveArea.width;
                    return;
                }
            }
        }
        else {
            index = 1;
        }
        if (width <= this.viewer.clientActiveArea.width) {
            //Fits the text in current line.
            this.addElementToLine(paragraph, element);
        }
        else if (isSplitByWord && (index > 0 || text.indexOf(' ') !== -1)) {
            this.splitByWord(lineWidget, paragraph, element, text, width, characterFormat);
        }
        else {
            this.splitByCharacter(lineWidget, element, text, width, characterFormat);
        }
    }
    /**
     * Handle tab or line break character splitting
     * @param  {LayoutViewer} viewer
     * @param  {TextElementBox} span
     * @param  {number} index
     * @param  {string} spiltBy
     * @private
     */
    splitByLineBreakOrTab(viewer, span, index, spiltBy) {
        // Splits tab character to separate SpanAdv
        let inlineIndex = span.line.children.indexOf(span);
        let value = span.text;
        let remainder = value.substring(index);
        let newSpan = spiltBy === '\t' ? new TabElementBox() : new TextElementBox();
        newSpan.line = span.line;
        newSpan.characterFormat.copyFormat(span.characterFormat);
        span.line.children.splice(inlineIndex + 1, 0, newSpan);
        if (index > 0 && remainder.length === 1) {
            newSpan.text = value.substring(index);
            span.text = value.substring(0, index);
        }
        else if (index > 0) {
            newSpan.text = spiltBy;
            let newText = new TextElementBox();
            newText.line = span.line;
            newText.text = value.substring(index + 1);
            newText.characterFormat.copyFormat(span.characterFormat);
            span.line.children.splice(inlineIndex + 2, 0, newText);
            span.text = value.substring(0, index);
        }
        else if (remainder !== '') {
            newSpan.text = value.substring(index + 1);
            span.text = spiltBy;
        }
    }
    /**
     * Moves to next line.
     */
    moveToNextLine(line) {
        let paragraph = line.paragraph;
        let paraFormat = paragraph.paragraphFormat;
        let isParagraphStart = line.isFirstLine();
        let isParagraphEnd = line.isLastLine();
        let height = 0;
        let maxDescent = 0;
        let afterSpacing = 0;
        let beforeSpacing = 0;
        let lineSpacing = 0;
        let firstLineIndent = 0;
        this.updateLineWidget(line);
        height = this.maxTextHeight;
        maxDescent = height - this.maxTextBaseline;
        //Updates before spacing at the top of Paragraph first line.
        if (isParagraphStart) {
            beforeSpacing = this.getBeforeSpacing(paragraph);
            firstLineIndent = HelperMethods.convertPointToPixel(paraFormat.firstLineIndent);
        }
        //Updates after spacing at the bottom of Paragraph last line.
        if (isParagraphEnd) {
            afterSpacing = HelperMethods.convertPointToPixel(paraFormat.afterSpacing);
        }
        if (isNaN(this.maxTextHeight)) {
            //Calculate line height and descent based on formatting defined in paragraph.
            let measurement = this.viewer.textHelper.measureText('a', paragraph.characterFormat);
            height = measurement.Height;
            maxDescent = height - measurement.BaselineOffset;
        }
        else {
            height = this.maxTextHeight;
            maxDescent = height - this.maxTextBaseline;
        }
        // Gets line spacing.
        lineSpacing = this.getLineSpacing(paragraph, height);
        if (paraFormat.lineSpacingType === 'Exactly'
            && lineSpacing < maxDescent + this.maxBaseline) {
            lineSpacing = maxDescent + this.maxBaseline;
        }
        let subWidth = 0;
        let whiteSpaceCount = 0;
        let textAlignment = paraFormat.textAlignment;
        //Calculates the sub width, for text alignments - Center, Right, Justify.
        if (textAlignment !== 'Left' && this.viewer.textWrap && !(textAlignment === 'Justify' && isParagraphEnd)) {
            // tslint:disable-next-line:max-line-length
            let getWidthAndSpace = this.getSubWidth(line, textAlignment === 'Justify', whiteSpaceCount, firstLineIndent);
            subWidth = getWidthAndSpace.subWidth;
            whiteSpaceCount = getWidthAndSpace.spaceCount;
        }
        let addSubWidth = false;
        let lineSpacingType = paraFormat.lineSpacingType;
        for (let i = 0; i < line.children.length; i++) {
            let topMargin = 0;
            let bottomMargin = 0;
            let leftMargin = 0;
            let elementBox = line.children[i];
            // tslint:disable-next-line:max-line-length
            let alignElements = this.alignLineElements(elementBox, topMargin, bottomMargin, maxDescent, addSubWidth, subWidth, textAlignment, whiteSpaceCount, i === line.children.length - 1);
            topMargin = alignElements.topMargin;
            bottomMargin = alignElements.bottomMargin;
            addSubWidth = alignElements.addSubWidth;
            whiteSpaceCount = alignElements.whiteSpaceCount;
            //Updates line spacing, paragraph after/ before spacing and aligns the text to base line offset.
            if (lineSpacingType === 'Multiple') {
                if (lineSpacing > height) {
                    bottomMargin += lineSpacing - height;
                }
                else {
                    topMargin += lineSpacing - height;
                }
            }
            else if (lineSpacingType === 'Exactly') {
                topMargin += lineSpacing - (topMargin + elementBox.height + bottomMargin);
            }
            else if (lineSpacing > topMargin + elementBox.height + bottomMargin) {
                topMargin += lineSpacing - (topMargin + elementBox.height + bottomMargin);
            }
            topMargin += beforeSpacing;
            bottomMargin += afterSpacing;
            if (i === 0) {
                line.height = topMargin + elementBox.height + bottomMargin;
                if (textAlignment === 'Right') {
                    //Aligns the text as right justified.
                    leftMargin = subWidth;
                }
                else if (textAlignment === 'Center') {
                    //Aligns the text as center justified.
                    leftMargin = subWidth / 2;
                }
            }
            elementBox.margin = new Margin(leftMargin, topMargin, 0, bottomMargin);
            elementBox.line = line;
        }
        this.viewer.cutFromTop(this.viewer.clientActiveArea.y + line.height);
    }
    updateLineWidget(line) {
        for (let i = 0; i < line.children.length; i++) {
            let element = line.children[i];
            if (element instanceof TextElementBox || element instanceof ListTextElementBox) {
                if (this.maxTextHeight < element.height) {
                    this.maxTextHeight = element.height;
                    this.maxTextBaseline = element.baselineOffset;
                }
                if (this.maxBaseline < this.maxTextBaseline) {
                    this.maxBaseline = this.maxTextBaseline;
                }
            }
            else if (this.maxBaseline < element.height) {
                this.maxBaseline = element.height;
            }
        }
    }
    /**
     * @param viewer
     */
    moveToNextPage(viewer, line, isPageBreak) {
        let paragraphWidget = line.paragraph;
        let index = 0;
        if (!isNullOrUndefined(line)) {
            index = paragraphWidget.childWidgets.indexOf(line);
            if (index > 0 || isPageBreak) {
                paragraphWidget.height = viewer.clientActiveArea.y - paragraphWidget.y;
            }
        }
        let nextBody = this.moveBlocksToNextPage(paragraphWidget);
        this.viewer.updateClientArea(nextBody.sectionFormat, nextBody.page);
        this.viewer.updateClientAreaForBlock(paragraphWidget, true);
        if (index > 0) {
            if (line.isLastLine() && isPageBreak) {
                return;
            }
            let nextParagraph;
            if (nextBody.firstChild instanceof ParagraphWidget && nextBody.firstChild.equals(paragraphWidget)) {
                nextParagraph = nextBody.firstChild;
            }
            else {
                nextParagraph = new ParagraphWidget();
            }
            nextParagraph = this.addParagraphWidget(this.viewer.clientActiveArea, nextParagraph);
            nextParagraph.index = paragraphWidget.index;
            let insertIndex = 0;
            for (let i = index; i < paragraphWidget.childWidgets.length; i++) {
                let lineWidget = paragraphWidget.childWidgets[i];
                lineWidget.paragraph = nextParagraph;
                nextParagraph.childWidgets.splice(insertIndex, 0, lineWidget);
                lineWidget.paragraph = nextParagraph;
                insertIndex++;
            }
            nextParagraph.paragraphFormat = paragraphWidget.paragraphFormat;
            nextParagraph.characterFormat = paragraphWidget.characterFormat;
            paragraphWidget.childWidgets.splice(index);
            paragraphWidget = nextParagraph;
        }
        else if (!isPageBreak) {
            paragraphWidget.containerWidget.removeChild(paragraphWidget.indexInOwner);
        }
        if (!isPageBreak) {
            if (nextBody.childWidgets.indexOf(paragraphWidget) === -1) {
                nextBody.childWidgets.splice(0, 0, paragraphWidget);
            }
            paragraphWidget.containerWidget = nextBody;
            this.viewer.updateClientAreaLocation(paragraphWidget, this.viewer.clientActiveArea);
        }
    }
    /**
     * Aligns line elements
     * @param element
     * @param topMargin
     * @param bottomMargin
     * @param maxDescent
     * @param addSubWidth
     * @param subWidth
     * @param textAlignment
     * @param whiteSpaceCount
     * @param isLastElement
     */
    // tslint:disable-next-line:max-line-length
    alignLineElements(element, topMargin, bottomMargin, maxDescent, addSubWidth, subWidth, textAlignment, whiteSpaceCount, isLastElement) {
        if (element instanceof TextElementBox || element instanceof ListTextElementBox) {
            let textElement = element instanceof TextElementBox ? element : undefined;
            //Updates the text to base line offset.
            // tslint:disable-next-line:max-line-length
            let baselineOffset = element instanceof TextElementBox ? textElement.baselineOffset : element.baselineOffset;
            topMargin += this.maxBaseline - baselineOffset;
            bottomMargin += maxDescent - (element.height - baselineOffset);
            //Updates the text to base line offset.
            if (!isNullOrUndefined(textElement) && textAlignment === 'Justify' && whiteSpaceCount > 0) {
                //Aligns the text as Justified.
                let width = textElement.width;
                let text = textElement.text;
                if (!addSubWidth) {
                    text = HelperMethods.trimStart(text); // trim start
                    addSubWidth = (text.length > 0);
                }
                if (addSubWidth) {
                    let spaceCount = text.length - HelperMethods.removeSpace(text).length;
                    if (isLastElement) {
                        spaceCount -= text.length - HelperMethods.trimEnd(text).length;
                    }
                    if (whiteSpaceCount < spaceCount) {
                        width = this.viewer.textHelper.measureTextExcludingSpaceAtEnd(text, textElement.characterFormat);
                        spaceCount = whiteSpaceCount;
                    }
                    if (spaceCount > 0) {
                        textElement.width = width + subWidth * spaceCount;
                        whiteSpaceCount -= spaceCount;
                    }
                }
            }
        }
        else {
            addSubWidth = true;
            //Updates the Image/UIElement to base line offset.
            topMargin += this.maxBaseline - element.height;
            bottomMargin += maxDescent;
        }
        return { 'topMargin': topMargin, 'bottomMargin': bottomMargin, 'addSubWidth': addSubWidth, 'whiteSpaceCount': whiteSpaceCount };
    }
    /**
     * Updates widget to page.
     * @param viewer
     * @param block
     * @private
     */
    updateWidgetToPage(viewer, paragraphWidget) {
        if (paragraphWidget.isInsideTable) {
            let cellWidget = paragraphWidget.associatedCell;
            paragraphWidget.height = viewer.clientActiveArea.y - paragraphWidget.y;
            // if (viewer instanceof PageLayoutViewer) {
            if (isNullOrUndefined(paragraphWidget.associatedCell) || isNullOrUndefined(paragraphWidget.associatedCell.ownerRow)
                || isNullOrUndefined(paragraphWidget.associatedCell.ownerRow.rowFormat)) {
                return;
            }
            if (paragraphWidget.associatedCell.ownerRow.rowFormat.heightType === 'Exactly') {
                cellWidget.height = HelperMethods.convertPointToPixel(paragraphWidget.associatedCell.ownerRow.rowFormat.height);
            }
            else {
                // tslint:disable-next-line:max-line-length
                if ([cellWidget].length <= 1 && paragraphWidget.associatedCell.ownerRow.rowFormat.heightType === 'AtLeast') {
                    cellWidget.height = Math.max(HelperMethods.convertPointToPixel(paragraphWidget.associatedCell.ownerRow.rowFormat.height), this.getCellContentHeight(cellWidget));
                }
                else {
                    cellWidget.height = cellWidget.height + paragraphWidget.height;
                }
            }
            // } else {
            //     cellWidget.height = cellWidget.height + paragraphWidget.height;
            // }
            // cellWidget.childWidgets.push(paragraphWidget);
            paragraphWidget.containerWidget = cellWidget;
        }
        else {
            if (!paragraphWidget.isEndsWithPageBreak) {
                paragraphWidget.height = viewer.clientActiveArea.y - paragraphWidget.y;
            }
            //Adds the paragraph widget to the Header Footer/ Body widget.
            // this.updateWidgetsToBody(paragraphWidget, viewer, paragraphWidget);
            //For canvas no need to render paragraph widget here. In case of div, need to render paragraph here.
            // tslint:disable-next-line:max-line-length             
            // this.render.renderParagraphWidget((paragraphWidget.containerWidget as BodyWidget).page, paragraphWidget);
        }
        if (paragraphWidget.bodyWidget instanceof HeaderFooterWidget) {
            if (!paragraphWidget.isInsideTable) {
                paragraphWidget.containerWidget.height += paragraphWidget.height;
            }
            if (this.viewer.owner.enableHeaderAndFooter && paragraphWidget.bodyWidget.headerFooterType.indexOf('Footer') !== -1) {
                this.shiftFooterChildLocation(paragraphWidget.bodyWidget, this.viewer);
            }
        }
    }
    /**
     * @private
     */
    shiftFooterChildLocation(widget, viewer) {
        let pageHeight = widget.page.bodyWidgets[0].sectionFormat.pageHeight;
        if (widget.headerFooterType.indexOf('Footer') !== -1) {
            let footerDistance = widget.page.bodyWidgets[0].sectionFormat.footerDistance;
            let height = HelperMethods.convertPointToPixel(pageHeight - footerDistance);
            let top;
            if (widget.y + widget.height > height) {
                top = height - (widget.y + widget.height);
            }
            else if (widget.y + widget.height < height) {
                top = (widget.y + widget.height) - height;
            }
            if (!isNullOrUndefined(top)) {
                top = height - (widget.y + widget.height);
                this.shiftChildLocation(top, widget);
                viewer.clientActiveArea.y += top;
            }
        }
    }
    /**
     * Checks previous element.
     * @param characterFormat
     */
    checkPreviousElement(line, index, characterFormat) {
        let paragraph = line.paragraph;
        let isSplitByWord = false;
        let lastTextElement = 0;
        for (let i = index - 1; i >= 0; i--) {
            let textElement = line.children[i];
            if (textElement instanceof TextElementBox) {
                let text = textElement.text;
                lastTextElement = i;
                if (text.length > 0 && text[text.length - 1] === ' ') {
                    if (i === index - 1) {
                        this.addSplittedLineWidget(line, index - 1);
                        return true;
                    }
                    isSplitByWord = true;
                    break;
                }
                else if (text === '\t') {
                    return false;
                }
                else if (text.indexOf(' ') >= 0) {
                    isSplitByWord = true;
                    let index = text.lastIndexOf(' ') + 1;
                    //Splits the text element by space.
                    let splittedElement = new TextElementBox();
                    splittedElement.text = text.substr(index);
                    splittedElement.characterFormat.copyFormat(textElement.characterFormat);
                    textElement.text = text.substr(0, index);
                    this.viewer.textHelper.getTextSize(splittedElement, characterFormat);
                    textElement.width -= splittedElement.width;
                    textElement.height = splittedElement.height;
                    if (textElement.width === 0) {
                        line.children.splice(i, 1);
                    }
                    //Adds the text element to the line
                    line.children.splice(i + 1, 0, splittedElement);
                    break;
                }
            }
            else if (!(textElement instanceof ListTextElementBox)) {
                //Handled for inline images/UIelements.
                lastTextElement = i;
                isSplitByWord = true;
                break;
            }
        }
        if (isSplitByWord) {
            lastTextElement++;
            if (lastTextElement < line.children.length) {
                let splitWidth = 0;
                for (let i = lastTextElement; i < line.children.length; i++) {
                    splitWidth += line.children[i].width;
                    this.addSplittedLineWidget(line, i - 1);
                    i--;
                }
                this.viewer.updateClientWidth(splitWidth);
            }
        }
        return isSplitByWord;
    }
    /**
     * @private
     */
    clearListElementBox(paragraph) {
        if (paragraph.childWidgets.length === 0) {
            return;
        }
        let line = paragraph.childWidgets[0];
        if (isNullOrUndefined(line.children)) {
            return;
        }
        for (let i = 0; i < line.children.length; i++) {
            if (line.children[i] instanceof ListTextElementBox) {
                line.children.splice(i, 1);
                i--;
            }
            else {
                break;
            }
        }
    }
    /**
     * Gets list number.
     * @param listFormat
     * @param document
     * @private
     */
    getListNumber(listFormat) {
        let list = this.viewer.getListById(listFormat.listId);
        let levelNumber = listFormat.listLevelNumber;
        let listLevel = this.getListLevel(list, listFormat.listLevelNumber);
        // tslint:disable-next-line:max-line-length
        let levelOverride = !isNullOrUndefined(list.levelOverrides) ? list.levelOverrides[levelNumber] : undefined;
        // If LevelOverride exists and have either override list level or StartAtOverride, then only list numbering will be restarted.
        // tslint:disable-next-line:max-line-length
        // if (!isNullOrUndefined(levelOverride) && !(document.renderedLevelOverrides.indexOf(levelOverride) > -1) && isNullOrUndefined(levelOverride.overrideListLevel)) {
        //     //Add List Override style
        //     document.renderedLevelOverrides.push(list.levelOverrides.getItem(levelNumber) as WLevelOverride);
        //     if (document.renderedLists.containsKey((list.wordDocument as WordDocument).getAbstractListById(list.abstractListId))) {
        // tslint:disable-next-line:max-line-length
        //         let levels: Dictionary<number, number> = document.renderedLists.get((list.wordDocument as WordDocument).getAbstractListById(list.abstractListId));
        //         if (levels.containsKey(levelNumber)) {
        //             levels.remove(levelNumber);
        //         }
        //     }
        // }
        this.updateListValues(list, levelNumber);
        return this.getListText(list, levelNumber, listLevel);
    }
    /**
     * Gets list start value
     * @param listLevelNumber
     * @param list
     * @private
     */
    getListStartValue(listLevelNumber, list) {
        // tslint:disable-next-line:max-line-length
        let levelOverride = !isNullOrUndefined(list.levelOverrides) ? list.levelOverrides[listLevelNumber] : undefined;
        if (!isNullOrUndefined(levelOverride) && isNullOrUndefined(levelOverride.overrideListLevel)) {
            return levelOverride.startAt;
        }
        let listLevel = this.getListLevel(list, listLevelNumber);
        if (isNullOrUndefined(listLevel)) {
            return 0;
        }
        else {
            return listLevel.startAt;
        }
    }
    /**
     * Updates list values.
     * @param list
     * @param listLevelNumber
     * @param document
     */
    updateListValues(list, listLevelNumber) {
        if (!this.viewer.renderedLists.containsKey(this.viewer.getAbstractListById(list.abstractListId))) {
            let startVal = new Dictionary();
            this.viewer.renderedLists.add(this.viewer.getAbstractListById(list.abstractListId), startVal);
            let listLevel = this.getListLevel(list, listLevelNumber);
            for (let i = 0; i <= listLevelNumber; i++) {
                startVal.add(i, this.getListStartValue(i, list));
            }
        }
        else {
            // tslint:disable-next-line:max-line-length
            let levels = this.viewer.renderedLists.get(this.viewer.getAbstractListById(list.abstractListId));
            if (levels.containsKey(listLevelNumber)) {
                let startAt = levels.get(listLevelNumber);
                levels.set(listLevelNumber, startAt + 1);
                let levelNumber = listLevelNumber + 1;
                while (levelNumber < this.viewer.getAbstractListById(list.abstractListId).levels.length) {
                    let listLevel = this.getListLevel(list, levelNumber);
                    // if (!isNullOrUndefined(listLevel)) {
                    if (levels.containsKey(levelNumber) && listLevel.restartLevel > listLevelNumber) {
                        levels.remove(levelNumber);
                        // if (document.renderedListLevels.indexOf(listLevel) > -1) {
                        //     document.renderedListLevels.pop();
                        // }
                    }
                    // }
                    levelNumber++;
                }
            }
            else {
                let levelNumber = listLevelNumber;
                while (!levels.containsKey(levelNumber - 1) && levelNumber > 0) {
                    let listLevel = this.getListLevel(list, levelNumber - 1);
                    // if (!isNullOrUndefined(listLevel)) {
                    levels.add(levelNumber - 1, this.getListStartValue(levelNumber - 1, list));
                    // if (document.renderedListLevels.indexOf(listLevel) !== -1) {
                    //     document.renderedListLevels.push(listLevel);
                    // }
                    // }
                    levelNumber--;
                }
                let startAt = this.getListStartValue(listLevelNumber, list);
                levels.add(listLevelNumber, startAt);
            }
        }
    }
    /**
     * Gets list text
     * @param listAdv
     * @param listLevelNumber
     * @param currentListLevel
     * @param document
     */
    getListText(listAdv, listLevelNumber, currentListLevel) {
        let listText = currentListLevel.numberFormat;
        // tslint:disable-next-line:max-line-length
        if (this.viewer.renderedLists.containsKey(this.viewer.getAbstractListById(listAdv.abstractListId))) {
            let levels = this.viewer.renderedLists.get(this.viewer.getAbstractListById(listAdv.abstractListId));
            let keys = levels.keys;
            for (let i = 0; i < keys.length; i++) {
                let levelNumber = keys[i];
                let levelKey = '%' + (levelNumber + 1).toString();
                let listLevel = this.getListLevel(listAdv, levelNumber);
                if (listText.match(levelKey)) {
                    if (levelNumber > listLevelNumber) {
                        return '';
                    }
                    else if (levels.containsKey(levelNumber) && !isNullOrUndefined(listLevel)) {
                        listText = listText.replace(levelKey, this.getListTextListLevel(listLevel, levels.get(levelNumber)));
                    }
                    else {
                        listText = listText.replace(levelKey, '0');
                    }
                }
            }
        }
        return listText;
    }
    /**
     * Gets the roman letter.
     * @param number
     * @private
     */
    getAsLetter(number) {
        // if (number <= 0) {
        //     return '';
        // }
        let quotient = number / 26;
        let remainder = number % 26;
        if (remainder === 0) {
            //If number denotes the factor of 26, then reduce quotient by 1 and set remainder as 26.
            remainder = 26;
            quotient--;
        }
        //Index of A char in the ASCII table.     
        let letter = String.fromCharCode(65 - 1 + remainder);
        let listValue = '';
        while (quotient >= 0) {
            listValue = listValue + letter.toString();
            quotient--;
        }
        return listValue;
    }
    /**
     * Gets list text using list level pattern.
     * @param listLevel
     * @param listValue
     * @private
     */
    getListTextListLevel(listLevel, listValue) {
        switch (listLevel.listLevelPattern) {
            case 'UpRoman':
                return this.getAsRoman(listValue).toUpperCase();
            case 'LowRoman':
                return this.getAsRoman(listValue).toLowerCase();
            case 'UpLetter':
                return this.getAsLetter(listValue).toUpperCase();
            case 'LowLetter':
                return this.getAsLetter(listValue).toLowerCase();
            case 'Arabic':
                return (listValue).toString();
            case 'LeadingZero':
                return this.getAsLeadingZero(listValue);
            case 'Number':
                return (listValue).toString();
            case 'OrdinalText':
                return (listValue).toString();
            case 'Ordinal':
                return (listValue).toString();
            case 'FarEast':
                return (listValue).toString();
            case 'Special':
                return (listValue).toString();
            default:
                return '';
        }
    }
    /**
     * Generate roman number for the specified number.
     * @param number
     * @param magnitude
     * @param letter
     */
    generateNumber(number, magnitude, letter) {
        let numberstring = '';
        while (number >= magnitude) {
            number -= magnitude;
            numberstring += letter;
            this.value = number;
        }
        return numberstring.toString();
    }
    /**
     * Gets list value prefixed with zero, if less than 10
     * @param listValue
     */
    getAsLeadingZero(listValue) {
        if (listValue < 10) {
            return '0' + listValue.toString();
        }
        else {
            return listValue.toString();
        }
    }
    /**
     * Gets the roman number
     * @param number
     * @private
     */
    getAsRoman(number) {
        let retval = '';
        this.value = number;
        retval += this.generateNumber(this.value, 1000, 'M');
        retval += this.generateNumber(this.value, 900, 'CM');
        retval += this.generateNumber(this.value, 500, 'D');
        retval += this.generateNumber(this.value, 400, 'CD');
        retval += this.generateNumber(this.value, 100, 'C');
        retval += this.generateNumber(this.value, 90, 'XC');
        retval += this.generateNumber(this.value, 50, 'L');
        retval += this.generateNumber(this.value, 40, 'XL');
        retval += this.generateNumber(this.value, 10, 'X');
        retval += this.generateNumber(this.value, 9, 'IX');
        retval += this.generateNumber(this.value, 5, 'V');
        retval += this.generateNumber(this.value, 4, 'IV');
        retval += this.generateNumber(this.value, 1, 'I');
        return retval.toString();
    }
    /**
     * Gets the list level
     * @param list
     * @param listLevelNumber
     * @private
     */
    getListLevel(list, listLevelNumber) {
        if (!isNullOrUndefined(list)) {
            let abstractList = this.viewer.getAbstractListById(list.abstractListId);
            if (!isNullOrUndefined(list) && abstractList.levels.length <= listLevelNumber
                && listLevelNumber >= 0 && listLevelNumber < 9) {
                this.addListLevels(abstractList);
            }
            let levelOverrideAdv = undefined;
            let level = false;
            level = (!isNullOrUndefined(list.levelOverrides))
                && !isNullOrUndefined(((levelOverrideAdv = list.levelOverrides[listLevelNumber])))
                && (!isNullOrUndefined(levelOverrideAdv.overrideListLevel));
            if (level) {
                return levelOverrideAdv.overrideListLevel;
            }
            else if (!isNullOrUndefined(abstractList) && listLevelNumber >= 0 && listLevelNumber < abstractList.levels.length) {
                return abstractList.levels[listLevelNumber];
            }
        }
        return undefined;
    }
    /**
     * Gets tab width
     * @param paragraph
     * @param viewer
     */
    // tslint:disable-next-line:max-line-length
    getTabWidth(paragraph, viewer, index, lineWidget, element) {
        let fposition = 0;
        let isCustomTab = false;
        let tabs = paragraph.paragraphFormat.getUpdatedTabs();
        //  Calculate hanging width
        if (viewer.clientActiveArea.x < viewer.clientArea.x) {
            return viewer.clientArea.x - viewer.clientActiveArea.x;
        }
        // Calculates tabwidth based on pageleftmargin and defaulttabwidth property
        let position = viewer.clientActiveArea.x -
            (viewer.clientArea.x - HelperMethods.convertPointToPixel(paragraph.paragraphFormat.leftIndent));
        let defaultTabWidth = HelperMethods.convertPointToPixel(viewer.defaultTabWidth);
        if (tabs.length === 0 && (position === 0 || defaultTabWidth === 0)) {
            return defaultTabWidth;
        }
        else {
            if (tabs.length > 0) {
                for (let i = 0; i < tabs.length; i++) {
                    let tabPosition = HelperMethods.convertPointToPixel(tabs[i].position);
                    if (tabs[i].tabJustification === 'Left' && position < tabPosition) {
                        fposition = tabPosition;
                        isCustomTab = true;
                        if (!isNullOrUndefined(element)) {
                            element.tabLeader = tabs[i].tabLeader;
                            element.tabText = '';
                        }
                        break;
                    }
                    else if (tabs[i].tabJustification === 'Right' && position < tabPosition) {
                        let tabwidth = tabPosition - position;
                        let width = this.getRightTabWidth(index + 1, lineWidget, paragraph);
                        if (width < tabwidth) {
                            defaultTabWidth = tabwidth - width;
                        }
                        else {
                            defaultTabWidth = 0;
                        }
                        fposition = position;
                        isCustomTab = true;
                        if (!isNullOrUndefined(element)) {
                            element.tabLeader = tabs[i].tabLeader;
                            element.tabText = '';
                        }
                        break;
                    }
                }
            }
            if (!isCustomTab) {
                let diff = ((Math.round(position) * 100) % (Math.round(defaultTabWidth) * 100)) / 100;
                let cnt = (Math.round(position) - diff) / Math.round(defaultTabWidth);
                fposition = (cnt + 1) * defaultTabWidth;
            }
            return (fposition - position) > 0 ? fposition - position : defaultTabWidth;
        }
    }
    /**
     * Returns the right tab width
     * @param index - index of starting inline
     * @param lineWidget - current line widget
     * @param paragraph - current paragraph widget
     */
    getRightTabWidth(index, lineWidget, paragraph) {
        let width = 0;
        let isFieldCode = false;
        while (index < lineWidget.children.length) {
            let elementBox = lineWidget.children[index];
            if ((elementBox instanceof FieldElementBox) || (elementBox instanceof BookmarkElementBox) || isFieldCode) {
                if (elementBox instanceof FieldElementBox) {
                    if (elementBox.fieldType === 0) {
                        isFieldCode = true;
                    }
                    else if (elementBox.fieldType === 2) {
                        isFieldCode = false;
                    }
                }
                elementBox.width = 0;
            }
            else {
                this.viewer.textHelper.getTextSize(elementBox, elementBox.characterFormat);
            }
            if (elementBox instanceof TextElementBox && elementBox.text === '\t') {
                return width;
            }
            else {
                width = width + elementBox.width;
            }
            index++;
        }
        return width;
    }
    /**
     * Gets split index by word.
     * @param clientActiveWidth
     * @param text
     * @param width
     * @param characterFormat
     */
    getSplitIndexByWord(clientActiveWidth, text, width, characterFormat) {
        let index = 0;
        let length = text.length;
        while (index < length) {
            let nextIndex = this.getTextIndexAfterSpace(text, index);
            if (nextIndex === 0 || nextIndex === length) {
                nextIndex = length - 1;
            }
            let splitWidth = width;
            if ((nextIndex < length - 1 || (nextIndex === length - 1 && text[nextIndex - 1] === ' ')) && index !== nextIndex) {
                splitWidth = this.viewer.textHelper.measureTextExcludingSpaceAtEnd(text.slice(0, nextIndex), characterFormat);
            }
            if (splitWidth <= clientActiveWidth) {
                index = nextIndex;
            }
            else {
                if (index === 0 && text[0] === ' ') {
                    index = this.getTextIndexAfterSpace(text, 0);
                }
                break;
            }
        }
        return index;
    }
    /**
     * Gets split index by character
     * @param totalClientWidth
     * @param clientActiveAreaWidth
     * @param text
     * @param width
     * @param characterFormat
     */
    // tslint:disable-next-line:max-line-length
    getTextSplitIndexByCharacter(totalClientWidth, clientActiveAreaWidth, text, width, characterFormat) {
        let length = text.length;
        for (let i = 0; i < length; i++) {
            let splitWidth = width;
            if (i + 1 < length) {
                splitWidth = this.viewer.textHelper.measureTextExcludingSpaceAtEnd(text.substring(0, i + 1), characterFormat);
            }
            if (splitWidth > clientActiveAreaWidth) {
                if (i === 0 && splitWidth > totalClientWidth) {
                    //Handle for cell/section having client width less than a character's width.
                    return (length > 1 && text[1] === ' ') ? this.getTextIndexAfterSpace(text, 1) : 1;
                }
                return i;
            }
        }
        return 0;
    }
    /**
     * Gets sub width.
     * @param justify
     * @param spaceCount
     * @param firstLineIndent
     */
    getSubWidth(lineWidget, justify, spaceCount, firstLineIndent) {
        let width = 0;
        let trimSpace = true;
        let lineText = '';
        for (let i = lineWidget.children.length - 1; i >= 0; i--) {
            let element = lineWidget.children[i];
            if (element instanceof TextElementBox) {
                let elementText = element.text;
                lineText = elementText + lineText;
                if (trimSpace && (elementText.trim() !== '' || elementText === '\t')) {
                    if (HelperMethods.endsWith(elementText)) {
                        width += this.viewer.textHelper.measureTextExcludingSpaceAtEnd(elementText, element.characterFormat);
                    }
                    else {
                        width += element.width;
                    }
                    trimSpace = false;
                }
                else if (!trimSpace) {
                    width += element.width;
                }
            }
            else {
                lineText = 'a' + lineText;
                trimSpace = false;
                width += element.width;
            }
            if (!justify) {
                width = Math.round(width);
            }
        }
        lineText = lineText.trim();
        spaceCount = lineText.length - HelperMethods.removeSpace(lineText).length;
        let subWidth = (this.viewer.clientArea.width - firstLineIndent - width);
        if (subWidth <= 0 || (spaceCount === 0 && justify)) {
            spaceCount = 0;
            subWidth = 0;
        }
        else if (justify) {
            subWidth = subWidth / spaceCount;
        }
        return { 'subWidth': subWidth, 'spaceCount': spaceCount };
    }
    /**
     * Gets before spacing.
     * @param paragraph
     * @private
     */
    getBeforeSpacing(paragraph) {
        let beforeSpacing = 0;
        if (paragraph.previousWidget instanceof ParagraphWidget) {
            if (paragraph.previousWidget.paragraphFormat.afterSpacing < paragraph.paragraphFormat.beforeSpacing) {
                // tslint:disable-next-line:max-line-length
                beforeSpacing = paragraph.paragraphFormat.beforeSpacing - paragraph.previousWidget.paragraphFormat.afterSpacing;
            }
        }
        else {
            beforeSpacing = paragraph.paragraphFormat.beforeSpacing;
        }
        return beforeSpacing;
    }
    /**
     * Gets line spacing.
     * @param paragraph
     * @param maxHeight
     * @private
     */
    getLineSpacing(paragraph, maxHeight) {
        if (isNullOrUndefined(paragraph.paragraphFormat)) {
            return 0;
        }
        let lineSpacing = 0;
        switch (paragraph.paragraphFormat.lineSpacingType) {
            case 'AtLeast':
            case 'Exactly':
                lineSpacing = paragraph.paragraphFormat.lineSpacing;
                break;
            default:
                lineSpacing = paragraph.paragraphFormat.lineSpacing * maxHeight;
                break;
        }
        return lineSpacing;
    }
    /**
     * Checks whether current line is first line in a paragraph.
     * @param paragraph
     */
    isParagraphFirstLine(paragraph, line) {
        let widget = paragraph;
        if (isNullOrUndefined(widget.childWidgets) || widget.childWidgets.indexOf(line) === 0) {
            //If the line elements conatins the elements from previous paragraph then need to retun false.
            //Example scenario, Field start and field end in different paragraphs.
            if (line.children.length > 0 && !isNullOrUndefined(paragraph.previousWidget)
                && paragraph.previousWidget instanceof ParagraphWidget) {
                return line.paragraph.index !== paragraph.previousWidget.index;
            }
            return true; //If the line elements count is zero then also need to return true.
        }
        return false;
    }
    /**
     * Checks whether current line is last line in a paragraph.
     * @param paragraph
     */
    isParagraphLastLine(element) {
        let paragraph = element.line.paragraph;
        let lastLineWidget = paragraph.childWidgets[paragraph.childWidgets.length - 1];
        let lastInline = lastLineWidget.children[lastLineWidget.children.length - 1];
        if (element === lastInline) {
            // tslint:disable-next-line:max-line-length            
            return (lastInline instanceof FieldElementBox) || ((!(lastInline instanceof TextElementBox && lastInline.text === '\v')));
        }
        return false;
    }
    /**
     * Gets text index after space.
     * @param text
     * @param startIndex
     */
    getTextIndexAfterSpace(text, startIndex) {
        let length = text.length;
        let index = 0;
        index = text.indexOf(' ', startIndex) + 1;
        let nextIndex = index;
        if (nextIndex === 0 || nextIndex === length) {
            return nextIndex;
        }
        while (text[nextIndex] === ' ') {
            nextIndex++;
            if (nextIndex === length) {
                break;
            }
        }
        return nextIndex;
    }
    //#region Table
    /**
     * @private
     */
    moveNextWidgetsToTable(tableWidget, rowWidgets, moveFromNext) {
        let currentRow = moveFromNext ? rowWidgets[rowWidgets.length - 2] : rowWidgets[rowWidgets.length - 1];
        let rowIndex = currentRow.indexInOwner;
        let currentTable = tableWidget[tableWidget.length - 1];
        if (moveFromNext) {
            rowIndex += 1;
        }
        let nextWidgets = currentRow.containerWidget.childWidgets.splice(rowIndex);
        for (let i = 0; i < nextWidgets.length; i++) {
            currentTable.childWidgets.push(nextWidgets[i]);
            nextWidgets[i].containerWidget = currentTable;
        }
    }
    /**
     * Adds table cell widget.
     * @param cell
     * @param area
     * @param maxCellMarginTop
     * @param maxCellMarginBottom
     */
    addTableCellWidget(cell, area, maxCellMarginTop, maxCellMarginBottom) {
        //let tableCellWidget: TableCellWidget = new TableCellWidget(cell);
        let prevColumnIndex = 0;
        let cellspace = 0;
        let left = 0;
        let top = maxCellMarginTop;
        let right = 0;
        let bottom = maxCellMarginBottom;
        if (!isNullOrUndefined(cell.cellFormat)) {
            if (cell.cellFormat.containsMargins()) {
                // tslint:disable-next-line:max-line-length
                left = isNullOrUndefined(cell.cellFormat.leftMargin) ? HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.leftMargin) : HelperMethods.convertPointToPixel(cell.cellFormat.leftMargin);
                right = isNullOrUndefined(cell.cellFormat.rightMargin) ? HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.rightMargin) : HelperMethods.convertPointToPixel(cell.cellFormat.rightMargin);
            }
            else {
                left = HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.leftMargin);
                right = HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.rightMargin);
            }
        }
        cell.margin = new Margin(left, top, right, bottom);
        cell.width = HelperMethods.convertPointToPixel(cell.cellFormat.cellWidth);
        if (!isNullOrUndefined(cell.previousWidget)) {
            // tslint:disable-next-line:max-line-length
            prevColumnIndex = cell.previousWidget.columnIndex + cell.previousWidget.cellFormat.columnSpan;
        }
        // tslint:disable-next-line:max-line-length
        cellspace = !isNullOrUndefined(cell.ownerTable) && !isNullOrUndefined(cell.ownerTable.tableFormat) ? HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.cellSpacing) : 0;
        let prevSpannedCellWidth = 0;
        if (prevColumnIndex < cell.columnIndex) {
            // tslint:disable-next-line:max-line-length
            prevSpannedCellWidth = HelperMethods.convertPointToPixel(cell.ownerTable.tableHolder.getPreviousSpannedCellWidth(prevColumnIndex, cell.columnIndex));
            if (prevColumnIndex === 0) {
                prevSpannedCellWidth = prevSpannedCellWidth - cellspace / 2;
            }
        }
        cell.x = area.x + prevSpannedCellWidth + cell.margin.left;
        cell.y = area.y + cell.margin.top + cellspace;
        cell.width = cell.width - cell.margin.left - cell.margin.right;
        if (cellspace > 0) {
            cell.x += cellspace;
            if (cell.ownerTable.tableHolder.columns.length === 1) {
                cell.width -= cellspace * 2;
            }
            else if (cell.columnIndex === 0 || cell.columnIndex === cell.ownerTable.tableHolder.columns.length - 1) {
                cell.width -= ((cellspace * 2) - cellspace / 2);
            }
            else {
                cell.width -= cellspace;
            }
        }
        // update the margins values respect to layouting of borders.
        // tslint:disable-next-line:max-line-length
        //For normal table cells only left border is rendred. for last cell left and right border is rendred. this border widths are not included in margins.
        cell.leftBorderWidth = HelperMethods.convertPointToPixel(TableCellWidget.getCellLeftBorder(cell).getLineWidth());
        cell.x += cell.leftBorderWidth;
        cell.width -= cell.leftBorderWidth;
        if (cellspace > 0 || cell.cellIndex === cell.ownerRow.childWidgets.length - 1) {
            cell.rightBorderWidth = TableCellWidget.getCellRightBorder(cell).getLineWidth();
            cell.width -= cell.rightBorderWidth;
        }
        //Add the border widths to respective margin side.
        cell.margin.left = cell.margin.left + cell.leftBorderWidth;
        cell.margin.right = cell.margin.right + cell.rightBorderWidth;
        //cell.ownerWidget = owner;
        return cell;
    }
    /**
     * Adds specified row widget to table.
     * @param viewer
     * @param tableRowWidget
     * @param row
     */
    // tslint:disable-next-line:max-line-length
    addWidgetToTable(viewer, tableCollection, rowCollection, row, endRowWidget) {
        //Adds table row widget to owner table widget.
        let tableWidget = tableCollection[0];
        let index = tableWidget.childWidgets.length;
        let prevWidget = undefined;
        let rowWidgetIndex = rowCollection.indexOf(row);
        if (rowWidgetIndex > 0) {
            prevWidget = rowCollection[rowWidgetIndex - 1];
            // Need to update on this further
        }
        else if (row.previousRenderedWidget instanceof TableRowWidget &&
            row.previousRenderedWidget.ownerTable.equals(row.ownerTable)) {
            // Need to update on this further
            prevWidget = row.previousRenderedWidget;
        }
        if (!isNullOrUndefined(prevWidget)) {
            tableWidget = prevWidget.containerWidget;
            // index = tableWidget.childWidgets.length;
            index = tableWidget.childWidgets.indexOf(prevWidget) + 1;
            if (Math.round(row.y) !== Math.round(prevWidget.y + prevWidget.height)) {
                let prevIndex = tableCollection.indexOf(tableWidget);
                if (prevIndex + 1 >= tableCollection.length) {
                    //Creates new table widget for splitted rows.
                    this.addTableWidget(viewer.clientActiveArea, tableCollection, true);
                }
                tableWidget = tableCollection[prevIndex + 1];
                index = tableWidget.childWidgets.length;
            }
            if (rowWidgetIndex > 0) {
                index = 0;
            }
        }
        this.updateRowHeightBySpannedCell(tableWidget, row, index);
        this.updateRowHeightByCellSpacing(tableCollection, row, viewer);
        //Remove widget from previous container after splitteing
        if (row.containerWidget && row.containerWidget !== tableWidget &&
            row.containerWidget.childWidgets.indexOf(row) !== -1) {
            row.containerWidget.childWidgets.splice(row.containerWidget.childWidgets.indexOf(row), 1);
        }
        if (tableWidget.childWidgets.indexOf(row) === -1) {
            tableWidget.childWidgets.splice(index, 0, row);
        }
        row.containerWidget = tableWidget;
        tableWidget.height = tableWidget.height + row.height;
        if (!isNullOrUndefined(tableWidget.containerWidget)
            && tableWidget.containerWidget.childWidgets.indexOf(tableWidget) >= 0 &&
            !(tableWidget.containerWidget instanceof HeaderFooterWidget)) {
            tableWidget.containerWidget.height += row.height;
        }
        this.updateHeightForRowWidget(viewer, false, tableCollection, rowCollection, row, false, endRowWidget);
        viewer.cutFromTop(row.y + row.height);
    }
    /**
     * Updates row height by spanned cell.
     * @param tableWidget
     * @param rowWidget
     * @param insertIndex
     * @param row
     * @private
     */
    updateRowHeightBySpannedCell(tableWidget, row, insertIndex) {
        let rowSpan = 1;
        if (tableWidget.childWidgets.length === 0 || insertIndex === 0) {
            this.updateRowHeight(row, row);
            return;
        }
        for (let i = 0; i < row.childWidgets.length; i++) {
            let cellWidget = row.childWidgets[i];
            // tslint:disable-next-line:max-line-length
            rowSpan = (isNullOrUndefined(cellWidget) || isNullOrUndefined(cellWidget.cellFormat)) ? rowSpan : cellWidget.cellFormat.rowSpan;
            this.updateSpannedRowCollection(rowSpan, row);
        }
        if (!isNullOrUndefined(row.ownerTable)) {
            for (let i = 0; i < row.ownerTable.spannedRowCollection.length; i++) {
                if (row.ownerTable.spannedRowCollection.keys[i] === row.index) {
                    // Back track to previous table row widgets and update it height if vertical merge ends with this row.
                    for (let j = 0; j < insertIndex; j++) {
                        let prevRowWidget = tableWidget.childWidgets[j];
                        this.updateRowHeight(prevRowWidget, row);
                    }
                    row.ownerTable.spannedRowCollection.remove(row.ownerTable.spannedRowCollection.keys[i]);
                    break;
                }
            }
        }
    }
    /**
     * Updates row height.
     * @param prevRowWidget
     * @param rowWidget
     * @param row
     */
    updateRowHeight(prevRowWidget, row) {
        let rowIndex = row.index;
        let rowSpan = 1;
        for (let i = 0; i < prevRowWidget.childWidgets.length; i++) {
            let cellWidget = prevRowWidget.childWidgets[i];
            // tslint:disable-next-line:max-line-length
            rowSpan = (isNullOrUndefined(cellWidget) || isNullOrUndefined(cellWidget.cellFormat)) ? rowSpan : cellWidget.cellFormat.rowSpan;
            //To update Row height- if row has row span value greater than 1, need to add it in spannedRowCollection            
            this.updateSpannedRowCollection(rowSpan, row);
            if (rowIndex - cellWidget.rowIndex === rowSpan - 1) {
                let mergedCellHeight = cellWidget.y + cellWidget.height + cellWidget.margin.bottom - row.y;
                if (row.height < mergedCellHeight) {
                    row.height = mergedCellHeight;
                }
            }
        }
    }
    //if row has row span value greater than 1, need to add it in spannedRowCollection
    updateSpannedRowCollection(rowSpan, row) {
        if (rowSpan > 1 && !isNullOrUndefined(row.ownerTable)) {
            //Checks the rowspan is already exist in the list
            if (!row.ownerTable.spannedRowCollection.containsKey(row.index + rowSpan - 1)) {
                row.ownerTable.spannedRowCollection.add(row.index + rowSpan - 1, row.index);
            }
        }
    }
    /**
     * Updates row height by cell spacing
     * @param rowWidget
     * @param viewer
     * @param row
     */
    updateRowHeightByCellSpacing(tableCollection, row, viewer) {
        if (row.ownerTable.tableFormat.cellSpacing > 0) {
            // In the Case of tableWidget is greater than one and rowWidget is start at the Top Position of the page. 
            // In such case we have update the row height with half of cell spacing.
            // Remaining cases we have to update the entire hight
            // tslint:disable-next-line:max-line-length
            if (tableCollection.length > 1 && row.y === viewer.clientArea.y && viewer instanceof PageLayoutViewer) {
                row.height = row.height - HelperMethods.convertPointToPixel(row.ownerTable.tableFormat.cellSpacing) / 2;
            }
        }
    }
    /**
     * Checks whether row span is end.
     * @param row
     * @param viewer
     */
    isRowSpanEnd(row, viewer) {
        let rowIndex = row.index;
        let rowSpan = 1;
        for (let i = 0; i < viewer.splittedCellWidgets.length; i++) {
            let splittedCell = viewer.splittedCellWidgets[i];
            // tslint:disable-next-line:max-line-length
            rowSpan = (isNullOrUndefined(splittedCell) || isNullOrUndefined(splittedCell.cellFormat)) ? rowSpan : splittedCell.cellFormat.rowSpan;
            if (rowIndex - splittedCell.rowIndex === rowSpan - 1) {
                return true;
            }
        }
        return false;
    }
    /**
     * Checks whether vertical merged cell to continue or not.
     * @param row
     * @private
     */
    isVerticalMergedCellContinue(row) {
        let colIndex = 0;
        for (let i = 0; i < row.childWidgets.length; i++) {
            let cell = row.childWidgets[i];
            if (colIndex < cell.columnIndex) {
                return true;
            }
            colIndex += cell.cellFormat.columnSpan;
        }
        return colIndex < row.ownerTable.tableHolder.columns.length;
    }
    /**
     * Splits widgets.
     * @param tableRowWidget
     * @param viewer
     * @param splittedWidget
     * @param row
     */
    // tslint:disable-next-line:max-line-length
    splitWidgets(tableRowWidget, viewer, tableCollection, rowCollection, splittedWidget, isLastRow) {
        if (this.isFirstLineFitForRow(viewer.clientArea.bottom, tableRowWidget) && tableRowWidget.childWidgets.length > 0) {
            splittedWidget = this.getSplittedWidgetForRow(viewer.clientArea.bottom, tableCollection, rowCollection, tableRowWidget);
            if (viewer.splittedCellWidgets.length > 0 || splittedWidget !== tableRowWidget) {
                if (isLastRow) {
                    for (let i = 0; i < splittedWidget.childWidgets.length; i++) {
                        let cell = splittedWidget.childWidgets[i];
                        if (cell.rowIndex !== splittedWidget.index) {
                            splittedWidget.childWidgets.splice(i, 1);
                            i--;
                        }
                    }
                }
                //Adds the splitted widget of a vertical merged cell, to next row widget in the next page.
                this.insertSplittedCellWidgets(viewer, tableCollection, splittedWidget, tableRowWidget.indexInOwner - 1);
            }
        }
        else {
            //Adds the splitted widget of a vertical merged cell, to next row widget in the next page.
            this.insertSplittedCellWidgets(viewer, tableCollection, splittedWidget, tableRowWidget.indexInOwner - 1);
        }
        return splittedWidget;
    }
    /**
     * Gets splitted widget for row.
     * @param bottom
     * @param tableRowWidget
     */
    // tslint:disable-next-line:max-line-length
    getSplittedWidgetForRow(bottom, tableCollection, rowCollection, tableRowWidget) {
        let splittedWidget = undefined;
        let rowIndex = tableRowWidget.index;
        for (let i = 0; i < tableRowWidget.childWidgets.length; i++) {
            let cellWidget = tableRowWidget.childWidgets[i];
            let splittedCell = this.getSplittedWidget(bottom, true, tableCollection, rowCollection, cellWidget);
            if (!isNullOrUndefined(splittedCell)) {
                if (splittedCell === cellWidget) {
                    //Returns if the whole content of the row does not fit in current page.
                    return tableRowWidget;
                }
                if (tableRowWidget.childWidgets.indexOf(splittedCell) !== -1) {
                    tableRowWidget.childWidgets.splice(tableRowWidget.childWidgets.indexOf(splittedCell), 1);
                }
                if (i === 0 || tableRowWidget.height < cellWidget.height + cellWidget.margin.top + cellWidget.margin.bottom) {
                    tableRowWidget.height = cellWidget.height + cellWidget.margin.top + cellWidget.margin.bottom;
                }
                if (isNullOrUndefined(splittedWidget)) {
                    //Creates new widget, to hold the splitted contents.
                    splittedWidget = new TableRowWidget();
                    splittedWidget.containerWidget = tableRowWidget.containerWidget;
                    splittedWidget.index = tableRowWidget.index;
                    splittedWidget.rowFormat = tableRowWidget.rowFormat;
                    this.updateWidgetLocation(tableRowWidget, splittedWidget);
                    splittedWidget.height = 0;
                    rowCollection.push(splittedWidget);
                }
                let rowSpan = 1;
                // tslint:disable-next-line:max-line-length
                rowSpan = (isNullOrUndefined(splittedCell) || isNullOrUndefined(splittedCell.cellFormat)) ? rowSpan : splittedCell.cellFormat.rowSpan;
                if (rowIndex - splittedCell.rowIndex === rowSpan - 1
                    && splittedWidget.height < splittedCell.height + splittedCell.margin.top + splittedCell.margin.bottom) {
                    splittedWidget.height = splittedCell.height + splittedCell.margin.top + splittedCell.margin.bottom;
                }
                splittedWidget.childWidgets.push(splittedCell);
                splittedCell.containerWidget = splittedWidget;
            }
        }
        return splittedWidget;
    }
    /**
     * Updates widget to table.
     * @param row
     * @param viewer
     */
    /* tslint:disable */
    updateWidgetsToTable(tableWidgets, rowWidgets, row) {
        let rowHeight = this.getRowHeight(row, [row]);
        let viewer = this.viewer;
        //initializing row properties with default values.
        let isHeader = row.rowFormat.isHeader;
        let isAllowBreakAcrossPages = row.rowFormat.allowBreakAcrossPages;
        let heightType = row.rowFormat.heightType;
        let cellSpacing = 0;
        let count = 0;
        let tableRowWidget = row;
        let moveRowToNextTable = false;
        if (row.ownerTable.continueHeader && !isHeader) {
            row.ownerTable.continueHeader = false;
        }
        let isLastRow = false;
        cellSpacing = (!isNullOrUndefined(row.ownerTable) && !isNullOrUndefined(row.ownerTable.tableFormat)) ? HelperMethods.convertPointToPixel(row.ownerTable.tableFormat.cellSpacing) : 0;
        while (count < rowWidgets.length) {
            count = rowWidgets.length;
            if (row.ownerTable.isInsideTable || (viewer.splittedCellWidgets.length === 0 && tableRowWidget.y + tableRowWidget.height + cellSpacing <= viewer.clientArea.bottom)) {
                this.addWidgetToTable(viewer, tableWidgets, rowWidgets, tableRowWidget);
                if (viewer.splittedCellWidgets.length > 0 && isNullOrUndefined(rowWidgets[rowWidgets.length - 1].nextRow)) {
                    count--;
                    isLastRow = true;
                }
            }
            else {
                //Split widget for next page
                if (viewer.splittedCellWidgets.length > 0 && tableRowWidget.y + tableRowWidget.height <= viewer.clientArea.bottom) {
                    let isRowSpanEnd = this.isRowSpanEnd(row, viewer);
                    if (!isRowSpanEnd) {
                        if (this.isVerticalMergedCellContinue(row) && tableRowWidget.y == viewer.clientArea.y) {
                            this.insertSplittedCellWidgets(viewer, tableWidgets, tableRowWidget, tableRowWidget.indexInOwner - 1);
                        }
                        this.addWidgetToTable(viewer, tableWidgets, rowWidgets, tableRowWidget);
                        continue;
                    }
                }
                let splittedWidget = tableRowWidget;
                let tableWidget = tableWidgets[tableWidgets.length - 1];
                if (rowHeight + tableRowWidget.y > viewer.clientArea.bottom) {
                    // tslint:disable-next-line:max-line-length
                    if (!isAllowBreakAcrossPages || (isHeader && row.ownerTable.continueHeader) || (heightType === 'AtLeast' && HelperMethods.convertPointToPixel(row.rowFormat.height) < viewer.clientArea.bottom)) {
                        // tslint:disable-next-line:max-line-length
                        if ((heightType === 'AtLeast' && HelperMethods.convertPointToPixel(row.rowFormat.height) < viewer.clientActiveArea.height && isAllowBreakAcrossPages) || (heightType !== 'Exactly' && tableRowWidget.y === viewer.clientArea.y) || (heightType === 'Auto' && isAllowBreakAcrossPages)) {
                            splittedWidget = this.splitWidgets(tableRowWidget, viewer, tableWidgets, rowWidgets, splittedWidget, isLastRow);
                        }
                        if (heightType === 'Exactly' && tableRowWidget.y === viewer.clientArea.y) {
                            this.addWidgetToTable(viewer, tableWidgets, rowWidgets, tableRowWidget);
                            count++;
                        }
                        if (isHeader && row.ownerTable.continueHeader) {
                            row.ownerTable.header = false;
                            row.ownerTable.continueHeader = false;
                            row.ownerTable.headerHeight = 0;
                            let pages = undefined;
                            // if (viewer instanceof PageLayoutViewer) {
                            pages = viewer.pages;
                            // }
                            if (!isNullOrUndefined(pages)) {
                                for (let i = 0; i < pages.length; i++) {
                                    if (pages[i].repeatHeaderRowTableWidget) {
                                        pages[i].repeatHeaderRowTableWidget = false;
                                    }
                                }
                            }
                        }
                    }
                    else {
                        if ((heightType === 'Auto' || heightType === 'AtLeast') && isAllowBreakAcrossPages) {
                            // tslint:disable-next-line:max-line-length
                            if (!(HelperMethods.convertPointToPixel(row.rowFormat.height) > viewer.clientArea.bottom) || tableRowWidget.y === viewer.clientArea.y) {
                                splittedWidget = this.splitWidgets(tableRowWidget, viewer, tableWidgets, rowWidgets, splittedWidget, isLastRow);
                            }
                        }
                        else if (heightType === 'Exactly' && tableRowWidget.y === viewer.clientArea.y) {
                            this.addWidgetToTable(viewer, tableWidgets, rowWidgets, tableRowWidget);
                            count++;
                        }
                    }
                }
                else {
                    let isInsertSplittedWidgets = false;
                    // Splitting handled for the merged cell with allowRowBreakAcross pages. 
                    if (this.isVerticalMergedCellContinue(row) && (isAllowBreakAcrossPages ||
                        (isInsertSplittedWidgets = tableRowWidget.y == viewer.clientArea.y))) {
                        if (isInsertSplittedWidgets) {
                            this.insertSplittedCellWidgets(viewer, tableWidgets, splittedWidget, tableRowWidget.indexInOwner - 1);
                        }
                        else {
                            splittedWidget = this.splitWidgets(tableRowWidget, viewer, tableWidgets, rowWidgets, splittedWidget, isLastRow);
                        }
                    }
                    else if (isLastRow && !isAllowBreakAcrossPages) {
                        splittedWidget = this.splitWidgets(tableRowWidget, viewer, tableWidgets, rowWidgets, splittedWidget, isLastRow);
                    }
                }
                //Create New table for splitted widget
                if (!isNullOrUndefined(splittedWidget)) {
                    if (splittedWidget !== tableRowWidget) {
                        this.addWidgetToTable(viewer, tableWidgets, rowWidgets, tableRowWidget, tableRowWidget.nextRow);
                        //Updates the fitted table rows to current page.
                        this.updateWidgetsToPage(tableWidgets, rowWidgets, row.ownerTable, tableRowWidget.nextRow);
                        let index = tableWidgets.indexOf(tableRowWidget.containerWidget);
                        if (index + 1 >= tableWidgets.length) {
                            //Creates new table widget for splitted rows.
                            this.addTableWidget(viewer.clientActiveArea, tableWidgets, true);
                        }
                        tableRowWidget = splittedWidget;
                    }
                    else {
                        if (row.index > 0) {
                            //Updates the fitted table rows to current page.
                            this.updateWidgetsToPage(tableWidgets, rowWidgets, row.ownerTable, row);
                            // Need to update on this further
                            if (row.previousRenderedWidget instanceof TableRowWidget) {
                                // Need to update on this further
                                let prevWidget = row.previousRenderedWidget;
                                if (HelperMethods.round(tableRowWidget.y, 2) === HelperMethods.round(prevWidget.y + prevWidget.height, 2)) {
                                    let prevIndex = tableWidgets.indexOf(prevWidget.containerWidget);
                                    if (prevIndex + 1 >= tableWidgets.length) {
                                        //Creates new table widget for splitted rows.
                                        this.addTableWidget(viewer.clientActiveArea, tableWidgets, true);
                                    }
                                }
                                else {
                                    //Creates new table widget for splitted rows.
                                    this.addTableWidget(viewer.clientActiveArea, tableWidgets, true);
                                }
                            }
                            else {
                                //Creates new table widget for splitted rows.
                                this.addTableWidget(viewer.clientActiveArea, tableWidgets, true);
                            }
                        }
                        moveRowToNextTable = true;
                        count--;
                    }
                    tableWidget = tableWidgets[tableWidgets.length - 1];
                    let prevBodyWidget = undefined;
                    if (tableWidgets.length > 1) {
                        //Get Previous Splitted Widget container
                        prevBodyWidget = tableWidgets[tableWidgets.length - 2].containerWidget;
                    }
                    else {
                        let previousBlock = row.ownerTable.previousRenderedWidget;
                        prevBodyWidget = previousBlock.containerWidget;
                    }
                    let pageIndex = 0;
                    if (!isNullOrUndefined(prevBodyWidget)) {
                        pageIndex = viewer.pages.indexOf(prevBodyWidget.page);
                    }
                    let index = row.ownerTable.containerWidget.index;
                    let bodyWidget;
                    let block;
                    if (moveRowToNextTable && tableWidgets.length === 1) {
                        block = tableWidgets[tableWidgets.length - 1];
                    }
                    else {
                        block = tableWidgets[tableWidgets.length - 2];
                    }
                    bodyWidget = this.moveBlocksToNextPage(block);
                    let curretTable = tableWidgets[tableWidgets.length - 1];
                    //Move Next RowWidge to next page
                    if (moveRowToNextTable) {
                        // tslint:disable-next-line:max-line-length
                        if (row.index === 0 && curretTable.containerWidget && curretTable.containerWidget.childWidgets.indexOf(curretTable) !== -1) {
                            curretTable.containerWidget.childWidgets.splice(curretTable.containerWidget.childWidgets.indexOf(curretTable), 1);
                        }
                    }
                    if (bodyWidget.childWidgets.indexOf(curretTable) !== -1) {
                        bodyWidget.childWidgets.splice(bodyWidget.childWidgets.indexOf(curretTable), 1);
                    }
                    bodyWidget.childWidgets.unshift(curretTable);
                    curretTable.containerWidget = bodyWidget;
                    if (moveRowToNextTable && row.index > 0 || rowWidgets.length > 1) {
                        this.moveNextWidgetsToTable(tableWidgets, rowWidgets, !moveRowToNextTable);
                    }
                    moveRowToNextTable = false;
                    if (row.ownerTable.header && tableRowWidget.height < viewer.clientArea.bottom) {
                        // if (viewer instanceof PageLayoutViewer) {
                        viewer.currentRenderingPage.repeatHeaderRowTableWidget = true;
                        // }
                        //Updates table widgets location.
                        viewer.updateClientAreaForBlock(row.ownerTable, true, tableWidgets);
                        // tslint:disable-next-line:max-line-length
                        //Update splitted row widget location. if header is repeated update the y position of splitted widget to header height.
                        splittedWidget.x = splittedWidget.x;
                        splittedWidget.y = tableWidget.y + row.ownerTable.headerHeight;
                        // let cellspace: number = viewer instanceof PageLayoutViewer ? cellspacing / 2 : cellspacing;
                        let cellspace = cellSpacing / 2;
                        this.updateChildLocationForRow(tableWidget.y + row.ownerTable.headerHeight - cellspace, splittedWidget);
                    }
                    else {
                        //Updates table widgets location.
                        viewer.updateClientAreaForBlock(row.ownerTable, true, tableWidgets);
                        // tslint:disable-next-line:max-line-length
                        //Update splitted row widget location. if header is repeated update the y position of splitted widget to header height.
                        splittedWidget.x = splittedWidget.x;
                        splittedWidget.y = tableWidget.y;
                        // let cellspace: number = viewer instanceof PageLayoutViewer ? cellspacing / 2 : cellspacing;
                        let cellspace = cellSpacing / 2;
                        this.updateChildLocationForRow(tableWidget.y - cellspace, splittedWidget);
                    }
                }
                isLastRow = false;
            }
            if (isHeader && row.ownerTable.continueHeader) {
                row.ownerTable.header = true;
                row.ownerTable.headerHeight = rowHeight + row.ownerTable.headerHeight;
            }
            if (isHeader && !isNullOrUndefined(this.getHeader(row.ownerTable)) && row.index === this.getHeader(row.ownerTable).index) {
                let headerHeight = this.getHeaderHeight(row.ownerTable, row, rowWidgets);
                if (headerHeight > row.ownerTable.headerHeight || headerHeight > row.ownerTable.headerHeight) {
                    row.ownerTable.headerHeight = headerHeight;
                }
                if (row.ownerTable.headerHeight > viewer.clientArea.height) {
                    row.ownerTable.header = false;
                    row.ownerTable.continueHeader = false;
                    row.ownerTable.headerHeight = 0;
                    let pages = viewer.pages;
                    for (let i = 0; i < pages.length; i++) {
                        if (pages[i].repeatHeaderRowTableWidget) {
                            pages[i].repeatHeaderRowTableWidget = false;
                        }
                    }
                }
            }
            if (tableWidgets.length > 2 && row.ownerTable.header && tableRowWidget.height < viewer.clientActiveArea.bottom &&
                !viewer.currentRenderingPage.repeatHeaderRowTableWidget) {
                viewer.currentRenderingPage.repeatHeaderRowTableWidget = true;
            }
        }
    }
    /* tslint:enable */
    /**
     * Gets header.
     * @param table
     * @private
     */
    getHeader(table) {
        let header = undefined;
        let flag = true;
        table = table.getSplitWidgets()[0];
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            if (row.rowFormat.isHeader) {
                header = row;
            }
            else {
                flag = false;
            }
            if (!flag) {
                break;
            }
        }
        return header;
    }
    /**
     * Gets header height.
     * @param ownerTable
     * @param row
     */
    getHeaderHeight(ownerTable, row, rowCollection) {
        let height = 0;
        if (row.ownerTable.childWidgets.length > 0 && ownerTable.childWidgets[0].rowFormat.isHeader) {
            for (let i = 0; i < ownerTable.childWidgets.length; i++) {
                let row = ownerTable.childWidgets[i];
                if (row.rowFormat.isHeader) {
                    height = height + this.getRowHeight(row, rowCollection);
                }
                else {
                    break;
                }
            }
        }
        return height;
    }
    /**
     * Updates widgets to row.
     * @param cell
     */
    updateWidgetToRow(cell) {
        let viewer = this.viewer;
        //Adds table cell widget to owner row widget.
        let rowWidget = cell.ownerRow;
        let cellLeft = rowWidget.x;
        if (rowWidget.childWidgets.length > 0) {
            let lastWidget = rowWidget.childWidgets[rowWidget.childWidgets.length - 1];
            cellLeft = lastWidget.x + lastWidget.width + lastWidget.margin.right;
        }
        // rowWidget.childWidgets.push(cell);
        cell.containerWidget = rowWidget;
        //If the row height is set as Atleast then height is set to atleast height for the first cell of the row.
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(cell.ownerRow) && cell.ownerRow.rowFormat.heightType !== 'Exactly' && HelperMethods.convertPointToPixel(cell.ownerRow.rowFormat.height) > 0 && cell.cellIndex === 0) {
            rowWidget.height = rowWidget.height + HelperMethods.convertPointToPixel(cell.ownerRow.rowFormat.height);
        }
        //Add condition not cell merged vertically.
        if (cell.cellFormat.rowSpan === 1) {
            let cellHeight = cell.height + cell.margin.top + cell.margin.bottom;
            if (rowWidget.height - HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.cellSpacing) < cellHeight) {
                rowWidget.height = cellHeight + HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.cellSpacing);
            }
        }
    }
    /**
     * Updates height for row widget.
     * @param viewer
     * @param isUpdateVerticalPosition
     * @param rowWidget
     */
    // tslint:disable-next-line:max-line-length
    updateHeightForRowWidget(viewer, isUpdateVerticalPosition, tableCollection, rowCollection, rowWidget, isLayouted, endRowWidget) {
        for (let i = 0; i < rowWidget.childWidgets.length; i++) {
            let cellspacing = 0;
            let cellWidget = undefined;
            let childWidget = rowWidget.childWidgets[i];
            // if (childWidget instanceof TableCellWidget) {
            cellWidget = childWidget;
            // }
            let rowSpan = 1;
            rowSpan = cellWidget.cellFormat.rowSpan;
            cellspacing = HelperMethods.convertPointToPixel(cellWidget.ownerTable.tableFormat.cellSpacing);
            if (rowSpan > 1) {
                let currentRowWidgetIndex = rowWidget.containerWidget.childWidgets.indexOf(rowWidget);
                // tslint:disable-next-line:max-line-length
                let rowSpanWidgetEndIndex = currentRowWidgetIndex + rowSpan - 1 - (rowWidget.index - cellWidget.rowIndex);
                if (viewer.clientArea.bottom < cellWidget.y + cellWidget.height + cellWidget.margin.bottom
                    || rowSpanWidgetEndIndex >= currentRowWidgetIndex + 1) {
                    this.splitSpannedCellWidget(cellWidget, tableCollection, rowCollection, viewer);
                }
                let spanEndRowWidget = rowWidget;
                if (rowSpanWidgetEndIndex > 0) {
                    if (rowSpanWidgetEndIndex < rowWidget.containerWidget.childWidgets.length) {
                        let childWidget = rowWidget.containerWidget.childWidgets[rowSpanWidgetEndIndex];
                        if (childWidget instanceof TableRowWidget) {
                            spanEndRowWidget = childWidget;
                            if (spanEndRowWidget === endRowWidget) {
                                spanEndRowWidget = rowWidget;
                            }
                        }
                    }
                    else {
                        // tslint:disable-next-line:max-line-length
                        spanEndRowWidget = rowWidget.containerWidget.childWidgets[rowWidget.containerWidget.childWidgets.length - 1];
                    }
                }
                if (cellWidget.y + cellWidget.height + cellWidget.margin.bottom < spanEndRowWidget.y + spanEndRowWidget.height) {
                    cellWidget.height = spanEndRowWidget.y + spanEndRowWidget.height - cellWidget.y - cellWidget.margin.bottom;
                    // tslint:disable-next-line:max-line-length
                }
                else if (isLayouted && spanEndRowWidget && (spanEndRowWidget.y !== 0 && spanEndRowWidget.height !== 0) && cellWidget.y + cellWidget.height + cellWidget.margin.bottom > spanEndRowWidget.y + spanEndRowWidget.height) {
                    spanEndRowWidget.height = cellWidget.y + cellWidget.height + cellWidget.margin.bottom - spanEndRowWidget.y;
                    // tslint:disable-next-line:max-line-length
                    //Update the next rowlayout widget location. Reason for the updation is previous row height is updated when cell height is greater. So already layouted next row location has to be updated again.
                    // if (rowWidget === spanEndRowWidget && rowWidget.nextWidget instanceof TableRowWidget) {
                    //     let nextRow: TableRowWidget = rowWidget.nextWidget as TableRowWidget;
                    //     // Need to update on this further
                    //     // if (viewer.renderedElements.containsKey(nextRow)) {
                    //     //     let nextWidget: TableRowWidget[] = viewer.renderedElements.get(nextRow) as TableRowWidget[];
                    //     //     if (nextWidget.length > 0) {
                    //     //         nextWidget[0].x = nextWidget[0].x;
                    //     //         nextWidget[0].y = rowWidget.y + rowWidget.height;
                    //     //     }
                    //     // }
                    // }
                }
            }
            else {
                if (cellspacing > 0) {
                    // In the Case of tableWidget is greater than one and rowWidget is start at the Top Position of the page. 
                    // In such case we have update the cell height with half of cell spacing.
                    // Remaining cases we have to update the entire hight
                    // tslint:disable-next-line:max-line-length
                    if (tableCollection.length > 1 && rowWidget.y === viewer.clientArea.y && viewer instanceof PageLayoutViewer) {
                        cellspacing = cellspacing / 2;
                    }
                }
                cellWidget.height = rowWidget.height - cellWidget.margin.top - cellWidget.margin.bottom - cellspacing;
            }
            this.updateHeightForCellWidget(viewer, tableCollection, rowCollection, cellWidget);
            let widget = rowWidget.containerWidget;
            while (widget.containerWidget instanceof Widget) {
                widget = widget.containerWidget;
            }
            let page = undefined;
            if (widget instanceof BodyWidget) {
                page = widget.page;
            }
            // tslint:disable-next-line:max-line-length
            if ((viewer instanceof PageLayoutViewer && viewer.visiblePages.indexOf(page) !== -1) || isUpdateVerticalPosition) {
                this.updateCellVerticalPosition(cellWidget, false, false);
            }
            //Renders the current table row contents, after relayout based on editing.
            // if (viewer instanceof PageLayoutViewer && (viewer as PageLayoutViewer).visiblePages.indexOf(page) !== -1) {
            //     //Added proper undefined condition check for Asynchronous operation.
            //     if (!isNullOrUndefined(rowWidget.tableRow) && !isNullOrUndefined(rowWidget.tableRow.rowFormat)) {
            //         this.viewer.updateScrollBars();
            //         //this.render.renderTableCellWidget(page, cellWidget);
            //     }
            // }
        }
    }
    /**
     * Updates height for cell widget.
     * @param viewer
     * @param cellWidget
     */
    // tslint:disable-next-line:max-line-length
    updateHeightForCellWidget(viewer, tableWidget, rowCollection, cellWidget) {
        for (let i = 0; i < cellWidget.childWidgets.length; i++) {
            if (cellWidget.childWidgets[i] instanceof TableWidget) {
                this.updateHeightForTableWidget(tableWidget, rowCollection, cellWidget.childWidgets[i]);
            }
        }
    }
    /**
     * Gets row height.
     * @param row
     * @private
     */
    getRowHeight(row, rowCollection) {
        let height = 0;
        if (row.rowFormat.heightType === 'Exactly') {
            height = row.rowFormat.height;
        }
        else {
            for (let i = 0; i < rowCollection.length; i++) {
                if (rowCollection[i] instanceof TableRowWidget) {
                    height = rowCollection[i].height + height;
                }
            }
            height = Math.max(height, row.rowFormat.height);
        }
        return height;
    }
    /**
     * splits spanned cell widget.
     * @param cellWidget
     * @param viewer
     */
    // tslint:disable-next-line:max-line-length
    splitSpannedCellWidget(cellWidget, tableCollection, rowCollection, viewer) {
        let splittedCell = this.getSplittedWidget(viewer.clientArea.bottom, false, tableCollection, rowCollection, cellWidget);
        if (!isNullOrUndefined(splittedCell)) {
            //Adds the splitted contents of a vertical merged cell, in order preserve in next page.
            viewer.splittedCellWidgets.push(splittedCell);
        }
    }
    /**
     * Inserts splitted cell widgets.
     * @param viewer
     * @param rowWidget
     */
    // tslint:disable-next-line:max-line-length
    insertSplittedCellWidgets(viewer, tableCollection, rowWidget, previousRowIndex) {
        let left = rowWidget.x;
        let tableWidth = 0;
        tableWidth = HelperMethods.convertPointToPixel(rowWidget.ownerTable.tableHolder.tableWidth);
        for (let i = 0; i < rowWidget.childWidgets.length; i++) {
            let cellWidget = rowWidget.childWidgets[i];
            if (Math.round(left) < Math.round(cellWidget.x - cellWidget.margin.left)) {
                if (this.insertRowSpannedWidget(rowWidget, viewer, left, i)) {
                    i--;
                    continue;
                }
                let length = rowWidget.childWidgets.length;
                this.insertEmptySplittedCellWidget(rowWidget, tableCollection, left, i, previousRowIndex);
                if (length < rowWidget.childWidgets.length) {
                    i--;
                    continue;
                }
            }
            left += cellWidget.margin.left + cellWidget.width + cellWidget.margin.right;
            if (i === rowWidget.childWidgets.length - 1 && Math.round(left) < Math.round(rowWidget.x + tableWidth)) {
                if (this.insertRowSpannedWidget(rowWidget, viewer, left, i + 1)) {
                    continue;
                }
                this.insertEmptySplittedCellWidget(rowWidget, tableCollection, left, i + 1, previousRowIndex);
                continue;
            }
        }
        // tslint:disable-next-line:max-line-length
        // Special case: when the child widgets of row is equal to 0 then the splitted widgets in the viewer is added in the table row widgets. 
        if ((isNullOrUndefined(rowWidget.childWidgets) || rowWidget.childWidgets.length === 0) && viewer.splittedCellWidgets.length > 0) {
            for (let j = 0; j < viewer.splittedCellWidgets.length; j++) {
                let widget = viewer.splittedCellWidgets[j];
                if (Math.round(left) <= Math.round(widget.x - widget.margin.left)) {
                    if (this.insertRowSpannedWidget(rowWidget, viewer, left, j)) {
                        j--;
                        continue;
                    }
                    let count = rowWidget.childWidgets.length;
                    this.insertEmptySplittedCellWidget(rowWidget, tableCollection, left, j, previousRowIndex);
                    if (count < rowWidget.childWidgets.length) {
                        j--;
                        continue;
                    }
                }
                left += widget.margin.left + widget.width + widget.margin.right;
                if (j === rowWidget.childWidgets.length - 1 && Math.round(left) <
                    Math.round(rowWidget.x + tableWidth)) {
                    if (this.insertRowSpannedWidget(rowWidget, viewer, left, j + 1)) {
                        continue;
                    }
                    this.insertEmptySplittedCellWidget(rowWidget, tableCollection, left, j + 1, previousRowIndex);
                    continue;
                }
            }
        }
        if (viewer.splittedCellWidgets.length > 0) {
            viewer.splittedCellWidgets = [];
        }
    }
    /**
     * Inserts spanned row widget.
     * @param rowWidget
     * @param viewer
     * @param left
     * @param index
     */
    insertRowSpannedWidget(rowWidget, viewer, left, index) {
        let cellSpacing = 0;
        if (rowWidget.ownerTable.tableFormat.cellSpacing > 0) {
            cellSpacing = HelperMethods.convertPointToPixel(rowWidget.ownerTable.tableFormat.cellSpacing);
        }
        for (let i = 0; i < viewer.splittedCellWidgets.length; i++) {
            let splittedCell = viewer.splittedCellWidgets[i];
            if (Math.round(left) === Math.round(splittedCell.x - splittedCell.margin.left)) {
                rowWidget.childWidgets.splice(index, 0, splittedCell);
                splittedCell.containerWidget = rowWidget;
                //If the splitted cell location differs from expected location update the location of row child widgets.
                if (splittedCell.y !== rowWidget.y + splittedCell.margin.top + cellSpacing) {
                    this.updateChildLocationForRow(rowWidget.y, rowWidget);
                }
                viewer.splittedCellWidgets = [];
                return true;
            }
        }
        return false;
    }
    /**
     * Inserts empty splitted cell widgets.
     * @param rowWidget
     * @param left
     * @param index
     */
    // tslint:disable-next-line:max-line-length
    insertEmptySplittedCellWidget(currentRow, tableCollection, left, index, previousRowIndex) {
        let tableWidget = tableCollection[tableCollection.length - 1];
        for (let i = previousRowIndex; i >= 0; i--) {
            let rowWidget = tableWidget.childWidgets[i];
            let previousLeft = rowWidget.x;
            for (let j = 0; j < rowWidget.childWidgets.length; j++) {
                let rowSpan = 1;
                let cellWidget = rowWidget.childWidgets[j];
                if (Math.round(left) === Math.round(previousLeft)) {
                    rowSpan = (isNullOrUndefined(cellWidget) || isNullOrUndefined(cellWidget.cellFormat)) ? rowSpan :
                        cellWidget.cellFormat.rowSpan;
                    if (rowSpan > 1) {
                        let emptyCellWidget = this.createCellWidget(cellWidget);
                        currentRow.childWidgets.splice(index, 0, emptyCellWidget);
                        emptyCellWidget.containerWidget = currentRow;
                    }
                    return;
                }
                previousLeft += cellWidget.margin.left + cellWidget.width + cellWidget.margin.right;
            }
        }
    }
    /**
     * Gets spllited widget.
     * @param bottom
     * @param splitMinimalWidget
     * @param cellWidget
     */
    // tslint:disable-next-line:max-line-length
    getSplittedWidget(bottom, splitMinimalWidget, tableCollection, rowCollection, cellWidget) {
        let splittedWidget = undefined;
        if (cellWidget.y + cellWidget.height > bottom - cellWidget.margin.bottom) {
            for (let i = 0; i < cellWidget.childWidgets.length; i++) {
                if (cellWidget.childWidgets[i] instanceof ParagraphWidget) {
                    let paragraphWidget = cellWidget.childWidgets[i];
                    let splittedPara = this.getSplittedWidgetForPara(bottom - cellWidget.margin.bottom, paragraphWidget);
                    if (!isNullOrUndefined(splittedPara)) {
                        if (i === 0 && splittedPara === paragraphWidget) {
                            //Returns if the whole content of the cell does not fit in current page.
                            return cellWidget;
                        }
                        if (cellWidget.childWidgets.indexOf(splittedPara) !== -1) {
                            cellWidget.childWidgets.splice(cellWidget.childWidgets.indexOf(splittedPara), 1);
                            i--;
                        }
                        cellWidget.height -= splittedPara.height;
                        if (isNullOrUndefined(splittedWidget)) {
                            //Creates new widget, to hold the splitted contents.
                            splittedWidget = this.createCellWidget(cellWidget);
                        }
                        splittedWidget.height += splittedPara.height;
                        splittedWidget.childWidgets.push(splittedPara);
                        splittedPara.containerWidget = splittedWidget;
                    }
                }
                else {
                    let tableWidget = cellWidget.childWidgets[i];
                    let tableCol = [tableWidget];
                    //Check for nested table.
                    if (bottom - cellWidget.margin.bottom < tableWidget.y + tableWidget.height) {
                        let tableHeight = tableWidget.height;
                        // tslint:disable-next-line:max-line-length
                        let splittedTable = this.getSplittedWidgetForTable(bottom - cellWidget.margin.bottom, tableCol, tableWidget);
                        if (!isNullOrUndefined(splittedTable)) {
                            if (i === 0 && splittedTable === tableWidget) {
                                //Returns if the whole table does not fit in current page.
                                return cellWidget;
                            }
                            if (cellWidget.childWidgets.indexOf(splittedTable) !== -1) {
                                cellWidget.childWidgets.splice(cellWidget.childWidgets.indexOf(splittedTable), 1);
                                i--;
                                cellWidget.height -= splittedTable.height;
                            }
                            else {
                                cellWidget.height -= tableHeight - tableWidget.height;
                            }
                            if (isNullOrUndefined(splittedWidget)) {
                                //Creates new widget, to hold the splitted contents.
                                splittedWidget = this.createCellWidget(cellWidget);
                            }
                            splittedWidget.height += splittedTable.height;
                            splittedWidget.childWidgets.push(splittedTable);
                            splittedTable.containerWidget = splittedWidget;
                        }
                    }
                }
            }
        }
        if (isNullOrUndefined(splittedWidget) && splitMinimalWidget) {
            //Creates new widget, to hold the splitted contents.
            splittedWidget = this.createCellWidget(cellWidget);
        }
        return splittedWidget;
    }
    /**
     * Gets list level pattern
     * @param value
     * @private
     */
    getListLevelPattern(value) {
        switch (value) {
            case 0:
                return 'Arabic';
            case 1:
                return 'UpRoman';
            case 2:
                return 'LowRoman';
            case 3:
                return 'UpLetter';
            case 4:
                return 'LowLetter';
            case 5:
                return 'Ordinal';
            case 6:
                return 'Number';
            case 7:
                return 'OrdinalText';
            case 8:
                return 'LeadingZero';
            case 9:
                return 'Bullet';
            case 10:
                return 'FarEast';
            case 11:
                return 'Special';
            default:
                return 'None';
        }
    }
    /**
     * Creates cell widget.
     * @param cell
     */
    createCellWidget(cell) {
        let cellWidget = new TableCellWidget();
        cellWidget.cellFormat = cell.cellFormat;
        cellWidget.index = cell.index;
        cellWidget.rowIndex = cell.rowIndex;
        cellWidget.columnIndex = cell.columnIndex;
        cellWidget.containerWidget = cell.containerWidget;
        this.updateWidgetLocation(cell, cellWidget);
        cellWidget.margin = cell.margin;
        cellWidget.leftBorderWidth = HelperMethods.convertPointToPixel(cell.leftBorderWidth);
        cellWidget.rightBorderWidth = HelperMethods.convertPointToPixel(cell.rightBorderWidth);
        return cellWidget;
    }
    /**
     * Create Table Widget
     */
    createTableWidget(table) {
        let newTable = new TableWidget();
        if (table.header) {
            newTable.header = table.header;
            newTable.headerHeight = table.headerHeight;
        }
        newTable.index = table.index;
        newTable.tableFormat = table.tableFormat;
        newTable.tableHolder = table.tableHolder;
        newTable.isGridUpdated = table.isGridUpdated;
        return newTable;
    }
    /**
     * Gets splitted widget for paragraph.
     * @param bottom
     * @param paragraphWidget
     */
    getSplittedWidgetForPara(bottom, paragraphWidget) {
        let lineBottom = paragraphWidget.y;
        let splittedWidget = undefined;
        for (let i = 0; i < paragraphWidget.childWidgets.length; i++) {
            let lineWidget = paragraphWidget.childWidgets[i];
            if (bottom < lineBottom + lineWidget.height) {
                if (i === 0) {
                    if (lineWidget.paragraph.containerWidget instanceof TableCellWidget) {
                        //checks first line of the page is exceed the page height
                        if (lineWidget.paragraph.containerWidget.y === paragraphWidget.y) {
                            lineBottom += lineWidget.height;
                            continue;
                        }
                    }
                    splittedWidget = paragraphWidget;
                    break;
                }
                if (paragraphWidget.childWidgets.indexOf(lineWidget) !== -1) {
                    paragraphWidget.childWidgets.splice(paragraphWidget.childWidgets.indexOf(lineWidget), 1);
                    i--;
                }
                paragraphWidget.height -= lineWidget.height;
                if (isNullOrUndefined(splittedWidget)) {
                    //Creates new widget, to hold the splitted contents.
                    splittedWidget = new ParagraphWidget();
                    splittedWidget.characterFormat = paragraphWidget.characterFormat;
                    splittedWidget.paragraphFormat = paragraphWidget.paragraphFormat;
                    splittedWidget.index = paragraphWidget.index;
                    this.updateWidgetLocation(paragraphWidget, splittedWidget);
                    splittedWidget.height = lineWidget.height;
                }
                else {
                    splittedWidget.height += lineWidget.height;
                }
                splittedWidget.childWidgets.push(lineWidget);
                lineWidget.paragraph = splittedWidget;
            }
            lineBottom += lineWidget.height;
        }
        return splittedWidget;
    }
    /**
     * Gets splitted table widget.
     * @param bottom
     * @param tableWidget
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getSplittedWidgetForTable(bottom, tableCollection, tableWidget) {
        let rowBottom = tableWidget.y;
        let splittedWidget = undefined;
        for (let i = 0; i < tableWidget.childWidgets.length; i++) {
            let rowWidget = undefined;
            let childWidget = tableWidget.childWidgets[i];
            // if (childWidget instanceof TableRowWidget) {
            rowWidget = childWidget;
            // }
            let rowHeight = rowWidget.height;
            if (bottom < rowBottom + rowHeight || !isNullOrUndefined(splittedWidget)) {
                //ToDo: Check whether row included in vertical merge or AllowRowSplitbyPage is true, if so split row.
                //Checks if atleast first line fits in the client area.                
                let splittedRow = undefined;
                let allowRowBreakAcrossPages = true;
                if (!isNullOrUndefined(rowWidget) && !isNullOrUndefined(rowWidget.rowFormat)) {
                    allowRowBreakAcrossPages = rowWidget.rowFormat.allowBreakAcrossPages;
                }
                if (allowRowBreakAcrossPages) {
                    // tslint:disable-next-line:max-line-length
                    splittedRow = (isNullOrUndefined(splittedWidget) && this.isFirstLineFitForRow(bottom, rowWidget)) ? this.getSplittedWidgetForRow(bottom, tableCollection, [rowWidget], rowWidget) : rowWidget;
                }
                if (!isNullOrUndefined(splittedRow)) {
                    if (i === 0 && splittedRow === rowWidget) {
                        //Returns if the whole table does not fit in current page.
                        return tableWidget;
                    }
                    if (tableWidget.childWidgets.indexOf(splittedRow) !== -1) {
                        tableWidget.childWidgets.splice(tableWidget.childWidgets.indexOf(splittedRow), 1);
                        i--;
                        tableWidget.height -= splittedRow.height;
                    }
                    else {
                        tableWidget.height -= rowHeight - rowWidget.height;
                    }
                    if (isNullOrUndefined(splittedWidget)) {
                        //Creates new widget, to hold the splitted contents.
                        splittedWidget = this.createTableWidget(tableWidget);
                        this.updateWidgetLocation(tableWidget, splittedWidget);
                        splittedWidget.height = splittedRow.height;
                    }
                    else {
                        splittedWidget.height += splittedRow.height;
                    }
                    splittedWidget.childWidgets.push(splittedRow);
                    splittedRow.containerWidget = splittedWidget;
                }
            }
            rowBottom += rowWidget.height;
        }
        return splittedWidget;
    }
    /**
     * Checks whether first line fits for paragraph or not.
     * @param bottom
     * @param paraWidget
     */
    isFirstLineFitForPara(bottom, paraWidget) {
        let lineWidget = paraWidget.childWidgets[0];
        let cellwidget = lineWidget.paragraph.containerWidget;
        // let document: WordDocument = undefined;
        // if (!isNullOrUndefined(lineWidget.paragraph.currentNode) && !isNullOrUndefined(cellwidget.containerWidget)) {
        //     document = WordDocument.getDocumentOf(lineWidget.paragraph.currentNode);
        // }
        //checks first line of the page is exceed the page height
        if (this.viewer.isFirstLineFitInShiftWidgets) {
            if (this.viewer.clientActiveArea.y === this.viewer.clientArea.y && paraWidget.y + lineWidget.height >= bottom) {
                return true;
            }
        }
        else {
            // For nested tables,
            if (cellwidget.ownerTable.isInsideTable) {
                // Gets the container cell widgets, consider it as client area for the cell widget.
                let containerCellWidget = undefined;
                if (cellwidget.containerWidget instanceof TableRowWidget &&
                    cellwidget.containerWidget.containerWidget instanceof TableWidget
                    && cellwidget.containerWidget.containerWidget.containerWidget instanceof TableCellWidget) {
                    containerCellWidget = cellwidget.containerWidget.containerWidget.containerWidget;
                }
                if (!isNullOrUndefined(containerCellWidget) && cellwidget.containerWidget.y === containerCellWidget.y
                    && paraWidget.y + lineWidget.height >= bottom) {
                    return true;
                }
            }
            else if (cellwidget.containerWidget.y === this.viewer.clientArea.y && paraWidget.y + lineWidget.height >= bottom) {
                return true;
            }
        }
        return (paraWidget.y + lineWidget.height <= bottom);
    }
    /**
     * Checks whether first line fits for table or not.
     * @param bottom
     * @param tableWidget
     * @private
     */
    isFirstLineFitForTable(bottom, tableWidget) {
        let rowWidget = undefined;
        let isFit = false;
        let childWidget = tableWidget.childWidgets[0];
        // if (childWidget instanceof TableRowWidget) {
        rowWidget = childWidget;
        // }
        if (!isNullOrUndefined(rowWidget)) {
            isFit = this.isFirstLineFitForRow(bottom, rowWidget);
        }
        return isFit;
    }
    /**
     * Checks whether first line fits for row or not.
     * @param bottom
     * @param rowWidget
     */
    isFirstLineFitForRow(bottom, rowWidget) {
        for (let i = 0; i < rowWidget.childWidgets.length; i++) {
            let cellWidget = rowWidget.childWidgets[i];
            if (!this.isFirstLineFitForCell(bottom, cellWidget)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Checks whether first line fits for cell or not.
     * @param bottom
     * @param cellWidget
     */
    isFirstLineFitForCell(bottom, cellWidget) {
        if (cellWidget.childWidgets.length === 0) {
            return true;
        }
        if (cellWidget.childWidgets[0] instanceof ParagraphWidget) {
            let paraWidget = cellWidget.childWidgets[0];
            return this.isFirstLineFitForPara(bottom - cellWidget.margin.bottom, paraWidget);
        }
        else {
            let tableWidget = cellWidget.childWidgets[0];
            return this.isFirstLineFitForTable(bottom - cellWidget.margin.bottom, tableWidget);
        }
    }
    /**
     * Updates widget location.
     * @param widget
     * @param table
     */
    updateWidgetLocation(widget, table) {
        table.x = widget.x;
        table.y = widget.y;
        table.width = widget.width;
    }
    /**
     * Updates child location for table.
     * @param top
     * @param tableWidget
     * @private
     */
    updateChildLocationForTable(top, tableWidget) {
        for (let i = 0; i < tableWidget.childWidgets.length; i++) {
            let rowWidget = tableWidget.childWidgets[i];
            rowWidget.x = rowWidget.x;
            rowWidget.y = top;
            this.updateChildLocationForRow(top, rowWidget);
            top += rowWidget.height;
        }
    }
    /**
     * Updates child location for row.
     * @param top
     * @param rowWidget
     * @private
     */
    updateChildLocationForRow(top, rowWidget) {
        let spacing = 0;
        if (rowWidget.ownerTable.tableFormat.cellSpacing > 0) {
            spacing = HelperMethods.convertPointToPixel(rowWidget.ownerTable.tableFormat.cellSpacing);
        }
        for (let i = 0; i < rowWidget.childWidgets.length; i++) {
            let cellWidget = rowWidget.childWidgets[i];
            cellWidget.x = cellWidget.x;
            cellWidget.y = top + cellWidget.margin.top + spacing;
            this.updateChildLocationForCell(cellWidget.y, cellWidget);
        }
    }
    /**
     * Updates child location for cell.
     * @param top
     * @param cellWidget
     */
    updateChildLocationForCell(top, cellWidget) {
        for (let i = 0; i < cellWidget.childWidgets.length; i++) {
            cellWidget.childWidgets[i].x = cellWidget.childWidgets[i].x;
            cellWidget.childWidgets[i].y = top;
            if (cellWidget.childWidgets[i] instanceof TableWidget) {
                this.updateChildLocationForTable(top, cellWidget.childWidgets[i]);
            }
            top += cellWidget.childWidgets[i].height;
        }
    }
    /**
     * Updates cell vertical position.
     * @param cellWidget
     * @param isUpdateToTop
     * @param isInsideTable
     * @private
     */
    updateCellVerticalPosition(cellWidget, isUpdateToTop, isInsideTable) {
        if (cellWidget.ownerTable.containerWidget instanceof BodyWidget || isInsideTable) {
            let displacement = this.getDisplacement(cellWidget, isUpdateToTop);
            //Update Y position alone for the child widget of cell
            this.updateCellContentVerticalPosition(cellWidget, displacement, isUpdateToTop);
        }
    }
    /**
     * Updates cell content vertical position.
     * @param cellWidget
     * @param displacement
     * @param isUpdateToTop
     */
    updateCellContentVerticalPosition(cellWidget, displacement, isUpdateToTop) {
        if (displacement === 0) {
            return;
        }
        let location = cellWidget.y + displacement;
        for (let i = 0; i < cellWidget.childWidgets.length; i++) {
            if (cellWidget.childWidgets[i] instanceof ParagraphWidget) {
                cellWidget.childWidgets[i].y = location;
            }
            else {
                location = this.updateTableWidgetLocation(cellWidget.childWidgets[i], location, isUpdateToTop);
            }
            location = location + cellWidget.childWidgets[i].height;
        }
    }
    /**
     * Updates table widget location.
     * @param tableWidget
     * @param location
     * @param isUpdateToTop
     */
    updateTableWidgetLocation(tableWidget, location, isUpdateToTop) {
        tableWidget.y = location = location + tableWidget.topBorderWidth;
        let cellSpacing = 0;
        for (let i = 0; i < tableWidget.childWidgets.length; i++) {
            let rowWidget = tableWidget.childWidgets[i];
            rowWidget.y = location;
            for (let j = 0; j < rowWidget.childWidgets.length; j++) {
                let cellWidget = rowWidget.childWidgets[j];
                cellWidget.y = location + cellWidget.margin.top + cellSpacing;
                this.updateCellVerticalPosition(cellWidget, isUpdateToTop, true);
            }
            location = location + rowWidget.height;
        }
        return location;
    }
    /**
     * Gets displacement.
     * @param cellWidget
     * @param isUpdateToTop
     */
    getDisplacement(cellWidget, isUpdateToTop) {
        //Gets the height of row
        let rowHeight = 0;
        let rowWidget = cellWidget.containerWidget;
        let padding = cellWidget.margin.top + cellWidget.margin.bottom;
        if (!isNullOrUndefined(cellWidget.cellFormat) && cellWidget.cellFormat.rowSpan > 1) {
            rowHeight = cellWidget.height;
        }
        else {
            rowHeight = ((!isNullOrUndefined(rowWidget) ? rowWidget.height : 0) - padding);
        }
        //Gets the height of content within the cell
        let cellContentHeight = this.getCellContentHeight(cellWidget);
        //Displacement field holds the value which has reduced from rowHeight and cellContentHeight
        let displacement = 0;
        if (rowHeight > cellContentHeight) {
            displacement = rowHeight - cellContentHeight;
            if (cellWidget.cellFormat.verticalAlignment === 'Center') {
                displacement = displacement / 2;
            }
            else if ((cellWidget.cellFormat.verticalAlignment === 'Top' || isUpdateToTop)) {
                displacement = 0;
            }
        }
        return displacement;
    }
    /**
     * Gets cell content height.
     * @param cellWidget
     */
    getCellContentHeight(cellWidget) {
        if (isNullOrUndefined(cellWidget.childWidgets)) {
            return 0;
        }
        let contentHeight = 0;
        for (let i = 0; i < cellWidget.childWidgets.length; i++) {
            if (cellWidget.childWidgets[i] instanceof ParagraphWidget) {
                contentHeight += cellWidget.childWidgets[i].height;
            }
            else {
                contentHeight += cellWidget.childWidgets[i].height;
            }
        }
        return contentHeight;
    }
    /**
     * Gets table left borders.
     * @param borders
     * @private
     */
    getTableLeftBorder(borders) {
        if (!isNullOrUndefined(borders.left)) {
            return borders.left;
        }
        else {
            let border = new WBorder(borders);
            border.lineStyle = 'Single';
            border.lineWidth = 0.66;
            return border;
        }
    }
    /**
     * Gets table right border.
     * @param borders
     * @private
     */
    getTableRightBorder(borders) {
        if (!isNullOrUndefined(borders.right)) {
            return borders.right;
        }
        else {
            let border = new WBorder(borders);
            border.lineStyle = 'Single';
            border.lineWidth = 0.66;
            return border;
        }
    }
    /**
     * Get table top border.
     * @param borders
     * @private
     */
    getTableTopBorder(borders) {
        if (!isNullOrUndefined(borders.top)) {
            return borders.top;
        }
        else {
            let border = new WBorder(borders);
            border.lineStyle = 'Single';
            border.lineWidth = 0.66;
            return border;
        }
    }
    /**
     * Gets table bottom border.
     * @param borders
     * @private
     */
    getTableBottomBorder(borders) {
        if (!isNullOrUndefined(borders.bottom)) {
            return borders.bottom;
        }
        else {
            let border = new WBorder(borders);
            border.lineStyle = 'Single';
            border.lineWidth = 0.66;
            return border;
        }
    }
    /**
     * Get diagonal cell up border.
     * @param tableCell
     * @private
     */
    getCellDiagonalUpBorder(tableCell) {
        let diagonalUpBorder = undefined;
        let cellBorder = undefined;
        cellBorder = tableCell.cellFormat.borders;
        diagonalUpBorder = cellBorder.diagonalUp;
        return diagonalUpBorder;
    }
    /**
     * Gets diagonal cell down border
     * @param tableCell
     * @private
     */
    getCellDiagonalDownBorder(tableCell) {
        let diagonalDownBorder = undefined;
        let cellBorder = undefined;
        cellBorder = tableCell.cellFormat.borders;
        diagonalDownBorder = cellBorder.diagonalDown;
        return diagonalDownBorder;
    }
    /**
     * Gets table width.
     * @param table
     * @private
     */
    getTableWidth(table) {
        let width = 0;
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            let rowWidth = 0;
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                rowWidth += HelperMethods.convertPointToPixel(cell.cellFormat.cellWidth);
            }
            if (width < rowWidth) {
                width = rowWidth;
            }
        }
        return width;
    }
    //#region shifting
    /**
     * @private
     */
    layoutNextItemsBlock(blockAdv, viewer) {
        let sectionIndex = blockAdv.bodyWidget.sectionIndex;
        let block = blockAdv;
        let splittedWidget = block.getSplitWidgets();
        let nextBlock = splittedWidget[splittedWidget.length - 1].nextRenderedWidget;
        if (isNullOrUndefined(nextBlock) || this.viewer.blockToShift === block) {
            this.viewer.blockToShift = undefined;
        }
        let updateNextBlockList = true;
        while (nextBlock instanceof BlockWidget && nextBlock.bodyWidget.sectionIndex === sectionIndex) {
            let currentWidget = undefined;
            let blocks = block.getSplitWidgets();
            currentWidget = blocks[blocks.length - 1];
            // if (viewer.fieldEndParagraph === block) {
            //     //Sets field end paragraph to undefined, inorder to hold reLayouting with this paragraph.
            //     viewer.fieldEndParagraph = undefined;
            // }
            block = nextBlock;
            if (viewer.blockToShift === block) {
                viewer.blockToShift = undefined;
            }
            updateNextBlockList = false;
            let nextWidget = undefined;
            nextWidget = block.getSplitWidgets()[0];
            // tslint:disable-next-line:max-line-length
            if (viewer.fieldStacks.length === 0 && !isNullOrUndefined(nextWidget) && currentWidget.containerWidget === nextWidget.containerWidget
                && (HelperMethods.round(nextWidget.y, 2) === HelperMethods.round(currentWidget.y + currentWidget.height, 2))) {
                if (!isNullOrUndefined(viewer.blockToShift)) {
                    viewer.blockToShift = block;
                    break;
                }
                if (isNullOrUndefined(nextWidget.nextWidget)) {
                    break;
                }
            }
            updateNextBlockList = true;
            if (viewer.owner.isShiftingEnabled && viewer.fieldStacks.length === 0) {
                viewer.blockToShift = block;
                break;
            }
            else if (isNullOrUndefined(this.viewer.owner.editorModule) || !this.viewer.owner.editorModule.isInsertingTOC) {
                block = block.combineWidget(this.viewer);
                let paragraph;
                if (currentWidget.containerWidget !== block.containerWidget) {
                    if (!(currentWidget instanceof ParagraphWidget) ||
                        (currentWidget instanceof ParagraphWidget) && !currentWidget.isEndsWithPageBreak) {
                        // tslint:disable-next-line:max-line-length
                        this.updateContainerWidget(block, currentWidget.containerWidget, currentWidget.indexInOwner + 1, false);
                    }
                }
                if (block instanceof TableWidget) {
                    this.clearTableWidget(block, true, true);
                    block.isGridUpdated = false;
                    paragraph = this.viewer.selection.getFirstParagraphInFirstCell(block);
                }
                else {
                    paragraph = block;
                }
                if ((this.viewer.owner.isDocumentLoaded) && this.viewer.owner.editorModule) {
                    this.viewer.owner.editorModule.updateWholeListItems(paragraph);
                }
                viewer.updateClientAreaForBlock(block, true);
                this.viewer.layout.layoutBlock(block, 0);
                viewer.updateClientAreaForBlock(block, false);
            }
            splittedWidget = nextBlock.getSplitWidgets();
            nextBlock = splittedWidget[splittedWidget.length - 1].nextRenderedWidget;
        }
        if (!viewer.owner.isShiftingEnabled || this.viewer.blockToShift !== block) {
            this.viewer.owner.editorModule.updateListItemsTillEnd(block, updateNextBlockList);
        }
    }
    /**
     * @private
     */
    updateClientAreaForLine(paragraph, startLineWidget, elementIndex) {
        //Clears the line widget starting from current line.
        let top = this.viewer.selection.getTop(startLineWidget);
        let left = this.viewer.clientArea.x;
        this.viewer.cutFromTop(top);
        this.viewer.cutFromLeft(left);
    }
    /**
     * @private
     */
    getParentTable(block) {
        let widget = block;
        while (widget.containerWidget) {
            if (widget.containerWidget instanceof BlockContainer) {
                return widget;
            }
            widget = widget.containerWidget;
        }
        return undefined;
    }
    /**
     * @private
     */
    reLayoutParagraph(paragraphWidget, lineIndex, elementBoxIndex) {
        if (this.viewer.blockToShift === paragraphWidget) {
            this.layoutBodyWidgetCollection(paragraphWidget.index, paragraphWidget.containerWidget, paragraphWidget, false);
        }
        // let isElementMoved: boolean = elementBoxIndex > 0;
        if (paragraphWidget.isInsideTable) {
            this.reLayoutTable(paragraphWidget);
        }
        else {
            this.reLayoutLine(paragraphWidget, lineIndex);
        }
        if (paragraphWidget.bodyWidget instanceof HeaderFooterWidget &&
            paragraphWidget.bodyWidget.headerFooterType.indexOf('Footer') !== -1) {
            this.shiftFooterChildLocation(paragraphWidget.bodyWidget, this.viewer);
        }
    }
    /**
     * @private
     */
    reLayoutTable(block) {
        //Get Top level owner of block
        let table = this.getParentTable(block);
        //Combine splitted table in to single table
        // this.combineTableWidgets(this.viewer, table, undefined);
        //Get Parent table
        let currentTable = table.combineWidget(this.viewer);
        currentTable.isGridUpdated = false;
        currentTable.buildTableColumns();
        currentTable.isGridUpdated = true;
        let bodyWidget = currentTable.containerWidget;
        if (this.viewer.owner.enableHeaderAndFooter || block.isInHeaderFooter) {
            bodyWidget.height -= currentTable.height;
            // tslint:disable-next-line:max-line-length
            this.viewer.updateHCFClientAreaWithTop(table.bodyWidget.sectionFormat, this.viewer.isBlockInHeader(table), bodyWidget.page);
        }
        else {
            this.viewer.updateClientArea(bodyWidget.sectionFormat, bodyWidget.page);
        }
        //Clear Hieght for all the content 
        if (this.viewer.owner.isDocumentLoaded && this.viewer.owner.editorModule) {
            let block = this.viewer.selection.getFirstParagraphInFirstCell(currentTable);
            this.viewer.owner.editorModule.updateWholeListItems(block);
        }
        this.viewer.updateClientAreaForBlock(currentTable, true);
        //Remove border width
        currentTable.x -= currentTable.leftBorderWidth;
        currentTable.y -= currentTable.topBorderWidth;
        //Update Client area for current position
        this.viewer.cutFromTop(currentTable.y);
        this.clearTableWidget(currentTable, true, true);
        this.layoutBlock(currentTable, 0, true);
        this.viewer.updateClientAreaForBlock(currentTable, false);
        this.layoutNextItemsBlock(currentTable, this.viewer);
    }
    /**
     * @private
     */
    clearTableWidget(table, clearPosition, clearHeight) {
        table.height = 0;
        if (clearPosition) {
            table.y = 0;
            table.x = 0;
        }
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            this.clearRowWidget(row, clearPosition, clearHeight);
        }
    }
    /**
     * @private
     */
    clearRowWidget(row, clearPosition, clearHeight) {
        row.height = 0;
        if (clearPosition) {
            row.y = 0;
            row.x = 0;
        }
        for (let i = 0; i < row.childWidgets.length; i++) {
            let cell = row.childWidgets[i];
            this.clearCellWidget(cell, clearPosition, clearHeight);
        }
    }
    /**
     * @private
     */
    clearCellWidget(cell, clearPosition, clearHeight) {
        cell.height = 0;
        if (clearPosition) {
            cell.y = 0;
            cell.x = 0;
        }
        for (let i = 0; i < cell.childWidgets.length; i++) {
            let block = cell.childWidgets[i];
            if (block instanceof ParagraphWidget) {
                if (clearHeight) {
                    block.height = 0;
                }
            }
            else {
                this.clearTableWidget(block, clearPosition, clearHeight);
            }
        }
    }
    /**
     * @param blockIndex
     * @param bodyWidget
     * @param block
     * @private
     */
    // tslint:disable-next-line:max-line-length
    layoutBodyWidgetCollection(blockIndex, bodyWidget, block, shiftNextWidget) {
        if (!isNullOrUndefined(this.viewer.owner)
            && this.viewer.owner.isLayoutEnabled) {
            if (bodyWidget instanceof BlockContainer) {
                let curretBlock = this.checkAndGetBlock(bodyWidget, blockIndex);
                if (isNullOrUndefined(curretBlock)) {
                    return;
                }
                if (bodyWidget instanceof HeaderFooterWidget) {
                    // tslint:disable-next-line:max-line-length
                    this.viewer.updateHCFClientAreaWithTop(bodyWidget.sectionFormat, bodyWidget.headerFooterType.indexOf('Header') !== -1, bodyWidget.page);
                    curretBlock.containerWidget.height -= curretBlock.height;
                }
                else {
                    this.viewer.updateClientArea(bodyWidget.sectionFormat, bodyWidget.page);
                }
                if (blockIndex > 0) {
                    let prevWidget = curretBlock.getSplitWidgets()[0].previousRenderedWidget;
                    if (!(prevWidget instanceof ParagraphWidget) ||
                        (prevWidget instanceof ParagraphWidget) && !prevWidget.isEndsWithPageBreak) {
                        this.viewer.cutFromTop(prevWidget.y + prevWidget.height);
                        if (curretBlock.containerWidget !== prevWidget.containerWidget) {
                            // tslint:disable-next-line:max-line-length
                            this.updateContainerWidget(curretBlock, prevWidget.containerWidget, prevWidget.indexInOwner + 1, false);
                        }
                    }
                    else if (prevWidget instanceof ParagraphWidget && prevWidget.isEndsWithPageBreak &&
                        prevWidget.containerWidget === curretBlock.containerWidget) {
                        this.moveBlocksToNextPage(prevWidget);
                    }
                }
                let currentParagraph;
                curretBlock = curretBlock.combineWidget(this.viewer);
                if (curretBlock instanceof TableWidget) {
                    this.clearTableWidget(curretBlock, true, true);
                    curretBlock.isGridUpdated = false;
                    currentParagraph = this.viewer.selection.getFirstParagraphInFirstCell(curretBlock);
                }
                else {
                    currentParagraph = curretBlock;
                }
                if ((this.viewer.owner.isDocumentLoaded) && this.viewer.owner.editorModule) {
                    this.viewer.owner.editorModule.updateWholeListItems(currentParagraph);
                }
                this.viewer.updateClientAreaForBlock(curretBlock, true);
                this.viewer.layout.layoutBlock(curretBlock, 0, true);
                this.viewer.updateClientAreaForBlock(curretBlock, false);
                if (shiftNextWidget) {
                    this.shiftNextWidgets(curretBlock);
                }
                else {
                    this.layoutNextItemsBlock(curretBlock, this.viewer);
                }
            }
            else if (bodyWidget instanceof TableCellWidget) {
                let table = this.viewer.layout.getParentTable(bodyWidget.ownerTable.getSplitWidgets()[0]);
                this.reLayoutTable(bodyWidget.ownerTable);
                this.layoutNextItemsBlock(table, this.viewer);
            }
        }
    }
    checkAndGetBlock(containerWidget, blockIndex) {
        let sectionIndex = containerWidget.index;
        while (containerWidget && containerWidget.index === sectionIndex) {
            if (containerWidget.childWidgets.length > 0 && containerWidget.firstChild.index <= blockIndex &&
                containerWidget.lastChild.index >= blockIndex) {
                for (let i = 0; i < containerWidget.childWidgets.length; i++) {
                    let block = containerWidget.childWidgets[i];
                    if (block.index === blockIndex) {
                        return block;
                    }
                }
            }
            if (containerWidget instanceof BodyWidget) {
                containerWidget = containerWidget.nextRenderedWidget;
            }
            else {
                break;
            }
        }
        return undefined;
    }
    //#endregion
    //#region Table
    /**
     * Layouts table.
     * @param table
     * @private
     */
    layoutTable(table, startIndex) {
        if (!table.isGridUpdated) {
            table.buildTableColumns();
            table.isGridUpdated = true;
        }
        let tableView = [table];
        this.addTableWidget(this.viewer.clientActiveArea, tableView);
        this.viewer.updateClientAreaTopOrLeft(table, true);
        let isHeader = table.childWidgets[0].rowFormat.isHeader;
        if (table.childWidgets.length > 0) {
            table.header = isHeader;
            table.continueHeader = isHeader;
            table.headerHeight = 0;
        }
        let row = table.childWidgets[startIndex];
        while (row) {
            row = this.layoutRow(tableView, row);
            row = row.nextRow;
        }
        this.updateWidgetsToPage(tableView, [], table);
        return tableView[tableView.length - 1];
    }
    /**
     * Adds table widget.
     * @param area
     * @param table
     * @private
     */
    addTableWidget(area, table, create) {
        let tableWidget = table[table.length - 1];
        if (create) {
            tableWidget = this.createTableWidget(tableWidget);
            table.push(tableWidget);
        }
        tableWidget.width = area.width;
        tableWidget.x = area.x;
        tableWidget.y = area.y;
        //Update the table height of tableWidget when cell spacing has been defined. 
        if (tableWidget.tableFormat.cellSpacing > 0) {
            tableWidget.height = tableWidget.height + HelperMethods.convertPointToPixel(tableWidget.tableFormat.cellSpacing);
            // tslint:disable-next-line:max-line-length
            tableWidget.leftBorderWidth = HelperMethods.convertPointToPixel(this.getTableLeftBorder(tableWidget.tableFormat.borders).getLineWidth());
            tableWidget.rightBorderWidth = HelperMethods.convertPointToPixel(this.getTableRightBorder(tableWidget.tableFormat.borders).getLineWidth());
            // tslint:disable-next-line:max-line-length
            tableWidget.topBorderWidth = HelperMethods.convertPointToPixel(this.getTableTopBorder(tableWidget.tableFormat.borders).getLineWidth());
            tableWidget.bottomBorderWidth = HelperMethods.convertPointToPixel(this.getTableBottomBorder(tableWidget.tableFormat.borders).getLineWidth());
            tableWidget.x += tableWidget.leftBorderWidth;
            tableWidget.y += tableWidget.topBorderWidth;
            tableWidget.width -= tableWidget.leftBorderWidth;
            tableWidget.width -= tableWidget.rightBorderWidth;
            tableWidget.height += tableWidget.bottomBorderWidth;
        }
        return tableWidget;
    }
    /**
     * Updates widget to page.
     * @param table
     * @private
     */
    updateWidgetsToPage(tables, rows, table, endRowWidget) {
        let viewer = this.viewer;
        let tableWidget = tables[tables.length - 1];
        if (!table.isInsideTable) {
            this.updateHeightForTableWidget(tables, rows, tableWidget, endRowWidget);
            if (tableWidget.childWidgets.length > 0 && tableWidget.y !== tableWidget.childWidgets[0].y) {
                tableWidget.y = tableWidget.childWidgets[0].y;
            }
            // Need to update on this further
            //Adds the table widget to owner cell widget.
            // tslint:disable-next-line:max-line-length
            // (viewer.renderedElements.get(table.associatedCell)[viewer.renderedElements.get(table.associatedCell).length - 1] as TableCellWidget).childWidgets.push(tableWidget);
            // tableWidget.containerWidget = viewer.renderedElements.get(table.associatedCell)[viewer.renderedElements.get(table.associatedCell).length - 1] as BodyWidget;
            // tslint:disable-next-line:max-line-length
            // (viewer.renderedElements.get(table.associatedCell)[viewer.renderedElements.get(table.associatedCell).length - 1] as TableCellWidget).height = (viewer.renderedElements.get(table.associatedCell)[viewer.renderedElements.get(table.associatedCell).length - 1] as TableCellWidget).height + tableWidget.height;
        }
        if (table.tableFormat.cellSpacing > 0) {
            // tslint:disable-next-line:max-line-length
            if (tableWidget.y + tableWidget.height + HelperMethods.convertPointToPixel(table.tableFormat.cellSpacing) > viewer.clientArea.bottom && viewer instanceof PageLayoutViewer) {
                //update the table height when split to next page. Which is equivalent Ms Word Behaviour. 
                //In Ms Word if the Table Split to next page the bottom spacing of the table will be half of the current spacing.
                //And the Remaining space will be used in next page top of the table.
                tableWidget.height = tableWidget.height - HelperMethods.convertPointToPixel(table.tableFormat.cellSpacing) / 2;
            }
            //Update the current Y position of current clientactivearea.
            viewer.cutFromTop(tableWidget.y + tableWidget.height);
        }
        if (table.bodyWidget instanceof HeaderFooterWidget) {
            table.containerWidget.height += table.height;
            if (this.viewer.owner.enableHeaderAndFooter && table.bodyWidget.headerFooterType.indexOf('Footer') !== -1) {
                this.shiftFooterChildLocation(table.bodyWidget, this.viewer);
            }
        }
    }
    /**
     * Updates height for table widget.
     * @param viewer
     * @param tableWidget
     * @private
     */
    // tslint:disable-next-line:max-line-length
    updateHeightForTableWidget(tables, rows, tableWidget, endRowWidget) {
        for (let i = 0; i < tableWidget.childWidgets.length; i++) {
            let rowWidget = tableWidget.childWidgets[i];
            if (rowWidget === endRowWidget) {
                break;
            }
            this.updateHeightForRowWidget(this.viewer, true, tables, rows, rowWidget, true, endRowWidget);
        }
    }
    //#endregion
    //#region Row
    /**
     * Layouts table row.
     * @param row
     * @private
     */
    layoutRow(tableWidget, row) {
        let viewer = this.viewer;
        let rowWidgets = [row];
        let widget = this.addTableRowWidget(viewer.clientActiveArea, rowWidgets);
        viewer.updateClientAreaForRow(row, true);
        for (let i = 0; i < row.childWidgets.length; i++) {
            let cell = row.childWidgets[i];
            // tslint:disable-next-line:max-line-length
            this.layoutCell(cell, this.getMaxTopOrBottomCellMargin(row, 0) + row.topBorderWidth, this.getMaxTopOrBottomCellMargin(row, 1) + row.bottomBorderWidth, widget);
        }
        viewer.updateClientAreaForRow(row, false);
        let rows = [row];
        this.updateWidgetsToTable(tableWidget, rows, row);
        return rows[rows.length - 1];
    }
    /**
     * @param area
     * @param row
     */
    addTableRowWidget(area, row) {
        let rowWidget = row[row.length - 1];
        rowWidget.x = area.x + rowWidget.rowFormat.gridBeforeWidth;
        rowWidget.y = area.y;
        rowWidget.width = area.width;
        let borderWidth = 0;
        if (!isNullOrUndefined(rowWidget.ownerTable) && !isNullOrUndefined(rowWidget.ownerTable.tableFormat)
            && rowWidget.ownerTable.tableFormat.cellSpacing > 0) {
            rowWidget.height = rowWidget.height + HelperMethods.convertPointToPixel(rowWidget.ownerTable.tableFormat.cellSpacing);
            //Update the table height with the border width to layout the border when the cell spacing is defined..
            for (let j = 0; j < rowWidget.childWidgets.length; j++) {
                if (!isNullOrUndefined(rowWidget.childWidgets[j].cellFormat)
                    && !isNullOrUndefined(rowWidget.childWidgets[j].cellFormat.borders)) {
                    // tslint:disable-next-line:max-line-length
                    let width = TableCellWidget.getCellBottomBorder(rowWidget.childWidgets[j]).getLineWidth();
                    if (width > borderWidth) {
                        borderWidth = width;
                    }
                }
            }
            //Maximum border width is calculated and hold it in a variable to add with the padding of the cells.
            rowWidget.bottomBorderWidth = HelperMethods.convertPointToPixel(borderWidth);
            if (rowWidget.index > 0 && !isNullOrUndefined(rowWidget.previousWidget)) {
                let prevRow = rowWidget.previousWidget;
                borderWidth = 0;
                for (let i = 0; i < prevRow.childWidgets.length; i++) {
                    // tslint:disable-next-line:max-line-length
                    if (!isNullOrUndefined(prevRow.childWidgets[i].cellFormat) && !isNullOrUndefined(prevRow.childWidgets[i].cellFormat.borders)) {
                        let value = TableCellWidget.getCellBottomBorder(prevRow.childWidgets[i]).getLineWidth();
                        if (value > borderWidth) {
                            borderWidth = value;
                        }
                    }
                }
                //Maximum border width is calculated and hold it in a variable to add with the padding of the cells.
                rowWidget.topBorderWidth = HelperMethods.convertPointToPixel(borderWidth);
            }
        }
        if (!isNullOrUndefined(rowWidget.childWidgets)) {
            for (let i = 0; i < rowWidget.childWidgets.length; i++) {
                // tslint:disable-next-line:max-line-length
                if (!isNullOrUndefined(rowWidget.childWidgets[i].cellFormat) && !isNullOrUndefined(rowWidget.childWidgets[i].cellFormat.borders)) {
                    let value = TableCellWidget.getCellTopBorder(rowWidget.childWidgets[i]).getLineWidth();
                    if (value > borderWidth) {
                        borderWidth = value;
                    }
                }
            }
        }
        //Maximum border width is calculated and hold it in a variable to add with the padding of the cells.
        rowWidget.topBorderWidth = HelperMethods.convertPointToPixel(borderWidth);
        //Update the table height of tableWidget when cell spacing has been defined. 
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(rowWidget.ownerTable) && !isNullOrUndefined(rowWidget.ownerTable.tableFormat) && rowWidget.ownerTable.tableFormat.cellSpacing <= 0 && rowWidget.rowIndex === rowWidget.ownerTable.childWidgets.length - 1) {
            // Update the bottom width for last row .
            for (let i = 0; i < rowWidget.childWidgets.length; i++) {
                // tslint:disable-next-line:max-line-length
                if (!isNullOrUndefined(rowWidget.childWidgets[i].cellFormat) && !isNullOrUndefined(rowWidget.childWidgets[i].cellFormat.borders)) {
                    let value = TableCellWidget.getCellBottomBorder(rowWidget.childWidgets[i]).getLineWidth();
                    if (value > borderWidth) {
                        borderWidth = value;
                    }
                }
            }
            //Maximum border width is calculated and hold it in a variable to add with the padding of the cells.
            rowWidget.bottomBorderWidth = HelperMethods.convertPointToPixel(borderWidth);
        }
        //tableRowWidget.ownerWidget = owner;
        return rowWidget;
    }
    /**
     * Gets maximum top or bottom cell margin.
     * @param row
     * @param topOrBottom
     */
    getMaxTopOrBottomCellMargin(row, topOrBottom) {
        if (isNullOrUndefined(row.childWidgets)) {
            return 0;
        }
        let value = 0;
        for (let i = 0; i < row.childWidgets.length; i++) {
            if (row.childWidgets.length > 0) {
                let cellFormat = row.childWidgets[i].cellFormat;
                if (cellFormat.containsMargins()) {
                    if (topOrBottom === 0 && !isNullOrUndefined(cellFormat.topMargin) &&
                        HelperMethods.convertPointToPixel(cellFormat.topMargin) > value) {
                        value = HelperMethods.convertPointToPixel(cellFormat.topMargin);
                    }
                    else if (topOrBottom === 1 && !isNullOrUndefined(cellFormat.bottomMargin) &&
                        HelperMethods.convertPointToPixel(cellFormat.bottomMargin) > value) {
                        value = HelperMethods.convertPointToPixel(cellFormat.bottomMargin);
                    }
                }
                else {
                    let tableFormat = row.childWidgets[i].ownerTable.tableFormat;
                    if (topOrBottom === 0 && HelperMethods.convertPointToPixel(tableFormat.topMargin) > value) {
                        value = HelperMethods.convertPointToPixel(tableFormat.topMargin);
                    }
                    else if (topOrBottom === 1 && HelperMethods.convertPointToPixel(tableFormat.bottomMargin) > value) {
                        value = HelperMethods.convertPointToPixel(tableFormat.bottomMargin);
                    }
                }
            }
        }
        return value;
    }
    //#endregion Row
    //#region cell
    /**
     * Layouts cell
     * @param cell
     * @param maxCellMarginTop
     * @param maxCellMarginBottom
     */
    layoutCell(cell, maxCellMarginTop, maxCellMarginBottom, owner) {
        let viewer = this.viewer;
        this.addTableCellWidget(cell, viewer.clientActiveArea, maxCellMarginTop, maxCellMarginBottom);
        viewer.updateClientAreaForCell(cell, true);
        if (cell.childWidgets.length === 0) {
            let paragraphWidget = new ParagraphWidget();
            paragraphWidget.characterFormat = new WCharacterFormat();
            paragraphWidget.paragraphFormat = new WParagraphFormat();
            paragraphWidget.index = 0;
            let lineWidget = new LineWidget(undefined);
            paragraphWidget.childWidgets.push(lineWidget);
            cell.childWidgets.push(paragraphWidget);
        }
        for (let i = 0; i < cell.childWidgets.length; i++) {
            let block = cell.childWidgets[i];
            viewer.updateClientAreaForBlock(block, true);
            block.containerWidget = cell;
            this.layoutBlock(block, 0);
            viewer.updateClientAreaForBlock(block, false);
        }
        this.updateWidgetToRow(cell);
        viewer.updateClientAreaForCell(cell, false);
    }
    //endregion cell
    //#region Shifting
    /**
     * @private
     */
    shiftLayoutedItems() {
        if (isNullOrUndefined(this.viewer.blockToShift) || isNullOrUndefined(this.viewer.blockToShift.containerWidget)) {
            this.viewer.blockToShift = undefined;
            return;
        }
        let block = this.viewer.blockToShift;
        let sectionIndex = block.bodyWidget.index;
        this.reLayoutOrShiftWidgets(block, this.viewer);
        let updateNextBlockList = true;
        // If flow layout, then all sections are in single page. Hence need to update till last block of last section.
        // Todo: For page layout and section break continuous, need to handle the same.
        let splittedWidget = block.getSplitWidgets();
        let nextBlock = splittedWidget[splittedWidget.length - 1].nextRenderedWidget;
        while (nextBlock instanceof BlockWidget && nextBlock.bodyWidget.index === sectionIndex) {
            let currentWidget = undefined;
            let blocks = block.getSplitWidgets();
            currentWidget = blocks[blocks.length - 1];
            block = nextBlock;
            updateNextBlockList = false;
            let nextWidget = undefined;
            blocks = block.getSplitWidgets();
            if (block instanceof ParagraphWidget) {
                nextWidget = blocks[0];
            }
            else {
                if (block instanceof TableWidget) {
                    nextWidget = blocks[0];
                }
            }
            if (currentWidget.containerWidget === nextWidget.containerWidget
                && (HelperMethods.round(nextWidget.y, 2) === HelperMethods.round(this.viewer.clientActiveArea.y, 2)) &&
                isNullOrUndefined(nextWidget.nextWidget)) {
                break;
            }
            updateNextBlockList = true;
            this.reLayoutOrShiftWidgets(block, this.viewer);
            splittedWidget = block.getSplitWidgets();
            nextBlock = splittedWidget[splittedWidget.length - 1].nextRenderedWidget;
        }
        if (this.viewer.owner.editorModule) {
            this.viewer.owner.editorModule.updateListItemsTillEnd(block, updateNextBlockList);
        }
        this.viewer.blockToShift = undefined;
        let viewer = this.viewer;
        // if (viewer instanceof PageLayoutViewer) {
        viewer.removeEmptyPages();
        this.updateFieldElements();
        viewer.updateScrollBars();
        // }
    }
    /**
     * @private
     */
    updateFieldElements() {
        for (let i = 0; i < this.viewer.fields.length; i++) {
            let fieldBegin = this.viewer.fields[i];
            if (!isNullOrUndefined(this.viewer.selection)) {
                let fieldCode = this.viewer.selection.getFieldCode(fieldBegin);
                if (!isNullOrUndefined(fieldCode) && fieldCode.toLowerCase().match('numpages')) {
                    let textElement = fieldBegin.fieldSeparator.nextNode;
                    if (!isNullOrUndefined(textElement)) {
                        textElement.text = this.viewer.pages.length.toString();
                        let paragraph = fieldBegin.line.paragraph;
                        if (!isNullOrUndefined(paragraph.bodyWidget) && !isNullOrUndefined(paragraph.bodyWidget.page)) {
                            let lineIndex = paragraph.childWidgets.indexOf(fieldBegin.line);
                            let elementIndex = fieldBegin.line.children.indexOf(textElement);
                            this.reLayoutParagraph(paragraph, lineIndex, elementIndex);
                        }
                    }
                }
            }
        }
    }
    reLayoutOrShiftWidgets(blockAdv, viewer) {
        let block = blockAdv;
        // if (block instanceof ParagraphWidget) {
        //     reLayoutItems = viewer.renderedElements.get(block as ParagraphWidget).length === 0;
        // } else {
        //     reLayoutItems = viewer.renderedElements.get(block as TableWidget).length === 0;
        // }
        // if (reLayoutItems) {
        //     //Handle layouting the block.
        //     viewer.updateClientAreaForBlock(block, true);
        //     this.layoutMod.layoutBlock(block);
        //     viewer.updateClientAreaForBlock(block, false);
        // } else {
        //Handled to check client area and shift layouted widget.
        this.shiftWidgetsBlock(block, viewer);
        //Updates the list value of the rendered paragraph.
        if (this.viewer.owner.editorModule) {
            this.viewer.owner.editorModule.updateRenderedListItems(block);
        }
        // }
    }
    shiftWidgetsBlock(block, viewer) {
        if (block instanceof ParagraphWidget) {
            this.shiftWidgetsForPara(block, viewer);
        }
        else if (block instanceof TableWidget) {
            this.shiftWidgetsForTable(block, viewer);
        }
    }
    shiftWidgetsForPara(paragraph, viewer) {
        let prevBodyObj = this.getBodyWidgetOfPreviousBlock(paragraph, 0);
        let prevBodyWidget = prevBodyObj.bodyWidget;
        let index = prevBodyObj.index;
        let prevWidget = undefined;
        for (let i = 0; i < paragraph.getSplitWidgets().length; i++) {
            let widget = paragraph.getSplitWidgets()[i];
            if (!isNullOrUndefined(prevWidget)) {
                let isPageBreak = prevWidget.lastChild ? prevWidget.lastChild.isEndsWithPageBreak : false;
                this.shiftToPreviousWidget(widget, viewer, prevWidget, isPageBreak);
                if ((isNullOrUndefined(widget.childWidgets) || widget.childWidgets.length === 0) && !isPageBreak) {
                    i--;
                    continue;
                }
                prevWidget = undefined;
                if (prevBodyWidget !== widget.containerWidget) {
                    prevBodyWidget = widget.containerWidget;
                    if (isPageBreak) {
                        viewer.updateClientAreaByWidget(widget);
                    }
                }
            }
            if (this.isFitInClientArea(widget, viewer)) {
                //Check whether this widget is moved to previous container widget.
                prevWidget = widget;
                widget.y = viewer.clientActiveArea.y;
                viewer.cutFromTop(viewer.clientActiveArea.y + widget.height);
                //Moves the paragraph widget to previous body widget.
                if (!isNullOrUndefined(prevBodyWidget) && prevBodyWidget !== widget.containerWidget) {
                    index++;
                    if (!prevBodyWidget.lastChild.isEndsWithPageBreak) {
                        this.updateContainerWidget(widget, prevBodyWidget, index, true);
                    }
                }
                if (widget.isEndsWithPageBreak) {
                    let nextBodyWidget = this.createOrGetNextBodyWidget(prevBodyWidget, this.viewer);
                    nextBodyWidget = this.moveBlocksToNextPage(widget);
                    viewer.updateClientArea(nextBodyWidget.sectionFormat, nextBodyWidget.page);
                }
            }
            else {
                let previousBlock = widget.previousRenderedWidget;
                let isPageBreak = false;
                if (previousBlock instanceof ParagraphWidget && previousBlock.isEndsWithPageBreak) {
                    isPageBreak = true;
                }
                let isSplittedToNewPage = this.splitWidget(widget, viewer, prevBodyWidget, index + 1, isPageBreak);
                prevWidget = undefined;
                if (prevBodyWidget !== widget.containerWidget) {
                    prevBodyWidget = widget.containerWidget;
                    i--;
                }
                index = prevBodyWidget.childWidgets.indexOf(widget);
                if (isSplittedToNewPage) {
                    prevBodyWidget = paragraph.getSplitWidgets()[i + 1].containerWidget;
                }
            }
        }
    }
    /**
     * @private
     */
    shiftTableWidget(table, viewer) {
        let tables = [table];
        this.addTableWidget(this.viewer.clientActiveArea, tables);
        this.viewer.updateClientAreaTopOrLeft(table, true);
        let row = table.childWidgets[0];
        while (row) {
            row = this.shiftRowWidget(tables, row);
            row = row.nextRow;
        }
        this.updateWidgetsToPage(tables, [], table);
        return tables[tables.length - 1];
    }
    /**
     * @private
     */
    shiftRowWidget(tables, row) {
        let viewer = this.viewer;
        let rows = [row];
        let widget = this.addTableRowWidget(viewer.clientActiveArea, rows);
        viewer.updateClientAreaForRow(row, true);
        for (let i = 0; i < row.childWidgets.length; i++) {
            let cell = row.childWidgets[i];
            // tslint:disable-next-line:max-line-length
            this.shiftCellWidget(cell, this.getMaxTopOrBottomCellMargin(row, 0) + row.topBorderWidth, this.getMaxTopOrBottomCellMargin(row, 1) + row.bottomBorderWidth);
        }
        viewer.updateClientAreaForRow(row, false);
        this.updateWidgetsToTable(tables, rows, row);
        return rows[rows.length - 1];
    }
    /**
     * @private
     */
    shiftCellWidget(cell, maxCellMarginTop, maxCellMarginBottom) {
        let viewer = this.viewer;
        this.addTableCellWidget(cell, viewer.clientActiveArea, maxCellMarginTop, maxCellMarginBottom);
        viewer.updateClientAreaForCell(cell, true);
        for (let i = 0; i < cell.childWidgets.length; i++) {
            let block = cell.childWidgets[i];
            viewer.updateClientAreaForBlock(block, true);
            if (block instanceof ParagraphWidget) {
                this.shiftParagraphWidget(block);
            }
            else {
                this.shiftTableWidget(block, viewer);
            }
            viewer.updateClientAreaForBlock(block, false);
        }
        this.updateWidgetToRow(cell);
        viewer.updateClientAreaForCell(cell, false);
    }
    /**
     * @private
     */
    shiftParagraphWidget(paragraph) {
        this.addParagraphWidget(this.viewer.clientActiveArea, paragraph);
        this.viewer.cutFromTop(this.viewer.clientActiveArea.y + paragraph.height);
        this.updateWidgetToPage(this.viewer, paragraph);
    }
    shiftWidgetsForTable(table, viewer) {
        let prevObj = this.getBodyWidgetOfPreviousBlock(table, 0);
        let prevBodyWidget = prevObj.bodyWidget;
        let index = prevObj.index;
        let isPageBreak = prevBodyWidget.lastChild.lastChild.isEndsWithPageBreak;
        if (prevBodyWidget !== table.containerWidget) {
            if (!isPageBreak) {
                this.updateContainerWidget(table, prevBodyWidget, index + 1, true);
            }
            else {
                viewer.updateClientArea(table.bodyWidget.sectionFormat, table.bodyWidget.page);
            }
        }
        if (table.isInHeaderFooter) {
            table.containerWidget.height -= table.height;
        }
        table.y = this.viewer.clientActiveArea.y;
        this.updateVerticalPositionToTop(table, true);
        let combinedTable = table.combineWidget(this.viewer);
        this.viewer.layout.updateChildLocationForTable(combinedTable.y, combinedTable);
        this.clearTableWidget(combinedTable, true, false);
        this.shiftTableWidget(combinedTable, this.viewer);
        this.updateVerticalPositionToTop(table, false);
    }
    updateVerticalPositionToTop(table, isUpdateTop) {
        //Iterate the tableWidgets counts
        for (let i = 0; i < table.getSplitWidgets().length; i++) {
            let tablewidget = table.getSplitWidgets()[i];
            //Iterate the tableWidget child items
            for (let j = 0; j < tablewidget.childWidgets.length; j++) {
                let rowWidget = tablewidget.childWidgets[j];
                //Iterate the RowWidgets child items
                for (let k = 0; k < rowWidget.childWidgets.length; k++) {
                    let cellWidget = rowWidget.childWidgets[k];
                    //Iterate the RowWidgets child items
                    this.viewer.layout.updateCellVerticalPosition(cellWidget, isUpdateTop, false);
                }
            }
        }
    }
    // tslint:disable-next-line:max-line-length
    splitWidget(paragraphWidget, viewer, previousBodyWidget, index, isPageBreak) {
        let firstLine = paragraphWidget.childWidgets[0];
        let maxElementHeight = this.getMaxElementHeight(firstLine, viewer);
        let paragraphView = paragraphWidget.getSplitWidgets();
        let nextBodyWidget = paragraphWidget.containerWidget;
        if (viewer.clientActiveArea.height >= maxElementHeight && !isPageBreak) {
            let splittedWidget = undefined;
            let widgetIndex = paragraphView.indexOf(paragraphWidget);
            if (widgetIndex < (paragraphView.length - 1)) {
                splittedWidget = paragraphView[widgetIndex + 1];
                nextBodyWidget = splittedWidget.containerWidget;
            }
            else {
                splittedWidget = new ParagraphWidget();
                splittedWidget.index = paragraphWidget.index;
                splittedWidget.characterFormat = paragraphWidget.characterFormat;
                splittedWidget.paragraphFormat = paragraphWidget.paragraphFormat;
                splittedWidget.width = paragraphWidget.width;
                splittedWidget.x = paragraphWidget.x;
                splittedWidget.y = paragraphWidget.y;
                paragraphView.push(splittedWidget);
            }
            if (previousBodyWidget !== paragraphWidget.containerWidget) {
                this.updateContainerWidget(paragraphWidget, previousBodyWidget, index, true);
            }
            for (let i = paragraphWidget.childWidgets.length - 1; i > 0; i--) {
                if (this.isFitInClientArea(paragraphWidget, viewer)) {
                    break;
                }
                else {
                    let line = paragraphWidget.childWidgets[i];
                    //Moves the line widget to next widget.
                    this.updateParagraphWidgetInternal(line, splittedWidget, 0);
                }
            }
            if (isNullOrUndefined(splittedWidget.containerWidget) && splittedWidget.childWidgets.length > 0) {
                let y = viewer.clientActiveArea.y;
                // tslint:disable-next-line:max-line-length
                let clientArea = new Rect(viewer.clientArea.x, viewer.clientArea.y, viewer.clientArea.width, viewer.clientArea.height);
                let activeArea = new Rect(viewer.clientActiveArea.x, viewer.clientActiveArea.y, viewer.clientActiveArea.width, viewer.clientActiveArea.height);
                //Checks whether next node exists, else adds new page.
                nextBodyWidget = this.moveBlocksToNextPage(paragraphWidget);
                // nextBodyWidget = this.createOrGetNextBodyWidget(previousBodyWidget, viewer);
                nextBodyWidget.childWidgets.splice(0, 0, splittedWidget);
                nextBodyWidget.height += splittedWidget.height;
                splittedWidget.containerWidget = nextBodyWidget;
                if (nextBodyWidget.childWidgets.length === 1 && nextBodyWidget.firstChild instanceof ParagraphWidget &&
                    nextBodyWidget.firstChild.equals(paragraphWidget)) {
                    paragraphWidget.x = paragraphWidget.x;
                    paragraphWidget.y = y;
                    return true;
                }
                else {
                    //Resetting Client area
                    viewer.clientArea = clientArea;
                    viewer.clientActiveArea = activeArea;
                }
            }
        }
        else {
            nextBodyWidget = this.createOrGetNextBodyWidget(previousBodyWidget, this.viewer);
            if (paragraphWidget.containerWidget !== nextBodyWidget) {
                nextBodyWidget = this.moveBlocksToNextPage(paragraphWidget);
                this.updateContainerWidget(paragraphWidget, nextBodyWidget, 0, true);
            }
        }
        if (previousBodyWidget === paragraphWidget.containerWidget) {
            paragraphWidget.y = viewer.clientActiveArea.y;
            viewer.cutFromTop(viewer.clientActiveArea.y + paragraphWidget.height);
        }
        else {
            //Updates client area based on next body widget.
            viewer.updateClientArea(nextBodyWidget.sectionFormat, nextBodyWidget.page);
        }
        return false;
    }
    getMaxElementHeight(lineWidget, viewer) {
        let height = 0;
        // tslint:disable-next-line:max-line-length
        if (lineWidget.children.length === 0 || ((lineWidget.children.length === 1 && lineWidget.children[0] instanceof ListTextElementBox) || (lineWidget.children.length === 2 && lineWidget.children[0] instanceof ListTextElementBox && lineWidget.children[1] instanceof ListTextElementBox))) {
            let topMargin = 0;
            let bottomMargin = 0;
            height = viewer.selection.getParagraphMarkSize(lineWidget.paragraph, topMargin, bottomMargin).height;
            height += topMargin;
            if (lineWidget.children.length > 0) {
                let element = lineWidget.children[0];
                if (height < element.margin.top + element.height) {
                    height = element.margin.top + element.height;
                }
            }
        }
        else {
            for (let i = 0; i < lineWidget.children.length; i++) {
                let element = lineWidget.children[i];
                if (height < element.margin.top + element.height) {
                    height = element.margin.top + element.height;
                }
            }
        }
        return height;
    }
    createOrGetNextBodyWidget(bodyWidget, viewer) {
        let nextBodyWidget = undefined;
        let pageIndex = 0;
        pageIndex = viewer.pages.indexOf(bodyWidget.page);
        let page = undefined;
        let index = undefined;
        index = bodyWidget.index;
        if (pageIndex === viewer.pages.length - 1
            || viewer.pages[pageIndex + 1].sectionIndex !== index) {
            let currentWidget = new BodyWidget();
            currentWidget.sectionFormat = bodyWidget.sectionFormat;
            currentWidget.index = bodyWidget.index;
            page = viewer.createNewPage(currentWidget);
            if (viewer.pages[pageIndex + 1].sectionIndex !== index) {
                viewer.insertPage(pageIndex + 1, page);
            }
            nextBodyWidget = page.bodyWidgets[0];
        }
        else {
            page = viewer.pages[pageIndex + 1];
            nextBodyWidget = page.bodyWidgets[0];
        }
        return nextBodyWidget;
    }
    isFitInClientArea(paragraphWidget, viewer) {
        let lastLine = paragraphWidget.childWidgets[paragraphWidget.childWidgets.length - 1];
        let height = paragraphWidget.height;
        let maxElementHeight = this.getMaxElementHeight(lastLine, viewer);
        if (lastLine.height > maxElementHeight) {
            height -= lastLine.height - maxElementHeight;
        }
        return viewer.clientActiveArea.height >= height;
    }
    // tslint:disable-next-line:max-line-length
    shiftToPreviousWidget(paragraphWidget, viewer, previousWidget, isPageBreak) {
        for (let i = 0; i < paragraphWidget.childWidgets.length; i++) {
            let line = paragraphWidget.childWidgets[i];
            let maxElementHeight = this.getMaxElementHeight(line, viewer);
            if (viewer.clientActiveArea.height >= maxElementHeight && !isPageBreak) {
                //Moves the line widget to previous widget.
                this.updateParagraphWidgetInternal(line, previousWidget, previousWidget.childWidgets.length);
                i--;
                viewer.cutFromTop(viewer.clientActiveArea.y + line.height);
                if (isNullOrUndefined(paragraphWidget.childWidgets)) {
                    break;
                }
            }
            else {
                let bodyWidget = previousWidget.containerWidget;
                let nextBodyWidget = this.createOrGetNextBodyWidget(bodyWidget, viewer);
                if (paragraphWidget.containerWidget !== nextBodyWidget) {
                    nextBodyWidget = this.moveBlocksToNextPage(paragraphWidget);
                }
                if (bodyWidget !== nextBodyWidget) {
                    this.updateContainerWidget(paragraphWidget, nextBodyWidget, 0, true);
                }
                //Updates client area based on next page.
                viewer.updateClientArea(nextBodyWidget.sectionFormat, nextBodyWidget.page);
                break;
            }
        }
    }
    updateParagraphWidgetInternal(lineWidget, newParagraphWidget, index) {
        if (!isNullOrUndefined(lineWidget.paragraph)) {
            lineWidget.paragraph.childWidgets.splice(lineWidget.paragraph.childWidgets.indexOf(lineWidget), 1);
            lineWidget.paragraph.height -= lineWidget.height;
            if (!isNullOrUndefined(lineWidget.paragraph.containerWidget)) {
                lineWidget.paragraph.containerWidget.height -= lineWidget.height;
            }
            // tslint:disable-next-line:max-line-length
            if (isNullOrUndefined(lineWidget.paragraph.childWidgets) || lineWidget.paragraph.childWidgets.length === 0) {
                lineWidget.paragraph.destroyInternal(this.viewer);
            }
        }
        newParagraphWidget.childWidgets.splice(index, 0, lineWidget);
        lineWidget.paragraph = newParagraphWidget;
        newParagraphWidget.height += lineWidget.height;
        if (!isNullOrUndefined(newParagraphWidget.containerWidget)) {
            newParagraphWidget.containerWidget.height += lineWidget.height;
        }
    }
    shiftNextWidgets(blockAdv) {
        let block = blockAdv;
        while (block.nextWidget instanceof BlockWidget) {
            block = block.nextWidget;
            this.reLayoutOrShiftWidgets(block, this.viewer);
        }
    }
    /**
     * @private
     */
    updateContainerWidget(widget, bodyWidget, index, destroyAndScroll) {
        if (!isNullOrUndefined(widget.containerWidget)) {
            widget.containerWidget.childWidgets.splice(widget.containerWidget.childWidgets.indexOf(widget), 1);
            widget.containerWidget.height -= bodyWidget.height;
            if ((isNullOrUndefined(widget.containerWidget.childWidgets) || widget.containerWidget.childWidgets.length === 0)
                && widget.containerWidget instanceof BodyWidget && widget.containerWidget !== bodyWidget && destroyAndScroll) {
                let page = widget.containerWidget.page;
                if (this.viewer.pages[this.viewer.pages.length - 1] === page &&
                    this.viewer.visiblePages.indexOf(page) !== -1) {
                    this.viewer.scrollToBottom();
                }
                if (isNullOrUndefined(page.nextPage) || page.nextPage.bodyWidgets[0].index !== widget.containerWidget.index) {
                    widget.containerWidget.destroyInternal(this.viewer);
                }
            }
        }
        bodyWidget.childWidgets.splice(index, 0, widget);
        bodyWidget.height += bodyWidget.height;
        widget.containerWidget = bodyWidget;
    }
    getBodyWidgetOfPreviousBlock(block, index) {
        index = 0;
        let prevBodyWidget = undefined;
        let previousBlock = block.previousRenderedWidget;
        prevBodyWidget = (previousBlock && previousBlock.containerWidget.equals(block.containerWidget)) ?
            previousBlock.containerWidget : block.containerWidget;
        index = previousBlock && previousBlock.containerWidget.equals(block.containerWidget) ?
            prevBodyWidget.childWidgets.indexOf(previousBlock) : block.containerWidget.childWidgets.indexOf(block);
        return { bodyWidget: prevBodyWidget, index: index };
    }
    /**
     * @private
     */
    moveBlocksToNextPage(block) {
        let body = block.bodyWidget;
        let page = body.page;
        let pageIndex = page.index + 1;
        let nextPage = undefined;
        let nextBody = undefined;
        let insertPage = false;
        if (this.viewer.pages.length > pageIndex) {
            nextPage = this.viewer.pages[pageIndex];
            if (nextPage.bodyWidgets.length === 0 || !body.equals(nextPage.bodyWidgets[0])) {
                nextPage = undefined;
                insertPage = true;
            }
            else {
                nextBody = nextPage.bodyWidgets[0];
                this.viewer.updateClientArea(nextBody.sectionFormat, nextBody.page);
            }
        }
        if (isNullOrUndefined(nextPage)) {
            nextBody = this.createSplitBody(body);
            nextPage = this.viewer.createNewPage(nextBody, pageIndex);
            if (insertPage) {
                this.viewer.insertPage(pageIndex, nextPage);
            }
        }
        //tslint:disable :no-constant-condition
        do {
            let lastBlock = body.lastChild;
            if (block === lastBlock) {
                break;
            }
            body.childWidgets.pop();
            nextBody.childWidgets.splice(0, 0, lastBlock);
            lastBlock.containerWidget = nextBody;
            nextBody.height += lastBlock.height;
        } while (true);
        return nextBody;
    }
    createSplitBody(body) {
        let newBody = this.addBodyWidget(this.viewer.clientActiveArea);
        newBody.sectionFormat = body.sectionFormat;
        newBody.index = body.index;
        return newBody;
    }
    //endregion
    //#region Relayout Parargaph 
    /**
     * Relayout Paragraph from specified line widget
     * @param paragraph Paragraph to reLayout
     * @param lineIndex start line index to reLayout
     * @private
     */
    reLayoutLine(paragraph, lineIndex) {
        if (this.viewer.owner.isDocumentLoaded && this.viewer.owner.editorModule) {
            this.viewer.owner.editorModule.updateWholeListItems(paragraph);
        }
        let lineWidget;
        if (paragraph.paragraphFormat.listFormat && paragraph.paragraphFormat.listFormat.listId !== -1) {
            lineWidget = paragraph.getSplitWidgets()[0].firstChild;
        }
        else {
            lineWidget = paragraph.childWidgets[lineIndex];
        }
        let lineToLayout = lineWidget.previousLine;
        if (isNullOrUndefined(lineToLayout)) {
            lineToLayout = lineWidget;
        }
        let currentParagraph = lineToLayout.paragraph;
        let bodyWidget = paragraph.containerWidget;
        bodyWidget.height -= paragraph.height;
        if (this.viewer.owner.enableHeaderAndFooter || paragraph.isInHeaderFooter) {
            // tslint:disable-next-line:max-line-length
            this.viewer.updateHCFClientAreaWithTop(paragraph.bodyWidget.sectionFormat, this.viewer.isBlockInHeader(paragraph), bodyWidget.page);
        }
        else {
            this.viewer.updateClientArea(bodyWidget.sectionFormat, bodyWidget.page);
        }
        this.viewer.updateClientAreaForBlock(paragraph, true);
        if (lineToLayout.paragraph.isEmpty()) {
            this.viewer.cutFromTop(paragraph.y);
            this.layoutParagraph(paragraph, 0);
        }
        else {
            this.updateClientAreaForLine(lineToLayout.paragraph, lineToLayout, 0);
            this.layoutListItems(lineToLayout.paragraph);
            if (lineToLayout.isFirstLine() && !isNullOrUndefined(paragraph.paragraphFormat)) {
                let firstLineIndent = -HelperMethods.convertPointToPixel(paragraph.paragraphFormat.firstLineIndent);
                this.viewer.updateClientWidth(firstLineIndent);
            }
            do {
                lineToLayout = this.layoutLine(lineToLayout, 0);
                paragraph = lineToLayout.paragraph;
                lineToLayout = lineToLayout.nextLine;
            } while (lineToLayout);
            this.updateWidgetToPage(this.viewer, paragraph);
            this.viewer.updateClientAreaForBlock(paragraph, false);
        }
        this.layoutNextItemsBlock(paragraph, this.viewer);
    }
}

/**
 * @private
 */
class Renderer {
    constructor(viewer) {
        this.isPrinting = false;
        this.pageLeft = 0;
        this.pageTop = 0;
        this.isFieldCode = false;
        this.viewer = viewer;
    }
    /**
     * Gets page canvas.
     * @private
     */
    get pageCanvas() {
        if (this.isPrinting) {
            if (isNullOrUndefined(this.pageCanvasIn)) {
                this.pageCanvasIn = document.createElement('canvas');
                this.pageCanvasIn.getContext('2d').save();
            }
            return this.pageCanvasIn;
        }
        return isNullOrUndefined(this.viewer) ? undefined : this.viewer.containerCanvas;
    }
    /**
     * Gets selection canvas.
     */
    get selectionCanvas() {
        return isNullOrUndefined(this.viewer) ? undefined : this.viewer.selectionCanvas;
    }
    /**
     * Gets page context.
     */
    get pageContext() {
        return this.pageCanvas.getContext('2d');
    }
    /**
     * Gets selection context.
     */
    get selectionContext() {
        return this.selectionCanvas.getContext('2d');
    }
    /**
     * Gets the color.
     */
    getColor(color) {
        if (color.length > 0) {
            if (color[0] === '#') {
                if (color.length > 7) {
                    return color.substr(0, 7);
                }
            }
        }
        return color;
    }
    /**
     * Renders widgets.
     * @param {Page} page
     * @param {number} left
     * @param {number} top
     * @param {number} width
     * @param {number} height
     * @private
     */
    renderWidgets(page, left, top, width, height) {
        if (isNullOrUndefined(this.pageCanvas) || isNullOrUndefined(page)) {
            return;
        }
        this.pageContext.fillStyle = this.getColor(this.viewer.backgroundColor);
        this.pageContext.beginPath();
        this.pageContext.fillRect(left, top, width, height);
        this.pageContext.closePath();
        this.pageContext.strokeStyle = this.viewer.owner.pageOutline;
        this.pageContext.strokeRect(left, top, width, height);
        this.pageLeft = left;
        this.pageTop = top;
        if (this.isPrinting) {
            this.setPageSize(page);
        }
        else {
            this.pageContext.beginPath();
            this.pageContext.save();
            this.pageContext.rect(left, top, width, height);
            this.pageContext.clip();
        }
        if (page.headerWidget) {
            this.renderHFWidgets(page, page.headerWidget, width, true);
        }
        if (page.footerWidget) {
            this.renderHFWidgets(page, page.footerWidget, width, false);
        }
        for (let i = 0; i < page.bodyWidgets.length; i++) {
            this.render(page, page.bodyWidgets[i]);
        }
        if (this.viewer.owner.enableHeaderAndFooter && !this.isPrinting) {
            this.renderHeaderSeparator(page, this.pageLeft, this.pageTop, page.headerWidget);
        }
        this.pageLeft = 0;
        this.pageTop = 0;
        this.pageContext.restore();
    }
    /**
     * Sets page size.
     * @param {Page} page
     */
    setPageSize(page) {
        this.pageContext.clearRect(0, 0, this.pageCanvas.width, this.pageCanvas.height);
        this.selectionContext.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
        this.pageContext.restore();
        this.selectionContext.restore();
        let width = page.boundingRectangle.width;
        let height = page.boundingRectangle.height;
        let dpr = Math.max(1, window.devicePixelRatio || 1);
        if (this.pageCanvas.width !== width * dpr || this.pageCanvas.height !== height * dpr) {
            this.pageCanvas.height = height * dpr;
            this.pageCanvas.width = width * dpr;
            this.pageCanvas.style.height = height + 'px';
            this.pageCanvas.style.width = width + 'px';
            this.pageContext.globalAlpha = 1;
            this.pageContext.scale(dpr, dpr);
        }
    }
    /**
     * Renders header footer widget.
     * @param {Page} page
     * @param {HeaderFooterWidget} headFootWidget
     */
    renderHFWidgets(page, widget, width, isHeader) {
        this.pageContext.globalAlpha = this.viewer.owner.enableHeaderAndFooter ? 1 : 0.65;
        let cliped = false;
        if (isHeader) {
            let topMargin = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.topMargin);
            let widgetHeight = Math.max((widget.y + widget.height), topMargin);
            let headerFooterHeight = page.boundingRectangle.height / 100 * 40;
            if (widgetHeight > headerFooterHeight) {
                cliped = true;
                this.pageContext.beginPath();
                this.pageContext.save();
                this.pageContext.rect(this.pageLeft, this.pageTop, width, this.getScaledValue(headerFooterHeight));
                this.pageContext.clip();
            }
        }
        for (let i = 0; i < widget.childWidgets.length; i++) {
            let block = widget.childWidgets[i];
            this.renderWidget(page, block);
        }
        if (cliped) {
            this.pageContext.restore();
        }
        this.pageContext.globalAlpha = this.viewer.owner.enableHeaderAndFooter ? 0.65 : 1;
    }
    renderHeaderSeparator(page, left, top, widget) {
        //Header Widget
        let topMargin = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.topMargin);
        let y = this.getScaledValue(Math.max((widget.y + widget.height), topMargin));
        let pageWidth = this.getScaledValue(page.boundingRectangle.width);
        let ctx = this.pageContext;
        ctx.save();
        ctx.globalAlpha = 0.65;
        let headerFooterHeight = (this.getScaledValue(page.boundingRectangle.height) / 100) * 40;
        //Maximum header height limit       
        y = Math.min(y, headerFooterHeight);
        //Dash line Separator
        this.renderDashLine(ctx, left, top + y, pageWidth);
        let type = this.getHeaderFooterType(page, true);
        ctx.font = '9pt Arial';
        let width = ctx.measureText(type).width;
        this.renderHeaderFooterMark(ctx, left + 5, top + y, width + 10, 20);
        this.renderHeaderFooterMarkText(ctx, type, left + 10, y + top + 15);
        if (page.footerWidget) {
            //Footer Widget
            let footerDistance = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.footerDistance);
            // tslint:disable-next-line:max-line-length
            let footerHeight = this.getScaledValue(page.boundingRectangle.height) -
                this.getScaledValue(Math.max(page.footerWidget.height + footerDistance, HelperMethods.convertPointToPixel(page.footerWidget.sectionFormat.bottomMargin)));
            //Maximum footer height limit     
            footerHeight = Math.max((this.getScaledValue(page.boundingRectangle.height) - headerFooterHeight), footerHeight);
            this.renderDashLine(ctx, left, top + footerHeight, pageWidth);
            type = this.getHeaderFooterType(page, false);
            width = ctx.measureText(type).width;
            this.renderHeaderFooterMark(ctx, left + 5, top + footerHeight - 20, width + 10, 20);
            this.renderHeaderFooterMarkText(ctx, type, left + 10, top + footerHeight - 5);
            ctx.restore();
        }
    }
    getHeaderFooterType(page, isHeader) {
        let type;
        type = isHeader ? 'Header' : 'Footer';
        if (page.bodyWidgets[0].sectionFormat.differentFirstPage && this.viewer.pages.indexOf(page) === 0) {
            type = isHeader ? 'First Page Header' : 'First Page Footer';
        }
        else if (page.bodyWidgets[0].sectionFormat.differentOddAndEvenPages) {
            if ((this.viewer.pages.indexOf(page) + 1) % 2 === 0) {
                type = isHeader ? 'Even Page Header' : 'Even Page Footer';
            }
            else {
                type = isHeader ? 'Odd Page Header' : 'Odd Page Footer';
            }
        }
        return type;
    }
    renderDashLine(ctx, x, y, width) {
        ctx.beginPath();
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.setLineDash([6, 4]);
        ctx.moveTo(x, y);
        ctx.lineTo(x + width, y);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.closePath();
    }
    renderHeaderFooterMark(ctx, x, y, w, h) {
        ctx.beginPath();
        ctx.fillStyle = 'lightgray';
        ctx.fillRect(x, y, w, h);
        ctx.strokeStyle = 'black';
        ctx.strokeRect(x, y, w, h);
        ctx.closePath();
    }
    renderHeaderFooterMarkText(ctx, content, x, y) {
        ctx.beginPath();
        ctx.fillStyle = '#000000';
        ctx.textBaseline = 'alphabetic';
        ctx.fillText(content, x, y);
        ctx.closePath();
    }
    /**
     * Renders body widget.
     * @param {Page} page
     * @param {BodyWidget} bodyWidget
     */
    render(page, bodyWidget) {
        for (let i = 0; i < bodyWidget.childWidgets.length; i++) {
            let widget = bodyWidget.childWidgets[i];
            if (i === 0 && bodyWidget.childWidgets[0] instanceof TableWidget && page.repeatHeaderRowTableWidget) {
                // tslint:disable-next-line:max-line-length
                this.renderHeader(page, widget, this.viewer.layout.getHeader(bodyWidget.childWidgets[0]));
            }
            this.renderWidget(page, widget);
        }
    }
    /**
     * Renders block widget.
     * @param {Page} page
     * @param {Widget} widget
     */
    renderWidget(page, widget) {
        if (widget instanceof ParagraphWidget) {
            this.renderParagraphWidget(page, widget);
        }
        else {
            this.renderTableWidget(page, widget);
        }
    }
    /**
     * Renders header.
     * @param {Page} page
     * @param {TableWidget} widget
     * @param {WRow} header
     * @private
     */
    renderHeader(page, widget, header) {
        if (isNullOrUndefined(header)) {
            return;
        }
        let top = page.viewer.clientArea.y;
        for (let i = 0; i <= header.rowIndex; i++) {
            if (header.ownerTable.getSplitWidgets()[0].childWidgets.length === 0) {
                return;
            }
            let row = header.ownerTable.getSplitWidgets()[0].childWidgets[0];
            let headerWidget = row.clone();
            headerWidget.containerWidget = row.containerWidget;
            // tslint:disable-next-line:max-line-length
            page.viewer.updateClientAreaLocation(headerWidget, new Rect(page.viewer.clientArea.x, top, headerWidget.width, headerWidget.height));
            page.viewer.layout.updateChildLocationForRow(top, headerWidget);
            let cell = undefined;
            //Renders table cell outline rectangle - Border and background color.
            for (let j = 0; j < headerWidget.childWidgets.length; j++) {
                cell = headerWidget.childWidgets[j];
                this.renderTableCellWidget(page, cell);
            }
            top += headerWidget.height;
        }
        if (widget.y !== top) {
            //this.Location.Y = top;
            page.viewer.layout.updateChildLocationForTable(top, widget);
        }
    }
    /**
     * Renders paragraph widget.
     * @param {Page} page
     * @param {ParagraphWidget} paraWidget
     */
    renderParagraphWidget(page, paraWidget) {
        let top = paraWidget.y;
        let left = paraWidget.x;
        for (let i = 0; i < paraWidget.childWidgets.length; i++) {
            let widget = paraWidget.childWidgets[i];
            this.renderLine(widget, page, left, top);
            top += widget.height;
        }
    }
    /**
     * Renders table widget.
     * @param {Page} page
     * @param {TableWidget} tableWidget
     */
    renderTableWidget(page, tableWidget) {
        for (let i = 0; i < tableWidget.childWidgets.length; i++) {
            let widget = tableWidget.childWidgets[i];
            this.renderTableRowWidget(page, widget);
            if (tableWidget.tableFormat.cellSpacing > 0) {
                this.renderTableOutline(tableWidget);
            }
        }
    }
    /**
     * Renders table row widget.
     * @param {Page} page
     * @param {Widget} rowWidget
     */
    renderTableRowWidget(page, rowWidget) {
        for (let i = 0; i < rowWidget.childWidgets.length; i++) {
            let widget = rowWidget.childWidgets[i];
            this.renderTableCellWidget(page, widget);
        }
    }
    /**
     * Renders table cell widget.
     * @param {Page} page
     * @param {TableCellWidget} cellWidget
     */
    renderTableCellWidget(page, cellWidget) {
        if (!this.isPrinting) {
            if (this.getScaledValue(cellWidget.y, 2) + cellWidget.height * this.viewer.zoomFactor < 0 ||
                this.getScaledValue(cellWidget.y, 2) > this.viewer.visibleBounds.height) {
                return;
            }
        }
        if (!this.isPrinting && page.viewer.owner.selection && page.viewer.owner.selection.selectedWidgets.length > 0) {
            page.viewer.owner.selection.addSelectionHighlightTable(this.selectionContext, cellWidget);
        }
        this.renderTableCellOutline(page.viewer, cellWidget);
        for (let i = 0; i < cellWidget.childWidgets.length; i++) {
            let widget = cellWidget.childWidgets[i];
            let width = cellWidget.width + cellWidget.margin.left - cellWidget.leftBorderWidth;
            this.clipRect(cellWidget.x, cellWidget.y, this.getScaledValue(width), this.getScaledValue(cellWidget.height));
            this.renderWidget(page, widget);
            this.pageContext.restore();
        }
    }
    /**
     * Renders line widget.
     * @param {LineWidget} lineWidget
     * @param {Page} page
     * @param {number} left
     * @param {number} top
     */
    renderLine(lineWidget, page, left, top) {
        if (!this.isPrinting && page.viewer.owner.selection && page.viewer.owner.selection.selectedWidgets.length > 0) {
            page.viewer.owner.selection.addSelectionHighlight(this.selectionContext, lineWidget, top);
        }
        if (lineWidget.isFirstLine()) {
            left += HelperMethods.convertPointToPixel(lineWidget.paragraph.paragraphFormat.firstLineIndent);
        }
        if (this.viewer.owner.searchModule) {
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(page.viewer.owner.searchModule.searchHighlighters) && page.viewer.owner.searchModule.searchHighlighters.containsKey(lineWidget)) {
                let widgetInfo = page.viewer.owner.searchModule.searchHighlighters.get(lineWidget);
                for (let i = 0; i < widgetInfo.length; i++) {
                    this.pageContext.fillStyle = '#ffe97f';
                    // tslint:disable-next-line:max-line-length
                    this.pageContext.fillRect(this.getScaledValue(widgetInfo[i].left, 1), this.getScaledValue(top, 2), this.getScaledValue(widgetInfo[i].width), this.getScaledValue(lineWidget.height));
                }
            }
        }
        for (let i = 0; i < lineWidget.children.length; i++) {
            let elementBox = lineWidget.children[i];
            if (elementBox instanceof FieldElementBox || this.isFieldCode ||
                (elementBox.width === 0 && elementBox.height === 0)) {
                if (this.isFieldCode) {
                    elementBox.width = 0;
                }
                left += elementBox.width + elementBox.margin.left;
                this.toSkipFieldCode(elementBox);
                continue;
            }
            let underlineY = this.getUnderlineYPosition(lineWidget);
            if (!this.isPrinting) {
                if (this.getScaledValue(top + elementBox.margin.top, 2) + elementBox.height * this.viewer.zoomFactor < 0 ||
                    this.getScaledValue(top + elementBox.margin.top, 2) > this.viewer.visibleBounds.height) {
                    left += elementBox.width + elementBox.margin.left;
                    continue;
                }
            }
            if (elementBox instanceof ListTextElementBox) {
                this.renderListTextElementBox(elementBox, left, top, underlineY);
            }
            else if (elementBox instanceof ImageElementBox) {
                this.renderImageElementBox(elementBox, left, top, underlineY);
            }
            else {
                this.renderTextElementBox(elementBox, left, top, underlineY);
            }
            left += elementBox.width + elementBox.margin.left;
        }
    }
    toSkipFieldCode(element) {
        if (element instanceof FieldElementBox) {
            if (element.fieldType === 0) {
                if ((!isNullOrUndefined(element.fieldEnd) || element.hasFieldEnd)) {
                    this.isFieldCode = true;
                }
            }
            else if (element.fieldType === 2 || element.fieldType === 1) {
                this.isFieldCode = false;
            }
        }
    }
    /**
     * Gets underline y position.
     * @param {LineWidget} lineWidget
     */
    getUnderlineYPosition(lineWidget) {
        let height = 0;
        let lineHeight = 0;
        for (let i = 0; i < lineWidget.children.length; i++) {
            if (lineWidget.children[i] instanceof FieldElementBox ||
                (lineWidget.children[i].width === 0 && lineWidget.children[i].height === 0)) {
                continue;
            }
            if (height < lineWidget.children[i].height + lineWidget.children[i].margin.top) {
                height = lineWidget.children[i].margin.top + lineWidget.children[i].height;
                lineHeight = lineWidget.children[i].height / 20;
            }
        }
        return height - 2 * lineHeight;
    }
    /**
     * Renders list element box
     * @param {ListTextElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {number} underlineY
     */
    renderListTextElementBox(elementBox, left, top, underlineY) {
        let topMargin = elementBox.margin.top;
        let leftMargin = elementBox.margin.left;
        let format = elementBox.listLevel.characterFormat;
        let breakCharacterFormat = elementBox.line.paragraph.characterFormat;
        let color = format.fontColor === '#000000' ? breakCharacterFormat.fontColor : format.fontColor;
        this.pageContext.textBaseline = 'top';
        let bold = '';
        let italic = '';
        let fontFamily = format.fontFamily === 'Verdana' ? breakCharacterFormat.fontFamily : format.fontFamily;
        let fontSize = format.fontSize === 11 ? breakCharacterFormat.fontSize : format.fontSize;
        // tslint:disable-next-line:max-line-length
        let baselineAlignment = format.baselineAlignment === 'Normal' ? breakCharacterFormat.baselineAlignment : format.baselineAlignment;
        bold = format.bold ? 'bold' : breakCharacterFormat.bold ? 'bold' : '';
        italic = format.italic ? 'italic' : breakCharacterFormat.italic ? 'italic' : '';
        fontSize = fontSize === 0 ? 0.5 : fontSize / (baselineAlignment === 'Normal' ? 1 : 1.5);
        let strikethrough = format.strikethrough === 'None' ? breakCharacterFormat.strikethrough : format.strikethrough;
        let highlightColor = format.highlightColor === 'NoColor' ? breakCharacterFormat.highlightColor :
            format.highlightColor;
        if (highlightColor !== 'NoColor') {
            if (highlightColor.substring(0, 1) !== '#') {
                this.pageContext.fillStyle = HelperMethods.getHighlightColorCode(highlightColor);
            }
            else {
                this.pageContext.fillStyle = this.getColor(highlightColor);
            }
            // tslint:disable-next-line:max-line-length
            this.pageContext.fillRect(this.getScaledValue(left + leftMargin, 1), this.getScaledValue(top + topMargin, 2), this.getScaledValue(elementBox.width), this.getScaledValue(elementBox.height));
        }
        this.pageContext.font = bold + ' ' + italic + ' ' + fontSize * this.viewer.zoomFactor + 'pt' + ' ' + fontFamily;
        if (baselineAlignment === 'Subscript') {
            topMargin += elementBox.height - elementBox.height / 1.5;
        }
        this.pageContext.fillStyle = this.getColor(color);
        // tslint:disable-next-line:max-line-length
        this.pageContext.fillText(elementBox.text, this.getScaledValue(left + leftMargin, 1), this.getScaledValue(top + topMargin, 2), this.getScaledValue(elementBox.width));
        if (format.underline !== 'None' && !isNullOrUndefined(format.underline)) {
            this.renderUnderline(elementBox, left, top, underlineY, color, format.underline, baselineAlignment);
        }
        if (strikethrough !== 'None') {
            this.renderStrikeThrough(elementBox, left, top, format.strikethrough, color, baselineAlignment);
        }
    }
    /**
     * Renders text element box.
     * @param {TextElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {number} underlineY
     */
    // tslint:disable-next-line:max-line-length
    renderTextElementBox(elementBox, left, top, underlineY) {
        let isHeightType = false;
        let containerWidget = elementBox.line.paragraph.containerWidget;
        if (containerWidget instanceof TableCellWidget) {
            isHeightType = (containerWidget.ownerRow.rowFormat.heightType === 'Exactly');
        }
        let topMargin = elementBox.margin.top;
        let leftMargin = elementBox.margin.left;
        if (isHeightType) {
            // tslint:disable-next-line:max-line-length
            this.clipRect(containerWidget.x, containerWidget.y, this.getScaledValue(containerWidget.width), this.getScaledValue(containerWidget.height));
        }
        let format = elementBox.characterFormat;
        if (format.highlightColor !== 'NoColor') {
            if (format.highlightColor.substring(0, 1) !== '#') {
                this.pageContext.fillStyle = HelperMethods.getHighlightColorCode(format.highlightColor);
            }
            else {
                this.pageContext.fillStyle = this.getColor(format.highlightColor);
            }
            // tslint:disable-next-line:max-line-length
            this.pageContext.fillRect(this.getScaledValue(left + leftMargin, 1), this.getScaledValue(top + topMargin, 2), this.getScaledValue(elementBox.width), this.getScaledValue(elementBox.height));
        }
        let color = format.fontColor;
        this.pageContext.textBaseline = 'top';
        let bold = '';
        let italic = '';
        let fontSize = 11;
        bold = format.bold ? 'bold' : '';
        italic = format.italic ? 'italic' : '';
        fontSize = format.fontSize === 0 ? 0.5 : format.fontSize / (format.baselineAlignment === 'Normal' ? 1 : 1.5);
        this.pageContext.font = bold + ' ' + italic + ' ' + fontSize * this.viewer.zoomFactor + 'pt' + ' ' + format.fontFamily;
        if (format.baselineAlignment === 'Subscript') {
            topMargin += elementBox.height - elementBox.height / 1.5;
        }
        this.pageContext.fillStyle = this.getColor(color);
        let scaledWidth = this.getScaledValue(elementBox.width);
        let text = elementBox.text;
        // tslint:disable-next-line:max-line-length
        if (elementBox instanceof TabElementBox) {
            let tabElement = elementBox;
            if (tabElement.tabText === '' && !isNullOrUndefined(tabElement.tabLeader) && tabElement.tabLeader !== 'None') {
                text = this.getTabLeader(elementBox);
                tabElement.tabText = text;
            }
            else if (tabElement.tabText !== '') {
                text = tabElement.tabText;
            }
        }
        // tslint:disable-next-line:max-line-length
        this.pageContext.fillText(text, this.getScaledValue(left + leftMargin, 1), this.getScaledValue(top + topMargin, 2), scaledWidth);
        if (format.underline !== 'None' && !isNullOrUndefined(format.underline)) {
            // tslint:disable-next-line:max-line-length
            this.renderUnderline(elementBox, left, top, underlineY, color, format.underline, format.baselineAlignment);
        }
        if (format.strikethrough !== 'None' && !isNullOrUndefined(format.strikethrough)) {
            this.renderStrikeThrough(elementBox, left, top, format.strikethrough, color, format.baselineAlignment);
        }
        if (isHeightType) {
            this.pageContext.restore();
        }
    }
    /**
     * Returns tab leader
     */
    getTabLeader(elementBox) {
        let textWidth = 0;
        let tabString = this.getTabLeaderString(elementBox.tabLeader);
        let tabText = tabString;
        textWidth = this.viewer.textHelper.getWidth(tabText, elementBox.characterFormat);
        let count = Math.floor(elementBox.width / textWidth);
        for (let i = 0; i <= count; i++) {
            tabText += tabString;
        }
        return tabText.slice(0, -1);
    }
    /**
     * Returns tab leader string.
     */
    getTabLeaderString(tabLeader) {
        let tabString = '';
        switch (tabLeader) {
            case 'Dot':
                tabString = '.';
                break;
            case 'Hyphen':
                tabString = '-';
                break;
            case 'Underscore':
                tabString = '_';
                break;
        }
        return tabString;
    }
    /**
     * Clips the rectangle with specified position.
     * @param {number} xPos
     * @param {number} yPos
     * @param {number} width
     * @param {number} height
     */
    clipRect(xPos, yPos, width, height) {
        this.pageContext.beginPath();
        this.pageContext.save();
        this.pageContext.rect(this.getScaledValue(xPos, 1), this.getScaledValue(yPos, 2), width, height);
        this.pageContext.clip();
    }
    /**
     * Renders underline.
     * @param {ElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {number} underlineY
     * @param {string} color
     * @param {Underline} underline
     * @param {BaselineAlignment} baselineAlignment
     */
    // tslint:disable-next-line:max-line-length
    renderUnderline(elementBox, left, top, underlineY, color, underline, baselineAlignment) {
        let renderedHeight = elementBox.height / (baselineAlignment === 'Normal' ? 1 : 1.5);
        let topMargin = elementBox.margin.top;
        let underlineHeight = renderedHeight / 20;
        let y = 0;
        if (baselineAlignment === 'Subscript' || elementBox instanceof ListTextElementBox) {
            y = (renderedHeight - 2 * underlineHeight) + top;
            topMargin += elementBox.height - renderedHeight;
            y += topMargin > 0 ? topMargin : 0;
        }
        else {
            y = underlineY + top;
        }
        // tslint:disable-next-line:max-line-length
        this.pageContext.fillRect(this.getScaledValue(left + elementBox.margin.left, 1), this.getScaledValue(y, 2), this.getScaledValue(elementBox.width), this.getScaledValue(underlineHeight));
    }
    /**
     * Renders strike through.
     * @param {ElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {Strikethrough} strikethrough
     * @param {string} color
     * @param {BaselineAlignment} baselineAlignment
     */
    // tslint:disable-next-line:max-line-length
    renderStrikeThrough(elementBox, left, top, strikethrough, color, baselineAlignment) {
        let renderedHeight = elementBox.height / (baselineAlignment === 'Normal' ? 1 : 1.5);
        let topMargin = elementBox.margin.top;
        if (baselineAlignment === 'Subscript') {
            topMargin += elementBox.height - renderedHeight;
        }
        top += topMargin > 0 ? topMargin : 0;
        let lineHeight = renderedHeight / 20;
        let y = (renderedHeight / 2) + (0.5 * lineHeight);
        let lineCount = 0;
        if (strikethrough === 'DoubleStrike') {
            y -= lineHeight;
        }
        while (lineCount < (strikethrough === 'DoubleStrike' ? 2 : 1)) {
            lineCount++;
            // tslint:disable-next-line:max-line-length
            this.pageContext.fillRect(this.getScaledValue(left + elementBox.margin.left, 1), this.getScaledValue(y + top, 2), this.getScaledValue(elementBox.width), this.getScaledValue(lineHeight));
            y += 2 * lineHeight;
        }
    }
    /**
     * Renders image element box.
     * @param {ImageElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {number} underlineY
     */
    // tslint:disable-next-line:max-line-length
    renderImageElementBox(elementBox, left, top, underlineY) {
        let topMargin = elementBox.margin.top;
        let leftMargin = elementBox.margin.left;
        this.pageContext.textBaseline = 'top';
        let widgetWidth = 0;
        let isClipped = false;
        if (topMargin < 0 || elementBox.line.paragraph.width < elementBox.width) {
            let containerWid = elementBox.line.paragraph.containerWidget;
            // if (containerWid instanceof BodyWidget) {
            //     widgetWidth = containerWid.width + containerWid.x;
            // } else 
            if (containerWid instanceof TableCellWidget) {
                let leftIndent = 0;
                if (containerWid.childWidgets[0] instanceof ParagraphWidget) {
                    let paraAdv = containerWid.childWidgets[0];
                    leftIndent = paraAdv.paragraphFormat.leftIndent;
                }
                widgetWidth = containerWid.width + containerWid.margin.left - containerWid.leftBorderWidth - leftIndent;
                isClipped = true;
                // tslint:disable-next-line:max-line-length
                this.clipRect(left + leftMargin, top + topMargin, this.getScaledValue(widgetWidth), this.getScaledValue(containerWid.height));
            }
        }
        if (elementBox.isMetaFile) {
            /* tslint:disable:no-empty */
        }
        else {
            // tslint:disable-next-line:max-line-length
            this.pageContext.drawImage(elementBox.element, this.getScaledValue(left + leftMargin, 1), this.getScaledValue(top + topMargin, 2), this.getScaledValue(elementBox.width), this.getScaledValue(elementBox.height));
        }
        if (isClipped) {
            this.pageContext.restore();
        }
    }
    /**
     * Renders table outline.
     * @param {TableWidget} tableWidget
     */
    renderTableOutline(tableWidget) {
        let layout = new Layout(this.viewer);
        let table = tableWidget;
        tableWidget.width = this.viewer.layout.getTableWidth(table);
        let border = layout.getTableTopBorder(table.tableFormat.borders);
        let lineWidth = 0;
        //ToDo: Need to draw the borders based on the line style.
        // if (!isNullOrUndefined(border )) {
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
        // tslint:disable-next-line:max-line-length
        this.renderSingleBorder(border, tableWidget.x - tableWidget.margin.left - lineWidth / 2, tableWidget.y, tableWidget.x - tableWidget.margin.left - lineWidth / 2, tableWidget.y + tableWidget.height, lineWidth);
        // }
        border = layout.getTableTopBorder(table.tableFormat.borders);
        lineWidth = 0;
        // if (!isNullOrUndefined(border )) {
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
        // tslint:disable-next-line:max-line-length
        this.renderSingleBorder(border, tableWidget.x - tableWidget.margin.left - lineWidth, tableWidget.y - lineWidth / 2, tableWidget.x + tableWidget.width + lineWidth + tableWidget.margin.right, tableWidget.y - lineWidth / 2, lineWidth);
        // }
        border = layout.getTableRightBorder(table.tableFormat.borders);
        lineWidth = 0;
        // if (!isNullOrUndefined(border )) {
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
        // tslint:disable-next-line:max-line-length
        this.renderSingleBorder(border, tableWidget.x + tableWidget.width + tableWidget.margin.right + lineWidth / 2, tableWidget.y, tableWidget.x + tableWidget.width + tableWidget.margin.right + lineWidth / 2, tableWidget.y + tableWidget.height, lineWidth);
        // }
        border = layout.getTableBottomBorder(table.tableFormat.borders);
        lineWidth = 0;
        // if (!isNullOrUndefined(border )) {
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
        // tslint:disable-next-line:max-line-length
        this.renderSingleBorder(border, tableWidget.x - tableWidget.margin.left - lineWidth, tableWidget.y + tableWidget.height - lineWidth / 2, tableWidget.x + tableWidget.width + lineWidth + tableWidget.margin.right, tableWidget.y + tableWidget.height - lineWidth / 2, lineWidth);
        // }
    }
    /**
     * Renders table cell outline.
     * @param {LayoutViewer} viewer
     * @param {TableCellWidget} cellWidget
     */
    renderTableCellOutline(viewer, cellWidget) {
        let layout = viewer.layout;
        let borders = undefined;
        let tableCell = cellWidget;
        let cellTopMargin = 0;
        let cellBottomMargin = 0;
        let cellLeftMargin = 0;
        let cellRightMargin = 0;
        let height = 0;
        borders = tableCell.cellFormat.borders;
        if (cellWidget.containerWidget instanceof TableRowWidget) {
            cellBottomMargin = cellWidget.margin.bottom - cellWidget.containerWidget.bottomBorderWidth;
            cellTopMargin = cellWidget.margin.top - cellWidget.containerWidget.topBorderWidth;
        }
        cellLeftMargin = cellWidget.margin.left - cellWidget.leftBorderWidth;
        cellRightMargin = cellWidget.margin.right - cellWidget.rightBorderWidth;
        if (!isNullOrUndefined(tableCell.ownerRow) && tableCell.ownerRow.rowFormat.heightType === 'Exactly') {
            height = HelperMethods.convertPointToPixel(tableCell.ownerRow.rowFormat.height) + cellTopMargin + cellBottomMargin;
        }
        else {
            if (!isNullOrUndefined(tableCell.ownerRow) && [tableCell.ownerRow].length <= 1) {
                // tslint:disable-next-line:max-line-length
                height = Math.max(HelperMethods.convertPointToPixel(tableCell.ownerRow.rowFormat.height), cellWidget.height) + cellTopMargin + cellBottomMargin;
            }
            else {
                height = cellWidget.height + cellTopMargin + cellBottomMargin;
            }
        }
        this.renderCellBackground(height, cellWidget);
        let border = TableCellWidget.getCellLeftBorder(tableCell);
        let lineWidth = 0;
        // if (!isNullOrUndefined(border )) {       
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth()); //Renders the cell left border.
        // tslint:disable-next-line:max-line-length
        this.renderSingleBorder(border, cellWidget.x - cellLeftMargin - lineWidth, cellWidget.y - cellTopMargin, cellWidget.x - cellLeftMargin - lineWidth, cellWidget.y + cellWidget.height + cellBottomMargin, lineWidth);
        // }
        border = TableCellWidget.getCellTopBorder(tableCell);
        // if (!isNullOrUndefined(border )) { //Renders the cell top border.        
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
        // tslint:disable-next-line:max-line-length
        this.renderSingleBorder(border, cellWidget.x - cellWidget.margin.left, cellWidget.y - cellWidget.margin.top + lineWidth / 2, cellWidget.x + cellWidget.width + cellWidget.margin.right, cellWidget.y - cellWidget.margin.top + lineWidth / 2, lineWidth);
        // }
        if (tableCell.ownerTable.tableFormat.cellSpacing > 0 || tableCell.cellIndex === tableCell.ownerRow.childWidgets.length - 1) {
            border = TableCellWidget.getCellRightBorder(tableCell);
            // if (!isNullOrUndefined(border )) { //Renders the cell right border.           
            lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
            // tslint:disable-next-line:max-line-length
            this.renderSingleBorder(border, cellWidget.x + cellWidget.width + cellWidget.margin.right - lineWidth / 2, cellWidget.y - cellTopMargin, cellWidget.x + cellWidget.width + cellWidget.margin.right - lineWidth / 2, cellWidget.y + cellWidget.height + cellBottomMargin, lineWidth);
            // }
        }
        let nextRow = tableCell.ownerRow.nextWidget;
        //Specifies the next row is within the current table widget.
        //True means current row is not rendered at page end; Otherwise False.
        let nextRowIsInCurrentTableWidget = false;
        if (!isNullOrUndefined(nextRow)) {
            let nextRowWidget = undefined;
            // if (viewer.renderedElements.containsKey(nextRow) && viewer.renderedElements.get(nextRow).length > 0) {
            nextRowWidget = nextRow;
            // }
            if (nextRowWidget instanceof TableRowWidget) {
                // tslint:disable-next-line:max-line-length
                if (cellWidget.containerWidget instanceof TableRowWidget && cellWidget.containerWidget.containerWidget instanceof TableWidget) {
                    nextRowIsInCurrentTableWidget = cellWidget.containerWidget.containerWidget.childWidgets.indexOf(nextRowWidget) !== -1;
                }
            }
        }
        if (tableCell.ownerTable.tableFormat.cellSpacing > 0 || tableCell.ownerRow.rowIndex === tableCell.ownerTable.childWidgets.length - 1
            || (tableCell.cellFormat.rowSpan > 1
                && tableCell.ownerRow.rowIndex + tableCell.cellFormat.rowSpan === tableCell.ownerTable.childWidgets.length) ||
            !nextRowIsInCurrentTableWidget) {
            // tslint:disable-next-line:max-line-length
            border = (tableCell.cellFormat.rowSpan > 1 && tableCell.ownerRow.rowIndex + tableCell.cellFormat.rowSpan === tableCell.ownerTable.childWidgets.length) ?
                //true part for vertically merged cells specifically.
                tableCell.getBorderBasedOnPriority(tableCell.cellFormat.borders.bottom, TableCellWidget.getCellBottomBorder(tableCell))
                //false part for remaining cases that has been handled inside method. 
                : TableCellWidget.getCellBottomBorder(tableCell);
            // if (!isNullOrUndefined(border )) {
            //Renders the cell bottom border.
            lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
            // tslint:disable-next-line:max-line-length
            this.renderSingleBorder(border, cellWidget.x - cellWidget.margin.left, cellWidget.y + cellWidget.height + cellBottomMargin + lineWidth / 2, cellWidget.x + cellWidget.width + cellWidget.margin.right, cellWidget.y + cellWidget.height + cellBottomMargin + lineWidth / 2, lineWidth);
            // }
        }
        border = layout.getCellDiagonalUpBorder(tableCell);
        // if (!isNullOrUndefined(border )) {
        //Renders the cell diagonal up border.
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
        if (lineWidth > 0) {
            // tslint:disable-next-line:max-line-length
            this.renderSingleBorder(border, cellWidget.x - cellLeftMargin, cellWidget.y + cellWidget.height + cellBottomMargin, cellWidget.x + cellWidget.width + cellRightMargin, cellWidget.y - cellTopMargin, lineWidth);
            // }
        }
        border = layout.getCellDiagonalDownBorder(tableCell);
        // if (!isNullOrUndefined(border )) {
        //Renders the cell diagonal down border.
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
        if (lineWidth > 0) {
            // tslint:disable-next-line:max-line-length
            this.renderSingleBorder(border, cellWidget.x - cellLeftMargin, cellWidget.y - cellTopMargin, cellWidget.x + cellWidget.width + cellRightMargin, cellWidget.y + cellWidget.height + cellBottomMargin, lineWidth);
        }
        // }
    }
    /**
     * Renders cell background.
     * @param {number} height
     * @param {TableCellWidget} cellWidget
     */
    renderCellBackground(height, cellWidget) {
        let cellFormat = cellWidget.cellFormat;
        let bgColor = cellFormat.shading.backgroundColor === '#ffffff' ?
            cellWidget.ownerTable.tableFormat.shading.backgroundColor : cellFormat.shading.backgroundColor;
        this.pageContext.beginPath();
        if (bgColor !== 'empty') {
            this.pageContext.fillStyle = this.getColor(bgColor);
            let left = cellWidget.x - cellWidget.margin.left + cellWidget.leftBorderWidth;
            let top = cellWidget.y - HelperMethods.convertPointToPixel(cellWidget.topMargin);
            // tslint:disable-next-line:max-line-length
            let width = cellWidget.width + cellWidget.margin.left + cellWidget.margin.right - cellWidget.leftBorderWidth - cellWidget.rightBorderWidth;
            // tslint:disable-next-line:max-line-length
            this.pageContext.fillRect(this.getScaledValue(left, 1), this.getScaledValue(top, 2), this.getScaledValue(width), this.getScaledValue(height));
            this.pageContext.closePath();
        }
    }
    /**
     * Renders single border.
     * @param {WBorder} border
     * @param {number} startX
     * @param {number} startY
     * @param {number} endX
     * @param {number} endY
     * @param {number} lineWidth
     */
    // tslint:disable-next-line:max-line-length
    renderSingleBorder(border, startX, startY, endX, endY, lineWidth) {
        this.pageContext.beginPath();
        this.pageContext.moveTo(this.getScaledValue(startX, 1), this.getScaledValue(startY, 2));
        this.pageContext.lineTo(this.getScaledValue(endX, 1), this.getScaledValue(endY, 2));
        this.pageContext.lineWidth = this.getScaledValue(lineWidth);
        // set line color
        this.pageContext.strokeStyle = border.color;
        if (lineWidth > 0) {
            this.pageContext.stroke();
        }
        this.pageContext.closePath();
    }
    /**
     * Gets scaled value.
     * @param {number} value
     * @param {number} type
     * @private
     */
    getScaledValue(value, type) {
        if (this.isPrinting) {
            return value;
        }
        if (isNullOrUndefined(type)) {
            type = 0;
        }
        let x = value * this.viewer.zoomFactor;
        return x + (type === 1 ? this.pageLeft : (type === 2 ? this.pageTop : 0));
    }
    /**
     * Destroys the internal objects which is maintained.
     */
    destroy() {
        this.viewer = undefined;
        if (!isNullOrUndefined(this.pageCanvasIn)) {
            this.pageCanvasIn.innerHTML = '';
        }
        this.pageCanvasIn = undefined;
    }
}

/**
 * @private
 */
class TextHelper {
    get paragraphMark() {
        return '¶';
    }
    get lineBreakMark() {
        return '↲';
    }
    constructor(viewer) {
        this.owner = viewer;
        if (!isNullOrUndefined(viewer)) {
            this.context = viewer.containerContext;
        }
    }
    /**
     * @private
     */
    getParagraphMarkWidth(characterFormat) {
        return this.getWidth(this.paragraphMark, characterFormat);
    }
    /**
     * @private
     */
    getParagraphMarkSize(characterFormat) {
        // Gets the text element's width;
        let width = this.getWidth(this.paragraphMark, characterFormat);
        let textHelper = this.getHeight(characterFormat);
        return {
            'Width': width, 'Height': textHelper.Height, 'BaselineOffset': textHelper.BaselineOffset
        };
    }
    /**
     * @private
     */
    getTextSize(elementBox, characterFormat) {
        // Gets the text element's width;
        let textTrimEndWidth = 0;
        textTrimEndWidth = this.getWidth(elementBox.text, characterFormat);
        elementBox.width = textTrimEndWidth;
        // Calculate the text element's height and baseline offset.
        let textHelper = this.getHeight(characterFormat);
        elementBox.height = textHelper.Height;
        elementBox.baselineOffset = textHelper.BaselineOffset;
        if (elementBox.text[elementBox.text.length - 1] === ' ') {
            textTrimEndWidth = this.getWidth(HelperMethods.trimEnd(elementBox.text), characterFormat);
        }
        return textTrimEndWidth;
    }
    /**
     * @private
     */
    getHeight(characterFormat) {
        // Get character format property as  below predefined structure to make it easy to check and retrieve
        // Predefined static structure `[FontName];[FontSize];bold;italic` to maintain as key in the collection 
        let key = this.getFormatText(characterFormat);
        if (!isNullOrUndefined(this.owner.heightInfoCollection[key])) {
            return this.owner.heightInfoCollection[key];
        }
        let sizeInfo = this.getHeightInternal(characterFormat);
        this.owner.heightInfoCollection[key] = sizeInfo;
        return sizeInfo;
    }
    /**
     * @private
     */
    getFormatText(characterFormat) {
        let formatText = characterFormat.fontFamily.toLocaleLowerCase();
        formatText += ';' + characterFormat.fontSize;
        if (characterFormat.bold) {
            formatText += ';' + 'bold';
        }
        if (characterFormat.italic) {
            formatText += ';' + 'italic';
        }
        return formatText;
    }
    /**
     * @private
     */
    getHeightInternal(characterFormat) {
        let textHeight = 0;
        let baselineOffset = 0;
        let spanElement = document.createElement('span');
        spanElement.id = 'tempSpan';
        spanElement.style.whiteSpace = 'nowrap';
        spanElement.innerText = 'm';
        this.applyStyle(spanElement, characterFormat);
        let body = document.getElementsByTagName('body');
        let parentDiv = document.createElement('div');
        parentDiv.style.display = 'inline-block';
        let tempDiv = document.createElement('div');
        tempDiv.setAttribute('style', 'display:inline-block;width: 1px; height: 0px;vertical-align: baseline;');
        parentDiv.appendChild(spanElement);
        parentDiv.appendChild(tempDiv);
        document.body.appendChild(parentDiv);
        // Sets the text element's height.
        textHeight = spanElement.offsetHeight;
        // Calculate the text element's baseline offset.
        let textTopVal = spanElement.offsetTop;
        let tempDivTopVal = tempDiv.offsetTop;
        baselineOffset = tempDivTopVal - textTopVal;
        document.body.removeChild(parentDiv);
        return { 'Height': textHeight, 'BaselineOffset': baselineOffset };
    }
    /**
     * @private
     */
    measureTextExcludingSpaceAtEnd(text, characterFormat) {
        return this.getWidth(HelperMethods.trimEnd(text), characterFormat);
    }
    /**
     * @private
     */
    getWidth(text, characterFormat) {
        if (text.match('\v')) {
            text.replace('\v', this.lineBreakMark);
        }
        let bold = '';
        let italic = '';
        let fontFamily = '';
        let fontSize = characterFormat.fontSize;
        bold = characterFormat.bold ? 'bold' : '';
        italic = characterFormat.italic ? 'italic' : '';
        fontFamily = characterFormat.fontFamily;
        fontSize = fontSize === 0 ? 0.5 : fontSize / (characterFormat.baselineAlignment === 'Normal' ? 1 : 1.5);
        this.context.font = bold + ' ' + italic + ' ' + fontSize + 'pt' + ' ' + fontFamily;
        return this.context.measureText(text).width;
    }
    /**
     * @private
     */
    applyStyle(spanElement, characterFormat) {
        if (!isNullOrUndefined(spanElement) && !isNullOrUndefined(characterFormat)) {
            if (characterFormat.fontFamily !== '') {
                spanElement.style.fontFamily = characterFormat.fontFamily;
            }
            let fontSize = characterFormat.fontSize;
            if (fontSize <= 0.5) {
                fontSize = 0.5;
            }
            spanElement.style.fontSize = fontSize.toString() + 'pt';
            if (characterFormat.bold) {
                spanElement.style.fontWeight = 'bold';
            }
            if (characterFormat.italic) {
                spanElement.style.fontStyle = 'italic';
            }
        }
    }
    /**
     * @private
     */
    measureText(text, characterFormat) {
        // Gets the text element's width;
        let width = this.getWidth(text, characterFormat);
        let textHelper = this.getHeight(characterFormat);
        return {
            'Width': width, 'Height': textHelper.Height, 'BaselineOffset': textHelper.BaselineOffset
        };
    }
    /**
     * @private
     */
    updateTextSize(elementBox, paragraph) {
        let format = new WCharacterFormat(undefined);
        let listCharacterFormat = elementBox.listLevel.characterFormat;
        let breakCharacterFormat = paragraph.characterFormat;
        format.fontSize = listCharacterFormat.fontSize === 11 ? breakCharacterFormat.fontSize : listCharacterFormat.fontSize;
        format.fontFamily = listCharacterFormat.fontFamily === 'Verdana' ? breakCharacterFormat.fontFamily
            : listCharacterFormat.fontFamily;
        let bold = '';
        let italic = '';
        let baselineAlignment = listCharacterFormat.baselineAlignment === 'Normal' ?
            breakCharacterFormat.baselineAlignment : listCharacterFormat.baselineAlignment;
        bold = listCharacterFormat.bold ? 'bold' : breakCharacterFormat.bold ? 'bold' : '';
        italic = listCharacterFormat.italic ? 'italic' : breakCharacterFormat.italic ? 'italic' : '';
        format.baselineAlignment = baselineAlignment;
        if (bold) {
            format.bold = true;
        }
        if (italic) {
            format.italic = true;
        }
        elementBox.width = this.getWidth(elementBox.text, format);
        // Calculate the text element's height and baseline offset.
        let textHelper = this.getHeight(format);
        elementBox.height = textHelper.Height;
        elementBox.baselineOffset = textHelper.BaselineOffset;
    }
    destroy() {
        this.owner = undefined;
        this.context = undefined;
    }
}

/**
 * @private
 */
class Zoom {
    constructor(viewer) {
        this.onMouseWheelInternal = (event) => {
            if (event.ctrlKey === true) {
                event.preventDefault();
                let pageX = event.pageX - this.viewer.viewerContainer.offsetLeft;
                if (pageX < this.viewer.pageContainer.offsetWidth) {
                    let wheel = navigator.userAgent.match('Firefox') ? event.detail < 0 : event.wheelDelta > 0;
                    let zoomFactor = this.viewer.zoomFactor;
                    if (wheel) {
                        if (zoomFactor <= 4.90) {
                            zoomFactor += .10;
                        }
                        else {
                            zoomFactor = 5.00;
                        }
                    }
                    else {
                        if (zoomFactor >= .20) {
                            zoomFactor -= .10;
                        }
                        else {
                            zoomFactor = 0.10;
                        }
                    }
                    this.viewer.zoomFactor = zoomFactor;
                }
            }
        };
        this.viewer = viewer;
    }
    setZoomFactor(value) {
        this.onZoomFactorChanged();
        if (!isNullOrUndefined(this.viewer.selection)) {
            this.viewer.selection.updateCaretPosition();
        }
        this.viewer.updateTouchMarkPosition();
        if (!isNullOrUndefined(this.viewer.owner.imageResizerModule)) {
            this.viewer.owner.imageResizerModule.updateImageResizerPosition();
        }
        this.viewer.owner.fireZoomFactorChange();
    }
    //Zoom Implementation Starts
    onZoomFactorChanged() {
        if (this.viewer.zoomFactor > 5) {
            this.viewer.zoomFactor = 5;
        }
        else if (this.viewer.zoomFactor < 0.1) {
            this.viewer.zoomFactor = 0.1;
        }
        this.zoom();
    }
    zoom() {
        let viewer = this.viewer;
        viewer.clearContent();
        viewer.handleZoom();
        viewer.updateFocus();
    }
}

/**
 * @private
 */
class LayoutViewer {
    //#endregion
    constructor(owner) {
        /**
         * @private
         */
        this.textWrap = true;
        /**
         * @private
         */
        this.currentPage = undefined;
        this.selectionStartPageIn = undefined;
        this.selectionEndPageIn = undefined;
        /**
         * @private
         */
        this.fieldStacks = [];
        /**
         * @private
         */
        this.splittedCellWidgets = [];
        /**
         * @private
         */
        this.tableLefts = [];
        this.tapCount = 0;
        this.timer = -1;
        this.isTimerStarted = false;
        /**
         * @private
         */
        this.isFirstLineFitInShiftWidgets = false;
        /**
         * @private
         */
        this.preZoomFactor = 0;
        /**
         * @private
         */
        this.preDifference = -1;
        /**
         * @private
         */
        this.fieldEndParagraph = undefined;
        /**
         * @private
         */
        this.fieldToLayout = undefined;
        /**
         * @private
         */
        this.backgroundColor = '#FFFFFF';
        /**
         * @private
         */
        this.containerTop = 0;
        /**
         * @private
         */
        this.containerLeft = 0;
        // Event 
        /**
         * @private
         */
        this.isMouseDown = false;
        /**
         * @private
         */
        this.isSelectionChangedOnMouseMoved = false;
        /**
         * @private
         */
        this.isControlPressed = false;
        /**
         * @private
         */
        this.isTouchInput = false;
        /**
         * @private
         */
        this.useTouchSelectionMark = false;
        /**
         * @private
         */
        this.touchDownOnSelectionMark = 0;
        /**
         * @private
         */
        this.isCompositionStart = false;
        /**
         * @private
         */
        this.isCompositionUpdated = false;
        /**
         * @private
         */
        this.isCompositionCanceled = false;
        /**
         * @private
         */
        this.isCompositionEnd = false;
        /**
         * @private
         */
        this.prefix = '';
        /**
         * @private
         */
        this.suffix = '';
        /**
         * @private
         */
        this.fields = [];
        /**
         * @private
         */
        this.heightInfoCollection = {};
        /**
         * @private
         */
        this.defaultTabWidth = 36;
        /**
         * @private
         */
        this.lists = [];
        /**
         * @private
         */
        this.abstractLists = [];
        /**
         * @private
         */
        this.styles = new WStyles();
        /**
         * @private
         */
        this.preDefinedStyles = undefined;
        /**
         * @private
         */
        this.isRowOrCellResizing = false;
        this.isMouseDownInFooterRegion = false;
        this.pageFitTypeIn = 'None';
        /**
         * @private
         */
        this.fieldCollection = [];
        /**
         * @private
         */
        this.isPageField = false;
        /**
         * @private
         */
        this.mouseDownOffset = new Point(0, 0);
        this.zoomFactorInternal = 1;
        /**
         * Fires when composition starts.
         * @private
         */
        this.compositionStart = (event) => {
            event.preventDefault();
            this.isCompositionStart = true;
        };
        /**
         * Fires on every input during composition.
         * @private
         */
        this.compositionUpdated = (event) => {
            event.preventDefault();
            this.isCompositionUpdated = true;
        };
        /**
         * Fires when user selects a character/word and finalizes the input.
         * @private
         */
        this.compositionEnd = (event) => {
            event.preventDefault();
            this.isCompositionUpdated = false;
            this.isCompositionEnd = true;
        };
        // tslint:disable:no-any 
        this.onImageResizer = (args) => {
            if (!isNullOrUndefined(this.owner.imageResizerModule) && this.owner.imageResizerModule.isImageResizerVisible
                && this.owner.imageResizerModule.isImageResizing) {
                if (args instanceof MouseEvent) {
                    this.onMouseUpInternal(args);
                }
                else if (args instanceof TouchEvent) {
                    this.onTouchUpInternal(args);
                }
            }
        };
        // tslint:enable:no-any 
        this.onKeyPressInternal = (event) => {
            event.preventDefault();
            if (!isNullOrUndefined(this.selection)) {
                let key = event.keyCode || event.charCode;
                let char = '';
                if (key) {
                    char = String.fromCharCode(key);
                }
                else if (event.key) {
                    char = event.key;
                }
                // tslint:disable-next-line:max-line-length
                if (char !== 'Spacebar' && char !== '\r' && char !== '\b' && char !== '\u001B' && !this.owner.isReadOnlyMode && event.ctrlKey === false) {
                    this.owner.editorModule.handleTextInput(char);
                }
                else if (char === 'Spacebar') {
                    this.owner.editorModule.handleTextInput(' ');
                }
            }
        };
        this.onTextInputInternal = (event) => {
            if (!this.owner.isReadOnlyMode) {
                this.owner.editorModule.onTextInputInternal(event);
            }
            else {
                this.editableDiv.innerText = '';
            }
        };
        /**
         * Fired on paste.
         * @param {ClipboardEvent} event
         * @private
         */
        this.onPaste = (event) => {
            if (!this.owner.isReadOnlyMode) {
                this.owner.editorModule.pasteInternal(event);
            }
            this.editableDiv.innerText = '';
            event.preventDefault();
        };
        /**
         * Fires when editable div loses focus.
         * @private
         */
        this.onFocusOut = () => {
            if (!isNullOrUndefined(this.selection)) {
                if (this.owner.contextMenuModule && this.owner.contextMenuModule.contextMenuInstance &&
                    this.owner.contextMenuModule.contextMenuInstance.element.style.display === 'block') {
                    return;
                }
                this.selection.hideCaret();
            }
        };
        /**
         * Updates focus to editor area.
         * @private
         */
        this.updateFocus = () => {
            if (this.selection) {
                this.editableDiv.focus();
                this.selection.showCaret();
            }
        };
        /**
         * Fires on scrolling.
         */
        this.scrollHandler = () => {
            this.clearContent();
            this.updateScrollBars();
            let vtHeight = this.containerTop + this.visibleBounds.height;
            if (vtHeight > this.pageContainer.offsetHeight) {
                this.viewerContainer.scrollTop = this.containerTop - (vtHeight - this.pageContainer.offsetHeight);
            }
            let viewer = this;
            if (viewer instanceof PageLayoutViewer && !isNullOrUndefined(this.owner)) {
                this.owner.fireViewChange();
            }
        };
        /**
         * Fires when the window gets resized.
         * @private
         */
        this.onWindowResize = () => {
            let viewer = this;
            let resizeTimer;
            /* tslint:disable:align */
            resizeTimer = setTimeout(() => {
                if (!isNullOrUndefined(viewer.owner) && !isNullOrUndefined(this.owner.element)) {
                    viewer.updateViewerSizeInternal(document.getElementById(viewer.owner.element.id));
                    viewer.updateScrollBars();
                    if (!isNullOrUndefined(this.selection)) {
                        this.selection.updateCaretPosition();
                    }
                    viewer.updateTouchMarkPosition();
                    if (viewer.owner.contextMenuModule && viewer.owner.contextMenuModule.contextMenuInstance) {
                        viewer.owner.contextMenuModule.contextMenuInstance.close();
                    }
                    if (resizeTimer) {
                        clearTimeout(resizeTimer);
                    }
                }
            }, 100);
        };
        /**
         * @private
         */
        this.onContextMenu = (event) => {
            if (this.owner.contextMenuModule) {
                this.owner.contextMenuModule.onContextMenuInternal(event);
            }
        };
        /**
         * Called on mouse down.
         * @param {MouseEvent} event
         * @private
         */
        this.onMouseDownInternal = (event) => {
            if (this.isTouchInput || event.offsetX > (this.visibleBounds.width - (this.visibleBounds.width - this.viewerContainer.clientWidth))
                || event.offsetY > (this.visibleBounds.height - (this.visibleBounds.height - this.viewerContainer.clientHeight))) {
                return;
            }
            if (!isNullOrUndefined(this.selection)) {
                this.updateCursor(event);
                // tslint:disable-next-line:max-line-length
                if (this.isLeftButtonPressed(event) && !this.owner.isReadOnlyMode && this.owner.enableImageResizerMode && !isNullOrUndefined(this.owner.imageResizerModule.selectedResizeElement)) {
                    this.owner.imageResizerModule.isImageResizing = true;
                }
                event.preventDefault();
                if (!this.isTouchInput) {
                    this.selection.hideCaret();
                }
                let cursorPoint = new Point(event.offsetX, event.offsetY);
                let touchPoint = this.findFocusedPage(cursorPoint, true);
                this.mouseDownOffset.x = touchPoint.x;
                this.mouseDownOffset.y = touchPoint.y;
                // tslint:disable-next-line:max-line-length
                this.isMouseDownInFooterRegion = this.selection.isCursorInsidePageRect(cursorPoint, this.currentPage) && this.selection.isCursorInFooterRegion(cursorPoint, this.currentPage);
                this.isSelectionChangedOnMouseMoved = false;
                if (!this.owner.isReadOnlyMode && (this.owner.editorModule.tableResize.isInCellResizerArea(touchPoint) ||
                    this.owner.editorModule.tableResize.isInRowResizerArea(touchPoint))) {
                    this.selection.hideCaret();
                    this.isMouseDown = true;
                    this.isSelectionChangedOnMouseMoved = false;
                    if (this.isLeftButtonPressed(event)) {
                        this.owner.editorModule.tableResize.startingPoint.x = touchPoint.x;
                        this.owner.editorModule.tableResize.startingPoint.y = touchPoint.y;
                        this.owner.editorModule.tableResize.handleResize(touchPoint);
                    }
                    return;
                }
                if (event.ctrlKey) {
                    this.isControlPressed = true;
                }
                if (this.owner.selection.isEmpty) {
                    this.useTouchSelectionMark = false;
                }
                if (event.which === 3 && !this.owner.selection.isEmpty
                    && this.selection.checkCursorIsInSelection(this.getLineWidget(touchPoint), touchPoint)) {
                    event.preventDefault();
                    return;
                }
                this.isTouchInput = false;
                this.isMouseDown = true;
                this.updateFocus();
                /* tslint:disable:align */
                this.timer = setTimeout(() => {
                    this.tapCount++;
                    if (this.tapCount === 4) {
                        this.tapCount = 1;
                    }
                }, 200);
            }
        };
        /**
         * Called on mouse move.
         * @param {MouseEvent} event
         * @private
         */
        this.onMouseMoveInternal = (event) => {
            event.preventDefault();
            if (!isNullOrUndefined(this.selection)) {
                //For image Resizing
                if (!this.owner.isReadOnlyMode && this.owner.enableImageResizerMode
                    && this.owner.imageResizerModule.isImageResizing) {
                    if (!this.owner.imageResizerModule.isImageMoveToNextPage) {
                        this.owner.imageResizerModule.handleImageResizingOnMouse(event);
                    }
                    return;
                }
                let cursorPoint = new Point(event.offsetX, event.offsetY);
                let touchPoint = this.findFocusedPage(cursorPoint, !this.owner.enableHeaderAndFooter);
                if (this.isMouseDown) {
                    if (!isNullOrUndefined(this.currentPage)) {
                        let xPosition = touchPoint.x;
                        let yPosition = touchPoint.y;
                        if (!this.owner.isReadOnlyMode && this.isRowOrCellResizing) {
                            this.owner.editorModule.tableResize.handleResizing(touchPoint);
                        }
                        else {
                            if (!(this.isTouchInput || this.isSelectionChangedOnMouseMoved || this.touchDownOnSelectionMark > 0)) {
                                this.updateTextPositionForSelection(touchPoint, 1);
                            }
                            if (this.isLeftButtonPressed(event)) {
                                event.preventDefault();
                                let touchY = yPosition;
                                let textPosition = this.owner.selection.end;
                                let touchPoint = new Point(xPosition, touchY);
                                if (!this.owner.enableImageResizerMode || !this.owner.imageResizerModule.isImageResizerVisible) {
                                    this.owner.selection.moveTextPosition(touchPoint, textPosition);
                                }
                                this.isSelectionChangedOnMouseMoved = true;
                            }
                        }
                    }
                    this.selection.checkForCursorVisibility();
                }
                if (!this.isRowOrCellResizing && !this.isSelectionChangedOnMouseMoved) {
                    this.updateCursor(event);
                }
                if (this.isRowOrCellResizing) {
                    this.selection.hideCaret();
                }
            }
        };
        /**
         * Fired on double tap.
         * @param {MouseEvent} event
         * @private
         */
        this.onDoubleTap = (event) => {
            if (!isNullOrUndefined(this.selection)) {
                this.isTouchInput = false;
                let cursorPoint = new Point(event.offsetX, event.offsetY);
                if (this.selection.checkAndEnableHeaderFooter(cursorPoint, this.findFocusedPage(cursorPoint, true))) {
                    return;
                }
                // tslint:disable-next-line:max-line-length
                if (this.selection.isEmpty && !isNullOrUndefined(this.currentPage) && !isNullOrUndefined(this.owner.selection.start)) {
                    this.owner.selection.selectCurrentWord();
                    this.selection.checkForCursorVisibility();
                    this.tapCount = 2;
                }
            }
        };
        /**
         * Called on mouse up.
         * @param {MouseEvent} event
         * @private
         */
        this.onMouseUpInternal = (event) => {
            event.preventDefault();
            this.isListTextSelected = false;
            let cursorPoint = new Point(event.offsetX, event.offsetY);
            let touchPoint = this.findFocusedPage(cursorPoint, true);
            if (!isNullOrUndefined(this.selection)) {
                let tapCount = 1;
                if (!Browser.isIE) {
                    if (event.detail > 2) {
                        tapCount = event.detail;
                    }
                }
                else {
                    tapCount = this.tapCount;
                }
                if (this.isRowOrCellResizing) {
                    this.owner.editorModule.tableResize.updateResizingHistory(touchPoint);
                }
                if (this.isMouseDown && !this.isSelectionChangedOnMouseMoved
                    && !isNullOrUndefined(this.currentPage) && !isNullOrUndefined(this.owner.selection.start)
                    && (!this.owner.enableImageResizerMode || !this.owner.imageResizerModule.isImageResizing)) {
                    if (this.touchDownOnSelectionMark === 0 && !this.isRowOrCellResizing) {
                        this.updateTextPositionForSelection(touchPoint, tapCount);
                        if (Browser.isIE && tapCount === 2) {
                            this.selection.checkAndEnableHeaderFooter(cursorPoint, touchPoint);
                        }
                    }
                    this.selection.checkForCursorVisibility();
                }
                if (!isNullOrUndefined(this.currentPage) && !isNullOrUndefined(this.owner.selection.start)
                    && (this.owner.selection.isEmpty || this.owner.selection.isImageSelected) &&
                    (((event.ctrlKey && this.owner.useCtrlClickToFollowHyperlink ||
                        !this.owner.useCtrlClickToFollowHyperlink) && this.isLeftButtonPressed(event) === true))) {
                    this.selection.navigateHyperLinkOnEvent(touchPoint, false);
                }
                if (!this.owner.isReadOnlyMode && this.isSelectionInListText(touchPoint)) {
                    this.selection.selectListText();
                }
                // tslint:disable-next-line:max-line-length
                if (!this.owner.isReadOnlyMode && this.owner.enableImageResizerMode && this.owner.imageResizerModule.isImageResizing) {
                    this.owner.imageResizerModule.mouseUpInternal();
                    this.scrollToPosition(this.owner.selection.start, this.owner.selection.end);
                    this.owner.imageResizerModule.isImageResizing = false;
                    this.owner.imageResizerModule.updateHistoryForImageResizer();
                }
                // tslint:disable-next-line:max-line-length
                if (this.owner.enableImageResizerMode && this.owner.imageResizerModule.isImageResizerVisible && !isNullOrUndefined(this.selection.caret)) {
                    this.selection.caret.style.display = 'none';
                }
                this.isMouseDown = false;
                this.isSelectionChangedOnMouseMoved = false;
                this.isTouchInput = false;
                this.useTouchSelectionMark = true;
                this.isControlPressed = false;
                this.updateFocus();
                if (this.isListTextSelected) {
                    this.selection.hideCaret();
                }
                if (this.owner.enableImageResizerMode) {
                    let imageResizer = this.owner.imageResizerModule;
                    imageResizer.isImageResizing = false;
                    imageResizer.isImageMoveToNextPage = false;
                    imageResizer.leftValue = undefined;
                    imageResizer.topValue = undefined;
                }
                this.isMouseDownInFooterRegion = false;
            }
        };
        /**
         * Fired on touch start.
         * @param {TouchEvent} event
         * @private
         */
        this.onTouchStartInternal = (event) => {
            if (this.selection) {
                this.isCompositionStart = false;
                this.isCompositionEnd = false;
                this.isCompositionUpdated = false;
                this.isCompositionCanceled = true;
                this.isTouchInput = true;
                if (this.isTimerStarted) {
                    if (this.tapCount === 1) {
                        this.tapCount = 2;
                    }
                    else {
                        this.tapCount = 3;
                        this.isTimerStarted = false;
                    }
                }
                else {
                    this.isTimerStarted = true;
                    this.tapCount = 1;
                }
                if (event.touches.length === 1) {
                    this.zoomX = event.touches[0].clientX;
                    this.zoomY = event.touches[0].clientY;
                    if (this.owner.selection.isEmpty) {
                        this.useTouchSelectionMark = false;
                    }
                    this.isMouseDown = true;
                    this.isSelectionChangedOnMouseMoved = false;
                    let point;
                    if (this.isMouseDown) {
                        point = this.getTouchOffsetValue(event);
                    }
                    point = this.findFocusedPage(point, true);
                    if (this.owner.enableImageResizerMode) {
                        let resizeObj = this.owner.imageResizerModule.getImagePointOnTouch(point);
                        this.owner.imageResizerModule.selectedResizeElement = resizeObj.selectedElement;
                    }
                    // tslint:disable-next-line:max-line-length
                    if (this.owner.enableImageResizerMode && !isNullOrUndefined(this.owner.imageResizerModule.selectedResizeElement)) {
                        this.owner.imageResizerModule.isImageResizing = true;
                    }
                    let x = this.owner.selection.end.location.x;
                    let y = this.selection.getCaretBottom(this.owner.selection.end, this.owner.selection.isEmpty) + 9;
                    //TouchDownOnSelectionMark will be 2 when touch end is pressed
                    this.touchDownOnSelectionMark = ((point.y <= y && point.y >= y - 20 || point.y >= y && point.y <= y + 20)
                        && (point.x <= x && point.x >= x - 20 || point.x >= x && point.x <= x + 20)) ? 1 : 0;
                    if (!this.owner.selection.isEmpty && this.touchDownOnSelectionMark === 0) {
                        x = this.owner.selection.start.location.x;
                        y = this.selection.getCaretBottom(this.owner.selection.start, false) + 9;
                        //TouchDownOnSelectionMark will be 1 when touch start is pressed
                        this.touchDownOnSelectionMark = ((point.y <= y && point.y >= y - 20 || point.y >= y && point.y <= y + 20)
                            && (point.x <= x && point.x >= x - 20 || point.x >= x && point.x <= x + 20)) ? 2 : 0;
                    }
                }
                if (!isNullOrUndefined(this.owner.contextMenuModule) && this.owner.contextMenuModule.contextMenuInstance) {
                    this.owner.contextMenuModule.contextMenuInstance.close();
                }
                if (this.touchDownOnSelectionMark || event.touches.length > 1) {
                    event.preventDefault();
                }
                this.timer = setTimeout(() => {
                    this.isTimerStarted = false;
                }, 200);
            }
        };
        /**
         * Fired on touch move.
         * @param {TouchEvent} event
         * @private
         */
        this.onTouchMoveInternal = (event) => {
            let touch = event.touches;
            let cursorPoint;
            if (!isNullOrUndefined(this.selection)) {
                // tslint:disable-next-line:max-line-length
                if (this.owner.editorModule && this.owner.enableImageResizerMode && this.owner.imageResizerModule.isImageResizing) {
                    event.preventDefault();
                    if (!this.owner.imageResizerModule.isImageMoveToNextPage) {
                        this.owner.imageResizerModule.handleImageResizingOnTouch(event);
                        this.selection.caret.style.display = 'none';
                    }
                    return;
                }
                if (this.isMouseDown) {
                    cursorPoint = this.getTouchOffsetValue(event);
                    let touchPoint = this.findFocusedPage(cursorPoint, true);
                    if (this.touchDownOnSelectionMark > 0 /*|| !this.useTouchSelectionMark*/) {
                        event.preventDefault();
                        let touchY = touchPoint.y;
                        let textPosition = this.owner.selection.end;
                        if (touchPoint.y <= 26) {
                            touchY -= touchPoint.y < 0 ? 0 : touchPoint.y + 0.5;
                        }
                        else {
                            touchY -= 36.5;
                        }
                        textPosition = this.touchDownOnSelectionMark === 2 ? this.selection.start : this.selection.end;
                        touchPoint = new Point(touchPoint.x, touchY);
                        this.owner.selection.moveTextPosition(touchPoint, textPosition);
                        this.isSelectionChangedOnMouseMoved = true;
                    }
                    this.selection.checkForCursorVisibility();
                }
            }
            if (touch.length > 1) {
                event.preventDefault();
                this.isMouseDown = false;
                this.zoomX = (touch[0].clientX + touch[1].clientX) / 2;
                this.zoomY = (touch[0].clientY + touch[1].clientY) / 2;
                // tslint:disable-next-line:max-line-length
                let currentDiff = Math.sqrt(Math.pow((touch[0].clientX - touch[1].clientX), 2) + Math.pow((touch[0].clientY - touch[1].clientY), 2));
                if (this.preDifference > -1) {
                    if (currentDiff > this.preDifference) {
                        this.onPinchOutInternal(event);
                    }
                    else if (currentDiff < this.preDifference) {
                        this.onPinchInInternal(event);
                    }
                }
                else if (this.zoomFactor < 2) {
                    if (this.preDifference !== -1) {
                        if (currentDiff > this.preDifference) {
                            this.onPinchInInternal(event);
                        }
                    }
                }
                else if (this.preDifference === -1) {
                    if (this.zoomFactor > 2) {
                        if (currentDiff > this.preDifference) {
                            this.onPinchInInternal(event);
                        }
                    }
                }
                this.preDifference = currentDiff;
            }
        };
        /**
         * Fired on touch up.
         * @param {TouchEvent} event
         * @private
         */
        this.onTouchUpInternal = (event) => {
            if (!isNullOrUndefined(this.selection)) {
                let point = this.getTouchOffsetValue(event);
                let touchPoint = this.findFocusedPage(point, true);
                if (event.changedTouches.length === 1) {
                    this.zoomX = undefined;
                    this.zoomY = undefined;
                    // tslint:disable-next-line:max-line-length
                    if (this.isMouseDown && !this.isSelectionChangedOnMouseMoved && !isNullOrUndefined(this.currentPage) && !isNullOrUndefined(this.owner.selection.start)) {
                        if (this.touchDownOnSelectionMark === 0) {
                            this.updateTextPositionForSelection(new Point(touchPoint.x, touchPoint.y), this.tapCount);
                            if (this.tapCount === 2) {
                                this.selection.checkAndEnableHeaderFooter(point, touchPoint);
                            }
                        }
                        if (this.owner.selection.isEmpty) {
                            this.selection.updateCaretPosition();
                        }
                        this.selection.checkForCursorVisibility();
                    }
                    if (!isNullOrUndefined(this.currentPage) && !isNullOrUndefined(this.selection.start)
                        && !this.isSelectionChangedOnMouseMoved && (this.selection.isEmpty ||
                        this.selection.isImageField() && (!this.owner.enableImageResizerMode ||
                            this.owner.enableImageResizerMode && !this.owner.imageResizerModule.isImageResizing))) {
                        this.selection.navigateHyperLinkOnEvent(touchPoint, true);
                    }
                    this.isMouseDown = false;
                    this.touchDownOnSelectionMark = 0;
                    this.useTouchSelectionMark = true;
                    this.isSelectionChangedOnMouseMoved = false;
                }
                if (this.owner.enableImageResizerMode && this.owner.imageResizerModule.isImageResizing) {
                    this.owner.imageResizerModule.mouseUpInternal();
                    this.owner.imageResizerModule.isImageResizing = false;
                    this.owner.imageResizerModule.isImageMoveToNextPage = false;
                    this.scrollToPosition(this.owner.selection.start, this.owner.selection.end);
                    this.owner.imageResizerModule.updateHistoryForImageResizer();
                }
                // tslint:disable-next-line:max-line-length
                if (this.owner.enableImageResizerMode && this.owner.imageResizerModule.isImageResizerVisible && this.isTouchInput) {
                    this.touchStart.style.display = 'none';
                    this.touchEnd.style.display = 'none';
                }
                // if (!this.owner.isReadOnlyMode && this.isSelectionInListText(touchPoint)) {
                //     this.selection.selectListText();
                // }
                event.preventDefault();
            }
            this.preDifference = -1;
            this.isTouchInput = false;
            if (!this.isTimerStarted) {
                this.tapCount = 1;
            }
            if (this.isListTextSelected) {
                this.selection.hideCaret();
            }
        };
        /**
         * Fired on keyup event.
         * @private
         */
        this.onKeyUpInternal = (event) => {
            if (Browser.isDevice) {
                if (window.getSelection().anchorOffset !== this.prefix.length) {
                    this.selection.setEditableDivCaretPosition(this.editableDiv.innerText.length);
                }
            }
            if (event.ctrlKey || (event.keyCode === 17 || event.which === 17)) {
                this.isControlPressed = false;
            }
        };
        /**
         * Fired on keydown.
         * @private
         */
        this.onKeyDownInternal = (event) => {
            let isHandled = false;
            let keyEventArgs = { 'event': event, 'isHandled': false, source: this.owner };
            this.owner.trigger('keyDown', keyEventArgs);
            if (keyEventArgs.isHandled) {
                return;
            }
            let key = event.which || event.keyCode;
            let ctrl = (event.ctrlKey || event.metaKey) ? true : ((key === 17) ? true : false); // ctrl detection       
            let shift = event.shiftKey ? event.shiftKey : ((key === 16) ? true : false); // Shift Key detection        
            let alt = event.altKey ? event.altKey : ((key === 18) ? true : false); // alt key detection
            if (ctrl && !shift && !alt) {
                switch (key) {
                    case 80:
                        event.preventDefault();
                        this.owner.print();
                        isHandled = true;
                        break;
                    case 83:
                        event.preventDefault();
                        this.owner.save(this.owner.documentName === '' ? 'sample' : this.owner.documentName, 'Sfdt');
                        isHandled = true;
                        break;
                }
            }
            if (!isHandled && !isNullOrUndefined(this.selection)) {
                this.selection.onKeyDownInternal(event, ctrl, shift, alt);
            }
            if (isHandled) {
                event.preventDefault();
            }
        };
        this.owner = owner;
        this.pages = [];
        this.render = new Renderer(this);
        this.lists = [];
        this.abstractLists = [];
        this.characterFormat = new WCharacterFormat(this);
        this.paragraphFormat = new WParagraphFormat(this);
        this.renderedLists = new Dictionary();
        this.headersFooters = [];
        this.styles = new WStyles();
        this.preDefinedStyles = new Dictionary();
        this.initalizeStyles();
        this.bookmarks = new Dictionary();
    }
    //#region Properties
    /**
     * Gets container canvas.
     * @private
     */
    get containerCanvas() {
        if (isNullOrUndefined(this.containerCanvasIn)) {
            this.containerCanvasIn = document.createElement('canvas');
            this.containerCanvasIn.getContext('2d').save();
        }
        if (!isNullOrUndefined(this.pageContainer)
            && this.containerCanvasIn.parentElement !== this.pageContainer) {
            this.pageContainer.appendChild(this.containerCanvasIn);
        }
        return this.containerCanvasIn;
    }
    /**
     * Gets selection canvas.
     * @private
     */
    get selectionCanvas() {
        if (isNullOrUndefined(this.selectionCanvasIn)) {
            this.selectionCanvasIn = document.createElement('canvas');
            this.selectionCanvas.getContext('2d').save();
        }
        if (!isNullOrUndefined(this.pageContainer)
            && this.selectionCanvasIn.parentElement !== this.pageContainer) {
            this.pageContainer.appendChild(this.selectionCanvasIn);
        }
        return this.selectionCanvasIn;
    }
    /**
     * Gets container context.
     * @private
     */
    get containerContext() {
        return this.containerCanvas.getContext('2d');
    }
    /**
     * Gets selection context.
     * @private
     */
    get selectionContext() {
        return this.selectionCanvas.getContext('2d');
    }
    /**
     * Gets the current rendering page.
     */
    get currentRenderingPage() {
        if (this.pages.length === 0) {
            return undefined;
        }
        return this.pages[this.pages.length - 1];
    }
    /**
     * Gets visible bounds.
     * @private
     */
    get visibleBounds() {
        return this.visibleBoundsIn;
    }
    /**
     * Gets or sets zoom factor.
     * @private
     */
    get zoomFactor() {
        return this.zoomFactorInternal;
    }
    set zoomFactor(value) {
        if (this.zoomFactorInternal !== value) {
            this.preZoomFactor = this.zoomFactor;
            this.zoomFactorInternal = value;
            this.zoomModule.setZoomFactor(value);
            this.owner.zoomFactor = value;
        }
    }
    /**
     * Gets the selection.
     * @private
     */
    get selection() {
        return this.owner.selection;
    }
    /**
     * Gets or sets selection start page.
     * @private
     */
    get selectionStartPage() {
        return this.selectionStartPageIn;
    }
    set selectionStartPage(value) {
        this.selectionStartPageIn = value;
    }
    /**
     * Gets or sets selection end page.
     * @private
     */
    get selectionEndPage() {
        return this.selectionEndPageIn;
    }
    set selectionEndPage(value) {
        this.selectionEndPageIn = value;
    }
    /**
     * Gets the initialized default dialog.
     * @private
     */
    get dialog() {
        if (!this.dialogInternal) {
            this.initDialog();
        }
        return this.dialogInternal;
    }
    /**
     * Gets the initialized default dialog.
     * @private
     */
    get dialog2() {
        if (!this.dialogInternal2) {
            this.initDialog2();
        }
        return this.dialogInternal2;
    }
    /**
     * Gets or sets page fit type.
     * @private
     */
    get pageFitType() {
        return this.pageFitTypeIn;
    }
    set pageFitType(value) {
        this.pageFitTypeIn = value;
        this.onPageFitTypeChanged(this.pageFitTypeIn);
    }
    initalizeStyles() {
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Normal', '{"type":"Paragraph","name":"Normal","next":"Normal"}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 1', '{"type":"Paragraph","name":"Heading 1","basedOn":"Normal","next":"Normal","link":"Heading 1 Char","characterFormat":{"fontSize":16.0,"fontFamily":"Calibri Light","fontColor":"#2F5496"},"paragraphFormat":{"leftIndent":0.0,"rightIndent":0.0,"firstLineIndent":0.0,"beforeSpacing":12.0,"afterSpacing":0.0,"lineSpacing":1.0791666507720947,"lineSpacingType":"Multiple","textAlignment":"Left","outlineLevel":"Level1"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 2', '{"type":"Paragraph","name":"Heading 2","basedOn":"Normal","next":"Normal","link":"Heading 2 Char","characterFormat":{"fontSize":13.0,"fontFamily":"Calibri Light","fontColor":"#2F5496"},"paragraphFormat":{"leftIndent":0.0,"rightIndent":0.0,"firstLineIndent":0.0,"beforeSpacing":2.0,"afterSpacing":0.0,"lineSpacing":1.0791666507720947,"lineSpacingType":"Multiple","textAlignment":"Left","outlineLevel":"Level2"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 3', '{"type":"Paragraph","name":"Heading 3","basedOn":"Normal","next":"Normal","link":"Heading 3 Char","characterFormat":{"fontSize":12.0,"fontFamily":"Calibri Light","fontColor":"#1F3763"},"paragraphFormat":{"leftIndent":0.0,"rightIndent":0.0,"firstLineIndent":0.0,"beforeSpacing":2.0,"afterSpacing":0.0,"lineSpacing":1.0791666507720947,"lineSpacingType":"Multiple","textAlignment":"Left","outlineLevel":"Level3"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 4', '{"type":"Paragraph","name":"Heading 4","basedOn":"Normal","next":"Normal","link":"Heading 4 Char","characterFormat":{"italic":true,"fontFamily":"Calibri Light","fontColor":"#2F5496"},"paragraphFormat":{"leftIndent":0.0,"rightIndent":0.0,"firstLineIndent":0.0,"beforeSpacing":2.0,"afterSpacing":0.0,"lineSpacing":1.0791666507720947,"lineSpacingType":"Multiple","textAlignment":"Left","outlineLevel":"Level4"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 5', '{"type":"Paragraph","name":"Heading 5","basedOn":"Normal","next":"Normal","link":"Heading 5 Char","characterFormat":{"fontFamily":"Calibri Light","fontColor":"#2F5496"},"paragraphFormat":{"leftIndent":0.0,"rightIndent":0.0,"firstLineIndent":0.0,"beforeSpacing":2.0,"afterSpacing":0.0,"lineSpacing":1.0791666507720947,"lineSpacingType":"Multiple","textAlignment":"Left","outlineLevel":"Level5"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 6', '{"type":"Paragraph","name":"Heading 6","basedOn":"Normal","next":"Normal","link":"Heading 6 Char","characterFormat":{"fontFamily":"Calibri Light","fontColor":"#1F3763"},"paragraphFormat":{"leftIndent":0.0,"rightIndent":0.0,"firstLineIndent":0.0,"beforeSpacing":2.0,"afterSpacing":0.0,"lineSpacing":1.0791666507720947,"lineSpacingType":"Multiple","textAlignment":"Left","outlineLevel":"Level6"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Default Paragraph Font', '{"type":"Character","name":"Default Paragraph Font"}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 1 Char', '{"type":"Character","name":"Heading 1 Char","basedOn":"Default Paragraph Font","characterFormat":{"fontSize":16.0,"fontFamily":"Calibri Light","fontColor":"#2F5496"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 2 Char', '{"type":"Character","name":"Heading 2 Char","basedOn":"Default Paragraph Font","characterFormat":{"fontSize":13.0,"fontFamily":"Calibri Light","fontColor":"#2F5496"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 3 Char', '{"type":"Character","name":"Heading 3 Char","basedOn":"Default Paragraph Font","characterFormat":{"fontSize":12.0,"fontFamily":"Calibri Light","fontColor": "#1F3763"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 4 Char', '{"type":"Character","name":"Heading 4 Char","basedOn":"Default Paragraph Font","characterFormat":{"italic":true,"fontFamily":"Calibri Light","fontColor":"#2F5496"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 5 Char', '{"type":"Character","name":"Heading 5 Char","basedOn":"Default Paragraph Font","characterFormat":{"fontFamily":"Calibri Light","fontColor":"#2F5496"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 6 Char', '{"type":"Character","name":"Heading 6 Char","basedOn":"Default Paragraph Font","characterFormat":{"fontFamily":"Calibri Light","fontColor":"#1F3763"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Hyperlink', '{"type":"Character","name":"Hyperlink","basedOn":"Default Paragraph Font","next":"Normal","characterFormat":{"fontColor":"#0563C1","underline": "Single"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc1', '{"type":"Paragraph","name":"Toc1","basedOn":"Normal","next":"Normal","paragraphFormat":{"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc2', '{"type":"Paragraph","name":"Toc2","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :11.0,"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc3', '{"type":"Paragraph","name":"Toc3","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :22.0,"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc4', '{"type":"Paragraph","name":"Toc4","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :33.0,"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc5', '{"type":"Paragraph","name":"Toc5","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :44.0,"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc6', '{"type":"Paragraph","name":"Toc6","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :55.0,"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc7', '{"type":"Paragraph","name":"Toc7","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :66.0,"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc8', '{"type":"Paragraph","name":"Toc8","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :77.0,"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc9', '{"type":"Paragraph","name":"Toc9","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :88.0,"afterSpacing":5.0}}');
    }
    /**
     * @private
     */
    clearDocumentItems() {
        this.headersFooters = [];
        this.fields = [];
        this.bookmarks.clear();
        this.styles.clear();
        this.characterFormat.clearFormat();
        this.paragraphFormat.clearFormat();
    }
    /**
     * @private
     */
    getAbstractListById(id) {
        if (isNullOrUndefined(this.abstractLists)) {
            return undefined;
        }
        for (let i = 0; i < this.abstractLists.length; i++) {
            let abstractList = this.abstractLists[i];
            if (abstractList instanceof WAbstractList && abstractList.abstractListId === id) {
                return abstractList;
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    getListById(id) {
        if (isNullOrUndefined(this.lists)) {
            return undefined;
        }
        for (let i = 0; i < this.lists.length; i++) {
            if (!isNullOrUndefined(this.lists[i]) && this.lists[i].listId === id) {
                return this.lists[i];
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    static getListLevelNumber(listLevel) {
        if (listLevel.ownerBase instanceof WLevelOverride) {
            return listLevel.ownerBase.levelNumber;
        }
        else if (listLevel.ownerBase instanceof WAbstractList && !isNullOrUndefined(listLevel.ownerBase.levels)) {
            return listLevel.ownerBase.levels.indexOf(listLevel);
        }
        else {
            return -1;
        }
    }
    /**
     * Gets the bookmarks.
     * @private
     */
    getBookmarks(includeHidden) {
        let bookmarks = [];
        for (let i = 0; i < this.bookmarks.keys.length; i++) {
            let bookmark = this.bookmarks.keys[i];
            if (includeHidden || bookmark.indexOf('_') !== 0) {
                bookmarks.push(bookmark);
            }
        }
        return bookmarks;
    }
    /**
     * Initializes components.
     * @private
     */
    initializeComponents() {
        let element = this.owner.element;
        if (isNullOrUndefined(element)) {
            return;
        }
        this.viewerContainer = createElement('div', { id: this.owner.containerId + '_viewerContainer' });
        this.viewerContainer.style.cssText = 'position:relative;backgroundColor:#FBFBFB;overflow:auto';
        element.appendChild(this.viewerContainer);
        this.viewerContainer.tabIndex = 0;
        this.viewerContainer.style.outline = 'none';
        this.pageContainer = createElement('div', { id: this.owner.containerId + '_pageContainer', className: 'e-de-background' });
        this.viewerContainer.appendChild(this.pageContainer);
        this.pageContainer.style.top = '0px';
        this.pageContainer.style.left = '0px';
        this.pageContainer.style.position = 'relative';
        this.pageContainer.style.pointerEvents = 'none';
        this.editableDiv = document.createElement('div');
        this.editableDiv.contentEditable = 'true';
        this.editableDiv.style.position = 'fixed';
        this.editableDiv.style.left = '-150em';
        this.editableDiv.style.width = '100%';
        this.editableDiv.style.height = '100%';
        this.editableDiv.id = element.id + '_editableDiv';
        document.body.appendChild(this.editableDiv);
        if (this.owner.enableImageResizerMode) {
            this.owner.imageResizerModule.initializeImageResizer();
        }
        this.updateViewerSizeInternal(element);
        this.layout = new Layout(this);
        this.textHelper = new TextHelper(this);
        this.zoomModule = new Zoom(this);
        // let locale: L10n = new L10n('documenteditor', this.owner.defaultLocale);
        // locale.setLocale(this.owner.locale);
        // setCulture(this.owner.locale);
        this.initTouchEllipse();
        this.wireEvent();
    }
    /**
     * Wires events and methods.
     */
    wireEvent() {
        if (!isNullOrUndefined(this.selection)) {
            this.selection.initCaret();
        }
        this.editableDiv.addEventListener('paste', this.onPaste);
        if (Browser.isIE) {
            this.editableDiv.addEventListener('keypress', this.onKeyPressInternal);
        }
        else {
            this.editableDiv.addEventListener('input', this.onTextInputInternal);
        }
        this.editableDiv.addEventListener('blur', this.onFocusOut);
        this.editableDiv.addEventListener('keydown', this.onKeyDownInternal);
        this.editableDiv.addEventListener('compositionstart', this.compositionStart);
        this.editableDiv.addEventListener('compositionupdate', this.compositionUpdated);
        this.editableDiv.addEventListener('compositionend', this.compositionEnd);
        this.viewerContainer.addEventListener('scroll', this.scrollHandler);
        this.viewerContainer.addEventListener('mousedown', this.onMouseDownInternal);
        this.viewerContainer.addEventListener('keydown', this.onKeyDownInternal);
        this.viewerContainer.addEventListener('mousemove', this.onMouseMoveInternal);
        this.viewerContainer.addEventListener('contextmenu', this.onContextMenu);
        this.viewerContainer.addEventListener('dblclick', this.onDoubleTap);
        this.viewerContainer.addEventListener('mouseup', this.onMouseUpInternal);
        window.addEventListener('resize', this.onWindowResize);
        window.addEventListener('keyup', this.onKeyUpInternal);
        window.addEventListener('mouseup', this.onImageResizer);
        window.addEventListener('touchend', this.onImageResizer);
        this.viewerContainer.addEventListener('touchstart', this.onTouchStartInternal);
        this.viewerContainer.addEventListener('touchmove', this.onTouchMoveInternal);
        this.viewerContainer.addEventListener('touchend', this.onTouchUpInternal);
        if (navigator.userAgent.match('Firefox')) {
            this.viewerContainer.addEventListener('DOMMouseScroll', this.zoomModule.onMouseWheelInternal);
        }
        this.viewerContainer.addEventListener('mousewheel', this.zoomModule.onMouseWheelInternal);
    }
    /**
     * Initializes dialog template.
     */
    initDialog() {
        if (!this.dialogInternal) {
            this.dialogTarget = createElement('div', { className: 'e-de-dlg-target' });
            document.body.appendChild(this.dialogTarget);
            this.dialogInternal = new Dialog({
                target: document.body, showCloseIcon: true,
                allowDragging: true, visible: false, width: '1px', isModal: true, position: { X: 'center', Y: 'center' }, zIndex: 20
            });
            this.dialogInternal.open = this.selection.hideCaret;
            this.dialogInternal.beforeClose = this.updateFocus;
            this.dialogInternal.appendTo(this.dialogTarget);
        }
    }
    /**
     * Initializes dialog template.
     */
    initDialog2() {
        if (!this.dialogInternal2) {
            let target = createElement('div', { className: 'e-de-dlg-target' });
            document.body.appendChild(target);
            this.dialogInternal2 = new Dialog({
                target: document.body, showCloseIcon: true,
                allowDragging: true, visible: false, width: '1px', isModal: true, position: { X: 'center', Y: 'Top' }, zIndex: 10
            });
            this.dialogInternal2.appendTo(target);
        }
    }
    /**
     * Clears the context.
     * @private
     */
    clearContent() {
        this.containerContext.clearRect(0, 0, this.containerCanvas.width, this.containerCanvas.height);
        this.selectionContext.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
    }
    /**
     * Fired when the document gets changed.
     * @param {WordDocument} document
     */
    onDocumentChanged(sections) {
        this.clearContent();
        if (this.owner.editorModule) {
            this.owner.editorModule.tocStyles = {};
            this.owner.editorModule.tocBookmarkId = 0;
        }
        this.heightInfoCollection = {};
        this.owner.isDocumentLoaded = false;
        for (let i = 0; i < this.pages.length; i++) {
            this.pages[i].bodyWidgets[0].destroy();
        }
        this.pages = [];
        if (!isNullOrUndefined(this.renderedLists)) {
            this.renderedLists.clear();
        }
        if (!isNullOrUndefined(this.owner.editorHistory)) {
            this.owner.editorHistory.destroy();
        }
        this.owner.isDocumentLoaded = true;
        this.layout.isInitialLoad = true;
        this.layout.layoutItems(sections);
        if (this.owner.selection) {
            this.owner.selection.selectRange(this.owner.documentStart, this.owner.documentStart);
        }
        if (this.owner.optionsPaneModule) {
            this.owner.optionsPaneModule.showHideOptionsPane(false);
        }
        this.owner.fireDocumentChange();
    }
    /**
     * Initialize touch ellipse.
     */
    initTouchEllipse() {
        let style = 'height: 30px;width: 30px;position: absolute;background-color: transparent;margin: 0px;padding: 0px;z-index:5';
        // tslint:disable-next-line:max-line-length
        let ellipse = ' height: 12px;width: 12px;border-radius: 50%;background-color: white;position: absolute;margin: 0px 6px 0px 6px;border-width: 2px;border-style: solid;border-color: #000000;';
        this.touchStart = createElement('div', { className: 'e-touch-ellipse', styles: style });
        let start = createElement('div', { styles: ellipse });
        this.touchEnd = createElement('div', { className: 'e-touch-ellipse', styles: style });
        this.touchStart.style.display = 'none';
        let end = createElement('div', { styles: ellipse });
        this.touchStart.appendChild(start);
        this.touchEnd.appendChild(end);
        this.touchEnd.style.display = 'none';
        this.viewerContainer.appendChild(this.touchStart);
        this.viewerContainer.appendChild(this.touchEnd);
    }
    /**
     * Updates touch mark position.
     * @private
     */
    updateTouchMarkPosition() {
        if (this.touchStart.style.display !== 'none' && !isNullOrUndefined(this.selection)) {
            if (!this.selection.isEmpty) {
                let y = this.selection.getCaretBottom(this.selection.start, false);
                let page = this.selection.getPage(this.selection.start.paragraph);
                let viewer = this;
                // tslint:disable-next-line:max-line-length
                let pageTop = (page.boundingRectangle.y - viewer.pageGap * (this.pages.indexOf(page) + 1)) * this.zoomFactor + viewer.pageGap * (this.pages.indexOf(page) + 1);
                // tslint:disable-next-line:max-line-length
                this.touchStart.style.left = page.boundingRectangle.x + (Math.round(this.selection.start.location.x) * this.zoomFactor - 14) + 'px';
                this.touchStart.style.top = pageTop + ((y) * this.zoomFactor) + 'px';
                if (!this.selection.isEmpty) {
                    y = this.selection.getCaretBottom(this.selection.end, false);
                    page = this.selection.getPage(this.selection.end.paragraph);
                }
                // tslint:disable-next-line:max-line-length
                this.touchEnd.style.left = page.boundingRectangle.x + (Math.round(this.selection.end.location.x) * this.zoomFactor - 14) + 'px';
                this.touchEnd.style.top = pageTop + (y * this.zoomFactor) + 'px';
            }
            else {
                this.selection.updateCaretPosition();
            }
        }
    }
    isSelectionInListText(cursorPoint) {
        let widget = this.getLineWidget(cursorPoint);
        if (!isNullOrUndefined(widget) && widget.children[0] instanceof ListTextElementBox) {
            let left = this.getLeftValue(widget);
            let width = widget.children[0].width;
            let height = widget.children[0].height;
            if (this.isInsideRect(left, widget.paragraph.y, width, height, cursorPoint)) {
                this.selectionLineWidget = widget;
                return true;
            }
        }
        return false;
    }
    /**
     * Check whether touch point is inside the rectangle or not.
     * @param x
     * @param y
     * @param width
     * @param height
     * @param touchPoint
     * @private
     */
    isInsideRect(x, y, width, height, touchPoint) {
        if ((touchPoint.x > x && touchPoint.x <= x + width) && (touchPoint.y > y && touchPoint.y <= y + height)) {
            return true;
        }
        return false;
    }
    /**
     * @private
     */
    getLeftValue(widget) {
        let left = widget.paragraph.x;
        let paragraphFormat = widget.paragraph.paragraphFormat;
        if (this.selection.isParagraphFirstLine(widget)) {
            if (paragraphFormat.textAlignment === 'Right') {
                left -= HelperMethods.convertPointToPixel(paragraphFormat.firstLineIndent);
                left -= HelperMethods.convertPointToPixel(paragraphFormat.leftIndent);
            }
            else {
                left += HelperMethods.convertPointToPixel(paragraphFormat.firstLineIndent);
            }
        }
        let element = widget.children[0];
        if (element instanceof ListTextElementBox) {
            left += element.margin.left;
        }
        return left;
    }
    /**
     * Checks whether left mouse button is pressed or not.
     */
    isLeftButtonPressed(event) {
        this.isTouchInput = false;
        let button = event.which || event.button;
        return button === 1;
    }
    /**
     * Gets touch offset value.
     */
    getTouchOffsetValue(event) {
        let targetElement = this.viewerContainer;
        let offset = targetElement.getBoundingClientRect();
        let touchOffsetValues = event.touches[0];
        if (isNullOrUndefined(touchOffsetValues)) {
            touchOffsetValues = event.changedTouches[0];
        }
        let offsetX = touchOffsetValues.pageX - offset.left;
        let offsetY = touchOffsetValues.pageY - offset.top;
        return new Point(offsetX, offsetY);
    }
    /**
     * Fired on pinch zoom in.
     * @param {TouchEvent} event
     */
    onPinchInInternal(event) {
        this.preZoomFactor = this.zoomFactor;
        let updatedZoomFactor = this.zoomFactor - 0.01;
        if (updatedZoomFactor < 5 && updatedZoomFactor > 2) {
            updatedZoomFactor = updatedZoomFactor - 0.01;
        }
        if (updatedZoomFactor < 0.1) {
            updatedZoomFactor = 0.1;
        }
        this.zoomFactor = updatedZoomFactor;
    }
    /**
     * Fired on pinch zoom out.
     * @param {TouchEvent} event
     */
    onPinchOutInternal(event) {
        this.preZoomFactor = this.zoomFactor;
        let updatedZoomFactor = this.zoomFactor + 0.01;
        if (updatedZoomFactor > 2) {
            updatedZoomFactor = updatedZoomFactor + 0.01;
        }
        if (updatedZoomFactor > 5) {
            updatedZoomFactor = 5;
        }
        this.zoomFactor = updatedZoomFactor;
    }
    /**
     * Gets page width.
     * @private
     */
    getPageWidth(page) {
        let width = page.boundingRectangle.width;
        return width;
    }
    /**
     * Removes specified page.
     * @private
     */
    removePage(page) {
        if (this.currentPage === page) {
            this.currentPage = undefined;
        }
        let index = this.pages.indexOf(page);
        // if (index > -1) {
        this.pages.splice(index, 1);
        // }        
        //this.removeRenderedPages();
        let viewer = this;
        if (!isNullOrUndefined(viewer.visiblePages)) {
            if ((viewer.visiblePages).indexOf(page) > -1) {
                let pageIndex = (viewer.visiblePages).indexOf(page);
                (viewer.visiblePages).splice(pageIndex, 1);
            }
        }
        //(viewer as PageLayoutViewer).visiblePages.remove(page);
        let height = 0;
        for (let i = 0; i < this.pages.length; i++) {
            height = height + this.pages[i].boundingRectangle.height;
        }
        //Updates the vertical height.
        height -= page.boundingRectangle.height + 20;
        //ToDo:Update horizontal width, if removed page has max width.
        let top = 20;
        if (index > 0) {
            top += this.pages[index - 1].boundingRectangle.bottom;
        }
        if (index !== -1) {
            for (let i = index; i < this.pages.length; i++) {
                //Update bounding rectangle of next pages in collection.
                page = this.pages[i];
                // tslint:disable-next-line:max-line-length
                page.boundingRectangle = new Rect(page.boundingRectangle.x, top, page.boundingRectangle.width, page.boundingRectangle.height);
                top = page.boundingRectangle.bottom + 20;
                page.repeatHeaderRowTableWidget = false;
            }
        }
    }
    // private removeRenderedPages(): void {
    //     for (let i: number = 0; i < this.pages.length; i++) {
    //         this.clearContainer(this.pages[i]);
    //     }
    // }
    /**
     * Updates viewer size on window resize.
     * @private
     */
    updateViewerSize() {
        let viewer = this;
        let element = this.owner.getDocumentEditorElement();
        viewer.updateViewerSizeInternal(element);
        viewer.updateScrollBars();
        if (!isNullOrUndefined(this.selection)) {
            this.selection.updateCaretPosition();
        }
    }
    /**
     * Updates viewer size.
     */
    updateViewerSizeInternal(element) {
        if (!isNullOrUndefined(element)) {
            let rect = element.getBoundingClientRect();
            let width = 0;
            let height = 0;
            height = rect.height > 0 ? rect.height : 200;
            if (this.owner.optionsPaneModule && this.owner.optionsPaneModule.isOptionsPaneShow) {
                let optionsRect = this.owner.optionsPaneModule.optionsPane.getBoundingClientRect();
                width = (rect.width - optionsRect.width) > 0 ? (rect.width - optionsRect.width) : 200;
            }
            else {
                width = rect.width > 0 ? rect.width : 200;
            }
            this.viewerContainer.style.height = height.toString() + 'px';
            this.viewerContainer.style.width = Math.ceil(width) + 'px';
            this.visibleBoundsIn = new Rect(0, 0, width, height);
            this.containerCanvas.width = width;
            this.containerCanvas.height = height;
            this.selectionCanvas.width = width;
            this.selectionCanvas.height = height;
        }
    }
    /**
     * Updates client area for block.
     * @private
     */
    updateClientAreaForBlock(block, beforeLayout, tableCollection) {
        let leftIndent = HelperMethods.convertPointToPixel(block.leftIndent);
        let rightIndent = HelperMethods.convertPointToPixel(block.rightIndent);
        if (beforeLayout) {
            if (block instanceof TableWidget && tableCollection) {
                let tableWidget = tableCollection[0];
                this.clientActiveArea.x = this.clientArea.x = tableWidget.x;
                this.clientActiveArea.width = this.clientArea.width = tableWidget.width;
                //Updates the location of last item.
                tableWidget = tableCollection[tableCollection.length - 1];
                tableWidget.x = this.clientActiveArea.x;
                tableWidget.y = this.clientActiveArea.y;
                this.clientArea = new Rect(this.clientArea.x, this.clientArea.y, this.clientArea.width, this.clientArea.height);
                // tslint:disable-next-line:max-line-length
                this.clientActiveArea = new Rect(this.clientActiveArea.x, this.clientActiveArea.y, this.clientActiveArea.width, this.clientActiveArea.height);
            }
            else {
                // tslint:disable-next-line:max-line-length
                if (block instanceof TableWidget && !isNullOrUndefined(block.tableFormat) && block.tableFormat.tableAlignment !== 'Left') {
                    if (!block.isGridUpdated) {
                        block.buildTableColumns();
                        block.isGridUpdated = true;
                    }
                    let tableWidth = block.getMaxRowWidth(block.getTableClientWidth(block.getOwnerWidth(false)));
                    // Fore resizing table, the tableholder table width taken for updated width. 
                    // Since, the columns will be cleared if we performed resizing.
                    if (this.owner.editor && this.owner.editor.tableResize.currentResizingTable === block
                        && this.owner.editor.tableResize.resizerPosition === 0) {
                        tableWidth = block.tableHolder.tableWidth;
                    }
                    tableWidth = HelperMethods.convertPointToPixel(tableWidth);
                    if (block.tableFormat.tableAlignment === 'Center') {
                        leftIndent = (this.clientArea.width - tableWidth) / 2;
                    }
                    else {
                        leftIndent = this.clientArea.width - tableWidth;
                    }
                    this.tableLefts.push(leftIndent);
                }
                this.clientActiveArea.x = this.clientArea.x = this.clientArea.x + leftIndent;
                let width = this.clientArea.width - (leftIndent + rightIndent);
                this.clientActiveArea.width = this.clientArea.width = width > 0 ? width : 0;
                // tslint:disable-next-line:max-line-length
                this.clientArea = new Rect(this.clientArea.x, this.clientArea.y, this.clientArea.width, this.clientArea.height);
                // tslint:disable-next-line:max-line-length
                this.clientActiveArea = new Rect(this.clientActiveArea.x, this.clientActiveArea.y, this.clientActiveArea.width, this.clientActiveArea.height);
            }
        }
        else {
            // tslint:disable-next-line:max-line-length
            if (block instanceof TableWidget && block.tableFormat.tableAlignment !== 'Left' && this.tableLefts.length > 0) {
                leftIndent = this.tableLefts.pop();
            }
            this.clientActiveArea.x = this.clientArea.x = this.clientArea.x - leftIndent;
            let width = this.clientArea.width + leftIndent + rightIndent;
            this.clientActiveArea.width = this.clientArea.width = width > 0 ? width : 0;
            this.clientArea = new Rect(this.clientArea.x, this.clientArea.y, this.clientArea.width, this.clientArea.height);
            // tslint:disable-next-line:max-line-length
            this.clientActiveArea = new Rect(this.clientActiveArea.x, this.clientActiveArea.y, this.clientActiveArea.width, this.clientActiveArea.height);
        }
    }
    /**
     * Updates client active area left.
     * @private
     */
    cutFromLeft(x) {
        if (x < this.clientActiveArea.x) {
            x = this.clientActiveArea.x;
        }
        if (x > this.clientActiveArea.right && this.textWrap) {
            x = this.clientActiveArea.right;
        }
        this.clientActiveArea.width = this.clientActiveArea.right > x ? this.clientActiveArea.right - x : 0;
        this.clientActiveArea.x = x;
    }
    /**
     * Updates client active area top.
     * @private
     */
    cutFromTop(y) {
        if (y < this.clientActiveArea.y) {
            y = this.clientActiveArea.y;
        }
        if (y > this.clientActiveArea.bottom) {
            y = this.clientActiveArea.bottom;
        }
        this.clientActiveArea.height = this.clientActiveArea.bottom - y;
        this.clientActiveArea.x = this.clientArea.x;
        this.clientActiveArea.width = this.clientArea.width;
        this.clientActiveArea.y = y;
    }
    /**
     * Updates client width.
     * @private
     */
    updateClientWidth(width) {
        this.clientActiveArea.x -= width;
        if (this.clientActiveArea.width + width > 0) {
            this.clientActiveArea.width += width;
        }
        else {
            this.clientActiveArea.width = 0;
        }
    }
    /**
     * Inserts page in specified index.
     * @private
     */
    insertPage(index, page) {
        if (this.pages.indexOf(page) > -1) {
            this.pages.splice(this.pages.indexOf(page), 1);
        }
        this.pages.splice(index, 0, page);
        let top = 20;
        if (index > 0) {
            top += this.pages[index - 1].boundingRectangle.bottom;
        }
        for (let i = index; i < this.pages.length; i++) {
            //Update bounding rectangle of next pages in collection.
            page = this.pages[i];
            page.boundingRectangle = new Rect(page.boundingRectangle.x, top, page.boundingRectangle.width, page.boundingRectangle.height);
            top = page.boundingRectangle.bottom + 20;
        }
    }
    /**
     * Updates client area.
     * @private
     */
    updateClientArea(sectionFormat, page) {
        let top = 0;
        let headerDistance = 48;
        let footerDistance = 48;
        let pageHeight = HelperMethods.convertPointToPixel(sectionFormat.pageHeight);
        let bottomMargin = HelperMethods.convertPointToPixel(sectionFormat.bottomMargin);
        if (!isNullOrUndefined(sectionFormat)) {
            top = HelperMethods.convertPointToPixel(sectionFormat.topMargin);
            headerDistance = HelperMethods.convertPointToPixel(sectionFormat.headerDistance);
            footerDistance = HelperMethods.convertPointToPixel(sectionFormat.footerDistance);
        }
        if (!isNullOrUndefined(page.headerWidget)) {
            top = Math.min(Math.max(headerDistance + page.headerWidget.height, top), pageHeight / 100 * 40);
        }
        let bottom = 0.667 + bottomMargin;
        if (!isNullOrUndefined(page.footerWidget)) {
            bottom = 0.667 + Math.min(pageHeight / 100 * 40, Math.max(footerDistance + page.footerWidget.height, bottomMargin));
        }
        let width = 0;
        if (!isNullOrUndefined(sectionFormat)) {
            width = HelperMethods.convertPointToPixel(sectionFormat.pageWidth - sectionFormat.leftMargin - sectionFormat.rightMargin);
            
        }
        if (width < 0) {
            width = 0;
        }
        this.clientArea = new Rect(HelperMethods.convertPointToPixel(sectionFormat.leftMargin), top, width, pageHeight - top - bottom);
        this.clientActiveArea = new Rect(this.clientArea.x, this.clientArea.y, this.clientArea.width, this.clientArea.height);
    }
    /**
     * Updates client area left or top position.
     * @private
     */
    updateClientAreaTopOrLeft(tableWidget, beforeLayout) {
        if (beforeLayout) {
            this.clientActiveArea.y = this.clientActiveArea.y + tableWidget.topBorderWidth;
            this.clientActiveArea.x = this.clientActiveArea.x + tableWidget.leftBorderWidth;
        }
    }
    /**
     * Updates client area for table.
     * @private
     */
    updateClientAreaForTable(tableWidget) {
        this.clientActiveArea.x = this.clientArea.x = tableWidget.x;
        this.clientActiveArea.width = this.clientArea.width = tableWidget.width;
    }
    /**
     * Updates client area for row.
     * @private
     */
    updateClientAreaForRow(row, beforeLayout) {
        // tslint:disable-next-line:max-line-length
        let tableWidget = row.ownerTable;
        if (beforeLayout) {
            //tslint:disable:no-empty
        }
        else {
            this.clientActiveArea.x = this.clientArea.x = tableWidget.x;
            this.clientActiveArea.width = this.clientArea.width = tableWidget.width;
            this.clientArea = new Rect(this.clientArea.x, this.clientArea.y, this.clientArea.width, this.clientArea.height);
            // tslint:disable-next-line:max-line-length
            this.clientActiveArea = new Rect(this.clientActiveArea.x, this.clientActiveArea.y, this.clientActiveArea.width, this.clientActiveArea.height);
        }
    }
    /**
     * Updates client area for cell.
     * @private
     */
    updateClientAreaForCell(cell, beforeLayout) {
        // tslint:disable-next-line:max-line-length
        let rowWidget = cell.ownerRow;
        let cellWidget = cell;
        if (beforeLayout) {
            this.clientActiveArea.x = this.clientArea.x = cellWidget.x;
            this.clientActiveArea.y = cellWidget.y;
            this.clientActiveArea.width = this.clientArea.width = cellWidget.width > 0 ? cellWidget.width : 0;
            if (this instanceof PageLayoutViewer) {
                this.clientActiveArea.height = Number.POSITIVE_INFINITY;
            }
            this.clientArea = new Rect(this.clientArea.x, this.clientArea.y, this.clientArea.width, this.clientArea.height);
            // tslint:disable-next-line:max-line-length
            this.clientActiveArea = new Rect(this.clientActiveArea.x, this.clientActiveArea.y, this.clientActiveArea.width, this.clientActiveArea.height);
        }
        else {
            this.clientActiveArea.x = this.clientArea.x = cellWidget.x + cellWidget.width + cellWidget.margin.right;
            if (rowWidget.x + rowWidget.width - this.clientArea.x < 0) {
                this.clientActiveArea.width = this.clientArea.width = 0;
            }
            else {
                this.clientActiveArea.width = this.clientArea.width = rowWidget.x + rowWidget.width - this.clientArea.x;
            }
            // tslint:disable-next-line:max-line-length
            this.clientActiveArea.y = cellWidget.y - cellWidget.margin.top - HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.cellSpacing);
            if (!cell.ownerTable.isInsideTable) {
                this.clientActiveArea.height = this.clientArea.bottom - rowWidget.y > 0 ? this.clientArea.bottom - rowWidget.y : 0;
            }
            this.clientArea = new Rect(this.clientArea.x, this.clientArea.y, this.clientArea.width, this.clientArea.height);
            // tslint:disable-next-line:max-line-length
            this.clientActiveArea = new Rect(this.clientActiveArea.x, this.clientActiveArea.y, this.clientActiveArea.width, this.clientActiveArea.height);
        }
    }
    /**
     * Updates the client area based on widget.
     * @private
     */
    updateClientAreaByWidget(widget) {
        this.clientArea.x = widget.x;
        this.clientArea.y = widget.y;
        this.clientActiveArea.x = widget.x;
        this.clientActiveArea.y = widget.y;
    }
    //Widget
    /**
     * Updates client area location.
     * @param widget
     * @param area
     * @private
     */
    updateClientAreaLocation(widget, area) {
        widget.x = area.x;
        widget.y = area.y;
        widget.width = area.width;
    }
    /**
     * Updates text position for selection.
     * @param cursorPoint
     * @param tapCount
     * @param clearMultiSelection
     * @private
     */
    updateTextPositionForSelection(cursorPoint, tapCount) {
        let widget = this.getLineWidget(cursorPoint);
        if (!isNullOrUndefined(widget)) {
            this.selection.updateTextPosition(widget, cursorPoint);
        }
        if (tapCount > 1) {
            this.isMouseDown = false;
            this.useTouchSelectionMark = false;
            if (this.pages.length === 0) {
                return;
            }
            //Double tap/triple tap selection
            if (!isNullOrUndefined(this.currentPage) && !isNullOrUndefined(this.owner.selection.start)) {
                if (tapCount % 2 === 0) {
                    this.owner.selection.selectCurrentWord();
                }
                else {
                    this.owner.selection.selectCurrentParagraph();
                }
            }
        }
    }
    /**
     * Scrolls to specified position.
     * @param startPosition
     * @param endPosition
     * @private
     */
    scrollToPosition(startPosition, endPosition) {
        if (this.owner.enableImageResizerMode && this.owner.imageResizerModule.isImageResizing
            || this.isMouseDownInFooterRegion || this.isRowOrCellResizing) {
            return;
        }
        let lineWidget = this.selection.getLineWidgetInternal(endPosition.currentWidget, endPosition.offset, true);
        if (isNullOrUndefined(lineWidget)) {
            return;
        }
        let top = this.selection.getTop(lineWidget);
        if (this.isMouseDown) {
            let prevLineWidget = this.selection.getLineWidgetInternal(endPosition.currentWidget, endPosition.offset, false);
            let prevTop = this.selection.getTop(prevLineWidget);
            if (prevLineWidget !== lineWidget && endPosition.location.y >= prevTop) {
                lineWidget = prevLineWidget;
            }
        }
        let height = lineWidget.height;
        //Gets current page.
        let endPage = this.selection.getPage(lineWidget.paragraph);
        this.currentPage = endPage;
        let x = 0;
        let y = 0;
        let viewer = this;
        let isPageLayout = viewer instanceof PageLayoutViewer;
        if (isPageLayout) {
            if (isNullOrUndefined(endPage)) {
                return;
            }
            let pageWidth = endPage.boundingRectangle.width;
            x = (this.visibleBounds.width - pageWidth * this.zoomFactor) / 2;
            if (x < 30) {
                x = 30;
            }
            // tslint:disable-next-line:max-line-length
            y = endPage.boundingRectangle.y * this.zoomFactor + (this.pages.indexOf(endPage) + 1) * viewer.pageGap * (1 - this.zoomFactor);
        }
        let scrollTop = this.containerTop;
        let scrollLeft = this.containerLeft;
        let pageHeight = this.visibleBounds.height;
        let caretInfo = this.selection.updateCaretSize(this.owner.selection.end, true);
        let topMargin = caretInfo.topMargin;
        let caretHeight = caretInfo.height;
        x += (endPosition.location.x) * this.zoomFactor;
        y += (endPosition.location.y + topMargin) * this.zoomFactor;
        //vertical scroll bar update
        if ((scrollTop + 20) > y) {
            this.viewerContainer.scrollTop = (y - 10);
        }
        else if (scrollTop + pageHeight < y + caretHeight) {
            this.viewerContainer.scrollTop = y + caretHeight - pageHeight + 10;
        }
        else {
            this.selection.updateCaretToPage(startPosition, endPage);
        }
        this.selection.updateCaretToPage(startPosition, endPage);
        let scrollBarWidth = this.viewerContainer.offsetWidth - this.viewerContainer.clientWidth;
        if (scrollLeft > x) {
            this.viewerContainer.scrollLeft = x - (viewer.pageContainer.offsetWidth / 100) * 20;
        }
        else if (scrollLeft + this.visibleBounds.width < x + scrollBarWidth) {
            this.viewerContainer.scrollLeft = scrollLeft + (viewer.pageContainer.offsetWidth / 100) * 15 + scrollBarWidth;
        }
    }
    /**
     * Gets line widget using cursor point.
     * @private
     */
    getLineWidget(cursorPoint) {
        return this.getLineWidgetInternal(cursorPoint, false);
    }
    /**
     * Gets line widget.
     * @private
     */
    getLineWidgetInternal(cursorPoint, isMouseDragged) {
        let widget = undefined;
        if (!isNullOrUndefined(this.currentPage)) {
            let childWidgets;
            if (this.owner.enableHeaderAndFooter) {
                let page = this.currentPage;
                let pageTop = this.selection.getPageTop(page);
                let pageBottom = page.boundingRectangle.height;
                let headerHeight = Math.max((page.headerWidget.y + page.headerWidget.height), HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.topMargin)) * this.zoomFactor;
                let footerDistance = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.footerDistance);
                let footerHeight = (page.boundingRectangle.height -
                    Math.max(page.footerWidget.height + footerDistance, footerDistance * 2));
                if (isMouseDragged) {
                    if (this.isBlockInHeader(this.selection.start.paragraph)) {
                        childWidgets = this.currentPage.headerWidget;
                    }
                    else {
                        childWidgets = this.currentPage.footerWidget;
                    }
                }
                else {
                    if (cursorPoint.y <= pageBottom && cursorPoint.y >= footerHeight) {
                        childWidgets = this.currentPage.footerWidget;
                    }
                    else if ((cursorPoint.y) >= 0 && (cursorPoint.y) <= headerHeight) {
                        childWidgets = this.currentPage.headerWidget;
                    }
                }
                if (isNullOrUndefined(childWidgets)) {
                    return undefined;
                }
                return this.selection.getLineWidgetBodyWidget(childWidgets, cursorPoint);
            }
            else {
                for (let i = 0; i < this.currentPage.bodyWidgets.length; i++) {
                    let bodyWidgets = this.currentPage.bodyWidgets[i];
                    widget = this.selection.getLineWidgetBodyWidget(bodyWidgets, cursorPoint);
                    if (!isNullOrUndefined(widget)) {
                        break;
                    }
                }
            }
        }
        return widget;
    }
    /**
     * @private
     */
    isBlockInHeader(block) {
        while (!(block.containerWidget instanceof HeaderFooterWidget)) {
            if (!block.containerWidget) {
                return false;
            }
            block = block.containerWidget;
        }
        return block.containerWidget.headerFooterType.indexOf('Header') !== -1;
    }
    /**
     * Clears selection highlight.
     * @private
     */
    clearSelectionHighlight() {
        let canClear = true;
        canClear = (!this.isControlPressed || !this.isMouseDown);
        // if (this.owner.selection.selectionRanges.length > 0 && canClear) {
        if (this.owner.selection.clearSelectionHighlightInSelectedWidgets()) {
            this.selectionContext.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
        }
        // } else if (!isNullOrUndefined(this.owner.selection.currentSelectionRange) && this.isMouseDown) {
        //     this.owner.selection.currentSelectionRange.clearSelectionHighlight();
        // }
        //this.renderVisiblePages();
    }
    /**
     * @private
     */
    removeEmptyPages() {
        let scrollToLastPage = false;
        let viewer = this;
        for (let j = 0; j < this.pages.length; j++) {
            let page = this.pages[j];
            if (page.bodyWidgets.length === 0 || page.bodyWidgets[0].childWidgets.length === 0) {
                // tslint:disable-next-line:max-line-length
                if (j === this.pages.length - 1 && viewer instanceof PageLayoutViewer && viewer.visiblePages.indexOf(this.pages[j]) !== -1) {
                    scrollToLastPage = true;
                }
                this.removePage(this.pages[j]);
                j--;
            }
        }
        if (scrollToLastPage) {
            this.scrollToBottom();
        }
    }
    /**
     * @private
     */
    scrollToBottom() {
        if (this.selection.start.paragraph && this.selection.start.paragraph.bodyWidget) {
            let page = this.selection.start.paragraph.bodyWidget.page;
            let containerHeight = this.visibleBounds.height;
            this.viewerContainer.scrollTop = page.boundingRectangle.bottom - containerHeight;
        }
    }
    /**
     * Returns the field code result.
     * @private
     */
    getFieldResult(fieldBegin, page) {
        if (!isNullOrUndefined(page) && !isNullOrUndefined(this.selection)) {
            let fieldCode = this.selection.getFieldCode(fieldBegin);
            let fieldCodes = fieldCode.split('\*');
            if (fieldCodes.length > 1) {
                let fieldCategory = fieldCodes[0].replace(/[^\w\s]/gi, '').trim().toLowerCase();
                let fieldPattern = fieldCodes[1].replace(/[^\w\s]/gi, '').trim();
                switch (fieldCategory) {
                    case 'page':
                        return this.getFieldText(fieldPattern, (page.index + 1));
                    case 'numpages':
                        return this.getFieldText(fieldPattern, page.viewer.pages.length);
                    default:
                        break;
                }
            }
        }
        return '';
    }
    /**
     * Returns field text.
     */
    getFieldText(pattern, value) {
        switch (pattern) {
            case 'ALPHABETIC':
                return this.layout.getAsLetter(value).toUpperCase();
            case 'alphabetic':
                return this.layout.getAsLetter(value).toLowerCase();
            case 'roman':
                return this.layout.getAsRoman(value).toLowerCase();
            case 'ROMAN':
                return this.layout.getAsRoman(value).toUpperCase();
            default:
                return value.toString();
        }
    }
    /**
     * Destroys the internal objects maintained for control.
     */
    destroy() {
        if (!isNullOrUndefined(this.owner)) {
            this.unWireEvent();
        }
        this.pages = [];
        this.pages = undefined;
        this.fieldStacks = [];
        this.fieldStacks = undefined;
        this.splittedCellWidgets = [];
        this.splittedCellWidgets = undefined;
        this.fields = [];
        this.fields = undefined;
        if (this.layout) {
            this.layout.destroy();
        }
        this.layout = undefined;
        if (!isNullOrUndefined(this.render)) {
            this.render.destroy();
        }
        this.render = undefined;
        if (this.dialogInternal) {
            this.dialogInternal.destroy();
        }
        this.dialogInternal = undefined;
        if (this.dialogTarget && this.dialogTarget.parentElement) {
            this.dialogTarget.parentElement.removeChild(this.dialogTarget);
        }
        this.dialogTarget = undefined;
        if (!isNullOrUndefined(this.touchStart)) {
            this.touchStart.innerHTML = '';
        }
        if (this.textHelper) {
            this.textHelper.destroy();
        }
        this.textHelper = undefined;
        this.touchStart = undefined;
        if (!isNullOrUndefined(this.touchEnd)) {
            this.touchEnd.innerHTML = '';
        }
        this.touchEnd = undefined;
        if (!isNullOrUndefined(this.containerCanvasIn)) {
            this.containerCanvasIn.innerHTML = '';
        }
        this.containerCanvasIn = undefined;
        if (!isNullOrUndefined(this.selectionCanvasIn)) {
            this.selectionCanvasIn.innerHTML = '';
        }
        this.selectionCanvasIn = undefined;
        if (!isNullOrUndefined(this.editableDiv)) {
            this.editableDiv.innerHTML = '';
            this.editableDiv.parentElement.removeChild(this.editableDiv);
        }
        this.editableDiv = undefined;
        if (!isNullOrUndefined(this.pageContainer)) {
            this.pageContainer.innerHTML = '';
        }
        this.pageContainer = undefined;
        if (!isNullOrUndefined(this.viewerContainer)) {
            this.viewerContainer.innerHTML = '';
        }
        this.viewerContainer = undefined;
        this.owner = undefined;
        this.heightInfoCollection = undefined;
    }
    /**
     * Un-Wires events and methods
     */
    unWireEvent() {
        this.viewerContainer.removeEventListener('scroll', this.scrollHandler);
        this.viewerContainer.removeEventListener('mousedown', this.onMouseDownInternal);
        this.viewerContainer.removeEventListener('mousemove', this.onMouseMoveInternal);
        if (Browser.isIE) {
            this.editableDiv.removeEventListener('keypress', this.onKeyPressInternal);
        }
        else {
            this.editableDiv.removeEventListener('input', this.onTextInputInternal);
        }
        this.editableDiv.removeEventListener('paste', this.onPaste);
        this.viewerContainer.removeEventListener('contextmenu', this.onContextMenu);
        this.editableDiv.removeEventListener('blur', this.onFocusOut);
        this.editableDiv.removeEventListener('keydown', this.onKeyDownInternal);
        this.editableDiv.removeEventListener('compositionstart', this.compositionStart);
        this.editableDiv.removeEventListener('compositionupdate', this.compositionUpdated);
        this.editableDiv.removeEventListener('compositionend', this.compositionEnd);
        this.viewerContainer.removeEventListener('mouseup', this.onMouseUpInternal);
        this.viewerContainer.removeEventListener('dblclick', this.onDoubleTap);
        window.removeEventListener('resize', this.onWindowResize);
        window.removeEventListener('keyup', this.onKeyUpInternal);
        window.removeEventListener('mouseup', this.onImageResizer);
        window.removeEventListener('touchend', this.onImageResizer);
    }
}
/**
 * @private
 */
class PageLayoutViewer extends LayoutViewer {
    /**
     * Initialize the constructor of PageLayoutViewer
     */
    constructor(owner) {
        super(owner);
        this.pageLeft = 30;
        /**
         * @private
         */
        this.pageGap = 20;
        /**
         * @private
         */
        this.visiblePages = [];
        if (isNullOrUndefined(owner) || isNullOrUndefined(owner.element)) {
            return;
        }
    }
    /**
     * Creates new page.
     * @private
     */
    createNewPage(section, index) {
        let viewer = this;
        let yPos = this.pageGap;
        if (this.pages.length > 0) {
            yPos = this.pages[this.pages.length - 1].boundingRectangle.bottom + this.pageGap;
        }
        let page = new Page();
        page.viewer = this;
        // tslint:disable-next-line:max-line-length
        let pageWidth = !isNullOrUndefined(section.sectionFormat) ? HelperMethods.convertPointToPixel(section.sectionFormat.pageWidth) : 816;
        // tslint:disable-next-line:max-line-length
        let pageHeight = !isNullOrUndefined(section.sectionFormat) ? HelperMethods.convertPointToPixel(section.sectionFormat.pageHeight) : 1056;
        let xPos = (this.visibleBounds.width - pageWidth * this.zoomFactor) / 2;
        if (xPos < this.pageLeft) {
            xPos = this.pageLeft;
        }
        page.boundingRectangle = new Rect(xPos, yPos, pageWidth, pageHeight);
        if (isNullOrUndefined(index)) {
            this.pages.push(page);
        }
        else {
            this.pages.splice(index, 0, page);
        }
        this.updateClientArea(section.sectionFormat, page);
        page.bodyWidgets.push(section);
        page.bodyWidgets[page.bodyWidgets.length - 1].page = page;
        this.layout.layoutHeaderFooter(section, viewer, page);
        this.updateClientArea(section.sectionFormat, page);
        return page;
    }
    /**
     * Updates cursor.
     */
    updateCursor(event) {
        let hyperlinkField = undefined;
        let div = this.viewerContainer;
        let point = new Point(event.offsetX, event.offsetY);
        let touchPoint = this.findFocusedPage(point, true);
        let widget = this.getLineWidget(touchPoint);
        let widgetInfo;
        let left;
        let top;
        let editor = !this.owner.isReadOnlyMode ? this.owner.editorModule : undefined;
        let isRowResize = editor ? editor.tableResize.isInRowResizerArea(touchPoint) : false;
        let isCellResize = editor ? editor.tableResize.isInCellResizerArea(touchPoint) : false;
        let resizePosition = '';
        if (this.owner.enableImageResizerMode) {
            let resizeObj = this.owner.imageResizerModule.getImagePoint(touchPoint);
            this.owner.imageResizerModule.selectedResizeElement = resizeObj.selectedElement;
            resizePosition = resizeObj.resizePosition;
        }
        let lineLeft = 0;
        if (!isNullOrUndefined(widget)) {
            lineLeft = this.selection.getLineStartLeft(widget);
            hyperlinkField = this.selection.getHyperLinkFieldInCurrentSelection(widget, touchPoint);
            widgetInfo = this.selection.updateTextPositionIn(widget, undefined, 0, touchPoint, true);
            left = this.selection.getLeft(widget);
            top = this.selection.getTop(widget);
            this.selection.setHyperlinkContentToToolTip(hyperlinkField, widget, touchPoint.x);
        }
        if (!isNullOrUndefined(hyperlinkField) && (event.ctrlKey &&
            this.owner.useCtrlClickToFollowHyperlink || !this.owner.useCtrlClickToFollowHyperlink)) {
            div.style.cursor = 'pointer';
            return;
        }
        else if (touchPoint.x >= lineLeft &&
            event.offsetX < (this.visibleBounds.width - (this.visibleBounds.width - this.viewerContainer.clientWidth)) &&
            event.offsetY < (this.visibleBounds.height - (this.visibleBounds.height - this.viewerContainer.clientHeight))) {
            if (this.selection.isEmpty) {
                div.style.cursor = 'text';
            }
            else {
                div.style.cursor = this.selection.checkCursorIsInSelection(widget, touchPoint) ? 'default' : 'text';
            }
        }
        else {
            div.style.cursor = 'default';
        }
        if (!isNullOrUndefined(resizePosition) && resizePosition !== '') {
            div.style.cursor = resizePosition;
        }
        else if (!isNullOrUndefined(widgetInfo) && widgetInfo.isImageSelected && left < touchPoint.x && top < touchPoint.y &&
            left + widget.width > touchPoint.x && top + widget.height > touchPoint.y) {
            div.style.cursor = 'move';
        }
        if (isRowResize) {
            div.style.cursor = 'row-resize';
        }
        else if (isCellResize) {
            div.style.cursor = 'col-resize';
        }
    }
    /**
     * Finds focused page.
     * @private
     */
    findFocusedPage(currentPoint, updateCurrentPage) {
        let point = new Point(currentPoint.x, currentPoint.y);
        point.x += this.viewerContainer.scrollLeft;
        point.y += this.viewerContainer.scrollTop;
        for (let i = 0; i < this.pages.length; i++) {
            let page = this.pages[i];
            let pageTop = (page.boundingRectangle.y - this.pageGap * (i + 1)) * this.zoomFactor + this.pageGap * (i + 1);
            let pageHeight = (page.boundingRectangle.height * this.zoomFactor) + this.pageGap;
            let pageLeft = page.boundingRectangle.x;
            let pageRight = ((page.boundingRectangle.right - pageLeft) * this.zoomFactor) + pageLeft;
            if (pageTop <= point.y && pageTop + pageHeight >= point.y) {
                if (updateCurrentPage) {
                    this.currentPage = page;
                }
                point.y = (point.y - (pageTop)) / this.zoomFactor;
                if (point.x > pageRight) {
                    point.x = page.boundingRectangle.right;
                }
                else if (point.x < pageLeft) {
                    point.x = 0;
                }
                else {
                    point.x = (point.x - pageLeft) / this.zoomFactor;
                }
                return point;
            }
        }
        return point;
    }
    /**
     * Fired when page fit type changed.
     * @private
     */
    onPageFitTypeChanged(pageFitType) {
        let width = this.visibleBounds.width;
        let height = this.visibleBounds.height;
        let section = this.visiblePages[0].bodyWidgets[0];
        let pageWidth = HelperMethods.convertPointToPixel(section.sectionFormat.pageWidth);
        let pageHeight = HelperMethods.convertPointToPixel(section.sectionFormat.pageHeight);
        switch (pageFitType) {
            case 'FitOnePage':
                if (height > 0 && pageHeight > 0) {
                    let zoomFactor = (this.visibleBounds.height - 2 * this.pageGap - (this.pageGap - 2)) / pageHeight;
                    if (zoomFactor === this.zoomFactor) {
                        if (!isNullOrUndefined(this.owner.selection) && !isNullOrUndefined(this.owner.selection.start) &&
                            !isNullOrUndefined(this.owner.selection.end)) {
                            this.scrollToPosition(this.owner.selection.start, this.owner.selection.end);
                        }
                    }
                    else {
                        this.zoomFactor = zoomFactor;
                    }
                }
                break;
            case 'FitPageWidth':
                if (width > 0 && pageWidth > 0) {
                    this.zoomFactor = (this.visibleBounds.width - 80) / pageWidth;
                }
                break;
            default:
                this.zoomFactor = 100 / 100;
                break;
        }
    }
    /**
     * @private
     */
    handleZoom() {
        let prevScaleFactor = this.preZoomFactor;
        let page = null;
        let verticalHeight = 0;
        let scrollToPosition = false;
        if (this.selection && isNullOrUndefined(this.zoomX && isNullOrUndefined(this.zoomY))) {
            let x = 0;
            let y = 0;
            let endPage = this.selection.getPage(this.selection.end.currentWidget.paragraph);
            x = (this.visibleBounds.width - endPage.boundingRectangle.width * prevScaleFactor) / 2;
            if (x < 30) {
                x = 30;
            }
            // tslint:disable-next-line:max-line-length
            y = endPage.boundingRectangle.y * prevScaleFactor + (this.pages.indexOf(endPage) + 1) * this.pageGap * (1 - prevScaleFactor);
            let caretInfo = this.selection.updateCaretSize(this.owner.selection.end, true);
            let topMargin = caretInfo.topMargin;
            let caretHeight = caretInfo.height;
            x += (this.selection.end.location.x) * prevScaleFactor;
            y += (this.selection.end.location.y + topMargin) * prevScaleFactor;
            if (x >= this.containerLeft && x <= this.visibleBounds.width &&
                y >= this.containerTop && y <= this.containerTop + this.visibleBounds.height) {
                scrollToPosition = true;
            }
        }
        for (let i = 0; i < this.pages.length; i++) {
            verticalHeight = verticalHeight + this.pages[i].boundingRectangle.height;
        }
        let horizontalWidth = 0;
        for (let i = 0; i < this.pages.length; i++) {
            if (horizontalWidth < this.pages[i].boundingRectangle.width) {
                horizontalWidth = this.pages[i].boundingRectangle.width;
            }
        }
        // tslint:disable-next-line:max-line-length
        let height = (verticalHeight * this.zoomFactor + (this.pages.length + 1) * this.pageGap * (1 - this.zoomFactor)) - this.visibleBounds.height;
        let horWidth = horizontalWidth * this.zoomFactor - this.visibleBounds.width;
        if (this.visibleBounds.width - horizontalWidth * this.zoomFactor < 60) {
            horWidth += 60;
        }
        //Update Vertical Scroll bar
        if (height > 0) {
            let value = this.containerTop;
            if (this.visiblePages.length > 0) {
                page = this.visiblePages[0];
                // tslint:disable-next-line:max-line-length
                let prevPageTop = (page.boundingRectangle.y - (page.index + 1) * this.pageGap) * prevScaleFactor + (page.index + 1) * this.pageGap;
                let zoomY = this.zoomY;
                if (isNullOrUndefined) {
                    zoomY = this.visibleBounds.height / 2;
                }
                let prevY = value + zoomY;
                while (prevY > prevPageTop + (page.boundingRectangle.height * prevScaleFactor)) {
                    let pageIndex = page.index + 1;
                    if (pageIndex === this.pages.length) {
                        break;
                    }
                    page = this.pages[pageIndex];
                    // tslint:disable-next-line:max-line-length
                    prevPageTop = (page.boundingRectangle.y - (page.index + 1) * this.pageGap) * prevScaleFactor + (page.index + 1) * this.pageGap;
                }
                // tslint:disable-next-line:max-line-length
                let currentY = (page.boundingRectangle.y - (page.index + 1) * this.pageGap) * this.zoomFactor + (page.index + 1) * this.pageGap
                    + ((prevY - prevPageTop) < 0 ? prevY - prevPageTop : (prevY - prevPageTop) * (this.zoomFactor / prevScaleFactor));
                value = currentY - zoomY;
                zoomY = this.visibleBounds.height / 2;
            }
            this.viewerContainer.scrollTop = value;
        }
        else {
            this.viewerContainer.scrollTop = 0;
        }
        // update Horizontal Scroll Bar
        if (horWidth > 0) {
            let value = this.containerLeft;
            if (this.visiblePages.length > 0) {
                if (page === null) {
                    page = this.visiblePages[0];
                }
                let zoomX = this.zoomX;
                if (isNullOrUndefined(zoomX)) {
                    zoomX = this.visibleBounds.width / 2;
                }
                let prevValue = (page.boundingRectangle.width * prevScaleFactor) / page.boundingRectangle.width;
                let prevX = value + zoomX;
                // tslint:disable-next-line:max-line-length
                let currentX = page.boundingRectangle.x
                    + ((prevX - page.boundingRectangle.x) < 0 ? prevX - page.boundingRectangle.x : (prevX - page.boundingRectangle.x) * (this.zoomFactor / prevValue));
                value = currentX - zoomX;
                zoomX = this.visibleBounds.width / 2;
            }
            this.viewerContainer.scrollLeft = value;
        }
        else {
            this.viewerContainer.scrollLeft = 0;
        }
        this.updateScrollBars();
        if (scrollToPosition) {
            this.scrollToPosition(this.selection.start, this.selection.end);
        }
    }
    /**
     * Gets current page header footer.
     * @private
     */
    getCurrentPageHeaderFooter(section, isHeader) {
        return this.getCurrentHeaderFooter(this.getHeaderFooterType(section, isHeader), section.index);
    }
    /**
     * Get header footer type
     * @private
     */
    getHeaderFooterType(section, isHeader) {
        let type;
        type = isHeader ? 'OddHeader' : 'OddFooter';
        // tslint:disable-next-line:max-line-length
        if (section.sectionFormat.differentFirstPage && (this.pages.length === 1 || this.pages[this.pages.length - 1].bodyWidgets[0].index !== section.index)) {
            type = isHeader ? 'FirstPageHeader' : 'FirstPageFooter';
        }
        else if (section.sectionFormat.differentOddAndEvenPages && this.pages.length % 2 === 0) {
            type = isHeader ? 'EvenHeader' : 'EvenFooter';
        }
        return type;
    }
    /**
     * Gets current header footer.
     * @param type
     * @param section
     * @private
     */
    getCurrentHeaderFooter(type, sectionIndex) {
        if (this.headersFooters[sectionIndex]) {
            let index = this.getHeaderFooter(type);
            let headerFooter = this.headersFooters[sectionIndex][index];
            if (!headerFooter) {
                headerFooter = this.createHeaderFooterWidget(type);
                this.headersFooters[sectionIndex][index] = headerFooter;
            }
            return headerFooter;
        }
        else if (sectionIndex > 0) {
            return this.getCurrentHeaderFooter(type, sectionIndex - 1);
        }
        return undefined;
    }
    createHeaderFooterWidget(type) {
        let headerFooter = new HeaderFooterWidget(type);
        let paragraph = new ParagraphWidget();
        paragraph.childWidgets.push(new LineWidget(paragraph));
        return headerFooter;
    }
    /**
     * Gets header footer.
     * @param type
     * @private
     */
    getHeaderFooter(type) {
        switch (type) {
            case 'OddHeader':
                return 0;
            case 'OddFooter':
                return 1;
            case 'EvenHeader':
                return 2;
            case 'EvenFooter':
                return 3;
            case 'FirstPageHeader':
                return 4;
            case 'FirstPageFooter':
                return 5;
        }
    }
    /**
     * Updates header footer client area.
     * @private
     */
    updateHFClientArea(sectionFormat, isHeader) {
        // tslint:disable-next-line:max-line-length
        let width = HelperMethods.convertPointToPixel(sectionFormat.pageWidth - sectionFormat.leftMargin - sectionFormat.rightMargin);
        if (width < 0) {
            width = 0;
        }
        if (isHeader) {
            // tslint:disable-next-line:max-line-length
            this.clientArea = new Rect(HelperMethods.convertPointToPixel(sectionFormat.leftMargin), HelperMethods.convertPointToPixel(sectionFormat.headerDistance), width, Number.POSITIVE_INFINITY);
        }
        else {
            // tslint:disable-next-line:max-line-length
            this.clientArea = new Rect(HelperMethods.convertPointToPixel(sectionFormat.leftMargin), HelperMethods.convertPointToPixel(sectionFormat.pageHeight - sectionFormat.footerDistance), width, Number.POSITIVE_INFINITY);
        }
        this.clientActiveArea = new Rect(this.clientArea.x, this.clientArea.y, this.clientArea.width, this.clientArea.height);
    }
    /**
     * @private
     */
    updateHCFClientAreaWithTop(sectionFormat, isHeader, page) {
        this.updateHFClientArea(sectionFormat, isHeader);
        if (!isHeader) {
            if (page.footerWidget.y < this.clientActiveArea.y) {
                this.clientActiveArea.y = page.footerWidget.y;
                this.clientActiveArea.height = Number.POSITIVE_INFINITY;
            }
        }
    }
    /**
     * Scrolls to the specified page
     * @private
     */
    scrollToPage(pageIndex) {
        let top = 0;
        for (let i = 0; i < this.pages.length; i++) {
            top = this.pages[i].boundingRectangle.y - (this.pageGap / 2);
            if (i === pageIndex) {
                break;
            }
        }
        this.viewerContainer.scrollTop = top;
        this.updateScrollBars();
    }
    /**
     * Updates scroll bars.
     * @private
     */
    updateScrollBars() {
        let height = 0;
        for (let i = 0; i < this.pages.length; i++) {
            height = height + this.pages[i].boundingRectangle.height;
        }
        let width = 0;
        for (let i = 0; i < this.pages.length; i++) {
            if (width < this.pages[i].boundingRectangle.width) {
                width = this.pages[i].boundingRectangle.width;
            }
        }
        let containerWidth = (width * this.zoomFactor) + (this.pageLeft * 2);
        let containerHeight = (height * this.zoomFactor) + (this.pages.length + 1) * this.pageGap;
        let viewerWidth = this.visibleBounds.width;
        let viewerHeight = this.visibleBounds.height;
        if (this.visibleBounds.width !== this.viewerContainer.clientWidth) {
            viewerWidth -= (this.visibleBounds.width - this.viewerContainer.clientWidth);
        }
        else if (containerHeight > viewerHeight) {
            viewerWidth -= this.viewerContainer.offsetWidth - this.viewerContainer.clientWidth;
        }
        if (containerWidth > viewerWidth) {
            viewerHeight -= (this.visibleBounds.height - this.viewerContainer.clientHeight);
        }
        width = containerWidth > viewerWidth ? containerWidth : viewerWidth;
        height = containerHeight > viewerHeight ? containerHeight : viewerHeight;
        if (parseInt(this.pageContainer.style.width.replace('px', ''), 10) !== width ||
            parseInt(this.pageContainer.style.height.replace('px', ''), 10) !== width) {
            this.pageContainer.style.width = width.toString() + 'px';
            this.pageContainer.style.height = height.toString() + 'px';
        }
        // if (!isNullOrUndefined(this.selection) && !this.selection.isEmpty) {
        //     this.selectionContext.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
        // }
        let displayPixelRatio = Math.max(1, window.devicePixelRatio || 1);
        if (this.containerCanvas.width !== Math.floor(viewerWidth * displayPixelRatio)
            || this.containerCanvas.height !== Math.floor(viewerHeight * displayPixelRatio)) {
            this.containerCanvas.width = viewerWidth * displayPixelRatio;
            this.containerCanvas.height = viewerHeight * displayPixelRatio;
            this.containerCanvas.style.width = viewerWidth + 'px';
            this.containerCanvas.style.height = viewerHeight + 'px';
            this.containerContext.scale(displayPixelRatio, displayPixelRatio);
            this.selectionCanvas.width = viewerWidth * displayPixelRatio;
            this.selectionCanvas.height = viewerHeight * displayPixelRatio;
            this.selectionCanvas.style.width = viewerWidth + 'px';
            this.selectionCanvas.style.height = viewerHeight + 'px';
            this.selectionContext.scale(displayPixelRatio, displayPixelRatio);
        }
        this.containerContext.globalAlpha = 1;
        this.selectionContext.globalAlpha = 0.4;
        for (let i = 0; i < this.pages.length; i++) {
            let left = (width - this.pages[i].boundingRectangle.width * this.zoomFactor) / 2;
            if (left > this.pageLeft) {
                // tslint:disable-next-line:max-line-length
                this.pages[i].boundingRectangle = new Rect(left, this.pages[i].boundingRectangle.y, this.pages[i].boundingRectangle.width, this.pages[i].boundingRectangle.height);
            }
            else {
                // tslint:disable-next-line:max-line-length
                this.pages[i].boundingRectangle = new Rect(this.pageLeft, this.pages[i].boundingRectangle.y, this.pages[i].boundingRectangle.width, this.pages[i].boundingRectangle.height);
            }
        }
        this.updateScrollBarPosition(containerWidth, containerHeight, viewerWidth, viewerHeight, width, height);
    }
    // tslint:disable-next-line:max-line-length
    updateScrollBarPosition(containerWidth, containerHeight, viewerWidth, viewerHeight, width, height) {
        let viewerHeight1 = parseFloat(this.viewerContainer.style.height);
        let containerHeight1 = parseFloat(this.pageContainer.style.height);
        this.containerTop = this.viewerContainer.scrollTop;
        this.containerCanvas.style.position = 'absolute';
        this.containerCanvas.style.top = this.containerTop.toString() + 'px';
        this.selectionCanvas.style.position = 'absolute';
        this.selectionCanvas.style.top = this.containerTop.toString() + 'px';
        this.containerLeft = this.viewerContainer.scrollLeft;
        this.containerCanvas.style.left = this.containerLeft + 'px';
        this.selectionCanvas.style.left = this.containerLeft + 'px';
        this.updateVisiblePages();
    }
    /**
     * Updates visible pages.
     * @private
     */
    updateVisiblePages() {
        this.visiblePages = [];
        let height = this.visibleBounds.height;
        let vertical = this.viewerContainer.scrollTop;
        for (let i = 0; i < this.pages.length; i++) {
            let page = this.pages[i];
            let y = (page.boundingRectangle.y - this.pageGap * (i + 1)) * this.zoomFactor + this.pageGap * (i + 1);
            let pageH = page.boundingRectangle.height * this.zoomFactor;
            let left = page.boundingRectangle.x;
            let isTopFit = y >= vertical && y <= vertical + height;
            let isBottomFit = y + pageH >= vertical && y + pageH <= vertical + height;
            let isMiddleFit = y <= vertical && y + pageH >= vertical + height;
            //UI Virtualization
            if (isTopFit || isBottomFit || isMiddleFit) {
                this.addVisiblePage(page, left, y);
            }
        }
    }
    /**
     * Adds visible pages.
     */
    addVisiblePage(page, x, y) {
        let width = page.boundingRectangle.width * this.zoomFactor;
        let height = page.boundingRectangle.height * this.zoomFactor;
        // tslint:disable-next-line:max-line-length
        if (this.owner.enableImageResizerMode && this.owner.imageResizerModule.currentPage !== undefined && this.owner.imageResizerModule.currentPage === page && this.owner.imageResizerModule.isImageResizerVisible) {
            this.owner.imageResizerModule.setImageResizerPositions(x, y, width, height);
        }
        this.visiblePages.push(page);
        this.renderPage(page, x, y, width, height);
    }
    /**
     * Render specified page widgets.
     */
    renderPage(page, x, y, width, height) {
        this.render.renderWidgets(page, x - this.containerLeft, y - this.containerTop, width, height);
    }
    /**
     * Renders visible pages.
     * @private
     */
    renderVisiblePages() {
        if (isNullOrUndefined(this.visiblePages) || this.visiblePages.length < 1) {
            return;
        }
        this.clearContent();
        for (let i = 0; i < this.visiblePages.length; i++) {
            let page = this.visiblePages[i];
            let width = page.boundingRectangle.width * this.zoomFactor;
            let height = page.boundingRectangle.height * this.zoomFactor;
            let x = page.boundingRectangle.x;
            let y = (page.boundingRectangle.y - this.pageGap * (i + 1)) * this.zoomFactor + this.pageGap * (i + 1);
            this.renderPage(page, x, y, width, height);
        }
    }
}

/**
 * @private
 */
class SfdtReader {
    constructor(viewer) {
        /* tslint:disable:no-any */
        this.viewer = undefined;
        this.viewer = viewer;
    }
    get isPasting() {
        return this.viewer && this.viewer.owner.isPastingContent;
    }
    /**
     * @private
     * @param json
     */
    convertJsonToDocument(json) {
        let sections = [];
        let jsonObject = JSON.parse(json);
        this.parseCharacterFormat(jsonObject.characterFormat, this.viewer.characterFormat);
        this.parseParagraphFormat(jsonObject.paragraphFormat, this.viewer.paragraphFormat);
        if (!isNullOrUndefined(jsonObject.background)) {
            this.viewer.backgroundColor = this.getColor(jsonObject.background.color);
        }
        if (!isNullOrUndefined(jsonObject.abstractLists)) {
            this.parseAbstractList(jsonObject, this.viewer.abstractLists);
        }
        if (!isNullOrUndefined(jsonObject.lists)) {
            this.parseList(jsonObject, this.viewer.lists);
        }
        if (!isNullOrUndefined(jsonObject.styles)) {
            this.parseStyles(jsonObject, this.viewer.styles);
        }
        if (!isNullOrUndefined(jsonObject.sections)) {
            this.parseSections(jsonObject.sections, sections);
        }
        return sections;
    }
    parseStyles(data, styles) {
        for (let i = 0; i < data.styles.length; i++) {
            if (isNullOrUndefined(this.viewer.styles.findByName(data.styles[i].name))) {
                this.parseStyle(data, data.styles[i], styles);
            }
        }
    }
    parseStyle(data, style, styles) {
        let wStyle;
        if (!isNullOrUndefined(style.type)) {
            if (style.type === 'Paragraph') {
                wStyle = new WParagraphStyle();
                wStyle.type = 'Paragraph';
            }
            if (style.type === 'Character') {
                wStyle = new WCharacterStyle();
                wStyle.type = 'Character';
            }
            if (!isNullOrUndefined(style.name)) {
                wStyle.name = style.name;
            }
            styles.push(wStyle);
            if (!isNullOrUndefined(style.basedOn)) {
                let basedOn = styles.findByName(style.basedOn);
                if (!isNullOrUndefined(basedOn)) {
                    if (basedOn.type === wStyle.type) {
                        wStyle.basedOn = basedOn;
                    }
                }
                else {
                    let basedStyle = this.getStyle(style.basedOn, data);
                    let styleString;
                    if (!isNullOrUndefined(basedStyle) && basedStyle.type === wStyle.type) {
                        styleString = basedStyle;
                    }
                    else {
                        if (wStyle.type === 'Paragraph') {
                            styleString = JSON.parse('{"type":"Paragraph","name":"Normal","next":"Normal"}');
                        }
                        else {
                            styleString = JSON.parse('{"type": "Character","name": "Default Paragraph Font"}');
                        }
                    }
                    this.parseStyle(data, styleString, styles);
                    wStyle.basedOn = styles.findByName(styleString.name);
                }
            }
            if (!isNullOrUndefined(style.link)) {
                let link = styles.findByName(style.link);
                let linkStyle = this.getStyle(style.link, data);
                let styleString;
                if (isNullOrUndefined(link)) {
                    if (isNullOrUndefined(linkStyle)) {
                        //Construct the CharacterStyle string
                        let charaStyle = {};
                        charaStyle.characterFormat = style.characterFormat;
                        charaStyle.name = style.name + ' Char';
                        charaStyle.type = 'Character';
                        //TODO: Implement basedOn
                        charaStyle.basedOn = style.basedOn === 'Normal' ? 'Default Paragraph Font' : (style.basedOn + ' Char');
                        styleString = charaStyle;
                    }
                    else {
                        styleString = linkStyle;
                    }
                    this.parseStyle(data, styleString, styles);
                    wStyle.link = isNullOrUndefined(styles.findByName(styleString.name)) ? style.link : styles.findByName(styleString.name);
                }
                else {
                    wStyle.link = link;
                }
            }
            if (!isNullOrUndefined(style.characterFormat)) {
                this.parseCharacterFormat(style.characterFormat, wStyle.characterFormat);
            }
            if (!isNullOrUndefined(style.paragraphFormat)) {
                this.parseParagraphFormat(style.paragraphFormat, wStyle.paragraphFormat);
            }
            if (!isNullOrUndefined(style.next)) {
                if (style.next === style.name) {
                    wStyle.next = wStyle;
                }
                else {
                    let next = styles.findByName(style.next);
                    if (!isNullOrUndefined(next) && next.type === wStyle.type) {
                        wStyle.next = next;
                    }
                    else {
                        let nextStyleString = this.getStyle(style.next, data);
                        if (!isNullOrUndefined(nextStyleString)) {
                            this.parseStyle(data, nextStyleString, styles);
                            wStyle.next = styles.findByName(nextStyleString.name);
                        }
                        else {
                            wStyle.next = wStyle;
                        }
                    }
                }
            }
        }
    }
    getStyle(name, data) {
        for (let i = 0; i < data.styles.length; i++) {
            if (data.styles[i].name === name) {
                return data.styles[i];
            }
        }
        return undefined;
    }
    parseAbstractList(data, abstractLists) {
        for (let i = 0; i < data.abstractLists.length; i++) {
            let abstractList = new WAbstractList();
            let abstract = data.abstractLists[i];
            abstractLists.push(abstractList);
            if (!isNullOrUndefined(abstract)) {
                if (!isNullOrUndefined(abstract.abstractListId)) {
                    abstractList.abstractListId = abstract.abstractListId;
                }
                if (!isNullOrUndefined(abstract.levels)) {
                    for (let j = 0; j < abstract.levels.length; j++) {
                        let level = abstract.levels[j];
                        if (!isNullOrUndefined(level)) {
                            let listLevel = this.parseListLevel(level, abstractList);
                            abstractList.levels.push(listLevel);
                        }
                    }
                }
            }
        }
    }
    parseListLevel(data, owner) {
        let listLevel = new WListLevel(owner);
        if (data.listLevelPattern === 'Bullet') {
            listLevel.listLevelPattern = 'Bullet';
            listLevel.numberFormat = !isNullOrUndefined(data.numberFormat) ? data.numberFormat : '';
        }
        else {
            listLevel.listLevelPattern = data.listLevelPattern;
            listLevel.startAt = data.startAt;
            listLevel.numberFormat = !isNullOrUndefined(data.numberFormat) ? data.numberFormat : '';
            if (data.restartLevel >= 0) {
                listLevel.restartLevel = data.restartLevel;
            }
            else {
                listLevel.restartLevel = data.levelNumber;
            }
        }
        listLevel.followCharacter = data.followCharacter;
        this.parseCharacterFormat(data.characterFormat, listLevel.characterFormat);
        this.parseParagraphFormat(data.paragraphFormat, listLevel.paragraphFormat);
        return listLevel;
    }
    parseList(data, listCollection) {
        for (let i = 0; i < data.lists.length; i++) {
            let list = new WList();
            let lists = data.lists[i];
            if (!isNullOrUndefined(lists.abstractListId)) {
                list.abstractListId = lists.abstractListId;
                list.abstractList = this.viewer.getAbstractListById(lists.abstractListId);
            }
            listCollection.push(list);
            if (!isNullOrUndefined(lists.listId)) {
                list.listId = lists.listId;
            }
            if (lists.hasOwnProperty('levelOverrides')) {
                this.parseLevelOverride(lists.levelOverrides, list);
            }
        }
    }
    parseLevelOverride(data, list) {
        if (isNullOrUndefined(data)) {
            return;
        }
        for (let i = 0; i < data.length; i++) {
            let levelOverrides = new WLevelOverride();
            let levelOverride = data[i];
            levelOverrides.startAt = levelOverride.startAt;
            levelOverrides.levelNumber = levelOverride.levelNumber;
            if (!isNullOrUndefined(levelOverride.overrideListLevel)) {
                levelOverrides.overrideListLevel = this.parseListLevel(levelOverride.overrideListLevel, levelOverrides);
            }
            list.levelOverrides.push(levelOverrides);
        }
    }
    parseSections(data, sections) {
        for (let i = 0; i < data.length; i++) {
            let section = new BodyWidget();
            section.sectionFormat = new WSectionFormat(section);
            section.index = i;
            let item = data[i];
            if (!isNullOrUndefined(item.sectionFormat)) {
                this.parseSectionFormat(item.sectionFormat, section.sectionFormat);
            }
            if (isNullOrUndefined(item.headersFooters)) {
                item.headersFooters = {};
            }
            this.viewer.headersFooters.push(this.parseHeaderFooter(item.headersFooters, this.viewer.headersFooters));
            this.parseTextBody(item.blocks, section);
            for (let i = 0; i < section.childWidgets.length; i++) {
                section.childWidgets[i].containerWidget = section;
            }
            sections.push(section);
        }
    }
    /**
     * @private
     */
    parseHeaderFooter(data, headersFooters) {
        let hfs = {};
        if (!isNullOrUndefined(data.header)) {
            let oddHeader = new HeaderFooterWidget('OddHeader');
            hfs[0] = oddHeader;
            this.parseTextBody(data.header.blocks, oddHeader);
        }
        if (!isNullOrUndefined(data.footer)) {
            let oddFooter = new HeaderFooterWidget('OddFooter');
            hfs[1] = oddFooter;
            this.parseTextBody(data.footer.blocks, oddFooter);
        }
        if (!isNullOrUndefined(data.evenHeader)) {
            let evenHeader = new HeaderFooterWidget('EvenHeader');
            hfs[2] = evenHeader;
            this.parseTextBody(data.evenHeader.blocks, evenHeader);
        }
        if (!isNullOrUndefined(data.evenFooter)) {
            let evenFooter = new HeaderFooterWidget('EvenFooter');
            hfs[3] = evenFooter;
            this.parseTextBody(data.evenFooter.blocks, evenFooter);
        }
        if (!isNullOrUndefined(data.firstPageHeader)) {
            let firstPageHeader = new HeaderFooterWidget('FirstPageHeader');
            hfs[4] = firstPageHeader;
            this.parseTextBody(data.firstPageHeader.blocks, firstPageHeader);
        }
        if (!isNullOrUndefined(data.firstPageFooter)) {
            let firstPageFooter = new HeaderFooterWidget('FirstPageFooter');
            hfs[5] = firstPageFooter;
            this.parseTextBody(data.firstPageFooter.blocks, firstPageFooter);
        }
        return hfs;
    }
    parseTextBody(data, section) {
        this.parseBody(data, section.childWidgets, section);
    }
    parseBody(data, blocks, container) {
        if (!isNullOrUndefined(data)) {
            for (let i = 0; i < data.length; i++) {
                let block = data[i];
                if (block.hasOwnProperty('inlines')) {
                    let writeInlineFormat = false;
                    //writeInlineFormat = this.isPasting && i === data.length - 1;
                    let paragraph = new ParagraphWidget();
                    paragraph.characterFormat = new WCharacterFormat(paragraph);
                    paragraph.paragraphFormat = new WParagraphFormat(paragraph);
                    this.parseCharacterFormat(block.characterFormat, paragraph.characterFormat);
                    this.parseParagraphFormat(block.paragraphFormat, paragraph.paragraphFormat);
                    let styleObj;
                    if (!isNullOrUndefined(block.paragraphFormat) && !isNullOrUndefined(block.paragraphFormat.styleName)) {
                        styleObj = this.viewer.styles.findByName(block.paragraphFormat.styleName, 'Paragraph');
                        if (!isNullOrUndefined(styleObj)) {
                            paragraph.paragraphFormat.ApplyStyle(styleObj);
                        }
                    }
                    if (block.inlines.length > 0) {
                        this.parseParagraph(block.inlines, paragraph, writeInlineFormat);
                    }
                    blocks.push(paragraph);
                    paragraph.index = i;
                    paragraph.containerWidget = container;
                }
                else if (block.hasOwnProperty('rows')) {
                    this.parseTable(block, blocks, i, container);
                }
            }
        }
    }
    parseTable(block, blocks, index, section) {
        let table = new TableWidget();
        table.index = index;
        table.tableFormat = new WTableFormat(table);
        if (!isNullOrUndefined(block.tableFormat)) {
            this.parseTableFormat(block.tableFormat, table.tableFormat);
        }
        table.title = block.title;
        table.description = block.description;
        for (let i = 0; i < block.rows.length; i++) {
            let row = new TableRowWidget();
            row.rowFormat = new WRowFormat(row);
            let tableRow = block.rows[i];
            if (tableRow.hasOwnProperty('rowFormat')) {
                this.parseRowFormat(tableRow.rowFormat, row.rowFormat);
                this.parseRowGridValues(tableRow, row.rowFormat);
                this.parseRowGridValues(tableRow.rowFormat, row.rowFormat);
                row.index = i;
                for (let j = 0; j < block.rows[i].cells.length; j++) {
                    let cell = new TableCellWidget();
                    cell.cellFormat = new WCellFormat(cell);
                    row.childWidgets.push(cell);
                    cell.containerWidget = row;
                    cell.index = j;
                    cell.rowIndex = i;
                    if (block.rows[i].cells[j].hasOwnProperty('cellFormat')) {
                        this.parseCellFormat(block.rows[i].cells[j].cellFormat, cell.cellFormat);
                    }
                    this.parseTextBody(block.rows[i].cells[j].blocks, cell);
                }
            }
            table.childWidgets.push(row);
            row.containerWidget = table;
        }
        table.containerWidget = section;
        blocks.push(table);
        table.isGridUpdated = false;
    }
    parseRowGridValues(data, rowFormat) {
        if (!isNullOrUndefined(data.gridBefore)) {
            rowFormat.gridBefore = data.gridBefore;
        }
        if (!isNullOrUndefined(data.gridBeforeWidth)) {
            rowFormat.gridBeforeWidth = data.gridBeforeWidth;
        }
        if (!isNullOrUndefined(data.gridBeforeWidthType)) {
            rowFormat.gridBeforeWidthType = data.gridBeforeWidthType;
        }
        if (!isNullOrUndefined(data.gridAfter)) {
            rowFormat.gridAfter = data.gridAfter;
        }
        if (!isNullOrUndefined(data.gridAfterWidth)) {
            rowFormat.gridAfterWidth = data.gridAfterWidth;
        }
        if (!isNullOrUndefined(data.gridAfterWidthType)) {
            rowFormat.gridAfterWidthType = data.gridAfterWidthType;
        }
    }
    parseParagraph(data, paragraph, writeInlineFormat) {
        let lineWidget = new LineWidget(paragraph);
        for (let i = 0; i < data.length; i++) {
            let inline = data[i];
            if (inline.hasOwnProperty('text')) {
                let textElement = undefined;
                if (this.viewer.isPageField) {
                    textElement = new FieldTextElementBox();
                    textElement.fieldBegin = this.viewer.fieldStacks[this.viewer.fieldStacks.length - 1];
                }
                else if (inline.text === '\t') {
                    textElement = new TabElementBox();
                }
                else {
                    textElement = new TextElementBox();
                }
                textElement.characterFormat = new WCharacterFormat(textElement);
                this.parseCharacterFormat(inline.characterFormat, textElement.characterFormat, writeInlineFormat);
                /*�tslint:disable-next-line:max-line-length */
                if (!isNullOrUndefined(inline.characterFormat) && !isNullOrUndefined(inline.characterFormat.styleName)) {
                    let charStyle = this.viewer.styles.findByName(inline.characterFormat.styleName, 'Character');
                    textElement.characterFormat.ApplyStyle(charStyle);
                }
                textElement.text = inline.text;
                textElement.line = lineWidget;
                lineWidget.children.push(textElement);
            }
            else if (inline.hasOwnProperty('imageString')) {
                let image = new ImageElementBox(data[i].isInlineImage);
                image.isMetaFile = data[i].isMetaFile;
                image.characterFormat = new WCharacterFormat(image);
                image.line = lineWidget;
                lineWidget.children.push(image);
                image.imageString = inline.imageString;
                image.width = HelperMethods.convertPointToPixel(inline.width);
                image.height = HelperMethods.convertPointToPixel(inline.height);
                this.parseCharacterFormat(inline.characterFormat, image.characterFormat);
            }
            else if (inline.hasOwnProperty('hasFieldEnd') || (inline.hasOwnProperty('fieldType') && inline.fieldType === 0)) {
                let fieldBegin = new FieldElementBox(0);
                fieldBegin.hasFieldEnd = inline.hasFieldEnd;
                this.viewer.fieldStacks.push(fieldBegin);
                fieldBegin.line = lineWidget;
                this.viewer.fields.push(fieldBegin);
                lineWidget.children.push(fieldBegin);
            }
            else if (inline.hasOwnProperty('fieldType')) {
                let field = undefined;
                if (inline.fieldType === 2) {
                    field = new FieldElementBox(2);
                    this.fieldSeparator = field;
                    if (this.viewer.fieldStacks.length > 0) {
                        field.fieldBegin = this.viewer.fieldStacks[this.viewer.fieldStacks.length - 1];
                        field.fieldBegin.fieldSeparator = field;
                        //finds the whether the field is page filed or not
                        let lineWidgetCount = lineWidget.children.length;
                        if (lineWidgetCount >= 2 && (lineWidget.children[lineWidgetCount - 2] instanceof FieldElementBox)
                            && lineWidget.children[lineWidgetCount - 2].hasFieldEnd
                            && (lineWidget.children[lineWidgetCount - 1] instanceof TextElementBox)) {
                            let fieldElementText = lineWidget.children[lineWidgetCount - 1].text;
                            if (fieldElementText.match('PAGE')) {
                                this.viewer.isPageField = true;
                            }
                        }
                    }
                }
                else if (inline.fieldType === 1) {
                    field = new FieldElementBox(1);
                    //For Field End Updated begin and separator.                                      
                    if (this.viewer.fieldStacks.length > 0) {
                        field.fieldBegin = this.viewer.fieldStacks[this.viewer.fieldStacks.length - 1];
                        field.fieldBegin.fieldEnd = field;
                    }
                    if (!isNullOrUndefined(field.fieldBegin) && field.fieldBegin.fieldSeparator) {
                        field.fieldSeparator = field.fieldBegin.fieldSeparator;
                        field.fieldBegin.fieldSeparator.fieldEnd = field;
                    }
                    //After setting all the property clear the field values
                    this.viewer.fieldStacks.splice(this.viewer.fieldStacks.length - 1, 1);
                    this.fieldSeparator = undefined;
                    this.viewer.isPageField = false;
                    this.viewer.fieldCollection.push(field.fieldBegin);
                }
                field.line = lineWidget;
                lineWidget.children.push(field);
            }
            else if (inline.hasOwnProperty('bookmarkType')) {
                let bookmark = undefined;
                bookmark = new BookmarkElementBox(inline.bookmarkType);
                bookmark.name = inline.name;
                lineWidget.children.push(bookmark);
                bookmark.line = lineWidget;
                if (inline.bookmarkType === 0) {
                    this.viewer.bookmarks.add(bookmark.name, bookmark);
                }
                else if (inline.bookmarkType === 1) {
                    if (this.viewer.bookmarks.containsKey(bookmark.name)) {
                        let bookmarkStart = this.viewer.bookmarks.get(bookmark.name);
                        bookmarkStart.reference = bookmark;
                        bookmark.reference = bookmarkStart;
                    }
                }
            }
        }
        paragraph.childWidgets.push(lineWidget);
    }
    parseTableFormat(sourceFormat, tableFormat) {
        this.parseBorders(sourceFormat.borders, tableFormat.borders);
        if (!isNullOrUndefined(sourceFormat.cellSpacing)) {
            tableFormat.cellSpacing = sourceFormat.cellSpacing;
        }
        if (!isNullOrUndefined(sourceFormat.leftMargin)) {
            tableFormat.leftMargin = sourceFormat.leftMargin;
        }
        if (!isNullOrUndefined(sourceFormat.topMargin)) {
            tableFormat.topMargin = sourceFormat.topMargin;
        }
        if (!isNullOrUndefined(sourceFormat.rightMargin)) {
            tableFormat.rightMargin = sourceFormat.rightMargin;
        }
        if (!isNullOrUndefined(sourceFormat.bottomMargin)) {
            tableFormat.bottomMargin = sourceFormat.bottomMargin;
        }
        if (!isNullOrUndefined(sourceFormat.leftIndent)) {
            tableFormat.leftIndent = sourceFormat.leftIndent;
        }
        this.parseShading(sourceFormat.shading, tableFormat.shading);
        if (!isNullOrUndefined(sourceFormat.tableAlignment)) {
            tableFormat.tableAlignment = sourceFormat.tableAlignment;
        }
        if (!isNullOrUndefined(sourceFormat.preferredWidth)) {
            tableFormat.preferredWidth = sourceFormat.preferredWidth;
        }
        if (!isNullOrUndefined(sourceFormat.preferredWidthType)) {
            tableFormat.preferredWidthType = sourceFormat.preferredWidthType;
        }
    }
    parseCellFormat(sourceFormat, cellFormat) {
        if (!isNullOrUndefined(sourceFormat)) {
            this.parseBorders(sourceFormat.borders, cellFormat.borders);
            if (!sourceFormat.isSamePaddingAsTable) {
                //    cellFormat.ClearMargins();
                //else
                this.parseCellMargin(sourceFormat, cellFormat);
            }
            if (!isNullOrUndefined(sourceFormat.cellWidth)) {
                cellFormat.cellWidth = sourceFormat.cellWidth;
            }
            if (!isNullOrUndefined(sourceFormat.columnSpan)) {
                cellFormat.columnSpan = sourceFormat.columnSpan;
            }
            if (!isNullOrUndefined(sourceFormat.rowSpan)) {
                cellFormat.rowSpan = sourceFormat.rowSpan;
            }
            this.parseShading(sourceFormat.shading, cellFormat.shading);
            if (!isNullOrUndefined(sourceFormat.verticalAlignment)) {
                cellFormat.verticalAlignment = sourceFormat.verticalAlignment;
            }
            if (!isNullOrUndefined(sourceFormat.preferredWidthType)) {
                cellFormat.preferredWidthType = sourceFormat.preferredWidthType;
            }
            if (!isNullOrUndefined(sourceFormat.preferredWidth)) {
                cellFormat.preferredWidth = sourceFormat.preferredWidth;
            }
        }
    }
    parseCellMargin(sourceFormat, cellFormat) {
        if (!isNullOrUndefined(sourceFormat.leftMargin)) {
            cellFormat.leftMargin = sourceFormat.leftMargin;
        }
        if (!isNullOrUndefined(sourceFormat.rightMargin)) {
            cellFormat.rightMargin = sourceFormat.rightMargin;
        }
        if (!isNullOrUndefined(sourceFormat.topMargin)) {
            cellFormat.topMargin = sourceFormat.topMargin;
        }
        if (!isNullOrUndefined(sourceFormat.bottomMargin)) {
            cellFormat.bottomMargin = sourceFormat.bottomMargin;
        }
    }
    parseRowFormat(sourceFormat, rowFormat) {
        if (!isNullOrUndefined(sourceFormat)) {
            if (!isNullOrUndefined(sourceFormat.allowBreakAcrossPages)) {
                rowFormat.allowBreakAcrossPages = sourceFormat.allowBreakAcrossPages;
            }
            if (!isNullOrUndefined(sourceFormat.isHeader)) {
                rowFormat.isHeader = sourceFormat.isHeader;
            }
            if (!isNullOrUndefined(sourceFormat.heightType)) {
                rowFormat.heightType = sourceFormat.heightType;
            }
            if (!isNullOrUndefined(sourceFormat.height)) {
                rowFormat.height = sourceFormat.height;
            }
            this.parseBorders(sourceFormat.borders, rowFormat.borders);
        }
    }
    parseBorders(sourceBorders, destBorder) {
        if (!isNullOrUndefined(sourceBorders)) {
            this.parseBorder(sourceBorders.left, destBorder.left);
            this.parseBorder(sourceBorders.right, destBorder.right);
            this.parseBorder(sourceBorders.top, destBorder.top);
            this.parseBorder(sourceBorders.bottom, destBorder.bottom);
            this.parseBorder(sourceBorders.vertical, destBorder.vertical);
            this.parseBorder(sourceBorders.horizontal, destBorder.horizontal);
            this.parseBorder(sourceBorders.diagonalDown, destBorder.diagonalDown);
            this.parseBorder(sourceBorders.diagonalUp, destBorder.diagonalUp);
        }
    }
    parseBorder(sourceBorder, destBorder) {
        if (!isNullOrUndefined(sourceBorder)) {
            if (!isNullOrUndefined(sourceBorder.color)) {
                destBorder.color = this.getColor(sourceBorder.color);
            }
            if (!isNullOrUndefined(sourceBorder.lineStyle)) {
                destBorder.lineStyle = sourceBorder.lineStyle;
            }
            if (!isNullOrUndefined(sourceBorder.lineWidth)) {
                destBorder.lineWidth = sourceBorder.lineWidth;
            }
            if (!isNullOrUndefined(sourceBorder.hasNoneStyle)) {
                destBorder.hasNoneStyle = sourceBorder.hasNoneStyle;
            }
        }
    }
    parseShading(sourceShading, destShading) {
        if (!isNullOrUndefined(sourceShading)) {
            if (!isNullOrUndefined(sourceShading.backgroundColor)) {
                destShading.backgroundColor = this.getColor(sourceShading.backgroundColor);
            }
            if (!isNullOrUndefined(sourceShading.foregroundColor)) {
                destShading.foregroundColor = this.getColor(sourceShading.foregroundColor);
            }
            if (!isNullOrUndefined(sourceShading.texture)) {
                destShading.textureStyle = sourceShading.texture;
            }
        }
    }
    parseCharacterFormat(sourceFormat, characterFormat, writeInlineFormat) {
        if (!isNullOrUndefined(sourceFormat)) {
            if (writeInlineFormat && sourceFormat.hasOwnProperty('inlineFormat')) {
                this.parseCharacterFormat(sourceFormat.inlineFormat, characterFormat);
                return;
            }
            if (!isNullOrUndefined(sourceFormat.baselineAlignment)) {
                characterFormat.baselineAlignment = sourceFormat.baselineAlignment;
            }
            if (!isNullOrUndefined(sourceFormat.underline)) {
                characterFormat.underline = sourceFormat.underline;
            }
            if (!isNullOrUndefined(sourceFormat.strikethrough)) {
                characterFormat.strikethrough = sourceFormat.strikethrough;
            }
            if (!isNullOrUndefined(sourceFormat.fontSize)) {
                characterFormat.fontSize = sourceFormat.fontSize;
            }
            if (!isNullOrUndefined(sourceFormat.fontFamily)) {
                characterFormat.fontFamily = sourceFormat.fontFamily;
            }
            if (!isNullOrUndefined(sourceFormat.bold)) {
                characterFormat.bold = sourceFormat.bold;
            }
            if (!isNullOrUndefined(sourceFormat.italic)) {
                characterFormat.italic = sourceFormat.italic;
            }
            if (!isNullOrUndefined(sourceFormat.highlightColor)) {
                characterFormat.highlightColor = sourceFormat.highlightColor;
            }
            if (!isNullOrUndefined(sourceFormat.fontColor)) {
                characterFormat.fontColor = this.getColor(sourceFormat.fontColor);
            }
        }
    }
    getColor(color) {
        let convertColor = color;
        return convertColor || '#ffffff';
    }
    parseParagraphFormat(sourceFormat, paragraphFormat) {
        if (!isNullOrUndefined(sourceFormat)) {
            if (!isNullOrUndefined(sourceFormat.leftIndent)) {
                paragraphFormat.leftIndent = sourceFormat.leftIndent;
            }
            if (!isNullOrUndefined(sourceFormat.rightIndent)) {
                paragraphFormat.rightIndent = sourceFormat.rightIndent;
            }
            if (!isNullOrUndefined(sourceFormat.firstLineIndent)) {
                paragraphFormat.firstLineIndent = sourceFormat.firstLineIndent;
            }
            if (!isNullOrUndefined(sourceFormat.afterSpacing)) {
                paragraphFormat.afterSpacing = sourceFormat.afterSpacing;
            }
            if (!isNullOrUndefined(sourceFormat.beforeSpacing)) {
                paragraphFormat.beforeSpacing = sourceFormat.beforeSpacing;
            }
            if (!isNullOrUndefined(sourceFormat.lineSpacing)) {
                paragraphFormat.lineSpacing = sourceFormat.lineSpacing;
            }
            if (!isNullOrUndefined(sourceFormat.lineSpacingType)) {
                paragraphFormat.lineSpacingType = sourceFormat.lineSpacingType;
            }
            if (!isNullOrUndefined(sourceFormat.textAlignment)) {
                paragraphFormat.textAlignment = sourceFormat.textAlignment;
            }
            if (!isNullOrUndefined(sourceFormat.outlineLevel)) {
                paragraphFormat.outlineLevel = sourceFormat.outlineLevel;
            }
            paragraphFormat.listFormat = new WListFormat();
            if (sourceFormat.hasOwnProperty('listFormat')) {
                this.parseListFormat(sourceFormat, paragraphFormat.listFormat);
            }
            if (sourceFormat.hasOwnProperty('tabs')) {
                this.parseTabStop(sourceFormat.tabs, paragraphFormat.tabs);
            }
        }
    }
    parseListFormat(block, listFormat) {
        if (!isNullOrUndefined(block.listFormat)) {
            if (!isNullOrUndefined(block.listFormat.listId)) {
                listFormat.listId = block.listFormat.listId;
                listFormat.list = this.viewer.getListById(block.listFormat.listId);
            }
            if (!isNullOrUndefined(block.listFormat.listLevelNumber)) {
                listFormat.listLevelNumber = block.listFormat.listLevelNumber;
            }
        }
    }
    parseSectionFormat(data, sectionFormat) {
        if (!isNullOrUndefined(data.pageWidth)) {
            sectionFormat.pageWidth = data.pageWidth;
        }
        if (!isNullOrUndefined(data.pageHeight)) {
            sectionFormat.pageHeight = data.pageHeight;
        }
        if (!isNullOrUndefined(data.leftMargin)) {
            sectionFormat.leftMargin = data.leftMargin;
        }
        if (!isNullOrUndefined(data.topMargin)) {
            sectionFormat.topMargin = data.topMargin;
        }
        if (!isNullOrUndefined(data.rightMargin)) {
            sectionFormat.rightMargin = data.rightMargin;
        }
        if (!isNullOrUndefined(data.bottomMargin)) {
            sectionFormat.bottomMargin = data.bottomMargin;
        }
        if (!isNullOrUndefined(data.headerDistance)) {
            sectionFormat.headerDistance = data.headerDistance;
        }
        if (!isNullOrUndefined(data.footerDistance)) {
            sectionFormat.footerDistance = data.footerDistance;
        }
        if (!isNullOrUndefined(data.differentFirstPage)) {
            sectionFormat.differentFirstPage = data.differentFirstPage;
        }
        if (!isNullOrUndefined(data.differentOddAndEvenPages)) {
            sectionFormat.differentOddAndEvenPages = data.differentOddAndEvenPages;
        }
    }
    parseTabStop(wTabs, tabs) {
        for (let i = 0; i < wTabs.length; i++) {
            let tabStop = new WTabStop();
            tabStop.position = wTabs[i].position;
            tabStop.tabLeader = wTabs[i].tabLeader;
            tabStop.deletePosition = wTabs[i].deletePosition;
            tabStop.tabJustification = wTabs[i].tabJustification;
            tabs.push(tabStop);
        }
    }
}

/**
 * Viewer Export
 */

/**
 * Selection character format implementation
 */
class SelectionCharacterFormat {
    /**
     * @private
     */
    constructor(selection) {
        this.boldIn = undefined;
        this.italicIn = undefined;
        this.underlineIn = undefined;
        this.strikeThroughIn = undefined;
        this.baselineAlignmentIn = undefined;
        this.highlightColorIn = undefined;
        this.fontSizeIn = 0;
        this.fontColorIn = undefined;
        this.selection = selection;
    }
    /**
     * Gets or sets the font size of selected contents.
     */
    get fontSize() {
        return this.fontSizeIn;
    }
    set fontSize(value) {
        if (value === this.fontSizeIn) {
            return;
        }
        this.fontSizeIn = value;
        this.notifyPropertyChanged('fontSize');
    }
    /**
     * Gets or sets the font family of selected contents.
     */
    get fontFamily() {
        return this.fontFamilyIn;
    }
    set fontFamily(value) {
        if (value === this.fontFamilyIn) {
            return;
        }
        this.fontFamilyIn = value;
        this.notifyPropertyChanged('fontFamily');
    }
    /**
     * Gets or sets the font color of selected contents.
     */
    get fontColor() {
        return this.fontColorIn;
    }
    set fontColor(value) {
        if (value === this.fontColorIn) {
            return;
        }
        this.fontColorIn = value;
        this.notifyPropertyChanged('fontColor');
    }
    /**
     * Gets or sets the bold formatting of selected contents.
     */
    get bold() {
        return this.boldIn;
    }
    set bold(value) {
        if (value === this.boldIn) {
            return;
        }
        this.boldIn = value;
        this.notifyPropertyChanged('bold');
    }
    /**
     * Gets or sets the italic formatting of selected contents.
     */
    get italic() {
        return this.italicIn;
    }
    set italic(value) {
        if (value === this.italic) {
            return;
        }
        this.italicIn = value;
        this.notifyPropertyChanged('italic');
    }
    /**
     * Gets or sets the strikethrough property of selected contents.
     */
    get strikethrough() {
        return this.strikeThroughIn;
    }
    set strikethrough(value) {
        if (value === this.strikeThroughIn) {
            return;
        }
        this.strikeThroughIn = value;
        this.notifyPropertyChanged('strikethrough');
    }
    /**
     * Gets or sets the baseline alignment property of selected contents.
     */
    get baselineAlignment() {
        return this.baselineAlignmentIn;
    }
    set baselineAlignment(value) {
        if (value === this.baselineAlignmentIn) {
            return;
        }
        this.baselineAlignmentIn = value;
        this.notifyPropertyChanged('baselineAlignment');
    }
    /**
     * Gets or sets the underline style of selected contents.
     */
    get underline() {
        return this.underlineIn;
    }
    set underline(value) {
        if (value === this.underlineIn) {
            return;
        }
        this.underlineIn = value;
        this.notifyPropertyChanged('underline');
    }
    /**
     * Gets or sets the highlight color of selected contents.
     */
    get highlightColor() {
        return this.highlightColorIn;
    }
    set highlightColor(value) {
        if (value === this.highlightColorIn) {
            return;
        }
        this.highlightColorIn = value;
        this.notifyPropertyChanged('highlightColor');
    }
    getPropertyValue(property) {
        switch (property) {
            case 'bold':
                return this.bold;
            case 'italic':
                return this.italic;
            case 'fontSize':
                if (this.fontSize >= 1) {
                    return this.fontSize;
                }
                return undefined;
            case 'fontFamily':
                return this.fontFamily;
            case 'strikethrough':
                return this.strikethrough;
            case 'baselineAlignment':
                return this.baselineAlignment;
            case 'highlightColor':
                return this.highlightColor;
            case 'underline':
                return this.underline;
            case 'fontColor':
                return this.fontColor;
            default:
                return undefined;
        }
    }
    /**
     * Notifies whenever property gets changed.
     * @param  {string} propertyName
     */
    notifyPropertyChanged(propertyName) {
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(this.selection) && (this.selection.isCleared || this.selection.owner.isReadOnlyMode || !this.selection.owner.isDocumentLoaded || this.selection.owner.isPastingContent) && !this.selection.isRetrieveFormatting) {
            return;
        }
        if (!isNullOrUndefined(this.selection) && !isNullOrUndefined(this.selection.start) && !this.selection.isRetrieveFormatting) {
            let propertyValue = this.getPropertyValue(propertyName);
            if (!isNullOrUndefined(propertyValue)) {
                this.selection.owner.editorModule.onApplyCharacterFormat(propertyName, propertyValue);
            }
        }
    }
    /**
     * Copies the source format.
     * @param  {WCharacterFormat} format
     * @returns void
     * @private
     */
    copyFormat(format) {
        this.styleName = !isNullOrUndefined(format.baseCharStyle) ? format.baseCharStyle.name : 'Default Paragraph Font';
        this.fontSize = format.fontSize;
        this.fontFamily = format.fontFamily;
        this.bold = format.bold;
        this.italic = format.italic;
        this.baselineAlignment = format.baselineAlignment;
        this.underline = format.underline;
        this.fontColor = format.fontColor;
        this.highlightColor = format.highlightColor;
        this.strikethrough = format.strikethrough;
    }
    /**
     * Combines the format.
     * @param  {WCharacterFormat} format
     * @private
     */
    combineFormat(format) {
        if (!isNullOrUndefined(this.bold) && this.bold !== format.bold) {
            this.bold = undefined;
        }
        if (!isNullOrUndefined(this.italic) && this.italic !== format.italic) {
            this.italic = undefined;
        }
        if (this.fontSize !== 0 && this.fontSize !== format.fontSize) {
            this.fontSize = 0;
        }
        if (!isNullOrUndefined(this.fontFamily) && this.fontFamily !== format.fontFamily) {
            this.fontFamily = undefined;
        }
        if (!isNullOrUndefined(this.highlightColor) && this.highlightColor !== format.highlightColor) {
            this.highlightColor = undefined;
        }
        if (!isNullOrUndefined(this.baselineAlignment) && this.baselineAlignment !== format.baselineAlignment) {
            this.baselineAlignment = undefined;
        }
        if (!isNullOrUndefined(this.fontColor) && (this.fontColor !== format.fontColor)) {
            this.fontColor = undefined;
        }
        if (!isNullOrUndefined(this.underline) && this.underline !== format.underline) {
            this.underline = undefined;
        }
        if (!isNullOrUndefined(this.strikethrough) && this.strikethrough !== format.strikethrough) {
            this.strikethrough = undefined;
        }
    }
    /**
     * Clones the format.
     * @param  {SelectionCharacterFormat} selectionCharacterFormat
     * @returns void
     * @private
     */
    cloneFormat(selectionCharacterFormat) {
        this.bold = selectionCharacterFormat.bold;
        this.italic = selectionCharacterFormat.italic;
        this.underline = selectionCharacterFormat.underline;
        this.strikethrough = selectionCharacterFormat.strikethrough;
        this.baselineAlignment = selectionCharacterFormat.baselineAlignment;
        this.highlightColor = selectionCharacterFormat.highlightColor;
        this.fontSize = selectionCharacterFormat.fontSize;
        this.fontFamily = selectionCharacterFormat.fontFamily;
        this.fontColor = selectionCharacterFormat.fontColor;
        this.styleName = selectionCharacterFormat.styleName;
    }
    /**
     * Checks whether current format is equal to the source format or not.
     * @param  {SelectionCharacterFormat} format
     * @returns boolean
     * @private
     */
    isEqualFormat(format) {
        return (this.fontSize === format.fontSize
            && this.strikethrough === format.strikethrough
            && this.bold === format.bold
            && this.fontFamily === format.fontFamily
            && this.underline === format.underline
            && this.highlightColor === format.highlightColor
            && this.italic === format.italic
            && this.baselineAlignment === format.baselineAlignment
            && this.fontColor === format.fontColor);
    }
    /**
     * Clears the format.
     * @returns void
     * @private
     */
    clearFormat() {
        this.fontSizeIn = 0;
        this.boldIn = undefined;
        this.italicIn = undefined;
        this.fontFamilyIn = undefined;
        this.fontColorIn = undefined;
        this.underlineIn = undefined;
        this.strikeThroughIn = undefined;
        this.highlightColorIn = undefined;
        this.baselineAlignmentIn = undefined;
        this.styleName = undefined;
    }
    /**
     * Destroys the maintained resources.
     * @returns void
     * @private
     */
    destroy() {
        this.fontSizeIn = undefined;
        this.boldIn = undefined;
        this.italicIn = undefined;
        this.fontFamilyIn = undefined;
        this.fontColorIn = undefined;
        this.underlineIn = undefined;
        this.strikeThroughIn = undefined;
        this.baselineAlignmentIn = undefined;
        this.highlightColorIn = undefined;
        this.selection = undefined;
        this.styleName = undefined;
    }
}
/**
 * Selection paragraph format implementation
 */
class SelectionParagraphFormat {
    /**
     * @private
     */
    constructor(selection, viewer) {
        // Declaring the character format properties.
        this.leftIndentIn = 0;
        this.rightIndentIn = 0;
        this.beforeSpacingIn = 0;
        this.afterSpacingIn = 0;
        this.textAlignmentIn = undefined;
        this.firstLineIndentIn = 0;
        this.lineSpacingIn = 1;
        this.lineSpacingTypeIn = undefined;
        this.listLevelNumberIn = -1;
        this.selection = selection;
        this.viewer = viewer;
    }
    /**
     * Gets or Sets the left indent for selected paragraphs.
     * @default undefined
     */
    get leftIndent() {
        return this.leftIndentIn;
    }
    set leftIndent(value) {
        if (value === this.leftIndentIn) {
            return;
        }
        this.leftIndentIn = value;
        this.notifyPropertyChanged('leftIndent');
    }
    /**
     * Gets or Sets the right indent for selected paragraphs.
     * @default undefined
     */
    get rightIndent() {
        return this.rightIndentIn;
    }
    set rightIndent(value) {
        if (value === this.rightIndentIn) {
            return;
        }
        this.rightIndentIn = value;
        this.notifyPropertyChanged('rightIndent');
    }
    /**
     * Gets or Sets the first line indent for selected paragraphs.
     * @default undefined
     */
    get firstLineIndent() {
        return this.firstLineIndentIn;
    }
    set firstLineIndent(value) {
        if (value === this.firstLineIndentIn) {
            return;
        }
        this.firstLineIndentIn = value;
        this.notifyPropertyChanged('firstLineIndent');
    }
    /**
     * Gets or Sets the text alignment for selected paragraphs.
     * @default undefined
     */
    get textAlignment() {
        return this.textAlignmentIn;
    }
    set textAlignment(value) {
        if (value === this.textAlignmentIn) {
            return;
        }
        this.textAlignmentIn = value;
        this.notifyPropertyChanged('textAlignment');
    }
    /**
     * Gets or Sets the after spacing for selected paragraphs.
     * @default undefined
     */
    get afterSpacing() {
        return this.afterSpacingIn;
    }
    set afterSpacing(value) {
        if (value === this.afterSpacingIn) {
            return;
        }
        this.afterSpacingIn = value;
        this.notifyPropertyChanged('afterSpacing');
    }
    /**
     * Gets or Sets the before spacing for selected paragraphs.
     * @default undefined
     */
    get beforeSpacing() {
        return this.beforeSpacingIn;
    }
    set beforeSpacing(value) {
        if (value === this.beforeSpacingIn) {
            return;
        }
        this.beforeSpacingIn = value;
        this.notifyPropertyChanged('beforeSpacing');
    }
    /**
     * Gets or Sets the line spacing for selected paragraphs.
     * @default undefined
     */
    get lineSpacing() {
        return this.lineSpacingIn;
    }
    set lineSpacing(value) {
        if (value === this.lineSpacingIn) {
            return;
        }
        this.lineSpacingIn = value;
        this.notifyPropertyChanged('lineSpacing');
    }
    /**
     * Gets or Sets the line spacing type for selected paragraphs.
     * @default undefined
     */
    get lineSpacingType() {
        return this.lineSpacingTypeIn;
    }
    set lineSpacingType(value) {
        if (value === this.lineSpacingTypeIn) {
            return;
        }
        this.lineSpacingTypeIn = value;
        this.notifyPropertyChanged('lineSpacingType');
    }
    /**
     * Gets or Sets the list level number for selected paragraphs.
     * @default undefined
     */
    get listLevelNumber() {
        return this.listLevelNumberIn;
    }
    set listLevelNumber(value) {
        if (value === this.listLevelNumberIn) {
            return;
        }
        this.listLevelNumberIn = value;
        this.notifyPropertyChanged('listLevelNumber');
    }
    /**
     * Gets the list text for selected paragraphs.
     */
    get listText() {
        let listFormat = undefined;
        let list = this.viewer.getListById(this.listId);
        if (list instanceof WList && this.listLevelNumberIn > -1 && this.listLevelNumberIn < 9) {
            let listLevel = list.getListLevel(this.listLevelNumber);
            if (listLevel instanceof WListLevel) {
                if (listLevel.listLevelPattern === 'Bullet') {
                    listFormat = listLevel.numberFormat;
                }
                else {
                    listFormat = listLevel.numberFormat;
                    for (let i = 0; i < 9; i++) {
                        let levelPattern = '%' + (i + 1);
                        if (listFormat.indexOf(levelPattern) > -1) {
                            let level = i === this.listLevelNumberIn ? listLevel : list.getListLevel(i);
                            let listText = this.selection.owner.viewer.layout.getListTextListLevel(level, 1);
                            listFormat = listFormat.replace(levelPattern, listText);
                        }
                    }
                }
            }
        }
        return listFormat;
    }
    getPropertyValue(property) {
        switch (property) {
            case 'leftIndent':
                return this.leftIndent;
            case 'rightIndent':
                return this.rightIndent;
            case 'firstLineIndent':
                return this.firstLineIndent;
            case 'beforeSpacing':
                return this.beforeSpacing;
            case 'afterSpacing':
                return this.afterSpacing;
            case 'textAlignment':
                return this.textAlignment;
            case 'lineSpacing':
                return this.lineSpacing;
            case 'lineSpacingType':
                return this.lineSpacingType;
            default:
                return undefined;
        }
    }
    /**
     * Notifies whenever the property gets changed.
     * @param  {string} propertyName
     */
    notifyPropertyChanged(propertyName) {
        if (!isNullOrUndefined(this.selection) &&
            (this.selection.owner.isReadOnlyMode || !this.selection.owner.isDocumentLoaded)
            && !this.selection.isRetrieveFormatting) {
            return;
        }
        if (!isNullOrUndefined(this.selection) && !isNullOrUndefined(this.selection.start) && !this.selection.isRetrieveFormatting) {
            let editorModule = this.selection.owner.editorModule;
            let value = this.getPropertyValue(propertyName);
            if ((propertyName === 'leftIndent' || propertyName === 'rightIndent' || propertyName === 'firstLineIndent')
                && !(value >= -1056 && value < 1056)) {
                return;
            }
            if (propertyName === 'listLevelNumber') {
                editorModule.onApplyListInternal(this.viewer.getListById(this.listId), this.listLevelNumber);
            }
            else {
                editorModule.onApplyParagraphFormat(propertyName, value, propertyName === 'textAlignment' ? true : false, false);
            }
        }
    }
    /**
     * Copies the format.
     * @param  {WParagraphFormat} format
     * @returns void
     * @private
     */
    copyFormat(format) {
        this.styleName = !isNullOrUndefined(format.baseStyle) ? format.baseStyle.name : 'Normal';
        this.leftIndent = format.leftIndent;
        this.rightIndent = format.rightIndent;
        this.firstLineIndent = format.firstLineIndent;
        this.afterSpacing = format.afterSpacing;
        this.beforeSpacing = format.beforeSpacing;
        this.lineSpacing = format.lineSpacing;
        this.lineSpacingType = format.lineSpacingType;
        this.textAlignment = format.textAlignment;
        if (!isNullOrUndefined(format.listFormat) && !isNullOrUndefined(format.listFormat.listId)) {
            this.listId = format.listFormat.listId;
            this.listLevelNumber = format.listFormat.listLevelNumber;
        }
        else {
            this.listId = undefined;
            this.listLevelNumber = 0;
        }
    }
    /**
     * Copies to format.
     * @param  {WParagraphFormat} format
     * @private
     */
    copyToFormat(format) {
        if (isNullOrUndefined(format)) {
            return;
        }
        if (!isNullOrUndefined(this.afterSpacing)) {
            format.afterSpacing = this.afterSpacing;
        }
        if (!isNullOrUndefined(this.beforeSpacing)) {
            format.beforeSpacing = this.beforeSpacing;
        }
        if (!isNullOrUndefined(this.leftIndent)) {
            format.leftIndent = this.leftIndent;
        }
        if (!isNullOrUndefined(this.rightIndent)) {
            format.rightIndent = this.rightIndent;
        }
        if (!isNullOrUndefined(this.textAlignment)) {
            format.textAlignment = this.textAlignment;
        }
        if (!isNullOrUndefined(this.lineSpacing)) {
            format.lineSpacing = this.lineSpacing;
        }
        if (!isNullOrUndefined(this.lineSpacingType)) {
            format.lineSpacingType = this.lineSpacingType;
        }
        if (!isNullOrUndefined(this.firstLineIndent)) {
            format.firstLineIndent = this.firstLineIndent;
        }
    }
    /**
     * Combines the format.
     * @param  {WParagraphFormat} format
     * @private
     */
    combineFormat(format) {
        if (!isNullOrUndefined(this.leftIndent) && this.leftIndent !== format.leftIndent) {
            this.leftIndent = undefined;
        }
        if (!isNullOrUndefined(this.rightIndent) && this.rightIndent !== format.rightIndent) {
            this.rightIndent = undefined;
        }
        if (!isNullOrUndefined(this.firstLineIndent) && this.firstLineIndent !== format.firstLineIndent) {
            this.firstLineIndent = undefined;
        }
        if (this.lineSpacing !== 0 && this.lineSpacing !== format.lineSpacing) {
            this.lineSpacing = 0;
        }
        if (this.beforeSpacing !== -1 && this.beforeSpacing !== format.beforeSpacing) {
            this.beforeSpacing = -1;
        }
        if (this.afterSpacing !== -1 && this.afterSpacing !== format.afterSpacing) {
            this.afterSpacing = -1;
        }
        if (!isNullOrUndefined(this.lineSpacingType) && this.lineSpacingType !== format.lineSpacingType) {
            this.lineSpacingType = undefined;
        }
        if (!isNullOrUndefined(this.textAlignment) && this.textAlignment !== format.textAlignment) {
            this.textAlignment = undefined;
        }
        // tslint:disable-next-line:max-line-length
        if (this.listLevelNumber >= 0 && !isNullOrUndefined(this.listId) && (isNullOrUndefined(format.listFormat) || format.listFormat.listLevelNumber !== this.listLevelNumber)) {
            this.listLevelNumber = -1;
        }
        // tslint:disable-next-line:max-line-length
        if (isNullOrUndefined(format.listFormat) || isNullOrUndefined(format.listFormat.listId) || (!isNullOrUndefined(this.listId) && this.listId !== format.listFormat.listId)) {
            this.listId = undefined;
        }
    }
    /**
     * Clears the format.
     * @returns void
     * @private
     */
    clearFormat() {
        this.leftIndent = 0;
        this.rightIndent = 0;
        this.beforeSpacing = 0;
        this.afterSpacing = 0;
        this.firstLineIndent = 0;
        this.lineSpacing = 1;
        this.textAlignment = undefined;
        this.lineSpacingType = undefined;
        this.listId = undefined;
        this.listLevelNumber = -1;
        this.styleName = undefined;
    }
    /**
     * Gets the clone of list at current selection.
     * @returns WList
     * @private
     */
    getList() {
        let list = this.viewer.getListById(this.listId);
        if (!isNullOrUndefined(list)) {
            let listAdv = new WList();
            let abstractList = new WAbstractList();
            let currentAbstractList = this.viewer.getAbstractListById(list.abstractListId);
            let editor = this.selection.owner.editorModule;
            if (!isNullOrUndefined(currentAbstractList)) {
                for (let i = 0; i < currentAbstractList.levels.length; i++) {
                    let level = editor.cloneListLevel(currentAbstractList.levels[i]);
                    abstractList.levels.push(level);
                    level.ownerBase = abstractList;
                }
            }
            else {
                abstractList.levels.push(new WListLevel(abstractList));
            }
            if (!isNullOrUndefined(list.levelOverrides)) {
                for (let i = 0; i < list.levelOverrides.length; i++) {
                    let levelOverride = editor.cloneLevelOverride(list.levelOverrides[i]);
                    listAdv.levelOverrides.push(levelOverride);
                }
            }
            listAdv.abstractList = abstractList;
            listAdv.abstractListId = abstractList.abstractListId;
            listAdv.sourceListId = list.listId;
            return listAdv;
        }
        return undefined;
    }
    /**
     * Modifies the list at current selection.
     * @param  {WList} listAdv
     * @private
     */
    setList(listAdv) {
        if (this.viewer.owner.isReadOnlyMode || !this.viewer.owner.isDocumentLoaded) {
            return;
        }
        let list = this.viewer.getListById(this.listId);
        let collection = undefined;
        let currentAbstractList = listAdv ? this.viewer.getAbstractListById(listAdv.abstractListId) : undefined;
        if (!isNullOrUndefined(list) && !isNullOrUndefined(listAdv)
            && !isNullOrUndefined(currentAbstractList) && listAdv.sourceListId === list.listId) {
            let history = this.viewer.owner.editorHistory;
            let listLevel = this.viewer.layout.getListLevel(list, 1);
            this.selection.owner.isLayoutEnabled = false;
            this.viewer.owner.editorModule.setOffsetValue(this.selection);
            if (history) {
                collection = history.updateListChangesInHistory(currentAbstractList, list);
            }
            this.viewer.owner.editorModule.updateListParagraphs();
            if (history) {
                history.applyListChanges(this.selection, collection);
            }
            this.selection.owner.isLayoutEnabled = true;
            this.viewer.renderedLists.clear();
            // this.viewer.pages = [];
            this.viewer.owner.editorModule.layoutWholeDocument();
            this.viewer.owner.editorModule.updateSelectionTextPosition(false);
            if (history && history.currentBaseHistoryInfo) {
                if (history.currentBaseHistoryInfo.modifiedProperties.length > 0) {
                    history.currentBaseHistoryInfo.updateSelection();
                }
                history.updateHistory();
            }
            this.viewer.owner.editorModule.fireContentChange();
        }
        else if (!isNullOrUndefined(listAdv)) {
            this.selection.owner.isLayoutEnabled = false;
            if (!isNullOrUndefined(currentAbstractList) && this.viewer.abstractLists.indexOf(currentAbstractList) === -1) {
                this.viewer.abstractLists.push(currentAbstractList);
            }
            if (this.viewer.lists.indexOf(listAdv) === -1) {
                this.viewer.lists.push(listAdv);
            }
            //currentAbstractList.listType = 'Numbering';
            this.selection.owner.isLayoutEnabled = true;
            this.selection.owner.editorModule.onApplyList(listAdv);
        }
        else {
            this.selection.owner.editorModule.onApplyList(undefined);
        }
    }
    /**
     * Destroys the managed resources.
     * @returns void
     * @private
     */
    destroy() {
        this.leftIndentIn = undefined;
        this.rightIndentIn = undefined;
        this.beforeSpacingIn = undefined;
        this.afterSpacingIn = undefined;
        this.firstLineIndentIn = undefined;
        this.lineSpacingIn = undefined;
        this.textAlignmentIn = undefined;
        this.lineSpacingTypeIn = undefined;
        this.listId = undefined;
        this.listLevelNumberIn = undefined;
        this.viewer = undefined;
        this.selection = undefined;
        this.styleName = undefined;
    }
}
/**
 * Selection section format implementation
 */
class SelectionSectionFormat {
    /**
     * @private
     */
    constructor(selection) {
        this.differentFirstPageIn = undefined;
        this.differentOddAndEvenPagesIn = undefined;
        this.selection = selection;
    }
    /**
     * Gets or sets the page height.
     */
    get pageHeight() {
        return this.pageHeightIn;
    }
    set pageHeight(value) {
        this.pageHeightIn = value;
        this.notifyPropertyChanged('pageHeight');
    }
    /**
     * Gets or sets the page width.
     */
    get pageWidth() {
        return this.pageWidthIn;
    }
    set pageWidth(value) {
        this.pageWidthIn = value;
        this.notifyPropertyChanged('pageWidth');
    }
    /**
     * Gets or sets the page left margin.
     */
    get leftMargin() {
        return this.leftMarginIn;
    }
    set leftMargin(value) {
        this.leftMarginIn = value;
        this.notifyPropertyChanged('leftMargin');
    }
    /**
     * Gets or sets the page bottom margin.
     */
    get bottomMargin() {
        return this.bottomMarginIn;
    }
    set bottomMargin(value) {
        this.bottomMarginIn = value;
        this.notifyPropertyChanged('bottomMargin');
    }
    /**
     * Gets or sets the page top margin.
     */
    get topMargin() {
        return this.topMarginIn;
    }
    set topMargin(value) {
        this.topMarginIn = value;
        this.notifyPropertyChanged('topMargin');
    }
    /**
     * Gets or sets the page right margin.
     */
    get rightMargin() {
        return this.rightMarginIn;
    }
    set rightMargin(value) {
        this.rightMarginIn = value;
        this.notifyPropertyChanged('rightMargin');
    }
    /**
     * Gets or sets the header distance.
     */
    get headerDistance() {
        return this.headerDistanceIn;
    }
    set headerDistance(value) {
        this.headerDistanceIn = value;
        this.notifyPropertyChanged('headerDistance');
    }
    /**
     * Gets or sets the footer distance.
     */
    get footerDistance() {
        return this.footerDistanceIn;
    }
    set footerDistance(value) {
        this.footerDistanceIn = value;
        this.notifyPropertyChanged('footerDistance');
    }
    /**
     * Gets or sets a value indicating whether the section has different first page.
     */
    get differentFirstPage() {
        return this.differentFirstPageIn;
    }
    set differentFirstPage(value) {
        this.differentFirstPageIn = value;
        this.notifyPropertyChanged('differentFirstPage');
    }
    /**
     * Gets or sets a value indicating whether the section has different odd and even page.
     */
    get differentOddAndEvenPages() {
        return this.differentOddAndEvenPagesIn;
    }
    set differentOddAndEvenPages(value) {
        this.differentOddAndEvenPagesIn = value;
        this.notifyPropertyChanged('differentOddAndEvenPages');
    }
    /**
     * Copies the format.
     * @param  {WSectionFormat} format
     * @returns void
     * @private
     */
    copyFormat(format) {
        this.pageHeight = format.pageHeight;
        this.pageWidth = format.pageWidth;
        this.leftMargin = format.leftMargin;
        this.topMargin = format.topMargin;
        this.rightMargin = format.rightMargin;
        this.bottomMargin = format.bottomMargin;
        this.headerDistance = format.headerDistance;
        this.footerDistance = format.footerDistance;
        this.differentFirstPage = format.differentFirstPage;
        this.differentOddAndEvenPages = format.differentOddAndEvenPages;
    }
    notifyPropertyChanged(propertyName) {
        let selection = this.selection;
        if (!isNullOrUndefined(selection) && (selection.isCleared || selection.owner.isPastingContent
            || selection.owner.isReadOnlyMode || !selection.owner.isDocumentLoaded)
            && !selection.isRetrieveFormatting) {
            return;
        }
        if (!isNullOrUndefined(selection) && !isNullOrUndefined(selection.start) && !selection.isRetrieveFormatting) {
            let value = this.getPropertyvalue(propertyName);
            if (!isNullOrUndefined(value)) {
                selection.owner.editorModule.onApplySectionFormat(propertyName, value);
            }
        }
    }
    getPropertyvalue(propertyName) {
        switch (propertyName) {
            case 'pageHeight':
                if (this.pageHeight > 0) {
                    return this.pageHeight;
                }
                return undefined;
            case 'pageWidth':
                if (this.pageWidth > 0) {
                    return this.pageWidth;
                }
                return undefined;
            case 'leftMargin':
                if (this.leftMargin >= 0) {
                    return this.leftMargin;
                }
                return undefined;
            case 'rightMargin':
                if (this.rightMargin >= 0) {
                    return this.rightMargin;
                }
                return undefined;
            case 'topMargin':
                if (this.topMargin >= 0) {
                    return this.topMargin;
                }
                return undefined;
            case 'bottomMargin':
                if (this.bottomMargin >= 0) {
                    return this.bottomMargin;
                }
                return undefined;
            case 'differentFirstPage':
                if (!isNullOrUndefined(this.differentFirstPage)) {
                    return this.differentFirstPage;
                }
                return undefined;
            case 'differentOddAndEvenPages':
                if (!isNullOrUndefined(this.differentOddAndEvenPages)) {
                    return this.differentOddAndEvenPages;
                }
                return undefined;
            case 'headerDistance':
                return this.headerDistanceIn;
            case 'footerDistance':
                return this.footerDistance;
            default:
                return undefined;
        }
    }
    /**
     * Combines the format.
     * @param  {WSectionFormat} format
     * @private
     */
    combineFormat(format) {
        if (this.pageHeight > 0 && this.pageHeight !== format.pageHeight) {
            this.pageHeight = 0;
        }
        if (this.pageWidth > 0 && this.pageWidth !== format.pageWidth) {
            this.pageWidth = 0;
        }
        if (this.leftMargin > -1 && this.leftMargin !== format.leftMargin) {
            this.leftMargin = -1;
        }
        if (this.topMargin > -1 && this.topMargin !== format.topMargin) {
            this.topMargin = -1;
        }
        if (this.rightMargin > -1 && this.rightMargin !== format.rightMargin) {
            this.rightMargin = -1;
        }
        if (this.bottomMargin > -1 && this.bottomMargin !== format.bottomMargin) {
            this.bottomMargin = -1;
        }
        if (this.headerDistance !== 0 && this.headerDistance !== format.headerDistance) {
            this.headerDistance = 0;
        }
        if (this.footerDistance !== 0 && this.footerDistance !== format.footerDistance) {
            this.footerDistance = 0;
        }
        if (!isNullOrUndefined(this.differentFirstPage) && this.differentFirstPage !== format.differentFirstPage) {
            this.differentFirstPage = undefined;
        }
        if (!isNullOrUndefined(this.differentOddAndEvenPages) && this.differentOddAndEvenPages !== format.differentOddAndEvenPages) {
            this.differentOddAndEvenPages = undefined;
        }
    }
    /**
     * Clears the format.
     * @returns void
     * @private
     */
    clearFormat() {
        this.headerDistance = 0;
        this.footerDistance = 0;
        this.pageHeight = 0;
        this.pageWidth = 0;
        this.leftMargin = -1;
        this.rightMargin = -1;
        this.topMargin = -1;
        this.bottomMargin = -1;
        this.differentFirstPage = undefined;
        this.differentOddAndEvenPages = undefined;
    }
    /**
     * Destroys the managed resources.
     * @returns void
     * @private
     */
    destroy() {
        this.headerDistanceIn = undefined;
        this.footerDistanceIn = undefined;
        this.pageHeightIn = undefined;
        this.pageWidthIn = undefined;
        this.leftMarginIn = undefined;
        this.rightMarginIn = undefined;
        this.topMarginIn = undefined;
        this.bottomMarginIn = undefined;
        this.differentFirstPageIn = undefined;
        this.differentOddAndEvenPagesIn = undefined;
        this.selection = undefined;
    }
}
/**
 * Selection table format implementation
 */
class SelectionTableFormat {
    /**
     * @private
     */
    constructor(selection) {
        this.leftIndentIn = 0;
        this.backgroundIn = undefined;
        this.tableAlignmentIn = undefined;
        this.cellSpacingIn = 0;
        this.leftMarginIn = 0;
        this.rightMarginIn = 0;
        this.topMarginIn = 0;
        this.bottomMarginIn = 0;
        this.preferredWidthIn = 0;
        this.selection = selection;
    }
    /**
     * Gets or sets the table.
     * @private
     */
    get table() {
        return this.tableIn;
    }
    set table(value) {
        this.tableIn = value;
    }
    /**
     * Gets or Sets the left indent for selected table.
     * @private
     */
    get leftIndent() {
        return this.leftIndentIn;
    }
    set leftIndent(value) {
        if (value === this.leftIndentIn) {
            return;
        }
        this.leftIndentIn = value;
        this.notifyPropertyChanged('leftIndent');
    }
    /**
     * Gets or Sets the default top margin of cell for selected table.
     * @default undefined
     */
    get topMargin() {
        return this.topMarginIn;
    }
    set topMargin(value) {
        if (value === this.topMarginIn) {
            return;
        }
        this.topMarginIn = value;
        this.notifyPropertyChanged('topMargin');
    }
    /**
     * Gets or Sets the background for selected table.
     * @default undefined
     */
    get background() {
        return this.backgroundIn;
    }
    set background(value) {
        if (value === this.backgroundIn) {
            return;
        }
        this.backgroundIn = value;
        this.notifyPropertyChanged('background');
    }
    /**
     * Gets or Sets the table alignment for selected table.
     * @default undefined
     */
    get tableAlignment() {
        return this.tableAlignmentIn;
    }
    set tableAlignment(value) {
        if (value === this.tableAlignmentIn) {
            return;
        }
        this.tableAlignmentIn = value;
        this.notifyPropertyChanged('tableAlignment');
    }
    /**
     * Gets or Sets the default left margin of cell for selected table.
     * @default undefined
     */
    get leftMargin() {
        return this.leftMarginIn;
    }
    set leftMargin(value) {
        if (value === this.leftMarginIn) {
            return;
        }
        this.leftMarginIn = value;
        this.notifyPropertyChanged('leftMargin');
    }
    /**
     * Gets or Sets the default bottom margin of cell for selected table.
     * @default undefined
     */
    get bottomMargin() {
        return this.bottomMarginIn;
    }
    set bottomMargin(value) {
        if (value === this.bottomMarginIn) {
            return;
        }
        this.bottomMarginIn = value;
        this.notifyPropertyChanged('bottomMargin');
    }
    /**
     * Gets or Sets the cell spacing for selected table.
     * @default undefined
     */
    get cellSpacing() {
        return this.cellSpacingIn;
    }
    set cellSpacing(value) {
        if (value === this.cellSpacingIn) {
            return;
        }
        this.cellSpacingIn = value;
        this.notifyPropertyChanged('cellSpacing');
    }
    /**
     * Gets or Sets the default right margin of cell for selected table.
     * @default undefined
     */
    get rightMargin() {
        return this.rightMarginIn;
    }
    set rightMargin(value) {
        if (value === this.rightMarginIn) {
            return;
        }
        this.rightMarginIn = value;
        this.notifyPropertyChanged('rightMargin');
    }
    /**
     * Gets or Sets the preferred width for selected table.
     * @default undefined
     */
    get preferredWidth() {
        return this.preferredWidthIn;
    }
    set preferredWidth(value) {
        if (value === this.preferredWidthIn) {
            return;
        }
        this.preferredWidthIn = value;
        this.notifyPropertyChanged('preferredWidth');
    }
    /**
     * Gets or Sets the preferred width type for selected table.
     * @default undefined
     */
    get preferredWidthType() {
        return this.preferredWidthTypeIn;
    }
    set preferredWidthType(value) {
        if (value === this.preferredWidthTypeIn) {
            return;
        }
        this.preferredWidthTypeIn = value;
        this.notifyPropertyChanged('preferredWidthType');
    }
    getPropertyValue(propertyName) {
        switch (propertyName) {
            case 'tableAlignment':
                return this.tableAlignment;
            case 'leftIndent':
                return this.leftIndent;
            case 'cellSpacing':
                return this.cellSpacing;
            case 'leftMargin':
                return this.leftMargin;
            case 'rightMargin':
                return this.rightMargin;
            case 'topMargin':
                return this.topMargin;
            case 'bottomMargin':
                return this.bottomMargin;
            case 'background':
                let shading = new WShading();
                shading.backgroundColor = this.background;
                return shading;
            case 'preferredWidth':
                return this.preferredWidth;
            case 'preferredWidthType':
                return this.preferredWidthType;
            default:
                return undefined;
        }
    }
    notifyPropertyChanged(propertyName) {
        if (!isNullOrUndefined(this.selection) && (this.selection.isCleared
            || !this.selection.owner.isDocumentLoaded || this.selection.owner.isReadOnlyMode
            || this.selection.owner.isPastingContent) && !this.selection.isRetrieveFormatting) {
            return;
        }
        if (!isNullOrUndefined(this.selection) && !isNullOrUndefined(this.selection.start) && !this.selection.isRetrieveFormatting) {
            let value = this.getPropertyValue(propertyName);
            if (propertyName === 'background') {
                propertyName = 'shading';
            }
            if (!isNullOrUndefined(value)) {
                this.selection.owner.editorModule.onApplyTableFormat(propertyName, value);
            }
        }
    }
    /**
     * Copies the format.
     * @param  {WTableFormat} format Format to copy.
     * @returns void
     * @private
     */
    copyFormat(format) {
        this.leftIndent = format.leftIndent;
        this.background = format.shading.backgroundColor;
        this.tableAlignment = format.tableAlignment;
        this.leftMargin = format.leftMargin;
        this.rightMargin = format.rightMargin;
        this.topMargin = format.topMargin;
        this.bottomMargin = format.bottomMargin;
        this.cellSpacing = format.cellSpacing;
        this.preferredWidth = format.preferredWidth;
        this.preferredWidthType = format.preferredWidthType;
    }
    /**
     * Clears the format.
     * @returns void
     * @private
     */
    clearFormat() {
        this.table = undefined;
        this.leftIndent = 0;
        this.background = undefined;
        this.leftIndent = 0;
        this.leftMargin = 0;
        this.rightMargin = 0;
        this.topMargin = 0;
        this.bottomMargin = 0;
        this.cellSpacing = 0;
        this.tableAlignment = undefined;
    }
    /**
     * Destroys the managed resources.
     * @returns void
     * @private
     */
    destroy() {
        this.leftIndentIn = undefined;
        this.backgroundIn = undefined;
        this.leftIndentIn = undefined;
        this.leftMarginIn = undefined;
        this.rightMarginIn = undefined;
        this.topMarginIn = undefined;
        this.bottomMarginIn = undefined;
        this.cellSpacingIn = undefined;
        this.tableAlignmentIn = undefined;
        this.tableIn = undefined;
        this.selection = undefined;
    }
}
/**
 * Selection cell format implementation
 */
class SelectionCellFormat {
    /**
     * @private
     */
    constructor(selection) {
        this.verticalAlignmentIn = undefined;
        this.leftMarginIn = 0;
        this.rightMarginIn = 0;
        this.topMarginIn = 0;
        this.bottomMarginIn = 0;
        this.backgroundIn = undefined;
        this.preferredWidthTypeIn = undefined;
        this.selection = selection;
    }
    /**
     * Gets or sets the vertical alignment of the selected cells.
     * @default undefined
     */
    get verticalAlignment() {
        return this.verticalAlignmentIn;
    }
    set verticalAlignment(value) {
        if (value === this.verticalAlignmentIn) {
            return;
        }
        this.verticalAlignmentIn = value;
        this.notifyPropertyChanged('verticalAlignment');
    }
    /**
     * Gets or Sets the left margin for selected cells.
     * @default undefined
     */
    /* tslint:disable */
    get leftMargin() {
        return this.leftMarginIn;
    }
    set leftMargin(value) {
        if (value === this.leftMarginIn) {
            return;
        }
        this.leftMarginIn = value;
        this.notifyPropertyChanged('leftMargin');
    }
    /**
     * Gets or Sets the right margin for selected cells.
     * @default undefined
     */
    get rightMargin() {
        return this.rightMarginIn;
    }
    set rightMargin(value) {
        if (value === this.rightMarginIn) {
            return;
        }
        this.rightMarginIn = value;
        this.notifyPropertyChanged('rightMargin');
    }
    /**
     * Gets or Sets the top margin for selected cells.
     * @default undefined
     */
    get topMargin() {
        return this.topMarginIn;
    }
    set topMargin(value) {
        if (value === this.topMarginIn) {
            return;
        }
        this.topMarginIn = value;
        this.notifyPropertyChanged('topMargin');
    }
    /**
     * Gets or Sets the bottom margin for selected cells.
     * @default undefined
     */
    get bottomMargin() {
        return this.bottomMarginIn;
    }
    set bottomMargin(value) {
        if (value === this.bottomMarginIn) {
            return;
        }
        this.bottomMarginIn = value;
        this.notifyPropertyChanged('bottomMargin');
    }
    /**
     * Gets or Sets the background for selected cells.
     * @default undefined
     */
    get background() {
        return this.backgroundIn;
    }
    /* tslint:enable */
    set background(value) {
        if (value === this.backgroundIn) {
            return;
        }
        this.backgroundIn = value;
        this.notifyPropertyChanged('background');
    }
    /* tslint:disable */
    /**
     * Gets or Sets the preferred width type for selected cells.
     * @default undefined
     */
    get preferredWidthType() {
        return this.preferredWidthTypeIn;
    }
    set preferredWidthType(value) {
        if (value === this.preferredWidthTypeIn) {
            return;
        }
        this.preferredWidthTypeIn = value;
        this.notifyPropertyChanged('preferredWidthType');
    }
    /**
     * Gets or Sets the preferred width  for selected cells.
     * @default undefined
     */
    get preferredWidth() {
        return this.preferredWidthIn;
    }
    set preferredWidth(value) {
        if (value === this.preferredWidthIn) {
            return;
        }
        this.preferredWidthIn = value;
        this.notifyPropertyChanged('preferredWidth');
    }
    /* tslint:enable */
    notifyPropertyChanged(propertyName) {
        let selection = this.selection;
        if (!isNullOrUndefined(selection)) {
            if ((selection.isCleared || !selection.owner.isDocumentLoaded
                || selection.owner.isReadOnlyMode || selection.owner.isPastingContent) && !selection.isRetrieveFormatting) {
                return;
            }
            if (!isNullOrUndefined(this.selection.start) && !this.selection.isRetrieveFormatting) {
                let value = this.getPropertyValue(propertyName);
                if (propertyName === 'background') {
                    propertyName = 'shading';
                }
                if (!isNullOrUndefined(value)) {
                    this.selection.owner.editorModule.onApplyTableCellFormat(propertyName, value);
                }
            }
        }
    }
    getPropertyValue(propertyName) {
        switch (propertyName) {
            case 'verticalAlignment':
                return this.verticalAlignment;
            case 'leftMargin':
                return this.leftMargin;
            case 'rightMargin':
                return this.rightMargin;
            case 'topMargin':
                return this.topMargin;
            case 'bottomMargin':
                return this.bottomMargin;
            case 'preferredWidth':
                return this.preferredWidth;
            case 'preferredWidthType':
                return this.preferredWidthType;
            case 'background':
                let shading = new WShading();
                shading.backgroundColor = this.background;
                return shading;
            default:
                return undefined;
        }
    }
    /**
     * Copies the format.
     * @param  {WCellFormat} format Source Format to copy.
     * @returns void
     * @private
     */
    copyFormat(format) {
        this.leftMargin = format.leftMargin;
        this.rightMargin = format.rightMargin;
        this.topMargin = format.topMargin;
        this.bottomMargin = format.bottomMargin;
        this.background = format.shading.backgroundColor;
        this.verticalAlignment = format.verticalAlignment;
        this.preferredWidth = format.preferredWidth;
        this.preferredWidthType = format.preferredWidthType;
    }
    /**
     * Clears the format.
     * @returns void
     * @private
     */
    clearCellFormat() {
        this.leftMargin = undefined;
        this.rightMargin = undefined;
        this.topMargin = undefined;
        this.bottomMargin = undefined;
        this.background = undefined;
        this.verticalAlignment = undefined;
    }
    /**
     * Combines the format.
     * @param  {WCellFormat} format
     * @private
     */
    combineFormat(format) {
        if (!isNullOrUndefined(this.leftMargin) && this.leftMargin !== format.leftMargin) {
            this.leftMargin = undefined;
        }
        if (!isNullOrUndefined(this.topMargin) && this.topMargin !== format.topMargin) {
            this.topMargin = undefined;
        }
        if (!isNullOrUndefined(this.rightMargin) && this.rightMargin !== format.rightMargin) {
            this.rightMargin = undefined;
        }
        if (!isNullOrUndefined(this.bottomMargin) && this.bottomMargin !== format.bottomMargin) {
            this.bottomMargin = undefined;
        }
        if (!isNullOrUndefined(this.background) && this.background !== format.shading.backgroundColor) {
            this.background = undefined;
        }
        if (!isNullOrUndefined(this.verticalAlignment) && this.verticalAlignment !== format.verticalAlignment) {
            this.verticalAlignment = undefined;
        }
        if (!isNullOrUndefined(this.preferredWidth) && this.preferredWidth !== format.preferredWidth) {
            this.preferredWidth = undefined;
        }
        if (!isNullOrUndefined(this.preferredWidthType) && this.preferredWidthType !== format.preferredWidthType) {
            this.preferredWidthType = undefined;
        }
    }
    /**
     * Clears the format.
     * @returns void
     * @private
     */
    clearFormat() {
        this.background = undefined;
        this.bottomMargin = 0;
        this.leftMargin = 0;
        this.rightMargin = 0;
        this.topMargin = 0;
        this.verticalAlignment = undefined;
    }
    /**
     * Destroys the manages resources.
     * @returns void
     * @private
     */
    destroy() {
        this.backgroundIn = undefined;
        this.verticalAlignmentIn = undefined;
        this.bottomMarginIn = undefined;
        this.leftMarginIn = undefined;
        this.rightMarginIn = undefined;
        this.topMarginIn = undefined;
        this.selection = undefined;
    }
}
/**
 * Selection row format implementation
 */
class SelectionRowFormat {
    /**
     * @private
     */
    constructor(selection) {
        this.heightIn = undefined;
        this.heightTypeIn = undefined;
        this.isHeaderIn = undefined;
        this.allowRowBreakAcrossPagesIn = undefined;
        this.selection = selection;
    }
    /**
     * Gets or Sets the height for selected rows.
     * @default undefined
     */
    get height() {
        return this.heightIn;
    }
    set height(value) {
        if (value === this.heightIn) {
            return;
        }
        this.heightIn = value;
        this.notifyPropertyChanged('height');
    }
    /**
     * Gets or Sets the height type for selected rows.
     * @default undefined
     */
    get heightType() {
        return this.heightTypeIn;
    }
    set heightType(value) {
        if (value === this.heightTypeIn) {
            return;
        }
        this.heightTypeIn = value;
        this.notifyPropertyChanged('heightType');
    }
    /**
     * Gets or Sets a value indicating whether the selected rows are header rows or not.
     * @default undefined
     */
    get isHeader() {
        return this.isHeaderIn;
    }
    set isHeader(value) {
        if (value === this.isHeaderIn) {
            return;
        }
        this.isHeaderIn = value;
        this.notifyPropertyChanged('isHeader');
    }
    /**
     * Gets or Sets a value indicating whether to allow break across pages for selected rows.
     * @default undefined
     */
    get allowBreakAcrossPages() {
        return this.allowRowBreakAcrossPagesIn;
    }
    set allowBreakAcrossPages(value) {
        if (value === this.allowRowBreakAcrossPagesIn) {
            return;
        }
        this.allowRowBreakAcrossPagesIn = value;
        this.notifyPropertyChanged('allowBreakAcrossPages');
    }
    notifyPropertyChanged(propertyName) {
        let selection = this.selection;
        if (!isNullOrUndefined(selection) && (selection.isCleared || selection.owner.isReadOnlyMode
            || !selection.owner.isDocumentLoaded || selection.owner.isPastingContent) && !selection.isRetrieveFormatting) {
            return;
        }
        if (!isNullOrUndefined(selection) && !isNullOrUndefined(selection.start) && !selection.isRetrieveFormatting) {
            let value = this.getPropertyValue(propertyName);
            if (!isNullOrUndefined(value)) {
                selection.owner.editorModule.onApplyTableRowFormat(propertyName, value);
            }
        }
    }
    getPropertyValue(propertyName) {
        switch (propertyName) {
            case 'height':
                return this.height;
            case 'heightType':
                return this.heightType;
            case 'isHeader':
                return this.isHeader;
            case 'allowBreakAcrossPages':
                return this.allowBreakAcrossPages;
            default:
                return undefined;
        }
    }
    /**
     * Copies the format.
     * @param  {WRowFormat} format
     * @returns void
     * @private
     */
    copyFormat(format) {
        this.height = format.height;
        this.heightType = format.heightType;
        this.allowBreakAcrossPages = format.allowBreakAcrossPages;
        this.isHeader = format.isHeader;
    }
    /**
     * Combines the format.
     * @param  {WRowFormat} format
     * @private
     */
    combineFormat(format) {
        if (!isNullOrUndefined(this.height) && this.height !== format.height) {
            this.height = undefined;
        }
        if (!isNullOrUndefined(this.heightType) && this.heightType !== format.heightType) {
            this.heightType = undefined;
        }
        if (!isNullOrUndefined(this.allowBreakAcrossPages) && this.allowBreakAcrossPages !== format.allowBreakAcrossPages) {
            this.allowBreakAcrossPages = undefined;
        }
        if (!isNullOrUndefined(this.isHeader) && this.isHeader !== format.isHeader) {
            this.isHeader = undefined;
        }
    }
    /**
     * Clears the row format.
     * @returns void
     * @private
     */
    clearRowFormat() {
        this.height = undefined;
        this.heightType = undefined;
        this.allowBreakAcrossPages = undefined;
        this.isHeader = undefined;
    }
    /**
     * Clears the format.
     * @returns void
     * @private
     */
    clearFormat() {
        this.height = 0;
        this.heightType = undefined;
        this.allowBreakAcrossPages = undefined;
        this.isHeader = undefined;
    }
    /**
     * Destroys the managed resources.
     * @returns void
     * @private
     */
    destroy() {
        this.heightIn = undefined;
        this.heightTypeIn = undefined;
        this.allowRowBreakAcrossPagesIn = undefined;
        this.isHeaderIn = undefined;
        this.selection = undefined;
    }
}
/**
 * Selection image format implementation
 */
class SelectionImageFormat {
    /**
     * Gets the width of the image.
     */
    get width() {
        if (this.image) {
            return this.image.width;
        }
        return 0;
    }
    /**
     * Gets the height of the image.
     */
    get height() {
        if (this.image) {
            return this.image.height;
        }
        return 0;
    }
    /**
     * @private
     */
    constructor(selection) {
        this.selection = selection;
    }
    /**
     * Resizes the image based on given size.
     * @param width
     * @param height
     */
    resize(width, height) {
        this.updateImageFormat(width, height);
    }
    /**
     * Update image width and height
     * @private
     */
    updateImageFormat(width, height) {
        if (this.image) {
            if (this.selection.owner.editorModule) {
                this.selection.owner.editorModule.onImageFormat(this.image, width, height);
            }
        }
    }
    /**
     * @private
     */
    copyImageFormat(image) {
        this.image = image;
    }
    /**
     * @private
     */
    clearImageFormat() {
        this.image = undefined;
    }
}
/* tslint:enable */

/**
 * @private
 */
class HtmlExport {
    constructor() {
        /* tslint:disable:no-any */
        this.document = undefined;
        /* tslint:disable:no-any */
        /**
         * @private
         */
        this.fieldCheck = 0;
        /* tslint:enable:no-any */
    }
    /* tslint:disable:no-any */
    /**
     * @private
     */
    writeHtml(document) {
        this.document = document;
        let html = '';
        for (let i = 0; i < document.sections.length; i++) {
            html = this.serializeSection(document.sections[i]);
        }
        return html;
    }
    /**
     * @private
     */
    serializeSection(section) {
        let string = '';
        for (let i = 0; i < section.blocks.length; i++) {
            let block = section.blocks[i];
            if (block.hasOwnProperty('inlines')) {
                string += this.serializeParagraph(block);
            }
            else {
                string += this.serializeTable(block);
            }
        }
        return string;
    }
    // Serialize Paragraph 
    /**
     * @private
     */
    serializeParagraph(paragraph) {
        let blockStyle = '';
        let isList = false;
        let tagAttributes = [];
        tagAttributes.push('style="' + this.serializeParagraphStyle(paragraph, '', isList) + '"');
        blockStyle += this.createAttributesTag('p', tagAttributes);
        if (paragraph.inlines.length === 0) {
            //Handled to preserve non breaking space for empty paragraphs similar to MS Word behavior.
            blockStyle += '&nbsp;';
        }
        else {
            blockStyle = this.serializeInlines(paragraph, blockStyle);
        }
        blockStyle += this.endTag('p');
        return blockStyle;
    }
    //SerializeInlines
    /**
     * @private
     */
    serializeInlines(paragraph, blockStyle) {
        let inline = undefined;
        let i = 0;
        while (paragraph.inlines.length > i) {
            inline = paragraph.inlines[i];
            if (inline.hasOwnProperty('imageString')) {
                blockStyle += this.serializeImageContainer(inline);
            }
            else if (inline.hasOwnProperty('fieldType')) {
                if (inline.fieldType === 0) {
                    this.fieldCheck = 1;
                    let tagAttributes = [];
                    tagAttributes.push('style="' + this.serializeInlineStyle(inline.characterFormat, '') + '"');
                    blockStyle += this.createAttributesTag('a', tagAttributes);
                }
                else if (inline.fieldType === 2) {
                    this.fieldCheck = 2;
                }
                else {
                    blockStyle += this.endTag('a');
                    this.fieldCheck = 0;
                }
            }
            else {
                let text = isNullOrUndefined(inline.text) ? '' : inline.text;
                if (this.fieldCheck === 0) {
                    blockStyle += this.serializeSpan(text, inline.characterFormat);
                }
                if (this.fieldCheck === 1) {
                    let hyperLink = text.replace('\"', '');
                    blockStyle += ' href= \"' + hyperLink.replace('HYPERLINK', '').trim();
                    blockStyle += '\"';
                    blockStyle += '>';
                }
                if (this.fieldCheck === 2) {
                    blockStyle += text;
                }
            }
            i++;
        }
        return blockStyle;
    }
    // Serialize Span
    /**
     * @private
     */
    serializeSpan(spanText, characterFormat) {
        let spanClass = '';
        if (spanText.indexOf('\v') !== -1) {
            spanClass += '<br>';
            return spanClass.toString();
        }
        let tagAttributes = [];
        this.serializeInlineStyle(characterFormat, '');
        tagAttributes.push('style="' + this.serializeInlineStyle(characterFormat, '') + '"');
        spanClass += this.createAttributesTag('span', tagAttributes);
        let text = this.decodeHtmlNames(spanText.toString());
        spanClass += text;
        spanClass += this.endTag('span');
        return spanClass.toString();
    }
    //Serialize Image
    /**
     * @private
     */
    serializeImageContainer(image) {
        let imageStyle = '';
        let tagAttributes = [];
        this.serializeInlineStyle(image.characterFormat, '');
        let imageSource = '';
        if (!isNullOrUndefined(image.imageString)) {
            imageSource = image.imageString;
        }
        let width = HelperMethods.convertPointToPixel(image.width);
        let height = HelperMethods.convertPointToPixel(image.height);
        tagAttributes.push('width="', width.toString() + '"');
        tagAttributes.push('height="', height.toString() + '"');
        tagAttributes.push('src="', imageSource + '"');
        imageStyle += this.createAttributesTag('img', tagAttributes);
        imageStyle += (this.endTag('img'));
        return imageStyle.toString();
    }
    // Serialize Table Cell
    /**
     * @private
     */
    serializeCell(cell) {
        let blockStyle = '';
        let tagAttributes = [];
        let cellHtml = '';
        tagAttributes = [];
        if (!isNullOrUndefined(cell.cellFormat)) {
            //if (cell.cellFormat.shading.backgroundColor !== Color.FromArgb(0, 0, 0, 0)) {
            tagAttributes.push('bgcolor="' + cell.cellFormat.shading.backgroundColor + '"');
            // }
            if (cell.cellFormat.columnSpan > 1) {
                tagAttributes.push('colspan="' + cell.cellFormat.columnSpan.toString() + '"');
            }
            if (cell.cellFormat.rowSpan > 1) {
                tagAttributes.push('rowspan="' + cell.cellFormat.rowSpan.toString() + '"');
            }
            if (cell.cellFormat.cellWidth !== 0) {
                tagAttributes.push('width="' + cell.cellFormat.cellWidth.toString() + '"');
            }
            if (cell.cellFormat.verticalAlignment !== 'Top') {
                tagAttributes.push('valign="' + cell.cellFormat.verticalAlignment.toString().toLowerCase() + '"');
            }
            if (!isNullOrUndefined(cell.cellFormat.leftMargin) && cell.cellFormat.leftMargin !== 0) {
                cellHtml += ('padding-left:' + cell.cellFormat.leftMargin.toString() + 'pt;');
            }
            if (!isNullOrUndefined(cell.cellFormat.rightMargin) && cell.cellFormat.rightMargin !== 0) {
                cellHtml += ('padding-right:' + cell.cellFormat.rightMargin.toString() + 'pt;');
            }
            if (!isNullOrUndefined(cell.cellFormat.topMargin) && cell.cellFormat.topMargin !== 0) {
                cellHtml += ('padding-top:' + cell.cellFormat.topMargin.toString() + 'pt;');
            }
            if (!isNullOrUndefined(cell.cellFormat.bottomMargin) && cell.cellFormat.bottomMargin !== 0) {
                cellHtml += ('padding-bottom:' + cell.cellFormat.bottomMargin.toString() + 'pt;');
            }
            if (!isNullOrUndefined(cell.cellFormat.borders)) {
                cellHtml += this.serializeCellBordersStyle(cell.cellFormat.borders);
            }
        }
        if (cellHtml.length !== 0) {
            tagAttributes.push('style="' + cellHtml + '"');
        }
        blockStyle += (this.createAttributesTag('td', tagAttributes));
        for (let k = 0; k < cell.blocks.length; k++) {
            let block = cell.blocks[k];
            if (block.hasOwnProperty('rows')) {
                blockStyle += this.serializeTable(block);
            }
            else {
                blockStyle += this.serializeParagraph(block);
            }
        }
        blockStyle += (this.endTag('td'));
        return blockStyle;
    }
    // Serialize Table
    /**
     * @private
     */
    serializeTable(table) {
        let html = '';
        html += this.createTableStartTag(table);
        for (let j = 0; j < table.rows.length; j++) {
            html += this.serializeRow(table.rows[j]);
        }
        html += this.createTableEndTag();
        return html;
    }
    // Serialize Row
    /**
     * @private
     */
    serializeRow(row) {
        let html = '';
        html += this.createRowStartTag(row);
        for (let k = 0; k < row.cells.length; k++) {
            html += this.serializeCell(row.cells[k]);
        }
        return html;
    }
    // Serialize Styles
    /**
     * @private
     */
    serializeParagraphStyle(paragraph, className, isList) {
        let paragraphClass = '';
        paragraphClass += this.serializeCharacterFormat(paragraph.characterFormat);
        paragraphClass += this.serializeParagraphFormat(paragraph.paragraphFormat, isList);
        return paragraphClass;
    }
    /**
     * @private
     */
    serializeInlineStyle(characterFormat, className) {
        return this.serializeCharacterFormat(characterFormat);
    }
    /**
     * @private
     */
    serializeTableBorderStyle(borders) {
        let borderStyle = '';
        borderStyle += ('border-left-style:' + this.convertBorderLineStyle(borders.left.lineStyle));
        borderStyle += ';';
        borderStyle += ('border-left-width:' + borders.left.lineWidth.toString() + 'pt');
        borderStyle += ';';
        borderStyle += ('border-left-color:' + borders.left.color);
        borderStyle += ';';
        borderStyle += ('border-right-style:' + this.convertBorderLineStyle(borders.right.lineStyle));
        borderStyle += ';';
        borderStyle += ('border-right-width:' + borders.right.lineWidth.toString() + 'pt');
        borderStyle += ';';
        borderStyle += ('border-right-color:' + borders.right.color);
        borderStyle += ';';
        borderStyle += ('border-top-style:' + this.convertBorderLineStyle(borders.top.lineStyle));
        borderStyle += ';';
        borderStyle += ('border-top-width:' + borders.top.lineWidth.toString() + 'pt');
        borderStyle += ';';
        borderStyle += ('border-top-color:' + borders.top.color);
        borderStyle += ';';
        borderStyle += ('border-Bottom-style:' + this.convertBorderLineStyle(borders.bottom.lineStyle));
        borderStyle += ';';
        borderStyle += ('border-Bottom-width:' + borders.bottom.lineWidth.toString() + 'pt');
        borderStyle += ';';
        borderStyle += ('border-Bottom-color:' + borders.bottom.color);
        borderStyle += ';';
        return borderStyle;
    }
    /**
     * @private
     */
    serializeCellBordersStyle(borders) {
        let borderStyle = '';
        borderStyle = 'border:solid 1px;';
        // Todo: handle
        // let border: WBorder = undefined;
        // //LeftBorder
        // border = WCell.getCellLeftBorder(WCell.getCellOf(borders));
        // if (!isNullOrUndefined(border) && border.lineStyle !== 'None') {
        //     borderStyle += this.serializeBorderStyle(border, 'left');
        // } else if (!isNullOrUndefined(border) && border.hasNoneStyle) {
        //     borderStyle += ('border-left-style:none;');
        // }
        // //RightBorder
        // border = WCell.getCellRightBorder(WCell.getCellOf(borders));
        // if (!isNullOrUndefined(border) && border.lineStyle !== 'None') {
        //     borderStyle += this.serializeBorderStyle(border, 'right');
        // } else if (!isNullOrUndefined(border) && border.hasNoneStyle) {
        //     borderStyle += ('border-right-style:none');
        // }
        // //TopBorder
        // border = WCell.getCellTopBorder(WCell.getCellOf(borders));
        // if (!isNullOrUndefined(border) && border.lineStyle !== 'None') {
        //     borderStyle += this.serializeBorderStyle(border, 'top');
        // } else if (!isNullOrUndefined(border) && border.hasNoneStyle) {
        //     borderStyle += ('border-top-style:none');
        // }
        // //BottomBorder
        // border = WCell.getCellBottomBorder(WCell.getCellOf(borders));
        // if (!isNullOrUndefined(border) && border.lineStyle !== 'None') {
        //     borderStyle += this.serializeBorderStyle(border, 'bottom');
        // } else if (!isNullOrUndefined(border) && border.hasNoneStyle) {
        //     borderStyle += ('border-bottom-style:none');
        // }
        return borderStyle;
    }
    /**
     * @private
     */
    serializeBorderStyle(border, borderPosition) {
        let borderStyle = '';
        borderStyle += ('border-' + borderPosition + '-style:' + this.convertBorderLineStyle(border.lineStyle));
        borderStyle += ';';
        if (border.lineWidth > 0) {
            borderStyle += ('border-' + borderPosition + '-width:' + border.lineWidth.toString() + 'pt;');
        }
        //if (border.color !== Color.FromArgb(0, 0, 0, 0))
        borderStyle += ('border-' + borderPosition + '-color:' + border.color + ';');
        return borderStyle;
    }
    /**
     * @private
     */
    convertBorderLineStyle(lineStyle) {
        switch (lineStyle) {
            case 'None':
                return 'none';
            case 'Single':
                return 'solid';
            case 'Dot':
                return 'dotted';
            case 'DashSmallGap':
            case 'DashLargeGap':
            case 'DashDot':
            case 'DashDotDot':
                return 'dashed';
            case 'Double':
            case 'Triple':
            case 'ThinThickSmallGap':
            case 'ThickThinSmallGap':
            case 'ThinThickThinSmallGap':
            case 'ThinThickMediumGap':
            case 'ThickThinMediumGap':
            case 'ThinThickThinMediumGap':
            case 'ThinThickLargeGap':
            case 'ThickThinLargeGap':
            case 'ThinThickThinLargeGap':
                return 'double';
            case 'SingleWavy':
                return 'solid';
            case 'DoubleWavy':
                return 'double';
            case 'DashDotStroked':
                return 'solid';
            case 'Emboss3D':
                return 'ridge';
            case 'Engrave3D':
                return 'groove';
            case 'Outset':
                return 'outset';
            case 'Inset':
                return 'inset';
            default:
                return 'solid';
        }
    }
    // Serialize Format
    /**
     * @private
     */
    serializeCharacterFormat(characterFormat) {
        if (!isNullOrUndefined(characterFormat.inlineFormat)) {
            return this.serializeCharacterFormat(characterFormat.inlineFormat);
        }
        let propertyValue;
        let charStyle = '';
        if (characterFormat.bold) {
            charStyle += 'font-weight';
            charStyle += ':';
            charStyle += 'bold';
            charStyle += ';';
        }
        charStyle += 'font-style';
        charStyle += ':';
        if (characterFormat.italic) {
            charStyle += 'italic';
        }
        else {
            charStyle += 'normal';
        }
        charStyle += ';';
        // Double strike through will become Single strike through while saving HTML using MS Word.
        if (characterFormat.strikethrough === 'SingleStrike' || characterFormat.strikethrough === 'DoubleStrike') {
            charStyle += 'text-decoration';
            charStyle += ':';
            charStyle += 'line-through';
            charStyle += ';';
        }
        //Text Baseline Alignment
        // tslint:disable-next-line:max-line-length
        if (characterFormat.baselineAlignment === 'Superscript' || characterFormat.baselineAlignment === 'Subscript') {
            charStyle += 'vertical-align';
            charStyle += ':';
            charStyle += characterFormat.baselineAlignment === 'Superscript' ? 'super' : 'sub';
            charStyle += ';';
        }
        //Text Foreground and Background Color 
        if (!isNullOrUndefined(characterFormat.highlightColor)) {
            charStyle += 'background-color';
            charStyle += ':';
            charStyle += characterFormat.highlightColor.toString();
            charStyle += ';';
        }
        //Font Color
        propertyValue = characterFormat.fontColor;
        if (!isNullOrUndefined(propertyValue)) {
            charStyle += 'color';
            charStyle += ':';
            charStyle += propertyValue;
            charStyle += ';';
        }
        if (!isNullOrUndefined(characterFormat.underline) && characterFormat.underline !== 'None') {
            charStyle += 'text-decoration';
            charStyle += ':';
            charStyle += 'underline';
            charStyle += ';';
        }
        propertyValue = characterFormat.fontSize;
        if (!isNullOrUndefined(propertyValue)) {
            charStyle += 'font-size';
            charStyle += ':';
            charStyle += propertyValue.toString();
            charStyle += 'pt';
            charStyle += ';';
        }
        propertyValue = characterFormat.fontFamily;
        if (!isNullOrUndefined(propertyValue)) {
            charStyle += 'font-family';
            charStyle += ':';
            charStyle += propertyValue.toString();
            charStyle += ';';
        }
        return charStyle.toString();
    }
    /**
     * @private
     */
    serializeParagraphFormat(paragraphFormat, isList) {
        if (!isNullOrUndefined(paragraphFormat.inlineFormat)) {
            return this.serializeParagraphFormat(paragraphFormat.inlineFormat, isList);
        }
        let propertyValue;
        let paraStyle = '';
        propertyValue = paragraphFormat.textAlignment;
        if (!isNullOrUndefined(propertyValue)) {
            paraStyle += 'text-align:' + propertyValue.toLowerCase() + ';';
        }
        propertyValue = paragraphFormat.beforeSpacing;
        if (!isNullOrUndefined(propertyValue)) {
            paraStyle += 'margin-top:' + propertyValue.toString() + 'pt; ';
        }
        propertyValue = paragraphFormat.rightIndent;
        if (!isNullOrUndefined(propertyValue)) {
            paraStyle += 'margin-right:' + propertyValue.toString() + 'pt; ';
        }
        propertyValue = paragraphFormat.afterSpacing;
        if (!isNullOrUndefined(propertyValue)) {
            paraStyle += 'margin-bottom:' + propertyValue.toString() + 'pt; ';
        }
        propertyValue = paragraphFormat.leftIndent;
        if (isList) {
            if (isNullOrUndefined(propertyValue)) {
                propertyValue = -48;
            }
            else {
                propertyValue -= 48;
            }
        }
        if (!isNullOrUndefined(propertyValue)) {
            paraStyle += 'margin-left:' + propertyValue.toString() + 'pt; ';
        }
        propertyValue = paragraphFormat.firstLineIndent;
        if (isList) {
            if (isNullOrUndefined(propertyValue)) {
                propertyValue = 24;
            }
            else {
                propertyValue += 24;
            }
        }
        if (!isNullOrUndefined(propertyValue) && propertyValue !== 0) {
            paraStyle += 'text-indent:' + propertyValue.toString() + 'pt;';
        }
        propertyValue = paragraphFormat.lineSpacing;
        if (!isNullOrUndefined(propertyValue)) {
            if (paragraphFormat.lineSpacingType === 'Multiple') {
                propertyValue = (propertyValue * 100).toString() + '%;';
            }
            else {
                propertyValue = propertyValue.toString() + 'pt;';
            }
            paraStyle += 'line-height:' + propertyValue;
        }
        return paraStyle.toString();
    }
    /**
     * @private
     */
    createAttributesTag(tagValue, localProperties) {
        let sb = '';
        sb += '<';
        sb += tagValue;
        for (let i = 0; i < localProperties.length; i++) {
            sb += ' ';
            sb += localProperties[i];
        }
        if (tagValue !== 'a') {
            sb += '>';
        }
        return sb;
    }
    /**
     * @private
     */
    createTag(tagValue) {
        let s = '';
        s += '<';
        s += tagValue;
        s += '>';
        return s;
    }
    /**
     * @private
     */
    endTag(tagValue) {
        let sb = '';
        sb += '<';
        sb += '/';
        sb += tagValue;
        sb += '>';
        return sb;
    }
    /**
     * @private
     */
    createTableStartTag(table) {
        let blockStyle = '';
        let tableStyle = '';
        let tagAttributes = [];
        tagAttributes.push('border="' + '1"');
        if (!isNullOrUndefined(table.tableFormat)) {
            //if (table.tableFormat.shading.backgroundColor !== Color.FromArgb(0, 0, 0, 0)) {
            tagAttributes.push('bgcolor="' + table.tableFormat.shading.backgroundColor + '"');
            //}
            if (table.tableFormat.leftIndent !== 0) {
                tagAttributes.push('left-indent="' + table.tableFormat.leftIndent.toString() + 'pt;');
            }
            if (table.tableFormat.cellSpacing > 0) {
                tagAttributes.push('cellspacing="' + (((table.tableFormat.cellSpacing * 72) / 96) * 2).toString() + '"');
            }
            else {
                tableStyle += ('border-collapse:collapse;');
            }
            tagAttributes.push('cellpadding="' + '0"');
            if (!isNullOrUndefined(table.tableFormat.borders)) {
                tableStyle += this.serializeTableBorderStyle(table.tableFormat.borders);
            }
        }
        if (tableStyle.length !== 0) {
            tagAttributes.push('style="', tableStyle.toString() + '"');
        }
        return blockStyle += (this.createAttributesTag('table', tagAttributes));
    }
    /**
     * @private
     */
    createTableEndTag() {
        let blockStyle = '';
        blockStyle += (this.endTag('table'));
        return blockStyle;
    }
    /**
     * @private
     */
    createRowStartTag(row) {
        let blockStyle = '';
        let tagAttributes = [];
        if (row.rowFormat.isHeader) {
            blockStyle += (this.createTag('thead'));
        }
        if (row.rowFormat.height > 0) {
            tagAttributes.push('height="' + row.rowFormat.height + '"');
        }
        return blockStyle + this.createAttributesTag('tr', tagAttributes);
    }
    /**
     * @private
     */
    createRowEndTag(row) {
        let blockStyle = '';
        blockStyle += (this.endTag('tr'));
        if (row.rowFormat.isHeader) {
            blockStyle += (this.endTag('thead'));
        }
        return blockStyle;
    }
    /**
     * @private
     */
    decodeHtmlNames(text) {
        if (text === '\t') {
            return '&emsp;';
        }
        let splittedText = text.split(' ');
        let htmlText = '';
        if (splittedText.length > 0) {
            htmlText = splittedText[0];
            for (let i = 0; i < splittedText.length - 1; i++) {
                htmlText += '&nbsp;' + splittedText[i + 1];
            }
        }
        return htmlText;
    }
}

/**
 * @private
 */
class TextPosition {
    constructor(owner) {
        /**
         * @private
         */
        this.location = new Point(0, 0);
        /**
         * @private
         */
        this.isUpdateLocation = true;
        this.owner = owner;
        this.viewer = this.owner.viewer;
    }
    /**
     * @private
     */
    get paragraph() {
        return this.currentWidget.paragraph;
    }
    /**
     * @private
     */
    get isAtParagraphStart() {
        return this.offset === this.owner.selection.getStartOffset(this.paragraph);
    }
    /**
     * @private
     */
    get isAtParagraphEnd() {
        return this.owner.selection.isParagraphLastLine(this.currentWidget)
            && this.offset === this.owner.selection.getLineLength(this.currentWidget);
    }
    /**
     * @private
     */
    get selection() {
        return this.owner.selection;
    }
    /**
     * Gets the hierarchical position of logical text position in the document
     * @returns {string}
     */
    get hierarchicalPosition() {
        return this.getHierarchicalIndexInternal();
    }
    /**
     * Return clone of current text position
     * @private
     */
    clone() {
        let textPosition = new TextPosition(this.owner);
        textPosition.currentWidget = this.currentWidget;
        textPosition.offset = this.offset;
        textPosition.location = this.location;
        return textPosition;
    }
    /**
     * Set text position for paragraph and inline
     * @private
     */
    setPositionForSelection(line, element, index, physicalLocation) {
        //Set the start end position
        let isParagraphEnd = false;
        if (isNullOrUndefined(element)) {
            this.currentWidget = line;
        }
        else {
            this.currentWidget = element.line;
            if (element.nextNode instanceof FieldElementBox && index > element.length) {
                isParagraphEnd = this.selection.isLastRenderedInline(element, element.length);
            }
        }
        this.location = physicalLocation;
        if (isParagraphEnd) {
            this.offset = this.selection.getParagraphLength(this.currentWidget.paragraph) + 1;
        }
        else {
            this.offset = this.currentWidget.getOffset(element, index);
        }
    }
    /**
     * Set text position
     * @private
     */
    setPositionFromLine(line, offset, location) {
        this.currentWidget = line;
        this.offset = offset;
        if (location instanceof Point) {
            this.location.copy(location);
        }
    }
    /**
     * Set text position
     * @private
     */
    setPosition(line, positionAtStart) {
        this.currentWidget = line;
        this.offset = positionAtStart ? this.selection.getStartOffset(line.paragraph)
            : this.selection.getParagraphLength(line.paragraph) + 1;
        this.updatePhysicalPosition(true);
    }
    /**
     * Set position for text position
     * @private
     */
    setPositionInternal(textPosition) {
        this.currentWidget = textPosition.currentWidget;
        this.offset = textPosition.offset;
        this.location = textPosition.location;
    }
    /**
     * Set position for current index
     * @private
     */
    setPositionForCurrentIndex(hierarchicalIndex) {
        let index = { index: hierarchicalIndex };
        let paragraph = this.getParagraphWidget(index); //ref hierarchicalIndex
        this.offset = parseFloat(index.index);
        this.setPositionParagraph(paragraph, this.offset);
    }
    /**
     * Get Page
     */
    getPage(position) {
        let page;
        let index = position.index.indexOf(';');
        let newValue = '0';
        if (index >= 0) {
            newValue = position.index.substring(0, index);
            position.index = position.index.substring(index).replace(';', '');
        }
        index = parseInt(newValue, 10);
        page = this.viewer.pages[index];
        return page;
    }
    /**
     * @private
     */
    getParagraphWidget(position) {
        if (isNullOrUndefined(position.index)) {
            return undefined;
        }
        let page = this.getPage(position);
        let child = this.getLineWidget(undefined, position, page);
        return child;
    }
    /**
     * @private
     */
    getLineWidget(widget, position, page) {
        if (isNullOrUndefined(position.index)) {
            return undefined;
        }
        let index = position.index.indexOf(';');
        let value = '0';
        if (index >= 0) {
            value = position.index.substring(0, index);
            position.index = position.index.substring(index).replace(';', '');
        }
        if (value === 'H' || value === 'F') {
            if (value === 'H') {
                widget = page.headerWidget;
            }
            else {
                widget = page.footerWidget;
            }
        }
        else if (!isNullOrUndefined(page)) {
            widget = page.bodyWidgets[0];
        }
        index = parseInt(value, 10);
        if (widget instanceof BlockContainer) {
            index = position.index.indexOf(';');
            value = '0';
            value = position.index.substring(0, index);
            position.index = position.index.substring(index).replace(';', '');
            index = parseInt(value, 10);
        }
        if (widget instanceof TableRowWidget && index >= widget.childWidgets.length) {
            position.index = '0;0';
            index = widget.childWidgets.length - 1;
        }
        if (index >= 0 && index < widget.childWidgets.length) {
            let child = widget.childWidgets[index];
            if (child instanceof LineWidget) {
                if (position.index.indexOf(';') > 0) {
                    position.index = '0';
                }
                return child;
            }
            if (child instanceof Widget) {
                if (position.index.indexOf(';') > 0) {
                    return this.getLineWidget(child, position);
                }
                else {
                    //If table is shifted to previous text position then return the first paragraph within table.
                    if (child instanceof TableWidget) {
                        return this.getLineWidget(this.selection.getFirstParagraphInFirstCell(child), position);
                    }
                    else if (child instanceof TableRowWidget && position.index.indexOf(';') === -1) {
                        return this.selection.getFirstParagraphInFirstCell(child.ownerTable).childWidgets[0];
                    }
                    return undefined;
                }
            }
        }
        else if (widget.nextRenderedWidget instanceof Widget) {
            position.index = '0';
            if (widget.nextRenderedWidget instanceof TableWidget) {
                return this.selection.getFirstParagraphInFirstCell(widget.nextRenderedWidget).firstChild;
            }
            return this.getLineWidget(widget.nextRenderedWidget, position);
        }
        return undefined;
    }
    /**
     * Update physical location of paragraph
     * @private
     */
    updatePhysicalPosition(moveNextLine) {
        if (this.currentWidget && this.owner.isLayoutEnabled && this.isUpdateLocation) {
            this.location = this.selection.getPhysicalPositionInternal(this.currentWidget, this.offset, moveNextLine);
        }
    }
    /**
     * Return true if text position are in same paragraph and offset
     * @private
     */
    isAtSamePosition(textPosition) {
        return this.currentWidget === textPosition.currentWidget
            && this.offset === textPosition.offset;
    }
    /**
     * Return true if text position is in same paragraph
     * @private
     */
    isInSameParagraph(textPosition) {
        if (isNullOrUndefined(textPosition)) {
            throw new Error('textPosition is undefined.');
        }
        return this.paragraph === textPosition.paragraph;
    }
    /**
     * Return true is current text position exist before given text position
     * @private
     */
    isExistBefore(textPosition) {
        if (isNullOrUndefined(textPosition)) {
            throw new Error('textPosition is undefined.');
        }
        if (this.currentWidget === textPosition.currentWidget) {
            return this.offset < textPosition.offset;
        }
        let currentParagraph = this.currentWidget.paragraph;
        let paragraph = textPosition.currentWidget.paragraph;
        if (currentParagraph === paragraph) {
            return currentParagraph.childWidgets.indexOf(this.currentWidget) < paragraph.childWidgets.indexOf(textPosition.currentWidget);
        }
        if (currentParagraph.containerWidget === paragraph.containerWidget) {
            if (currentParagraph.isInsideTable) {
                return currentParagraph.associatedCell.childWidgets.indexOf(currentParagraph) <
                    paragraph.associatedCell.childWidgets.indexOf(paragraph);
                //handle after header footer implementation
                // } else if ((this.currentParagraph).owner instanceof WHeaderFooter) {
                //     return ((this.currentParagraph).owner as WHeaderFooter).blocks.indexOf((this.currentParagraph)) <
                //         ((textPosition.currentParagraph).owner as WHeaderFooter).blocks.indexOf((textPosition.currentParagraph));
            }
            else {
                return (currentParagraph.containerWidget.childWidgets.indexOf(currentParagraph)) <
                    (paragraph.containerWidget.childWidgets.indexOf(paragraph));
            }
        }
        return this.owner.selection.isExistBefore(currentParagraph, paragraph);
    }
    /**
     * Return true is current text position exist after given text position
     * @private
     */
    isExistAfter(textPosition) {
        if (isNullOrUndefined(textPosition)) {
            throw new Error('textPosition is undefined.');
        }
        if (this.currentWidget === textPosition.currentWidget) {
            return this.offset > textPosition.offset;
        }
        if (this.currentWidget.paragraph === textPosition.currentWidget.paragraph) {
            return this.currentWidget.paragraph.childWidgets.indexOf(this.currentWidget) >
                textPosition.currentWidget.paragraph.childWidgets.indexOf(textPosition.currentWidget);
        }
        let startParagraph = this.currentWidget.paragraph;
        let endParagraph = textPosition.currentWidget.paragraph;
        if (startParagraph.containerWidget.index === endParagraph.containerWidget.index) {
            if (startParagraph.isInsideTable) {
                return startParagraph.associatedCell.childWidgets.indexOf(startParagraph) >
                    endParagraph.associatedCell.childWidgets.indexOf(endParagraph);
                // } else if ((this.currentParagraph).owner instanceof WHeaderFooter) {
                //     return ((this.currentParagraph).owner as WHeaderFooter).blocks.indexOf((this.currentParagraph)) >
                //         ((textPosition.currentParagraph).owner as WHeaderFooter).blocks.indexOf((textPosition.currentParagraph));
            }
            else {
                return (startParagraph.containerWidget.childWidgets.indexOf(startParagraph) >
                    (endParagraph.containerWidget.childWidgets.indexOf(endParagraph)));
            }
        }
        return this.owner.selection.isExistAfter(startParagraph, endParagraph);
    }
    /**
     * Return hierarchical index of current text position
     * @private
     */
    getHierarchicalIndexInternal() {
        return this.getHierarchicalIndex(this.currentWidget, this.offset.toString());
    }
    /**
     * @private
     */
    getHierarchicalIndex(line, hierarchicalIndex) {
        let node = line;
        if (node) {
            return node.getHierarchicalIndex(hierarchicalIndex);
        }
        return hierarchicalIndex;
    }
    /**
     * @private
     */
    setPositionParagraph(line, offsetInLine) {
        this.currentWidget = line;
        this.offset = offsetInLine;
        this.updatePhysicalPosition(true);
    }
    /**
     * @private
     */
    setPositionForLineWidget(lineWidget, offset) {
        let lineLength = this.selection.getLineLength(lineWidget);
        let lineIndex = lineWidget.paragraph.childWidgets.indexOf(lineWidget);
        if (offset > lineLength + 1) {
            let nextLineWidget;
            if (lineIndex >= lineWidget.paragraph.childWidgets.length - 1) {
                let nextBlock = this.selection.getNextRenderedBlock(lineWidget.paragraph);
                if (nextBlock && nextBlock.index === lineWidget.paragraph.index) {
                    nextLineWidget = nextBlock.firstChild;
                }
            }
            else {
                nextLineWidget = lineWidget.paragraph.childWidgets[lineIndex + 1];
            }
            this.setPositionForLineWidget(nextLineWidget, offset - lineLength);
            return;
        }
        else if (offset < 0) {
            let prevLine = lineWidget.paragraph.childWidgets[lineIndex - 1];
            let curretOffSet = this.selection.getLineLength(prevLine) + offset;
            this.setPositionForLineWidget(prevLine, curretOffSet);
            return;
        }
        else {
            this.currentWidget = lineWidget;
            this.offset = offset;
        }
        this.updatePhysicalPosition(true);
    }
    /**
     * move to next text position
     * @private
     */
    moveNextPosition(isNavigate) {
        if (isNullOrUndefined(isNavigate)) {
            isNavigate = true;
        }
        let inline = this.selection.getNextStartInline(this.currentWidget, this.offset);
        if (inline instanceof FieldElementBox && inline.fieldType === 0 && !isNullOrUndefined(inline.fieldEnd)) {
            if (isNavigate) {
                this.moveNextPositionInternal(inline);
                this.moveNextPosition();
                return;
            }
            else {
                let line = inline.fieldEnd.line;
                let fieldEnd = inline.fieldEnd;
                let fieldEndOffset = line.getOffset(fieldEnd, 1);
                let fieldEndIndex = this.getHierarchicalIndex(line, fieldEndOffset.toString());
                if (TextPosition.isForwardSelection(this.selection.end.getHierarchicalIndexInternal(), fieldEndIndex)) {
                    //If field end is after selection end, extend selection end to field end.
                    this.selection.end.moveToInline(inline.fieldEnd, 1);
                    return;
                }
                this.moveToInline(inline.fieldEnd, 1);
            }
        }
        let nextOffset = this.selection.getNextValidOffset(this.currentWidget, this.offset);
        let lineIndex = this.paragraph.childWidgets.indexOf(this.currentWidget);
        let index = 0;
        if (nextOffset > this.offset) {
            this.offset = nextOffset;
            let info = this.currentWidget.getInline(this.offset, index);
            inline = info.element;
            index = info.index;
            if (!isNullOrUndefined(inline) && index === inline.length && inline.nextNode instanceof FieldElementBox) {
                let nextValidInline = this.selection.getNextValidElement(inline.nextNode);
                //Moves to field end mark.
                if (nextValidInline instanceof FieldElementBox && nextValidInline.fieldType === 1) {
                    inline = nextValidInline;
                    this.offset = this.currentWidget.getOffset(inline, 1);
                }
            }
        }
        else if (lineIndex + 1 < this.paragraph.childWidgets.length) {
            let nextLineWidget = this.paragraph.childWidgets[lineIndex + 1];
            if (nextLineWidget) {
                this.currentWidget = nextLineWidget;
                this.offset = this.selection.getStartLineOffset(this.currentWidget);
            }
            let inlineObj = this.currentWidget.getInline(this.offset, index);
            inline = inlineObj.element;
            index = inlineObj.index;
            if (inline instanceof FieldElementBox && inline.fieldType === 0) {
                this.offset++;
            }
        }
        else {
            this.updateOffsetToNextParagraph(index, false);
        }
        //Gets physical position in current page.
        this.updatePhysicalPosition(true);
    }
    /**
     * Move text position to previous paragraph inside table
     * @private
     */
    moveToPreviousParagraphInTable(selection) {
        let previousParagraph;
        let currentPara = this.currentWidget.paragraph;
        if (currentPara.isInsideTable) {
            previousParagraph = selection.getPreviousSelectionCell(currentPara.associatedCell);
        }
        else {
            previousParagraph = selection.getPreviousParagraphBlock(currentPara);
        }
        if (isNullOrUndefined(previousParagraph)) {
            return;
        }
        this.currentWidget = previousParagraph.childWidgets[previousParagraph.childWidgets.length - 1];
        this.offset = this.currentWidget.getEndOffset() + 1;
    }
    updateOffsetToNextParagraph(indexInInline, isHighlight) {
        //Moves to owner and get next paragraph.
        let inline;
        let positionAtStart = false;
        let nextParagraph = undefined;
        let lineIndex = this.paragraph.childWidgets.indexOf(this.currentWidget);
        if (!isHighlight) {
            nextParagraph = this.selection.getNextParagraphBlock(this.paragraph);
        }
        else if (lineIndex + 1 < this.paragraph.childWidgets.length) {
            let nextLineWidget = this.paragraph.childWidgets[lineIndex + 1];
            if (nextLineWidget) {
                this.currentWidget = nextLineWidget;
                this.offset = 0;
            }
        }
        else {
            nextParagraph = this.selection.getNextSelectionBlock(this.paragraph);
            if (!isNullOrUndefined(nextParagraph)) {
                if (nextParagraph.containerWidget instanceof TableCellWidget) {
                    if (this.selection.start.paragraph.isInsideTable) {
                        // tslint:disable-next-line:max-line-length
                        let containerCell = this.selection.getContainerCellOf(this.selection.start.paragraph.associatedCell, nextParagraph.associatedCell);
                        positionAtStart = !containerCell.ownerTable.contains(nextParagraph.associatedCell);
                    }
                    else {
                        positionAtStart = true;
                    }
                }
            }
        }
        if (!isNullOrUndefined(nextParagraph) && nextParagraph.childWidgets.length > 0) {
            if (!positionAtStart) {
                this.currentWidget = nextParagraph.firstChild;
                this.offset = isHighlight ? 1 : this.selection.getStartLineOffset(this.currentWidget);
            }
            else {
                this.currentWidget = nextParagraph.childWidgets[nextParagraph.childWidgets.length - 1];
                this.offset = this.selection.getLineLength(this.currentWidget) + 1;
            }
        }
        let inlineObj = this.currentWidget.getInline(this.offset, indexInInline);
        inline = inlineObj.element;
        indexInInline = inlineObj.index;
        if (inline instanceof FieldElementBox && inline.fieldType === 0) {
            this.offset++;
        }
    }
    updateOffsetToPrevPosition(index, isHighlight) {
        let inlineInfo;
        let inline;
        let lineIndex = this.paragraph.childWidgets.indexOf(this.currentWidget);
        let prevOffset = this.selection.getPreviousValidOffset(this.currentWidget.paragraph, this.offset);
        if (this.offset > prevOffset) {
            this.offset = prevOffset;
        }
        else if (lineIndex > 0) {
            let prevLineWidget = this.paragraph.childWidgets[lineIndex - 1];
            if (prevLineWidget) {
                this.currentWidget = prevLineWidget;
                this.offset = this.currentWidget.getEndOffset();
            }
        }
        else {
            //Moves to owner and get previous paragraph.
            let previousParagraph = undefined;
            let positionAtStart = false;
            if (!isHighlight) {
                previousParagraph = this.selection.getPreviousParagraphBlock(this.paragraph);
            }
            else {
                previousParagraph = this.selection.getPreviousSelectionBlock(this.paragraph);
                if (!isNullOrUndefined(previousParagraph)) {
                    if (previousParagraph.containerWidget instanceof TableCellWidget) {
                        if (this.selection.start.paragraph.isInsideTable) {
                            // tslint:disable-next-line:max-line-length
                            let containerCell = this.selection.getContainerCellOf(this.selection.start.paragraph.associatedCell, previousParagraph.associatedCell);
                            positionAtStart = !containerCell.ownerTable.contains(previousParagraph.associatedCell);
                        }
                        else {
                            positionAtStart = true;
                        }
                    }
                }
            }
            if (!isNullOrUndefined(previousParagraph)) {
                if (!positionAtStart) {
                    this.currentWidget = previousParagraph.childWidgets[previousParagraph.childWidgets.length - 1];
                    this.offset = this.currentWidget.getEndOffset();
                }
                else {
                    this.currentWidget = previousParagraph.firstChild;
                    this.offset = this.selection.getStartLineOffset(this.currentWidget);
                }
            }
        }
        index = 0;
        inlineInfo = this.currentWidget.getInline(this.offset, index);
        inline = inlineInfo.element;
        index = inlineInfo.index;
        if (inline instanceof FieldElementBox && inline.fieldType === 0) {
            this.offset++;
        }
        if (inline instanceof FieldElementBox) {
            //Checks if field character is part of rendered field, otherwise moves to previous rendered content.
            let previousInline = this.selection.getPreviousValidElement(inline);
            if (!isNullOrUndefined(previousInline)) {
                inline = previousInline;
                this.currentWidget = inline.line;
                this.offset = this.currentWidget.getOffset(inline, inline.length);
                if (inline instanceof FieldElementBox && inline.fieldType === 0) {
                    this.offset--;
                }
            }
        }
        //Gets physical position in current page.
        this.updatePhysicalPosition(true);
    }
    /**
     * Moves the text position to start of the next paragraph.
     */
    moveToNextParagraphStartInternal() {
        let paragraph = this.currentWidget.paragraph;
        if (!isNullOrUndefined(this.selection.getNextParagraphBlock(paragraph))) {
            // tslint:disable-next-line:max-line-length
            this.currentWidget = this.selection.getNextParagraphBlock(paragraph).firstChild;
            this.offset = this.selection.getStartOffset(paragraph);
            this.updatePhysicalPosition(true);
        }
    }
    /**
     * Move to previous position
     * @private
     */
    movePreviousPosition() {
        let index = 0;
        let inlineInfo = this.currentWidget.getInline(this.offset, index);
        let inline = inlineInfo.element;
        index = inlineInfo.index;
        let lineIndex = this.paragraph.childWidgets.indexOf(this.currentWidget);
        if (inline instanceof FieldElementBox && inline.fieldType === 1 && !isNullOrUndefined(inline.fieldBegin)) {
            this.movePreviousPositionInternal(inline);
        }
        this.updateOffsetToPrevPosition(index, false);
    }
    /**
     * Move to next position
     * @private
     */
    moveNextPositionInternal(fieldBegin) {
        let inline;
        if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
            inline = fieldBegin.fieldEnd;
        }
        else {
            inline = fieldBegin.fieldSeparator;
            this.currentWidget = inline.line;
            // tslint:disable-next-line:max-line-length
            if (this.currentWidget === fieldBegin.fieldEnd.line && !this.selection.hasValidInline(this.paragraph, inline, fieldBegin.fieldEnd)) {
                inline = fieldBegin.fieldEnd;
            }
        }
        this.currentWidget = inline.line;
        this.offset = this.currentWidget.getOffset(inline, 1);
    }
    /**
     * Move text position backward
     * @private
     */
    moveBackward() {
        let indexInInline = 0;
        let inlineObj = this.currentWidget.getInline(this.offset, indexInInline);
        let inline = inlineObj.element;
        indexInInline = inlineObj.index;
        if (!this.owner.selection.isEmpty && !isNullOrUndefined(inline)) {
            let nextInline = this.selection.getNextRenderedElementBox(inline, indexInInline);
            if (nextInline instanceof FieldElementBox && nextInline.fieldType === 0) {
                let hierarchicalIndex = this.owner.selection.start.getHierarchicalIndexInternal();
                // tslint:disable-next-line:max-line-length
                let fieldEndOffset = nextInline.fieldEnd.line.getOffset(nextInline.fieldEnd, 1);
                // tslint:disable-next-line:max-line-length
                let fieldEndIndex = this.getHierarchicalIndex(nextInline.fieldEnd.line, fieldEndOffset.toString());
                if (!TextPosition.isForwardSelection(fieldEndIndex, hierarchicalIndex)) {
                    //If field end is after selection start, move selection start to field end.
                    // tslint:disable-next-line:max-line-length
                    this.owner.selection.start.setPositionParagraph(nextInline.fieldEnd.line, fieldEndOffset);
                    return;
                }
            }
        }
        if (inline instanceof FieldElementBox && inline.fieldType === 1 && !isNullOrUndefined(inline.fieldBegin)) {
            let hierarchicalIndex = this.owner.selection.start.getHierarchicalIndexInternal();
            let fieldEndOffset = inline.line.getOffset(inline, 1);
            let fieldEndIndex = this.getHierarchicalIndex(inline.line, fieldEndOffset.toString());
            if (!TextPosition.isForwardSelection(hierarchicalIndex, fieldEndIndex)) {
                //If field end is after selection start, extend selection end to field begin.
                // tslint:disable-next-line:max-line-length
                let fieldBeginOffset = inline.fieldBegin.line.getOffset(inline.fieldBegin, 0);
                this.currentWidget = inline.fieldBegin.line;
                this.offset = fieldBeginOffset;
                //Updates physical position in current page.
                this.updatePhysicalPosition(true);
                return;
            }
            this.movePreviousPositionInternal(inline);
        }
        this.updateOffsetToPrevPosition(indexInInline, true);
    }
    /**
     * Move text position forward
     * @private
     */
    moveForward() {
        let indexInInline = 0;
        let inlineObj = this.currentWidget.getInline(this.offset, indexInInline);
        let inline = inlineObj.element;
        indexInInline = inlineObj.index;
        if (!isNullOrUndefined(inline)) {
            if (!this.owner.selection.isEmpty && indexInInline === inline.length && inline instanceof FieldElementBox
                && inline.fieldType === 1) {
                let hierarchicalIndex = this.owner.selection.start.getHierarchicalIndexInternal();
                // tslint:disable-next-line:max-line-length
                let fieldBeginOffset = inline.fieldBegin.line.getOffset(inline.fieldBegin, 0);
                // tslint:disable-next-line:max-line-length
                let fieldBeginIndex = this.getHierarchicalIndex(inline.fieldBegin.line, fieldBeginOffset.toString());
                if (!TextPosition.isForwardSelection(hierarchicalIndex, fieldBeginIndex)) {
                    //If field begin is before selection start, move selection start to field begin.
                    // tslint:disable-next-line:max-line-length
                    this.owner.selection.start.setPositionParagraph(inline.fieldBegin.line, fieldBeginOffset);
                    return;
                }
            }
            inline = this.selection.getNextRenderedElementBox(inline, indexInInline);
        }
        if (inline instanceof FieldElementBox && !isNullOrUndefined(inline.fieldEnd)) {
            let selectionStartParagraph = this.owner.selection.start.paragraph;
            let selectionStartIndex = 0;
            // tslint:disable-next-line:max-line-length
            let selectionStartInlineObj = selectionStartParagraph.getInline(this.owner.selection.start.offset, selectionStartIndex);
            let selectionStartInline = selectionStartInlineObj.element;
            selectionStartIndex = selectionStartInlineObj.index;
            let nextRenderInline = this.selection.getNextRenderedElementBox(selectionStartInline, selectionStartIndex);
            if (nextRenderInline === inline) {
                this.moveNextPositionInternal(inline);
            }
            else {
                //If selection start is before field begin, extend selection end to field end.
                inline = inline.fieldEnd;
                this.currentWidget = inline.line;
                this.offset = this.currentWidget.getOffset(inline, 1);
                //Updates physical position in current page.
                this.updatePhysicalPosition(true);
                return;
            }
        }
        else if ((inline instanceof FieldElementBox)
            && (inline.fieldType === 0 || inline.fieldType === 1)) {
            this.currentWidget = inline.line;
            this.offset = this.currentWidget.getOffset(inline, 1);
        }
        indexInInline = 0;
        let nextOffset = this.selection.getNextValidOffset(this.currentWidget, this.offset);
        let length = this.selection.getLineLength(this.currentWidget);
        let isParagraphEnd = this.selection.isParagraphLastLine(this.currentWidget);
        if (this.offset < nextOffset) {
            this.offset = nextOffset;
            let inlineObj = this.currentWidget.getInline(this.offset, indexInInline);
            inline = inlineObj.element;
            indexInInline = inlineObj.index;
            if (!isNullOrUndefined(inline) && indexInInline === inline.length && inline.nextNode instanceof FieldElementBox) {
                let nextValidInline = this.selection.getNextValidElement(inline.nextNode);
                //Moves to field end mark.
                if (nextValidInline instanceof FieldElementBox && nextValidInline.fieldType === 1) {
                    inline = nextValidInline;
                    this.offset = this.currentWidget.getOffset(inline, 1);
                }
            }
        }
        else if (this.offset === nextOffset && this.offset < length + 1 && isParagraphEnd) {
            this.offset = length + 1;
        }
        else {
            this.updateOffsetToNextParagraph(indexInInline, true);
        }
        //Gets physical position in current page.
        this.updatePhysicalPosition(true);
    }
    /**
     * Move to given inline
     * @private
     */
    moveToInline(inline, index) {
        this.currentWidget = inline.line;
        this.offset = this.currentWidget.getOffset(inline, index);
        //Updates physical position in current page.
        this.updatePhysicalPosition(true);
    }
    /**
     * Return true is start element exist before end element
     * @private
     */
    static isForwardSelection(start, end) {
        if (start === end) {
            return true;
        }
        start = start.replace(/C;/g, '');
        end = end.replace(/C;/g, '');
        start = start.replace(/H;/g, '');
        end = end.replace(/H;/g, '');
        start = start.replace(/F;/g, '');
        end = end.replace(/F;/g, '');
        let selectionStart = start.split(';');
        let selectionEnd = end.split(';');
        let length = selectionStart.length;
        if (length > selectionEnd.length) {
            length = selectionEnd.length - 1;
        }
        for (let i = 0; i < length; i++) {
            let startOffset = parseFloat(selectionStart[i]);
            let endOffset = parseFloat(selectionEnd[i]);
            if (startOffset !== endOffset) {
                return startOffset < endOffset;
            }
        }
        return false;
    }
    /**
     * Move to previous position offset
     * @private
     */
    movePreviousPositionInternal(fieldEnd) {
        let inline;
        if (isNullOrUndefined(fieldEnd.fieldSeparator)) {
            inline = this.selection.getPreviousValidElement(fieldEnd.fieldBegin);
        }
        else {
            inline = this.selection.getPreviousValidElement(fieldEnd);
        }
        this.currentWidget = inline.line;
        this.offset = this.currentWidget.getOffset(inline, inline instanceof FieldElementBox ? 0 : inline.length);
    }
    /**
     * Moves the text position to start of the word.
     * @private
     */
    moveToWordStartInternal(type) {
        let endOffset = this.currentWidget.getEndOffset();
        let currentPara = this.currentWidget.paragraph;
        let selection = this.selection;
        if (type === 2 && (this.offset === endOffset || this.offset === endOffset + 1)) {
            return;
        }
        if (this.offset === endOffset + 1) {
            this.offset = endOffset;
        }
        else if (this.offset === selection.getStartOffset(currentPara) && this.currentWidget === currentPara.childWidgets[0]) {
            let previousParagraph = selection.getPreviousParagraphBlock(currentPara);
            if (isNullOrUndefined(previousParagraph)) {
                return;
            }
            this.currentWidget = previousParagraph.childWidgets[previousParagraph.childWidgets.length - 1];
            this.offset = this.currentWidget.getEndOffset();
        }
        else {
            if (this.offset === selection.getStartLineOffset(this.currentWidget)) {
                let lineIndex = currentPara.childWidgets.indexOf(this.currentWidget);
                if (lineIndex - 1 >= 0) {
                    this.currentWidget = currentPara.childWidgets[lineIndex - 1];
                    this.offset = this.currentWidget.getEndOffset();
                }
            }
            let isStarted = false;
            let endSelection = false;
            let indexInInline = 0;
            let inlineObj = this.currentWidget.getInline(this.offset, indexInInline);
            let inline = inlineObj.element;
            indexInInline = inlineObj.index;
            // tslint:disable-next-line:max-line-length           
            this.getPreviousWordOffset(inline, selection, indexInInline, type, (inline instanceof FieldElementBox && inline.fieldType === 1), isStarted, endSelection, this);
        }
        if (type === 1) {
            this.calculateOffset();
        }
        this.updatePhysicalPosition(true);
    }
    /**
     * Get next word offset
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getNextWordOffset(inline, indexInInline, type, isInField, endSelection, endPosition, excludeSpace) {
        if (inline instanceof TextElementBox) {
            this.getNextWordOffsetSpan(inline, indexInInline, type, isInField, endSelection, endPosition, excludeSpace);
        }
        else if (inline instanceof ImageElementBox) {
            // tslint:disable-next-line:max-line-length
            this.getNextWordOffsetImage(inline, indexInInline, type, isInField, endSelection, endPosition, excludeSpace);
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 0) {
            // tslint:disable-next-line:max-line-length
            this.getNextWordOffsetFieldBegin(inline, indexInInline, type, isInField, endSelection, endPosition, excludeSpace);
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 2 || inline instanceof BookmarkElementBox) {
            // tslint:disable-next-line:max-line-length
            this.getNextWordOffsetFieldSeperator(inline, indexInInline, type, isInField, endSelection, endPosition, excludeSpace);
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 1) {
            // tslint:disable-next-line:max-line-length
            this.getNextWordOffsetFieldEnd(inline, indexInInline, type, isInField, endSelection, endPosition, excludeSpace);
        }
    }
    /**
     * get next word offset from field begin
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getNextWordOffsetFieldBegin(fieldBegin, indexInInline, type, isInField, endSelection, endPosition, excludeSpace) {
        let startOffset = fieldBegin.line.getOffset(fieldBegin, 0);
        let endOffset = startOffset + fieldBegin.length;
        if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
            this.getNextWordOffsetFieldEnd(fieldBegin.fieldEnd, 0, type, isInField, endSelection, endPosition, excludeSpace);
        }
        else if (type === 0) {
            // tslint:disable-next-line:max-line-length
            this.getNextWordOffsetFieldSeperator(fieldBegin.fieldSeparator, 0, type, isInField, endSelection, endPosition, excludeSpace);
        }
        else if (!isNullOrUndefined(fieldBegin.fieldEnd)) {
            let inline = fieldBegin.fieldSeparator;
            // tslint:disable-next-line:max-line-length
            if (inline.line.paragraph === fieldBegin.fieldEnd.line.paragraph && !this.selection.hasValidInline(inline.line.paragraph, inline, fieldBegin.fieldEnd)) {
                inline = fieldBegin.fieldEnd;
            }
            // tslint:disable-next-line:max-line-length
            this.getNextWordOffset(inline, 0, type, !(endPosition.paragraph === fieldBegin.line.paragraph && endPosition.offset === startOffset), endSelection, endPosition, excludeSpace);
            // tslint:disable-next-line:max-line-length
            if (endSelection && !isNullOrUndefined(fieldBegin.fieldSeparator) && (endPosition.paragraph === fieldBegin.line.paragraph) && (endPosition.offset === fieldBegin.fieldSeparator.line.getOffset(fieldBegin.fieldSeparator, fieldBegin.fieldSeparator.length))) {
                endPosition.setPositionParagraph(fieldBegin.line, startOffset);
                return;
            }
            if (!endSelection) {
                // tslint:disable-next-line:max-line-length
                endPosition.setPositionParagraph(fieldBegin.fieldEnd.line, fieldBegin.fieldEnd.line.getOffset(fieldBegin.fieldEnd, fieldBegin.fieldEnd.length));
            }
        }
    }
    /**
     * get next word offset from image
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getNextWordOffsetImage(image, indexInInline, type, isInField, endSelection, endPosition, excludeSpace) {
        if (isInField) {
            endPosition.setPositionParagraph(image.line, image.line.getOffset(image, indexInInline));
            endSelection = false;
            return;
        }
        if (indexInInline === 0) {
            let startOffset = image.line.getOffset(image, 0);
            endSelection = true;
            if (endPosition.offset === startOffset) {
                if (isNullOrUndefined(image.nextNode)) {
                    endPosition.setPositionParagraph(image.line, startOffset + image.length);
                }
                else {
                    this.getNextWordOffset(image.nextNode, 0, type, isInField, endSelection, endPosition, excludeSpace);
                }
            }
            else {
                endPosition.setPositionParagraph(image.line, startOffset);
            }
        }
        else if (!isNullOrUndefined(image.nextNode)) {
            this.getNextWordOffset(image.nextNode, 0, type, isInField, endSelection, endPosition, excludeSpace);
        }
    }
    /**
     * get next word offset from span
     */
    // tslint:disable-next-line:max-line-length
    getNextWordOffsetSpan(span, indexInInline, type, isInField, endSelection, endPosition, excludeSpace) {
        if (span.text === '\t' || span.text === '\v') {
            if (isInField) {
                endPosition.setPositionParagraph(span.line, span.line.getOffset(span, indexInInline));
                endSelection = false;
                return;
            }
            if (indexInInline === 0) {
                endSelection = true;
                let startOffset = span.line.getOffset(span, 0);
                if (endPosition.offset === startOffset) {
                    endPosition.setPositionParagraph(span.line, startOffset + span.length);
                }
                else {
                    endPosition.setPositionParagraph(span.line, startOffset);
                }
            }
            else if (!isNullOrUndefined(span.nextNode)) {
                this.getNextWordOffset(span.nextNode, 0, type, isInField, endSelection, endPosition, excludeSpace);
            }
        }
        else {
            let wordEndIndex = 0;
            if (indexInInline === 0 && endSelection && (HelperMethods.wordSplitCharacters.indexOf(span.text[0]) === -1)) {
                endPosition.setPositionParagraph(span.line, span.line.getOffset(span, indexInInline));
                if (isInField) {
                    return;
                }
            }
            else if (indexInInline < span.length) {
                // tslint:disable-next-line:max-line-length
                let txt = indexInInline > 0 && span.text.length - 1 >= indexInInline ? span.text.slice(indexInInline, span.length) : span.text;
                wordEndIndex = HelperMethods.indexOfAny(txt, HelperMethods.wordSplitCharacters);
                if (wordEndIndex !== -1) {
                    if (isInField) {
                        endSelection = false;
                        return;
                    }
                    let offset = span.line.getOffset(span, wordEndIndex + indexInInline);
                    // tslint:disable-next-line:max-line-length
                    if ((excludeSpace || txt[wordEndIndex] !== ' ') && !endSelection && span.line.paragraph === endPosition.paragraph && offset !== endPosition.offset) {
                        endSelection = true;
                        endPosition.setPositionParagraph(span.line, offset);
                        return;
                    }
                    wordEndIndex++;
                    while (wordEndIndex < txt.length && HelperMethods.wordSplitCharacters.indexOf(txt[wordEndIndex]) !== -1) {
                        if (txt[wordEndIndex] !== ' ' && txt[wordEndIndex] !== '　') {
                            break;
                        }
                        wordEndIndex++;
                    }
                    endSelection = true;
                    if (wordEndIndex < txt.length) {
                        // tslint:disable-next-line:max-line-length
                        endPosition.setPositionParagraph(span.line, span.line.getOffset(span, wordEndIndex + indexInInline));
                    }
                    else if (!isNullOrUndefined(span.nextNode)) {
                        // tslint:disable-next-line:max-line-length
                        this.getNextWordOffset(span.nextNode, 0, type, isInField, endSelection, endPosition, excludeSpace);
                    }
                    else {
                        // tslint:disable-next-line:max-line-length
                        endPosition.setPositionParagraph(span.line, span.line.getOffset(span, wordEndIndex + indexInInline));
                    }
                }
                else if (!isNullOrUndefined(span.nextNode)) {
                    this.getNextWordOffset(span.nextNode, 0, type, isInField, endSelection, endPosition, excludeSpace);
                }
                else {
                    endPosition.setPositionParagraph(span.line, span.line.getEndOffset());
                }
            }
            else if (!isNullOrUndefined(span.nextNode)) {
                this.getNextWordOffset(span.nextNode, 0, type, isInField, endSelection, endPosition, excludeSpace);
            }
        }
    }
    /**
     * get next word offset from field separator
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getNextWordOffsetFieldSeperator(fieldSeparator, indexInInline, type, isInField, endSelection, endPosition, excludeSpace) {
        if (!isNullOrUndefined(fieldSeparator.nextNode)) {
            this.getNextWordOffset(fieldSeparator.nextNode, 0, type, isInField, endSelection, endPosition, excludeSpace);
        }
    }
    /**
     * get next word offset from field end
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getNextWordOffsetFieldEnd(fieldEnd, indexInInline, type, isInField, endSelection, endPosition, excludeSpace) {
        let startOffset = fieldEnd.line.getOffset(fieldEnd, 0);
        let endOffset = startOffset + fieldEnd.length;
        if (endPosition.offset === startOffset) {
            endPosition.setPositionParagraph(fieldEnd.line, endOffset);
            if (isNullOrUndefined(fieldEnd.nextNode)) {
                return;
            }
        }
        if (!isNullOrUndefined(fieldEnd.nextNode)) {
            this.getNextWordOffset(fieldEnd.nextNode, 0, type, false, endSelection, endPosition, excludeSpace);
            if (endPosition.offset === endOffset) {
                endPosition.setPositionParagraph(fieldEnd.line, startOffset);
            }
        }
        else {
            endPosition.setPositionParagraph(fieldEnd.line, startOffset);
        }
        endSelection = true;
    }
    /**
     * Get previous word offset
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getPreviousWordOffset(inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        if (inline instanceof TextElementBox) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffsetSpan(inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
        }
        else if (inline instanceof ImageElementBox) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffsetImage(inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 0) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffsetFieldBegin(inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 2) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffsetFieldSeparator(inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 1) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffsetFieldEnd(inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
        }
        else if (inline instanceof BookmarkElementBox) {
            this.getPreviousWordOffsetBookMark(inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
        }
        else if (inline instanceof ListTextElementBox && inline.previousNode) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffsetSpan(inline.previousNode, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
        }
    }
    // tslint:disable-next-line:max-line-length
    getPreviousWordOffsetBookMark(bookmark, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        if (bookmark.previousNode) {
            if (bookmark.previousNode instanceof TextElementBox) {
                let inline = bookmark.previousNode;
                if (HelperMethods.lastIndexOfAny(inline.text, HelperMethods.wordSplitCharacters) !== inline.text.length - 1) {
                    this.getPreviousWordOffset(inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
                }
                else {
                    endPosition.setPositionParagraph(bookmark.line, bookmark.line.getOffset(bookmark, 0));
                }
            }
        }
        else {
            endPosition.setPositionParagraph(bookmark.line, selection.getStartLineOffset(bookmark.line));
        }
    }
    /**
     * get previous word offset from field end
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getPreviousWordOffsetFieldEnd(fieldEnd, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        let startOffset = fieldEnd.line.getOffset(fieldEnd, 0);
        let endOffset = startOffset + fieldEnd.length;
        if (isNullOrUndefined(fieldEnd.fieldSeparator)) {
            this.getPreviousWordOffsetFieldBegin(fieldEnd.fieldBegin, selection, 0, type, isInField, isStarted, endSelection, endPosition);
        }
        else if (type === 0 && !isNullOrUndefined(fieldEnd.previousNode)) {
            let inline = fieldEnd.previousNode;
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffset(inline, selection, inline.length, type, (inline instanceof FieldElementBox && inline.fieldType === 1), isStarted, endSelection, endPosition);
        }
        else if (!isNullOrUndefined(fieldEnd.fieldBegin) && type !== 0) {
            let inline = fieldEnd.previousNode;
            // tslint:disable-next-line:max-line-length
            if (isNullOrUndefined(inline) || (inline.line.paragraph === fieldEnd.fieldBegin.line.paragraph && !selection.hasValidInline(inline.line.paragraph, inline, fieldEnd.fieldBegin))) {
                inline = fieldEnd.fieldBegin;
            }
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffset(inline, selection, inline.length, type, !(endPosition.paragraph === fieldEnd.line.paragraph && endPosition.offset === endOffset), isStarted, endSelection, endPosition);
            if (endSelection && endPosition.paragraph === fieldEnd.line.paragraph
                && endPosition.offset === startOffset) {
                endPosition.setPositionParagraph(fieldEnd.line, endOffset);
                return;
            }
            if (!endSelection) {
                // tslint:disable-next-line:max-line-length
                endPosition.setPositionParagraph(fieldEnd.fieldBegin.line, fieldEnd.fieldBegin.line.getOffset(fieldEnd.fieldBegin, 0));
            }
        }
    }
    /**
     * get previous word offset from field separator
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getPreviousWordOffsetFieldSeparator(fieldSeparator, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        this.getPreviousWordOffsetFieldBegin(fieldSeparator.fieldBegin, selection, fieldSeparator.fieldBegin.length, type, isInField, isStarted, endSelection, endPosition);
    }
    /**
     * get previous word offset from field begin
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getPreviousWordOffsetFieldBegin(fieldBegin, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        let startOffset = fieldBegin.line.getOffset(fieldBegin, 0);
        let endOffset = startOffset + fieldBegin.length;
        if (endPosition.offset === endOffset) {
            endPosition.setPositionParagraph(fieldBegin.line, startOffset);
        }
        if (!isNullOrUndefined(fieldBegin.previousNode)) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffset(fieldBegin.previousNode, selection, fieldBegin.previousNode.length, type, false, isStarted, endSelection, endPosition);
            if (endPosition.offset === startOffset) {
                if (type !== 0 && !isNullOrUndefined(fieldBegin.fieldSeparator)) {
                    // tslint:disable-next-line:max-line-length
                    endPosition.setPositionParagraph(fieldBegin.line, fieldBegin.fieldSeparator.line.getOffset(fieldBegin.fieldSeparator, fieldBegin.fieldSeparator.length));
                }
            }
        }
        else {
            endPosition.setPositionParagraph(fieldBegin.line, selection.getStartLineOffset(fieldBegin.line));
        }
    }
    /**
     * get previous word offset from image
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getPreviousWordOffsetImage(image, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        if (isInField) {
            endPosition.setPositionParagraph(image.line, image.line.getOffset(image, indexInInline));
            endSelection = false;
            return;
        }
        if (indexInInline === image.length) {
            let endOffset = image.line.getOffset(image, image.length);
            if (endOffset === endPosition.offset) {
                endPosition.setPositionParagraph(image.line, endOffset - image.length);
            }
            else {
                endPosition.setPositionParagraph(image.line, endOffset);
            }
        }
        else if (!isNullOrUndefined(image.previousNode)) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffset(image.previousNode, selection, image.previousNode.length, type, isInField, isStarted, endSelection, endPosition);
        }
    }
    /**
     * Get previous word offset from span
     * @private
     */
    // tslint:disable-next-line:max-line-length   
    getPreviousWordOffsetSpan(span, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        if (span.text === '\t' || span.text === '\v') {
            if (isInField) {
                endSelection = false;
                return;
            }
            if (indexInInline === span.length) {
                endSelection = true;
                let endOffset = span.line.getOffset(span, span.length);
                if (endOffset === endPosition.offset) {
                    endPosition.setPositionParagraph(span.line, endOffset - span.length);
                }
                else {
                    endPosition.setPositionParagraph(span.line, endOffset);
                }
            }
            else if (!isNullOrUndefined(span.previousNode)) {
                // tslint:disable-next-line:max-line-length
                this.getPreviousWordOffset(span.previousNode, selection, span.previousNode.length, type, isInField, isStarted, endSelection, endPosition);
            }
        }
        else {
            let wordStartIndex = 0;
            if (!isStarted) {
                while (indexInInline > 0 && span.text[indexInInline - 1] === ' ') {
                    indexInInline--;
                }
                endPosition.setPositionParagraph(span.line, span.line.getOffset(span, indexInInline));
            }
            if (indexInInline > 0) {
                isStarted = true;
                if (indexInInline === 0 && endSelection && (HelperMethods.wordSplitCharacters.indexOf(span.text[0])) === -1) {
                    endPosition.setPositionParagraph(span.line, span.line.getOffset(span, indexInInline));
                    endSelection = true;
                    return;
                }
                let txt = span.text.length > indexInInline ? span.text.slice(0, indexInInline) : span.text;
                wordStartIndex = HelperMethods.lastIndexOfAny(txt, HelperMethods.wordSplitCharacters);
                if (wordStartIndex !== -1) {
                    if (isInField) {
                        endSelection = false;
                        return;
                    }
                    while (wordStartIndex > 0 && endSelection && txt[wordStartIndex] !== ' '
                        && (HelperMethods.wordSplitCharacters.indexOf(txt[wordStartIndex - 1])) !== -1) {
                        wordStartIndex--;
                    }
                    if (txt[wordStartIndex] === ' ' || txt[wordStartIndex] === '　' || !endSelection) {
                        wordStartIndex++;
                    }
                    endSelection = true;
                    if (wordStartIndex > 0) {
                        let offset = span.line.getOffset(span, wordStartIndex);
                        if (span.line.paragraph === endPosition.paragraph && offset === endPosition.offset) {
                            // tslint:disable-next-line:max-line-length
                            this.getPreviousWordOffsetSpan(span, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
                        }
                        else {
                            endPosition.setPositionParagraph(span.line, offset);
                        }
                    }
                    else if (span.previousNode instanceof TextElementBox) {
                        // tslint:disable-next-line:max-line-length
                        this.getPreviousWordOffset(span.previousNode, selection, span.previousNode.length, type, isInField, isStarted, endSelection, endPosition);
                    }
                    else {
                        endPosition.setPositionParagraph(span.line, span.line.getOffset(span, 0));
                    }
                }
                else {
                    this.setPreviousWordOffset(span, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
                }
            }
            else {
                this.setPreviousWordOffset(span, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
            }
        }
    }
    /**
     * set previous word offset in span
     * @private
     */
    // tslint:disable-next-line:max-line-length
    setPreviousWordOffset(span, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        if (span.previousNode instanceof ElementBox && span.line === span.previousNode.line) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffset(span.previousNode, selection, span.previousNode.length, type, isInField, isStarted, endSelection, endPosition);
        }
        else {
            endPosition.setPositionParagraph(span.line, selection.getStartLineOffset(span.line));
        }
    }
    /**
     * Validate if text position is in field forward
     * @private
     */
    validateForwardFieldSelection(currentIndex, selectionEndIndex) {
        let textPosition = new TextPosition(this.owner);
        textPosition.setPositionForCurrentIndex(currentIndex);
        textPosition.isUpdateLocation = false;
        let isPositionMoved = false;
        while (currentIndex !== selectionEndIndex && TextPosition.isForwardSelection(currentIndex, selectionEndIndex)) {
            if (!isPositionMoved) {
                textPosition.moveNextPosition(false);
                let nextIndex = textPosition.getHierarchicalIndexInternal();
                //Handled specifically to break infinite looping, if selection ends at last paragraph mark.
                if (currentIndex === nextIndex) {
                    break;
                }
            }
            let indexInInline = 0;
            let inlineObj = textPosition.currentWidget.getInline(textPosition.offset, indexInInline);
            let inline = inlineObj.element;
            indexInInline = inlineObj.index;
            if (!isNullOrUndefined(inline)) {
                let selectionStartIndex = this.selection.start.getHierarchicalIndexInternal();
                if (indexInInline === inline.length && inline instanceof FieldElementBox && inline.fieldType === 1) {
                    if (inline.line.getOffset(inline, 0) === this.offset) {
                        return;
                    }
                    let lineWidget = inline.fieldBegin.line;
                    let fieldBeginOffset = lineWidget.getOffset(inline.fieldBegin, 0);
                    let fieldBeginIndex = this.getHierarchicalIndex(lineWidget, fieldBeginOffset.toString());
                    if (!TextPosition.isForwardSelection(selectionStartIndex, fieldBeginIndex)) {
                        this.selection.start.setPositionParagraph(lineWidget, fieldBeginOffset);
                    }
                }
                let nextInline = this.selection.getNextRenderedElementBox(inline, indexInInline);
                if (!isNullOrUndefined(nextInline) && nextInline instanceof ElementBox) {
                    inline = nextInline;
                }
            }
            isPositionMoved = (inline instanceof FieldElementBox && inline.fieldType === 0 && !isNullOrUndefined(inline.fieldEnd));
            if (isPositionMoved) {
                if (inline.line.getOffset(inline, 0) === this.offset) {
                    return;
                }
                let fieldEnd = inline.fieldEnd;
                let paragraph = fieldEnd.line.paragraph;
                let fieldEndOffset = fieldEnd.line.getOffset(fieldEnd, 1);
                let fieldEndIndex = this.getHierarchicalIndex(fieldEnd.line, fieldEndOffset.toString());
                if (!TextPosition.isForwardSelection(fieldEndIndex, selectionEndIndex)) {
                    //If selection end is after field begin, extend selection end to field end.
                    this.moveToInline(inline.fieldEnd, 1);
                    return;
                }
                textPosition.moveToInline(inline.fieldEnd, 1);
            }
            currentIndex = textPosition.getHierarchicalIndexInternal();
        }
    }
    /**
     * Validate if text position is in field backward
     * @private
     */
    validateBackwardFieldSelection(currentIndex, selectionEndIndex) {
        let textPosition = new TextPosition(this.owner);
        textPosition.setPositionForCurrentIndex(currentIndex);
        textPosition.isUpdateLocation = false;
        let selectionStartIndex = this.selection.start.getHierarchicalIndexInternal();
        while (currentIndex !== selectionEndIndex && TextPosition.isForwardSelection(selectionEndIndex, currentIndex)) {
            let indexInInline = 0;
            let inlineObj = textPosition.currentWidget.getInline(textPosition.offset, indexInInline);
            let inline = inlineObj.element;
            indexInInline = inlineObj.index;
            if (!isNullOrUndefined(inline)) {
                let nextInline = this.selection.getNextRenderedElementBox(inline, indexInInline);
                if (nextInline instanceof FieldElementBox && nextInline.fieldType === 0) {
                    let paragraph = nextInline.fieldEnd.line;
                    let fieldEndOffset = paragraph.getOffset(nextInline.fieldEnd, 1);
                    let fieldEndIndex = this.getHierarchicalIndex(paragraph, fieldEndOffset.toString());
                    if (!TextPosition.isForwardSelection(fieldEndIndex, selectionStartIndex)) {
                        this.selection.start.setPositionParagraph(paragraph, fieldEndOffset);
                        selectionStartIndex = fieldEndIndex;
                    }
                }
            }
            if (inline instanceof FieldElementBox && inline.fieldType === 1 && !isNullOrUndefined(inline.fieldBegin)) {
                let line = inline.fieldBegin.line;
                let fieldBegin = inline.fieldBegin;
                let fieldBeginOffset = line.getOffset(fieldBegin, 0);
                let fieldBeginIndex = this.getHierarchicalIndex(line, fieldBeginOffset.toString());
                if (!TextPosition.isForwardSelection(selectionEndIndex, fieldBeginIndex)) {
                    //If field begin is before selection end, extend selection end to field begin.
                    this.moveToInline(inline.fieldBegin, 0);
                    return;
                }
                textPosition.moveToInline(inline.fieldBegin, 0);
            }
            else {
                textPosition.movePreviousPosition();
            }
            currentIndex = textPosition.getHierarchicalIndexInternal();
        }
    }
    /**
     * @private
     */
    paragraphStartInternal(selection, moveToPreviousParagraph) {
        let offset = selection.getStartLineOffset(this.currentWidget);
        if (this.offset === offset && moveToPreviousParagraph) {
            let startParagraph = this.moveToNextParagraphInTableCheck();
            if (startParagraph) {
                this.moveToPreviousParagraphInTable(selection);
            }
            else if (!isNullOrUndefined(selection.getPreviousParagraphBlock(this.currentWidget.paragraph))) {
                let paragraphValue = selection.getPreviousParagraphBlock(this.currentWidget.paragraph);
                this.currentWidget = paragraphValue.childWidgets[0];
                this.offset = selection.getStartLineOffset(this.currentWidget);
            }
        }
        else {
            this.currentWidget = this.currentWidget.paragraph.getSplitWidgets()[0].childWidgets[0];
            this.offset = offset;
        }
        this.calculateOffset();
    }
    /**
     * @private
     */
    calculateOffset() {
        let selectionStartIndex = this.owner.selection.start.getHierarchicalIndexInternal();
        let selectionEndIndex = this.getHierarchicalIndexInternal();
        if (selectionStartIndex !== selectionEndIndex) {
            this.validateBackwardFieldSelection(selectionStartIndex, selectionEndIndex);
        }
        this.updatePhysicalPosition(true);
    }
    /**
     * Moves the text position to start of the paragraph.
     * @private
     */
    moveToParagraphStartInternal(selection, moveToPreviousParagraph) {
        let startOffset = selection.getStartOffset(this.paragraph);
        if (this.offset === startOffset && moveToPreviousParagraph) {
            let paragraphstart = this.moveToNextParagraphInTableCheck();
            if (paragraphstart) {
                this.moveToPreviousParagraphInTable(selection);
            }
            else if (!isNullOrUndefined(selection.getPreviousParagraphBlock(this.paragraph))) {
                this.currentWidget = selection.getPreviousParagraphBlock(this.paragraph).firstChild;
                this.offset = selection.getStartOffset(this.paragraph);
            }
        }
        else {
            this.currentWidget = this.paragraph.firstChild;
            this.offset = selection.getStartLineOffset(this.currentWidget);
        }
        let selectionStartIndex = this.owner.selection.start.getHierarchicalIndexInternal();
        let selectionEndIndex = this.getHierarchicalIndexInternal();
        if (selectionStartIndex !== selectionEndIndex) {
            this.validateBackwardFieldSelection(selectionStartIndex, selectionEndIndex);
        }
        this.updatePhysicalPosition(false);
    }
    /**
     * Moves the text position to end of the paragraph.
     * @private
     */
    moveToParagraphEndInternal(selection, moveToNextParagraph) {
        // tslint:disable-next-line:max-line-length
        let splittedParagraph = this.currentWidget.paragraph;
        while (splittedParagraph.nextSplitWidget) {
            splittedParagraph = splittedParagraph.nextSplitWidget;
        }
        this.currentWidget = splittedParagraph.childWidgets[splittedParagraph.childWidgets.length - 1];
        let endOffset = this.currentWidget.getEndOffset() + 1;
        if (this.offset === endOffset && moveToNextParagraph) {
            let paragraphEnd = this.moveToNextParagraphInTableCheck();
            if (paragraphEnd) {
                this.moveToNextParagraphInTable();
            }
            else if (!isNullOrUndefined(selection.getNextParagraphBlock(this.currentWidget.paragraph))) {
                let endParagraph = selection.getNextParagraphBlock(this.currentWidget.paragraph);
                this.currentWidget = endParagraph.childWidgets[endParagraph.childWidgets.length - 1];
                this.offset = this.currentWidget.getEndOffset() + 1;
            }
        }
        else {
            this.offset = endOffset;
        }
        this.calculateOffset();
    }
    /**
     * @private
     */
    moveUp(selection, left) {
        let paragraph = this.currentWidget.paragraph;
        //Moves text position to start of line.
        this.moveToLineStartInternal(selection, true);
        //Moves previous line starting.
        this.movePreviousPosition();
        let prevLine = undefined;
        let currentParagraph = this.currentWidget.paragraph;
        if (paragraph.isInsideTable && paragraph !== currentParagraph && paragraph.associatedCell !== currentParagraph.associatedCell
            // tslint:disable-next-line:max-line-length
            && (!isNullOrUndefined(currentParagraph.associatedCell) && (paragraph.associatedCell.ownerRow === currentParagraph.associatedCell.ownerRow))) {
            let ownerRow = currentParagraph.associatedCell.ownerRow;
            if (ownerRow.previousRenderedWidget instanceof TableRowWidget) {
                // tslint:disable-next-line:max-line-length
                let cell = selection.getFirstCellInRegion(ownerRow.previousRenderedWidget, currentParagraph.associatedCell, left, true);
                let lastParagraph = selection.getLastParagraph(cell);
                this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], false);
            }
            else {
                let prevBlock = ownerRow.ownerTable.previousRenderedWidget;
                do {
                    if (prevBlock instanceof TableWidget) {
                        prevBlock = selection.getLastBlockInLastCell(prevBlock);
                    }
                } while (prevBlock instanceof TableWidget);
                if (prevBlock instanceof ParagraphWidget) {
                    this.setPosition(prevBlock.childWidgets[prevBlock.childWidgets.length - 1], false);
                }
            }
            prevLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        }
        else {
            if (!paragraph.isInsideTable && this.currentWidget.paragraph.isInsideTable) {
                // tslint:disable-next-line:max-line-length
                let cell = selection.getFirstCellInRegion(this.currentWidget.paragraph.associatedCell.ownerRow, this.currentWidget.paragraph.associatedCell, this.owner.selection.upDownSelectionLength, true);
                let lastParagraph = selection.getLastParagraph(cell);
                this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], false);
                // tslint:disable-next-line:max-line-length
            }
            else if (paragraph.isInsideTable && (!isNullOrUndefined(this.currentWidget.paragraph.associatedCell) && paragraph.associatedCell.ownerRow.previousRenderedWidget !== paragraph.associatedCell.ownerRow.previousSplitWidget &&
                paragraph.associatedCell.ownerRow.previousRenderedWidget === this.currentWidget.paragraph.associatedCell.ownerRow)) {
                // tslint:disable-next-line:max-line-length
                let cell = selection.getLastCellInRegion(this.currentWidget.paragraph.associatedCell.ownerRow, this.currentWidget.paragraph.associatedCell, this.owner.selection.upDownSelectionLength, true);
                let lastParagraph = selection.getLastParagraph(cell);
                this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], false);
            }
            prevLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        }
        //Moves till the Up/Down selection width.
        let top = selection.getTop(prevLine);
        selection.updateTextPositionWidget(prevLine, new Point(left, top), this, false);
    }
    /**
     * @private
     */
    moveDown(selection, left) {
        //Moves text position to end of line.
        let prevParagraph = this.currentWidget.paragraph;
        let prevOffset = this.offset;
        this.moveToLineEndInternal(selection, true);
        let length = this.selection.getParagraphLength(this.currentWidget.paragraph);
        if (this.offset > length) {
            this.offset = length;
        }
        //Moves next line starting.
        this.moveNextPosition();
        let nextLine = undefined;
        // tslint:disable-next-line:max-line-length
        if (prevParagraph.isInsideTable && prevParagraph !== this.currentWidget.paragraph && prevParagraph.associatedCell !== this.currentWidget.paragraph.associatedCell && (!isNullOrUndefined(this.currentWidget.paragraph.associatedCell) && prevParagraph.associatedCell.ownerRow === this.currentWidget.paragraph.associatedCell.ownerRow)) {
            let ownerRow = this.currentWidget.paragraph.associatedCell.ownerRow;
            // tslint:disable-next-line:max-line-length
            if (prevParagraph.isInsideTable && this.currentWidget.paragraph.isInsideTable && prevParagraph.associatedCell.cellFormat.rowSpan > 1 && prevParagraph.associatedCell.cellFormat.rowSpan + prevParagraph.associatedCell.ownerRow.rowIndex === prevParagraph.associatedCell.ownerTable.childWidgets.length) {
                //If the prevParagraph  owner cell is Verically merged upto the last row, then theposition moved to next column. the position moved to out of the current tabel so owner row is assigned to last row.
                // tslint:disable-next-line:max-line-length
                ownerRow = this.currentWidget.paragraph.associatedCell.ownerTable.childWidgets[this.currentWidget.paragraph.associatedCell.ownerTable.childWidgets.length - 1];
            }
            if (ownerRow.nextRenderedWidget instanceof TableRowWidget) {
                // tslint:disable-next-line:max-line-length
                let cell = this.selection.getLastCellInRegion(ownerRow.nextRenderedWidget, this.currentWidget.paragraph.associatedCell, left, false);
                this.setPosition(this.selection.getFirstParagraph(cell).childWidgets[0], true);
            }
            else {
                let nextBlock = this.selection.getNextRenderedBlock(ownerRow.ownerTable);
                do {
                    if (nextBlock instanceof TableWidget) {
                        nextBlock = this.selection.getFirstBlockInFirstCell(nextBlock);
                    }
                } while (nextBlock instanceof TableWidget);
                if (nextBlock instanceof ParagraphWidget) {
                    this.setPosition(nextBlock.childWidgets[0], true);
                }
            }
            nextLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        }
        else {
            if (!prevParagraph.isInsideTable && this.currentWidget.paragraph.isInsideTable) {
                // tslint:disable-next-line:max-line-length
                let cell = this.selection.getLastCellInRegion(this.currentWidget.paragraph.associatedCell.ownerRow, this.currentWidget.paragraph.associatedCell, this.owner.selection.upDownSelectionLength, false);
                this.setPosition(this.selection.getFirstParagraph(cell).childWidgets[0], true);
                // tslint:disable-next-line:max-line-length
            }
            else if (prevParagraph.isInsideTable && (!isNullOrUndefined(this.currentWidget.paragraph.associatedCell) && prevParagraph.associatedCell.ownerRow.nextRenderedWidget !== prevParagraph.associatedCell.ownerRow.nextSplitWidget
                && prevParagraph.associatedCell.ownerRow.nextRenderedWidget === this.currentWidget.paragraph.associatedCell.ownerRow)) {
                // tslint:disable-next-line:max-line-length
                let cell = selection.getLastCellInRegion(this.currentWidget.paragraph.associatedCell.ownerRow, this.currentWidget.paragraph.associatedCell, this.owner.selection.upDownSelectionLength, true);
                this.setPosition(selection.getFirstParagraph(cell).childWidgets[0], false);
            }
            nextLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        }
        //Moves till the Up/Down selection width.
        let top = this.selection.getTop(nextLine);
        this.selection.updateTextPositionWidget(nextLine, new Point(left, top), this, false);
    }
    /**
     * Moves the text position to start of the line.
     * @private
     */
    moveToLineStartInternal(selection, moveToPreviousLine) {
        if (this.location.x > this.viewer.clientActiveArea.right) {
            this.offset = this.offset - 1;
        }
        let currentLine = selection.getLineWidgetInternal(this.currentWidget, this.offset, moveToPreviousLine);
        let firstElement = selection.getFirstElementInternal(currentLine);
        let startOffset = selection.getStartOffset(this.currentWidget.paragraph);
        if (isNullOrUndefined(firstElement) && this.offset > startOffset) {
            let index = 0;
            let inlineObj = this.currentWidget.getInline(this.offset, index);
            let inline = inlineObj.element;
            index = inlineObj.index;
            if (inline instanceof TextElementBox && inline.text !== '\v') {
                this.offset = startOffset;
            }
        }
        else if (!isNullOrUndefined(firstElement)) {
            let indexInInline = selection.getIndexInInline(firstElement);
            this.currentWidget = firstElement.line;
            this.offset = this.currentWidget.getOffset(firstElement, indexInInline);
            indexInInline = 0;
            let inlineObj = this.currentWidget.getInline(this.offset, indexInInline);
            let inline = inlineObj.element;
            indexInInline = inlineObj.index;
            if (inline instanceof FieldElementBox) {
                //Checks if field character is part of rendered field, otherwise moves to previous rendered content.
                let prevInline = selection.getPreviousValidElement(inline);
                if (!isNullOrUndefined(prevInline)) {
                    inline = prevInline;
                    this.currentWidget = inline.line;
                    this.offset = this.currentWidget.getOffset(inline, inline.length);
                    if (inline instanceof FieldElementBox) {
                        this.offset--;
                    }
                }
            }
        }
        this.updatePhysicalPosition(true);
    }
    /**
     * Check paragraph is inside table
     * @private
     */
    moveToNextParagraphInTableCheck() {
        if ((this.selection.start.paragraph.isInsideTable || this.paragraph.isInsideTable)
            && (this.selection.start.paragraph.associatedCell !== this.paragraph.associatedCell
                || this.selection.isCellSelected(this.selection.start.paragraph.associatedCell, this.selection.start, this))) {
            return true;
        }
        return false;
    }
    /**
     * Moves the text position to end of the word.
     * @private
     */
    moveToWordEndInternal(type, excludeSpace) {
        // type === 0 -------->CTRL+ARROW Navigation
        // type === 1 -------->CTRL+SHIFT+ARROW Selection
        // type === 2 -------->Double-tap Word Selection
        let incrementValue = 0;
        let endOffset = this.currentWidget.getEndOffset();
        if (this.selection.isParagraphFirstLine(this.currentWidget)) {
            if (this.currentWidget.children[0] instanceof ListTextElementBox) {
                incrementValue = 1;
            }
            if (this.currentWidget.children[1] instanceof ListTextElementBox) {
                incrementValue = 2;
            }
        }
        if (this.offset + incrementValue === endOffset || this.offset === endOffset + 1) {
            if (this.offset === endOffset && type !== 0) {
                this.setPositionParagraph(this.currentWidget, endOffset + 1);
            }
            else {
                let nextParagraph = this.selection.getNextParagraphBlock(this.currentWidget.paragraph);
                if (isNullOrUndefined(nextParagraph)) {
                    return;
                }
                this.currentWidget = nextParagraph.childWidgets[0];
                this.offset = this.selection.getStartLineOffset(this.currentWidget);
                if (type === 1) {
                    // tslint:disable-next-line:max-line-length
                    let nextWord = this.moveToNextParagraphInTableCheck();
                    if (nextWord) {
                        this.moveToNextParagraphInTable();
                    }
                    else {
                        this.moveToWordEndInternal(type, excludeSpace);
                    }
                }
            }
        }
        else {
            let indexInInline = 0;
            let endSelection = false;
            let inlineObj = this.currentWidget.getInline(this.offset, indexInInline);
            let inline = inlineObj.element;
            indexInInline = inlineObj.index;
            this.getNextWordOffset(inline, indexInInline, type, false, endSelection, this, excludeSpace);
        }
        if (type !== 0) {
            let selectionStartIndex = this.owner.selection.start.getHierarchicalIndexInternal();
            let selectionEndIndex = this.getHierarchicalIndexInternal();
            if (selectionStartIndex !== selectionEndIndex) {
                this.validateForwardFieldSelection(selectionStartIndex, selectionEndIndex);
            }
        }
        this.updatePhysicalPosition(true);
    }
    /**
     * move text position to next paragraph inside table
     * @private
     */
    moveToNextParagraphInTable() {
        let paragraph = this.currentWidget.paragraph;
        let nextParagraph = (paragraph.isInsideTable) ? this.selection.getNextSelectionCell(paragraph.associatedCell) :
            this.selection.getNextParagraphBlock(paragraph);
        if (isNullOrUndefined(nextParagraph)) {
            return;
        }
        this.currentWidget = nextParagraph.childWidgets[nextParagraph.childWidgets.length - 1];
        this.offset = this.currentWidget.getEndOffset() + 1;
    }
    /**
     * Moves the text position to start of the previous paragraph.
     */
    moveToPreviousParagraph(selection) {
        let startOffset = selection.getStartOffset(this.currentWidget.paragraph);
        // tslint:disable-next-line:max-line-length
        if (this.offset === startOffset && !isNullOrUndefined(selection.getPreviousParagraphBlock(this.currentWidget.paragraph))) {
            let previousParagraph = selection.getPreviousParagraphBlock(this.currentWidget.paragraph);
            this.currentWidget = previousParagraph.childWidgets[0];
            this.offset = selection.getStartOffset(this.currentWidget.paragraph);
        }
        else {
            this.offset = selection.getStartOffset(this.currentWidget.paragraph);
        }
        this.updatePhysicalPosition(true);
    }
    /**
     * Move to previous line from current position
     * @private
     */
    moveToPreviousLine(selection, left) {
        let currentIndex = this.getHierarchicalIndexInternal();
        let currentLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        //Moves text position to start of line.
        this.moveToLineStartInternal(selection, true);
        if (this.currentWidget.paragraph.isInsideTable) {
            this.moveUpInTable(selection);
        }
        else {
            this.moveBackward();
        }
        let prevLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        let lineStart = selection.getLeft(prevLine);
        let lineWidth = selection.getWidth(prevLine, true);
        //Moves till the Up/Down selection width.
        if (lineWidth + lineStart >= left && currentLine !== prevLine) {
            let top = selection.getTop(prevLine);
            let point = new Point(left, top);
            selection.updateTextPositionWidget(prevLine, point, this, true);
        }
        //Checks if the current position is between field result, then move to field begin.
        let selectionEndIndex = this.getHierarchicalIndexInternal();
        this.validateBackwardFieldSelection(currentIndex, selectionEndIndex);
    }
    /**
     * @private
     */
    moveToLineEndInternal(selection, moveToNextLine) {
        if (this.location.x > this.viewer.clientActiveArea.right) {
            this.offset = this.offset - 1;
        }
        let currentLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        let firstElement = selection.getFirstElementInternal(currentLine);
        if (isNullOrUndefined(firstElement) && this.offset === selection.getStartLineOffset(this.currentWidget)) {
            this.offset = selection.getParagraphLength(this.paragraph) + 1;
            this.updatePhysicalPosition(true);
        }
        else if (!isNullOrUndefined(firstElement)) {
            let lastElement = currentLine.children[currentLine.children.length - 1];
            let index = 0;
            index += lastElement instanceof TextElementBox ? lastElement.length : 1;
            this.currentWidget = lastElement.line;
            if (index === lastElement.length
                && isNullOrUndefined(lastElement.nextNode) && selection.isParagraphLastLine(this.currentWidget)) {
                let length = selection.getLineLength(this.currentWidget);
                this.offset = moveToNextLine ? length + 1 : length;
            }
            else {
                let inline = lastElement;
                while (!isNullOrUndefined(inline) && inline.length === index && inline.nextNode instanceof FieldElementBox) {
                    let nextInline = selection.getNextValidElement(inline.nextNode);
                    if (inline !== nextInline) {
                        inline = nextInline;
                        index = 0;
                    }
                    if (inline instanceof FieldElementBox && inline.fieldType === 0
                        && !isNullOrUndefined(inline.fieldEnd)) {
                        let fieldBegin = inline;
                        if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
                            inline = fieldBegin.fieldEnd;
                        }
                        else {
                            inline = fieldBegin.fieldSeparator;
                            this.currentWidget = inline.line;
                            if (this.currentWidget === fieldBegin.fieldEnd.line
                                && !selection.hasValidInline(this.currentWidget.paragraph, inline, fieldBegin.fieldEnd)) {
                                inline = fieldBegin.fieldEnd;
                            }
                        }
                        this.currentWidget = inline.line;
                    }
                    if (inline instanceof FieldElementBox) {
                        index = 1;
                    }
                }
                if (index === inline.length && isNullOrUndefined(inline.nextNode)) {
                    index++;
                }
                if (!moveToNextLine && inline instanceof ElementBox && inline.text === '\v') {
                    index--;
                }
                this.offset = this.currentWidget.getOffset(inline, index);
            }
            this.updatePhysicalPosition(moveToNextLine);
        }
    }
    /**
     * Move to next line
     * @private
     */
    moveToNextLine(left) {
        let selection = this.selection;
        let textPosition = new TextPosition(this.owner);
        textPosition.setPositionInternal(this);
        let currentIndex = this.getHierarchicalIndexInternal();
        let currentLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        let isAtLineStart = this.offset === 0 ? true : false;
        //Moves text position to end of line.
        this.moveToLineEndInternal(selection, true);
        let isMoveToLineEnd = !textPosition.isAtSamePosition(this);
        textPosition.setPositionInternal(this);
        if (this.currentWidget.paragraph.isInsideTable) {
            this.moveDownInTable(selection);
        }
        else {
            this.moveNextPosition();
            this.moveForward();
        }
        let nextLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        let lineStart = selection.getLeft(nextLine);
        let firstElement = selection.getFirstElementInternal(nextLine);
        // tslint:disable-next-line:max-line-length
        let firstItemWidth = isNullOrUndefined(firstElement) ? selection.getWidth(nextLine, true) : selection.getLeftInternal(nextLine, firstElement, 1) - lineStart;
        //Moves till the Up/Down selection width.
        if (lineStart < left && (firstItemWidth / 2 < left - lineStart)) {
            let top = selection.getTop(nextLine);
            let point = new Point(left, top);
            selection.updateTextPositionWidget(nextLine, point, this, true);
            let width = selection.getWidth(nextLine, true);
            if (width < left - lineStart) {
                this.moveToLineEndInternal(selection, true);
            }
        }
        else if (isMoveToLineEnd && this.currentWidget.paragraph.isInsideTable
            && this.currentWidget === this.owner.selection.start.currentWidget) {
            this.setPositionInternal(textPosition);
        }
        else if (!isMoveToLineEnd) {
            this.moveToLineEndInternal(selection, true);
        }
        //Checks if the current position is between field result, then move to field end.
        let selectionEndIndex = this.getHierarchicalIndexInternal();
        this.validateForwardFieldSelection(currentIndex, selectionEndIndex);
    }
    /**
     * Move upward in table
     * @private
     */
    moveUpInTable(selection) {
        let isPositionUpdated = false;
        let end = this.owner.selection.end;
        let isBackwardSelection = !this.owner.selection.isEmpty;
        isPositionUpdated = end.paragraph.isInsideTable;
        if (isPositionUpdated) {
            let startCell = this.currentWidget.paragraph.associatedCell;
            let endCell = end.paragraph.associatedCell;
            let containerCell = selection.getContainerCellOf(endCell, startCell);
            isPositionUpdated = containerCell.ownerTable.contains(startCell);
            if (isPositionUpdated) {
                endCell = selection.getSelectedCell(endCell, containerCell);
                startCell = selection.getSelectedCell(startCell, containerCell);
                // tslint:disable-next-line:max-line-length
                let isInContainerCell = selection.containsCell(containerCell, this.currentWidget.paragraph.associatedCell);
                let isContainerCellSelected = selection.isCellSelected(containerCell, this, end);
                if (!isContainerCellSelected) {
                    // tslint:disable-next-line:max-line-length
                    isContainerCellSelected = this.currentWidget.paragraph === selection.getFirstParagraph(containerCell) && this.isAtParagraphStart;
                }
                if ((isInContainerCell && isContainerCellSelected
                    || !isInContainerCell) && !isNullOrUndefined(startCell.ownerRow.previousRenderedWidget)) {
                    //Moves to cell in previous row.
                    let row = startCell.ownerRow.previousRenderedWidget;
                    // tslint:disable-next-line:max-line-length
                    let cell = selection.getFirstCellInRegion(row, containerCell, this.owner.selection.upDownSelectionLength, true);
                    let previousParagraph = selection.getLastParagraph(cell);
                    this.setPosition(previousParagraph.childWidgets[0], true);
                    return;
                }
                else if (isInContainerCell && isContainerCellSelected
                    && isNullOrUndefined(startCell.ownerRow.previousRenderedWidget) || !isInContainerCell) {
                    if (isBackwardSelection) {
                        //Moves to first cell of row.
                        startCell = startCell.ownerRow.childWidgets[0];
                        let previousParagraph = selection.getFirstParagraph(startCell);
                        this.setPosition(previousParagraph.childWidgets[0], true);
                    }
                    else {
                        //Moves to last cell of row.
                        startCell = startCell.ownerRow.childWidgets[startCell.ownerRow.childWidgets.length - 1];
                        let previousParagraph = selection.getLastParagraph(startCell);
                        this.setPosition(previousParagraph.childWidgets[0], false);
                    }
                }
            }
        }
        if (!isPositionUpdated) {
            //Moves to previous row / previous block.
            let cell = selection.getContainerCell(this.currentWidget.paragraph.associatedCell);
            if (isBackwardSelection) {
                //Moves to first cell of row.
                cell = cell.ownerRow.childWidgets[0];
                let previousParagraph = selection.getFirstParagraph(cell);
                this.setPosition(previousParagraph.childWidgets[0], true);
            }
            else {
                //Moves to end of row.
                cell = cell.ownerRow.childWidgets[cell.ownerRow.childWidgets.length - 1];
                let previousParagraph = selection.getLastParagraph(cell);
                this.setPosition(previousParagraph.childWidgets[0], false);
            }
        }
        //Moves to previous row / previous block.
        this.moveBackward();
    }
    /**
     * Move down inside table
     * @private
     */
    moveDownInTable(selection) {
        let isPositionUpdated = false;
        let isForwardSelection = this.owner.selection.isEmpty || this.owner.selection.isForward;
        isPositionUpdated = this.owner.selection.start.paragraph.isInsideTable;
        if (isPositionUpdated) {
            let startCell = this.owner.selection.start.paragraph.associatedCell;
            let endCell = this.currentWidget.paragraph.associatedCell;
            let containerCell = selection.getContainerCellOf(startCell, endCell);
            isPositionUpdated = containerCell.ownerTable.contains(endCell);
            if (isPositionUpdated) {
                startCell = selection.getSelectedCell(startCell, containerCell);
                endCell = selection.getSelectedCell(endCell, containerCell);
                // tslint:disable-next-line:max-line-length
                let isInContainerCell = selection.containsCell(containerCell, this.currentWidget.paragraph.associatedCell);
                let isContainerCellSelected = selection.isCellSelected(containerCell, this.owner.selection.start, this);
                if ((isInContainerCell && isContainerCellSelected
                    || !isInContainerCell) && !isNullOrUndefined(endCell.ownerRow.nextRenderedWidget)) {
                    //Moves to cell in next row.
                    let row = endCell.ownerRow.nextRenderedWidget;
                    // tslint:disable-next-line:max-line-length
                    let cell = selection.getLastCellInRegion(row, containerCell, this.owner.selection.upDownSelectionLength, false);
                    let lastParagraph = selection.getLastParagraph(cell);
                    this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], false);
                    return;
                }
                else if (isInContainerCell && isContainerCellSelected
                    && isNullOrUndefined(endCell.ownerRow.nextRenderedWidget) || !isInContainerCell) {
                    if (isForwardSelection) {
                        //Moves to last cell of row.
                        endCell = endCell.ownerRow.childWidgets[endCell.ownerRow.childWidgets.length - 1];
                        let lastParagraph = selection.getLastParagraph(endCell);
                        this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], false);
                    }
                    else {
                        //Moves to first cell of row.
                        endCell = endCell.ownerRow.childWidgets[0];
                        let lastParagraph = selection.getFirstParagraph(endCell);
                        this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], true);
                    }
                }
            }
        }
        if (!isPositionUpdated) {
            //Moves to next row / next block.
            let cell = selection.getContainerCell(this.currentWidget.paragraph.associatedCell);
            if (isForwardSelection) {
                //Moves to end of row.
                cell = cell.ownerRow.childWidgets[cell.ownerRow.childWidgets.length - 1];
                let lastParagraph = selection.getLastParagraph(cell);
                this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], false);
            }
            else if (cell.ownerRow.nextRenderedWidget) {
                //Moves to first cell of row.
                cell = cell.ownerRow.nextRenderedWidget.childWidgets[0];
                let lastParagraph = selection.getFirstParagraph(cell);
                this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], true);
            }
        }
        //Moves to next row / next block.
        this.moveForward();
    }
    /**
     * @private
     */
    destroy() {
        this.offset = undefined;
        this.isUpdateLocation = undefined;
        if (!isNullOrUndefined(this.location)) {
            this.location.destroy();
        }
        this.location = undefined;
        this.currentWidget = undefined;
        this.owner = undefined;
        this.viewer = undefined;
    }
}
/**
 * @private
 */
class SelectionWidgetInfo {
    constructor(left, width) {
        this.leftIn = 0;
        this.widthIn = 0;
        this.leftIn = left;
        this.widthIn = width;
    }
    /**
     * @private
     */
    get left() {
        return this.leftIn;
    }
    /**
     * @private
     */
    set left(value) {
        this.leftIn = value;
    }
    /**
     * @private
     */
    get width() {
        return this.widthIn;
    }
    /**
     * @private
     */
    set width(value) {
        this.widthIn = value;
    }
    /**
     * @private
     */
    destroy() {
        this.widthIn = undefined;
        this.leftIn = undefined;
    }
}
/**
 * @private
 */
class Hyperlink {
    constructor(fieldBeginAdv, selection) {
        this.linkInternal = '';
        this.localRef = '';
        this.opensNewWindow = false;
        let fieldCode = selection.getFieldCode(fieldBeginAdv);
        let lowercase = fieldCode.toLowerCase();
        if (lowercase.substring(0, 9) === 'hyperlink') {
            this.parseFieldValues(fieldCode.substring(9).trim(), selection);
        }
    }
    /**
     * Gets navigation link.
     * @returns string
     * @private
     */
    get navigationLink() {
        return this.linkInternal;
    }
    /**
     * Gets the local reference if any.
     * @returns string
     * @private
     */
    get localReference() {
        return this.localRef;
    }
    /**
     * Gets hyper link type.
     * @returns HyperLinkType
     * @private
     */
    get linkType() {
        return this.typeInternal;
    }
    /**
     * Parse field values
     * @param  {string} value
     * @returns Void
     */
    parseFieldValues(value, selection) {
        let codes = value.split(' ');
        let isLocalRef = false;
        for (let i = 0; i < codes.length; i++) {
            let code = codes[i];
            if (code.length < 1) {
                continue;
            }
            if (code === '\\t' || code === '\\l') {
                isLocalRef = true;
            }
            else if (code === '\\n') {
                this.opensNewWindow = true;
            }
            else {
                code = this.parseFieldValue(code, code[0] === '\"' ? '\"' : undefined);
                if (isLocalRef) {
                    this.localRef = code;
                    isLocalRef = false;
                }
                else {
                    this.linkInternal = code;
                }
            }
        }
        this.setLinkType();
    }
    parseFieldValue(value, endChar) {
        value = value.substring(1);
        let endIndex = endChar ? value.indexOf(endChar) : -1;
        if (endIndex < 0) {
            endIndex = value.length;
        }
        return value.substring(0, endIndex).trim();
    }
    setLinkType() {
        // If only local reference.
        if (isNullOrUndefined(this.linkInternal) || this.linkInternal.length < 1) {
            this.typeInternal = 'Bookmark';
            return;
        }
        // Validates link.
        if (this.linkInternal.substring(0, 4) === ('www.')) {
            this.linkInternal = 'http://' + this.navigationLink;
        }
        else if (this.linkInternal[0] === '@') {
            this.linkInternal = 'mailto:' + this.navigationLink;
        }
        // Finds proper link type.
        if (this.linkInternal.substring(0, 7) === 'http://'
            || this.linkInternal.substring(0, 8) === 'https://') {
            this.typeInternal = 'WebPage';
        }
        else if (this.linkInternal.substring(0, 7) === 'mailto:') {
            this.typeInternal = 'Email';
        }
        else {
            this.typeInternal = 'File';
        }
    }
    /**
     * @private
     */
    destroy() {
        this.linkInternal = undefined;
        this.localRef = undefined;
        this.typeInternal = undefined;
        this.opensNewWindow = undefined;
    }
}
/**
 * @private
 */
class ImageFormat {
    /**
     * Constructor for image format class
     * @param imageContainer - Specifies for image width and height values.
     */
    constructor(imageContainer) {
        /**
         * @private
         */
        this.width = 0;
        /**
         * @private
         */
        this.height = 0;
        this.width = imageContainer.width;
        this.height = imageContainer.height;
    }
    /**
     * Dispose the internal objects which are maintained.
     * @private
     */
    destroy() {
        this.width = undefined;
        this.height = undefined;
    }
}

/**
 * Selection
 */
class Selection {
    /**
     * @private
     */
    constructor(documentEditor) {
        /**
         * @private
         */
        this.upDownSelectionLength = 0;
        /**
         * @private
         */
        this.isSkipLayouting = false;
        /**
         * @private
         */
        this.isImageSelected = false;
        this.contextTypeInternal = undefined;
        /**
         * @private
         */
        this.caret = undefined;
        //Format Retrieval Field
        /**
         * @private
         */
        this.isRetrieveFormatting = false;
        /**
         * @private
         */
        this.skipFormatRetrieval = false;
        this.isMoveDownOrMoveUp = false;
        /**
         * @private
         */
        this.selectedWidgets = undefined;
        /**
         * Hides caret.
         * @private
         */
        this.hideCaret = () => {
            this.caret.style.display = 'none';
        };
        this.owner = documentEditor;
        this.viewer = this.owner.viewer;
        this.start = new TextPosition(this.owner);
        this.end = new TextPosition(this.owner);
        this.selectedWidgets = new Dictionary();
        this.characterFormatIn = new SelectionCharacterFormat(this);
        this.paragraphFormatIn = new SelectionParagraphFormat(this, this.viewer);
        this.sectionFormatIn = new SelectionSectionFormat(this);
        this.rowFormatIn = new SelectionRowFormat(this);
        this.cellFormatIn = new SelectionCellFormat(this);
        this.tableFormatIn = new SelectionTableFormat(this);
        this.imageFormatInternal = new SelectionImageFormat(this);
    }
    /**
     * @private
     */
    get htmlWriter() {
        if (isNullOrUndefined(this.htmlWriterIn)) {
            this.htmlWriterIn = new HtmlExport();
        }
        return this.htmlWriterIn;
    }
    /**
     * Gets the start text position of last range in the selection
     * @returns {TextPosition}
     * @private
     */
    get start() {
        if (!isNullOrUndefined(this.owner) && !isNullOrUndefined(this.viewer)) {
            if (isNullOrUndefined(this.startInternal)) {
                this.startInternal = this.owner.documentStart;
            }
            return this.startInternal;
        }
        return undefined;
    }
    /**
     * @private
     */
    set start(value) {
        this.startInternal = value;
    }
    //Format retrieval properties
    /**
     * Gets the instance of selection character format.
     * @default undefined
     * @return {SelectionCharacterFormat}
     */
    get characterFormat() {
        return this.characterFormatIn;
    }
    /**
     * Gets the instance of selection paragraph format.
     * @default undefined
     * @return {SelectionParagraphFormat}
     */
    get paragraphFormat() {
        return this.paragraphFormatIn;
    }
    /**
     * Gets the instance of selection section format.
     * @default undefined
     * @return {SelectionSectionFormat}
     */
    get sectionFormat() {
        return this.sectionFormatIn;
    }
    /**
     * Gets the instance of selection table format.
     * @default undefined
     * @return {SelectionTableFormat}
     */
    get tableFormat() {
        return this.tableFormatIn;
    }
    /**
     * Gets the instance of selection cell format.
     * @default undefined
     * @return {SelectionCellFormat}
     */
    get cellFormat() {
        return this.cellFormatIn;
    }
    /**
     * Gets the instance of selection row format.
     * @default undefined
     * @returns SelectionRowFormat
     */
    get rowFormat() {
        return this.rowFormatIn;
    }
    /**
     * Gets the instance of selection image format.
     * @default undefined
     * @returns SelectionImageFormat
     */
    get imageFormat() {
        return this.imageFormatInternal;
    }
    /**
     * Gets the start text position of selection range.
     * @private
     */
    get end() {
        return this.endInternal;
    }
    /**
     * Gets the page number where the selection ends.
     * @private
     */
    get startPage() {
        if (!this.owner.isDocumentLoaded || isNullOrUndefined(this.viewer)
            || isNullOrUndefined(this.viewer.selectionStartPage)) {
            return 1;
        }
        return this.viewer.pages.indexOf(this.viewer.selectionStartPage) + 1;
    }
    /**
     * Gets the page number where the selection ends.
     * @private
     */
    get endPage() {
        if (!this.owner.isDocumentLoaded || isNullOrUndefined(this.viewer)
            || isNullOrUndefined(this.viewer.selectionEndPage)) {
            return 1;
        }
        return this.viewer.pages.indexOf(this.viewer.selectionEndPage) + 1;
    }
    /**
     * For internal use
     * @private
     */
    set end(value) {
        this.endInternal = value;
    }
    /**
     * Determines whether the selection direction is forward or not.
     * @default false
     * @returns {boolean}
     * @private
     */
    get isForward() {
        return this.start.isExistBefore(this.end);
    }
    /**
     * Determines whether the start and end positions are same or not.
     * @default false
     * @returns {boolean}
     * @private
     */
    get isEmpty() {
        if (isNullOrUndefined(this.start)) {
            return true;
        }
        return this.start.isAtSamePosition(this.end);
    }
    /**
     * Gets the text within selection.
     * @default ''
     * @returns {string}
     */
    get text() {
        return this.getText(false);
    }
    /**
     * Gets the context type of the selection.
     */
    get contextType() {
        return this.contextTypeInternal;
    }
    /**
     * @private
     */
    get isCleared() {
        return isNullOrUndefined(this.end);
    }
    getModuleName() {
        return 'Selection';
    }
    //Public API
    /**
     * Moves the selection to the header of current page.
     */
    goToHeader() {
        this.owner.enableHeaderAndFooter = true;
        this.enableHeadersFootersRegion(this.start.paragraph.bodyWidget.page.headerWidget);
    }
    /**
     * Moves the selection to the footer of current page.
     */
    goToFooter() {
        this.owner.enableHeaderAndFooter = true;
        this.enableHeadersFootersRegion(this.start.paragraph.bodyWidget.page.footerWidget);
    }
    /**
     * Closes the header and footer region.
     */
    closeHeaderFooter() {
        this.disableHeaderFooter();
    }
    /**
     * Moves the selection to the start of specified page number.
     */
    goToPage(pageNumber) {
        if (pageNumber >= 1 && pageNumber <= this.viewer.pages.length) {
            let page = this.viewer.pages[pageNumber - 1];
            this.updateTextPositionForBlockContainer(page.bodyWidgets[0]);
        }
    }
    /**
     * Selects the entire table if the context is within table.
     */
    selectTable() {
        if (!this.owner.enableSelection) {
            return;
        }
        this.selectTableInternal();
    }
    /**
     * Selects the entire row if the context is within table.
     */
    selectRow() {
        if (!this.owner.enableSelection) {
            return;
        }
        this.selectTableRow();
    }
    /**
     * Selects the entire column if the context is within table.
     */
    selectColumn() {
        if (!this.owner.enableSelection) {
            return;
        }
        this.selectColumnInternal();
    }
    /**
     * Selects the entire cell if the context is within table.
     */
    selectCell() {
        if (!this.owner.enableSelection) {
            return;
        }
        this.selectTableCell();
    }
    /**
     * Select content based on selection settings
     */
    select(selectionSettings) {
        let point = new Point(selectionSettings.x, selectionSettings.y);
        let pageCoordinates = this.viewer.findFocusedPage(point, true);
        if (selectionSettings.extend) {
            this.moveTextPosition(pageCoordinates, this.end);
        }
        else {
            this.viewer.updateTextPositionForSelection(pageCoordinates, 1);
        }
    }
    /**
     * Toggles the bold property of selected contents.
     * @private
     */
    toggleBold() {
        if (this.owner.editorModule) {
            this.owner.editorModule.toggleBold();
        }
    }
    /**
     * Toggles the italic property of selected contents.
     * @private
     */
    toggleItalic() {
        if (this.owner.editorModule) {
            this.owner.editorModule.toggleItalic();
        }
    }
    /**
     * Toggles the underline property of selected contents.
     * @param underline Default value of ‘underline’ parameter is Single.
     * @private
     */
    toggleUnderline(underline) {
        if (this.owner.editor) {
            this.owner.editor.toggleUnderline(underline);
        }
    }
    /**
     * Toggles the strike through property of selected contents.
     * @param {Strikethrough} strikethrough Default value of strikethrough parameter is SingleStrike.
     * @private
     */
    toggleStrikethrough(strikethrough) {
        if (this.owner.editor) {
            this.owner.editor.toggleStrikethrough(strikethrough);
        }
    }
    /**
     * Toggles the highlight color property of selected contents.
     * @param {HighlightColor} highlightColor Default value of ‘underline’ parameter is Yellow.
     * @private
     */
    toggleHighlightColor(highlightColor) {
        if (this.owner.editor) {
            this.owner.editor.toggleHighlightColor(highlightColor);
        }
    }
    /**
     * Toggles the subscript formatting of selected contents.
     * @private
     */
    toggleSubscript() {
        if (this.owner.editor) {
            this.owner.editor.toggleSubscript();
        }
    }
    /**
     * Toggles the superscript formatting of selected contents.
     * @private
     */
    toggleSuperscript() {
        if (this.owner.editor) {
            this.owner.editor.toggleSuperscript();
        }
    }
    /**
     * Toggles the text alignment property of selected contents.
     * @param {TextAlignment} textAlignment Default value of ‘textAlignment parameter is TextAlignment.Left.
     * @private
     */
    toggleTextAlignment(textAlignment) {
        if (this.owner.editor) {
            this.owner.editor.toggleTextAlignment(textAlignment);
        }
    }
    /**
     * Increases the left indent of selected paragraphs to a factor of 36 points.
     * @private
     */
    increaseIndent() {
        if (this.owner.editor) {
            this.owner.editor.increaseIndent();
        }
    }
    /**
     * Decreases the left indent of selected paragraphs to a factor of 36 points.
     * @private
     */
    decreaseIndent() {
        if (this.owner.editor) {
            this.owner.editor.decreaseIndent();
        }
    }
    /**
     * Fires the `requestNavigate` event if current selection context is in hyperlink.
     */
    navigateHyperlink() {
        let fieldBegin = this.getHyperlinkField();
        if (fieldBegin) {
            this.fireRequestNavigate(fieldBegin);
        }
    }
    /**
     * Navigate Hyperlink
     * @param fieldBegin
     * @private
     */
    fireRequestNavigate(fieldBegin) {
        let hyperlink = new Hyperlink(fieldBegin, this);
        let eventArgs = {
            isHandled: false,
            navigationLink: hyperlink.navigationLink,
            linkType: hyperlink.linkType,
            localReference: hyperlink.localReference,
            source: this.owner
        };
        this.owner.trigger('requestNavigate', eventArgs);
        if (!eventArgs.isHandled) {
            this.viewer.selection.navigateBookmark(hyperlink.localReference, true);
        }
    }
    /**
     * Copies the hyperlink URL if the context is within hyperlink.
     */
    copyHyperlink() {
        let hyperLinkField = this.getHyperlinkField();
        let linkText = this.getLinkText(hyperLinkField);
        this.copyToClipboard(linkText);
    }
    //Selection add, Highlight, remove API starts
    /**
     * @private
     */
    highlightSelection(isSelectionChanged) {
        if (this.owner.enableImageResizerMode) {
            this.owner.imageResizerModule.hideImageResizer();
        }
        if (this.isEmpty) {
            this.updateCaretPosition();
        }
        else {
            if (this.isForward) {
                this.highlightSelectedContent(this.start, this.end);
            }
            else {
                this.highlightSelectedContent(this.end, this.start);
            }
        }
        this.viewer.updateTouchMarkPosition();
        if (isSelectionChanged) {
            this.viewer.scrollToPosition(this.start, this.end);
        }
    }
    /**
     * @private
     */
    createHighlightBorder(lineWidget, width, left, top) {
        if (width < 0) {
            width = 0;
        }
        let page = this.getPage(lineWidget.paragraph);
        let height = lineWidget.height;
        let selectionWidget = undefined;
        if (!this.selectedWidgets.containsKey(lineWidget)) {
            selectionWidget = new SelectionWidgetInfo(left, width);
            this.selectedWidgets.add(lineWidget, selectionWidget);
        }
        let viewer = this.viewer;
        let pageTop = this.getPageTop(page);
        let pageLeft = page.boundingRectangle.x;
        if (viewer.containerTop <= pageTop
            || pageTop < viewer.containerTop + viewer.selectionCanvas.height) {
            viewer.selectionContext.fillStyle = 'gray';
            viewer.selectionContext.globalAlpha = 0.4;
            let zoomFactor = viewer.zoomFactor;
            this.clipSelection(page, pageTop);
            // tslint:disable-next-line:max-line-length
            viewer.selectionContext.fillRect((pageLeft + (left * zoomFactor)) - viewer.containerLeft, (pageTop + (top * zoomFactor)) - viewer.containerTop, width * zoomFactor, height * zoomFactor);
            viewer.selectionContext.restore();
        }
    }
    /**
     * Create selection highlight inside table
     * @private
     */
    createHighlightBorderInsideTable(cellWidget) {
        let page = this.getPage(cellWidget);
        let selectionWidget = undefined;
        let left = cellWidget.x - cellWidget.margin.left + cellWidget.leftBorderWidth;
        let width = cellWidget.width + cellWidget.margin.left
            + cellWidget.margin.right - cellWidget.leftBorderWidth - cellWidget.rightBorderWidth;
        let top = cellWidget.y;
        let height = cellWidget.height;
        let pageTop = this.getPageTop(page);
        let pageLeft = page.boundingRectangle.x;
        let isVisiblePage = this.viewer.containerTop <= pageTop
            || pageTop < this.viewer.containerTop + this.viewer.selectionCanvas.height;
        if (this.selectedWidgets.containsKey(cellWidget)) {
            selectionWidget = this.selectedWidgets.get(cellWidget);
            if (isVisiblePage) {
                // tslint:disable-next-line:max-line-length
                this.viewer.selectionContext.clearRect((pageLeft + (selectionWidget.left * this.viewer.zoomFactor) - this.viewer.containerLeft), (pageTop + (top * this.viewer.zoomFactor)) - this.viewer.containerTop, selectionWidget.width * this.viewer.zoomFactor, height * this.viewer.zoomFactor);
            }
        }
        selectionWidget = new SelectionWidgetInfo(left, width);
        this.selectedWidgets.add(cellWidget, selectionWidget);
        if (isVisiblePage) {
            this.viewer.selectionContext.fillStyle = 'gray';
            this.viewer.selectionContext.globalAlpha = 0.4;
            let zoomFactor = this.viewer.zoomFactor;
            this.clipSelection(page, pageTop);
            // tslint:disable-next-line:max-line-length
            this.viewer.selectionContext.fillRect((pageLeft + (left * zoomFactor)) - this.viewer.containerLeft, (pageTop + (top * zoomFactor)) - this.viewer.containerTop, width * zoomFactor, height * zoomFactor);
            this.viewer.selectionContext.restore();
        }
    }
    /**
     * @private
     */
    clipSelection(page, pageTop) {
        let viewer = this.viewer;
        let width = page.boundingRectangle.width * viewer.zoomFactor;
        let height = page.boundingRectangle.height * viewer.zoomFactor;
        let left = page.boundingRectangle.x;
        viewer.selectionContext.beginPath();
        viewer.selectionContext.save();
        viewer.selectionContext.rect(left - viewer.containerLeft, pageTop - viewer.containerTop, width, height);
        viewer.selectionContext.clip();
    }
    /**
     * Add selection highlight
     * @private
     */
    addSelectionHighlight(canvasContext, widget, top) {
        if (this.selectedWidgets.containsKey(widget)) {
            let height = this.viewer.render.getScaledValue(widget.height);
            let widgetInfo = this.selectedWidgets.get(widget);
            let width = this.viewer.render.getScaledValue(widgetInfo.width);
            let left = this.viewer.render.getScaledValue(widgetInfo.left, 1);
            canvasContext.fillStyle = 'gray';
            let page = this.owner.selection.getPage(widget.paragraph);
            this.owner.selection.clipSelection(page, this.owner.selection.getPageTop(page));
            canvasContext.fillRect(left, this.viewer.render.getScaledValue(top, 2), width, height);
            canvasContext.restore();
        }
    }
    /**
     * Add Selection highlight inside table
     * @private
     */
    addSelectionHighlightTable(canvasContext, tableCellWidget) {
        if (this.selectedWidgets.containsKey(tableCellWidget)) {
            let selectionWidget = this.selectedWidgets.get(tableCellWidget);
            let left = this.viewer.render.getScaledValue(selectionWidget.left, 1);
            let top = this.viewer.render.getScaledValue(tableCellWidget.y, 2);
            let width = this.viewer.render.getScaledValue(selectionWidget.width);
            let height = this.viewer.render.getScaledValue(tableCellWidget.height);
            canvasContext.fillStyle = 'gray';
            let page = this.owner.selection.getPage(tableCellWidget);
            this.owner.selection.clipSelection(page, this.owner.selection.getPageTop(page));
            canvasContext.fillRect(left, top, width, height);
            canvasContext.restore();
        }
    }
    /**
     * Remove Selection highlight
     * @private
     */
    removeSelectionHighlight(widget) {
        let left = 0;
        let top = 0;
        let width = 0;
        let height = 0;
        let page = undefined;
        if (widget instanceof LineWidget) {
            let lineWidget = widget;
            let currentParaWidget = lineWidget.paragraph;
            page = !isNullOrUndefined(currentParaWidget) ?
                this.getPage((lineWidget.paragraph)) : undefined;
            if (isNullOrUndefined(page)) {
                return;
            }
            top = this.getTop(lineWidget);
            height = lineWidget.height;
        }
        else if (widget instanceof TableCellWidget) {
            page = !isNullOrUndefined(widget) ?
                this.getPage(widget) : undefined;
            if (isNullOrUndefined(page)) {
                return;
            }
            top = widget.y;
            height = widget.height;
        }
        if (isNullOrUndefined(page)) {
            return;
        }
        let widgetInfo = this.selectedWidgets.get(widget);
        width = widgetInfo.width;
        left = widgetInfo.left;
        let pageRect = page.boundingRectangle;
        let pageIndex = this.viewer.pages.indexOf(page);
        let pageGap = this.viewer.pageGap;
        let pageTop = (pageRect.y - pageGap * (pageIndex + 1)) * this.viewer.zoomFactor + pageGap * (pageIndex + 1);
        let pageLeft = pageRect.x;
        let zoomFactor = this.viewer.zoomFactor;
        if (this.viewer.containerTop <= pageTop
            || pageTop < this.viewer.containerTop + this.viewer.selectionCanvas.height) {
            // tslint:disable-next-line:max-line-length
            this.viewer.selectionContext.clearRect((pageLeft + (left * zoomFactor) - this.viewer.containerLeft) - 0.5, (pageTop + (top * zoomFactor)) - this.viewer.containerTop - 0.5, width * zoomFactor + 0.5, height * zoomFactor + 0.5);
        }
    }
    /**
     * Select Current word
     * @private
     */
    selectCurrentWord() {
        let startPosition = this.start.clone();
        let endPosition = this.end.clone();
        this.selectCurrentWordRange(startPosition, endPosition, false);
        this.selectRange(startPosition, endPosition);
    }
    /**
     * Select current paragraph
     * @private
     */
    selectCurrentParagraph() {
        if (!isNullOrUndefined(this.start)) {
            this.start.paragraphStartInternal(this, false);
            this.end.moveToParagraphEndInternal(this, false);
            this.upDownSelectionLength = this.end.location.x;
            this.fireSelectionChanged(true);
        }
    }
    /**
     * Select current word range
     * @private
     */
    selectCurrentWordRange(startPosition, endPosition, excludeSpace) {
        if (!isNullOrUndefined(startPosition)) {
            if (startPosition.offset > 0) {
                let wordStart = startPosition.clone();
                let indexInInline = 0;
                let inlineObj = startPosition.currentWidget.getInline(startPosition.offset, indexInInline);
                let inline = inlineObj.element;
                indexInInline = inlineObj.index;
                if (!isNullOrUndefined(inline) && inline instanceof FieldElementBox && inline.fieldType === 1) {
                    // tslint:disable-next-line:max-line-length
                    if (startPosition.offset > 2 && (!isNullOrUndefined(inline.fieldSeparator) || isNullOrUndefined(inline.fieldBegin))) {
                        wordStart.setPositionParagraph(wordStart.currentWidget, startPosition.offset - 2);
                        wordStart.moveToWordEndInternal(0, false);
                        if (!(wordStart.paragraph === startPosition.paragraph && wordStart.offset === startPosition.offset - 1)) {
                            startPosition.moveToWordStartInternal(2);
                        }
                    }
                    else if (startPosition.offset > 3 && isNullOrUndefined(inline.fieldSeparator)) {
                        wordStart.setPositionParagraph(wordStart.currentWidget, startPosition.offset - 3);
                        wordStart.moveToWordEndInternal(0, false);
                        if (!(wordStart.paragraph === startPosition.paragraph && wordStart.offset === startPosition.offset)) {
                            startPosition.moveToWordStartInternal(2);
                        }
                    }
                }
                else {
                    wordStart.setPositionParagraph(wordStart.currentWidget, startPosition.offset - 1);
                    wordStart.moveToWordEndInternal(0, false);
                    if (!(wordStart.paragraph === startPosition.paragraph && wordStart.offset === startPosition.offset)) {
                        startPosition.moveToWordStartInternal(2);
                    }
                }
            }
            endPosition.moveToWordEndInternal(2, excludeSpace);
        }
    }
    /**
     * Extend selection to paragraph start
     * @private
     */
    extendToParagraphStart() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.paragraphStartInternal(this, true);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Extend selection to paragraph end
     * @private
     */
    extendToParagraphEnd() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.moveToParagraphEndInternal(this, true);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Move to next text position
     * @private
     */
    moveNextPosition() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        if (this.isEmpty) {
            this.start.moveNextPosition();
            this.end.setPositionInternal(this.start);
        }
        this.updateForwardSelection();
        this.upDownSelectionLength = this.start.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Move to next paragraph
     * @private
     */
    moveToNextParagraph() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.moveToNextParagraphStartInternal();
        this.start.setPositionInternal(this.end);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Move to previous text position
     * @private
     */
    movePreviousPosition() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        if (this.isEmpty) {
            this.start.movePreviousPosition();
            this.end.setPositionInternal(this.start);
        }
        this.updateBackwardSelection();
        this.upDownSelectionLength = this.start.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Move to previous paragraph
     * @private
     */
    moveToPreviousParagraph() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.moveToPreviousParagraph(this);
        this.start.setPositionInternal(this.end);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Extend selection to previous line
     * @private
     */
    extendToPreviousLine() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.moveToPreviousLine(this, this.upDownSelectionLength);
        this.fireSelectionChanged(true);
    }
    /**
     * Extend selection to line end
     * @private
     */
    extendToLineEnd() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.moveToLineEndInternal(this, true);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Extend to line start
     * @private
     */
    extendToLineStart() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.moveToLineStartInternal(this, true);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * @private
     */
    moveUp() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        if (!this.isEmpty) {
            if (this.isForward) {
                this.end.setPositionInternal(this.start);
            }
            else {
                this.start.setPositionInternal(this.end);
            }
            this.upDownSelectionLength = this.start.location.x;
        }
        this.upDownSelectionLength = this.start.location.x;
        this.start.moveUp(this, this.upDownSelectionLength);
        this.end.setPositionInternal(this.start);
        this.fireSelectionChanged(true);
    }
    /**
     * @private
     */
    moveDown() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        if (!this.isEmpty) {
            if (this.isForward) {
                this.start.setPositionInternal(this.end);
            }
            else {
                this.end.setPositionInternal(this.start);
            }
            this.upDownSelectionLength = this.start.location.x;
        }
        this.start.moveDown(this, this.upDownSelectionLength);
        this.end.setPositionInternal(this.start);
        this.fireSelectionChanged(true);
    }
    updateForwardSelection() {
        if (!this.isEmpty) {
            if (this.isForward) {
                this.start.setPositionInternal(this.end);
            }
            else {
                this.end.setPositionInternal(this.start);
            }
        }
    }
    updateBackwardSelection() {
        if (!this.isEmpty) {
            if (this.isForward) {
                this.end.setPositionInternal(this.start);
            }
            else {
                this.start.setPositionInternal(this.end);
            }
        }
    }
    /**
     * @private
     */
    getFirstBlockInFirstCell(table) {
        if (table.childWidgets.length > 0) {
            let firstrow = table.childWidgets[0];
            if (firstrow.childWidgets.length > 0) {
                let firstcell = firstrow.childWidgets[0];
                if (firstcell.childWidgets.length === 0) {
                    return undefined;
                }
                return firstcell.childWidgets[0];
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getFirstCellInRegion(row, startCell, selectionLength, isMovePrevious) {
        let cellStart = this.getCellLeft(row, startCell);
        let cellEnd = cellStart + startCell.cellFormat.cellWidth;
        let flag = true;
        if (cellStart <= selectionLength && selectionLength < cellEnd) {
            for (let k = 0; k < row.childWidgets.length; k++) {
                let left = this.getCellLeft(row, row.childWidgets[k]);
                if (HelperMethods.round(cellStart, 2) <= HelperMethods.round(left, 2) &&
                    HelperMethods.round(left, 2) < HelperMethods.round(cellEnd, 2)) {
                    flag = false;
                    return row.childWidgets[k];
                }
            }
        }
        else {
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cellLeft = this.getCellLeft(row, row.childWidgets[j]);
                if (cellLeft <= selectionLength && cellLeft +
                    row.childWidgets[j].cellFormat.cellWidth > selectionLength) {
                    flag = false;
                    return row.childWidgets[j];
                }
            }
        }
        if (flag) {
            if (!isNullOrUndefined(row.previousRenderedWidget) && isMovePrevious) {
                let previousWidget = row.previousRenderedWidget;
                return this.getFirstCellInRegion(previousWidget, startCell, selectionLength, isMovePrevious);
            }
            else if (!isNullOrUndefined(row.nextRenderedWidget) && !isMovePrevious) {
                return this.getFirstCellInRegion(row.nextRenderedWidget, startCell, selectionLength, isMovePrevious);
            }
        }
        return row.childWidgets[0];
    }
    /**
     * @private
     */
    getFirstParagraph(tableCell) {
        while (tableCell.previousSplitWidget) {
            tableCell = tableCell.previousSplitWidget;
        }
        let firstBlock = tableCell.firstChild;
        return this.getFirstParagraphBlock(firstBlock);
    }
    /**
     * Get last block in last cell
     * @private
     */
    //Table
    getLastBlockInLastCell(table) {
        if (table.childWidgets.length > 0) {
            let lastrow = table.childWidgets[table.childWidgets.length - 1];
            let lastcell = lastrow.childWidgets[lastrow.childWidgets.length - 1];
            return lastcell.childWidgets[lastcell.childWidgets.length - 1];
        }
        return undefined;
    }
    /**
     * Move to line start
     * @private
     */
    moveToLineStart() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.updateBackwardSelection();
        this.start.moveToLineStartInternal(this, false);
        this.end.setPositionInternal(this.start);
        this.upDownSelectionLength = this.start.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Move to line end
     * @private
     */
    moveToLineEnd() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.updateForwardSelection();
        this.start.moveToLineEndInternal(this, false);
        this.end.setPositionInternal(this.start);
        this.upDownSelectionLength = this.start.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Get Page top
     * @private
     */
    getPageTop(page) {
        // tslint:disable-next-line:max-line-length
        return (page.boundingRectangle.y - this.viewer.pageGap * (this.viewer.pages.indexOf(page) + 1)) * this.viewer.zoomFactor + this.viewer.pageGap * (this.viewer.pages.indexOf(page) + 1);
    }
    /**
     * Move text position to cursor point
     * @private
     */
    moveTextPosition(cursorPoint, textPosition) {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        //Updates the text position based on the cursor position.
        let widget = this.viewer.getLineWidgetInternal(cursorPoint, true);
        if (!isNullOrUndefined(widget)) {
            this.updateTextPositionWidget(widget, cursorPoint, textPosition, true);
        }
        this.upDownSelectionLength = textPosition.location.x;
        let selectionStartIndex = this.start.getHierarchicalIndexInternal();
        let selectionEndIndex = this.end.getHierarchicalIndexInternal();
        if (selectionStartIndex !== selectionEndIndex) {
            // Extends selection end to field begin or field end.
            if (TextPosition.isForwardSelection(selectionStartIndex, selectionEndIndex)) {
                textPosition.validateForwardFieldSelection(selectionStartIndex, selectionEndIndex);
            }
            else {
                textPosition.validateBackwardFieldSelection(selectionStartIndex, selectionEndIndex);
            }
        }
        this.fireSelectionChanged(true);
    }
    //Helper Method Implementation 
    //Document
    /**
     * Get document start position
     * @private
     */
    getDocumentStart() {
        let block = this.viewer.pages[0].bodyWidgets[0].childWidgets[0];
        return this.setPositionForBlock(block, true);
    }
    /**
     * Get document end position
     * @private
     */
    getDocumentEnd() {
        let textPosition = undefined;
        let documentStart = this.owner.documentStart;
        let lastPage = this.viewer.pages[this.viewer.pages.length - 1];
        if (!isNullOrUndefined(documentStart) && lastPage.bodyWidgets[0].childWidgets.length > 0) {
            let block = undefined;
            let section = lastPage.bodyWidgets[0];
            let blocks = section.childWidgets;
            let lastBlkItem = blocks.length - 1;
            let lastBlock = blocks[lastBlkItem];
            if (lastBlock instanceof BlockWidget) {
                block = lastBlock;
            }
            textPosition = this.setPositionForBlock(block, false);
        }
        return textPosition;
    }
    //Keyboard shortcut internal API
    /**
     * @private
     * Handles control end key.
     */
    handleControlEndKey() {
        let documentEnd = undefined;
        if (!isNullOrUndefined(this.owner.documentEnd)) {
            documentEnd = this.owner.documentEnd;
        }
        if (!isNullOrUndefined(documentEnd)) {
            this.owner.selection.selectContent(documentEnd, true);
        }
        this.checkForCursorVisibility();
    }
    /**
     * @private
     * Handles control home key.
     */
    handleControlHomeKey() {
        let documentStart = undefined;
        if (!isNullOrUndefined(this.owner.documentStart)) {
            documentStart = this.owner.documentStart;
        }
        if (!isNullOrUndefined(documentStart)) {
            this.owner.selection.selectContent(documentStart, true);
        }
        this.checkForCursorVisibility();
    }
    /**
     * @private
     * Handles control left key.
     */
    handleControlLeftKey() {
        this.extendToWordStart(true);
        this.checkForCursorVisibility();
    }
    /**
     * @private
     * Handles control right key.
     */
    handleControlRightKey() {
        this.extendToWordEnd(true);
        this.checkForCursorVisibility();
    }
    /**
     * Handles control down key.
     * @private
     */
    handleControlDownKey() {
        this.moveToNextParagraph();
        this.checkForCursorVisibility();
    }
    /**
     * Handles control up key.
     * @private
     */
    handleControlUpKey() {
        this.moveToPreviousParagraph();
        this.checkForCursorVisibility();
    }
    /**
     * @private
     * Handles shift left key.
     */
    handleShiftLeftKey() {
        this.extendBackward();
        this.checkForCursorVisibility();
    }
    /**
     * Handles shift up key.
     * @private
     */
    handleShiftUpKey() {
        this.extendToPreviousLine();
        this.checkForCursorVisibility();
    }
    /**
     * Handles shift right key.
     * @private
     */
    handleShiftRightKey() {
        this.extendForward();
        this.checkForCursorVisibility();
    }
    /**
     * Handles shift down key.
     * @private
     */
    handleShiftDownKey() {
        this.extendToNextLine();
        this.checkForCursorVisibility();
    }
    /**
     * @private
     * Handles control shift left key.
     */
    handleControlShiftLeftKey() {
        this.extendToWordStart(false);
        this.checkForCursorVisibility();
    }
    /**
     * Handles control shift up key.
     * @private
     */
    handleControlShiftUpKey() {
        this.extendToParagraphStart();
        this.checkForCursorVisibility();
    }
    /**
     * Handles control shift right key
     * @private
     */
    handleControlShiftRightKey() {
        this.extendToWordEnd(false);
        this.checkForCursorVisibility();
    }
    /**
     * Handles control shift down key.
     * @private
     */
    handleControlShiftDownKey() {
        this.extendToParagraphEnd();
        this.checkForCursorVisibility();
    }
    /**
     * Handles left key.
     * @private
     */
    handleLeftKey() {
        this.movePreviousPosition();
        this.checkForCursorVisibility();
    }
    /**
     * Handles up key.
     * @private
     */
    handleUpKey() {
        this.isMoveDownOrMoveUp = true;
        this.moveUp();
        this.isMoveDownOrMoveUp = false;
        this.checkForCursorVisibility();
    }
    /**
     * Handles right key.
     * @private
     */
    handleRightKey() {
        this.moveNextPosition();
        this.checkForCursorVisibility();
    }
    /**
     * Handles end key.
     * @private
     */
    handleEndKey() {
        this.moveToLineEnd();
        this.checkForCursorVisibility();
    }
    /**
     * Handles home key.
     * @private
     */
    handleHomeKey() {
        this.moveToLineStart();
        this.checkForCursorVisibility();
    }
    /**
     * Handles down key.
     * @private
     */
    handleDownKey() {
        this.isMoveDownOrMoveUp = true;
        this.moveDown();
        this.isMoveDownOrMoveUp = false;
        this.checkForCursorVisibility();
    }
    /**
     * Handles shift end key.
     * @private
     */
    handleShiftEndKey() {
        this.extendToLineEnd();
        this.checkForCursorVisibility();
    }
    /**
     * Handles shift home key.
     * @private
     */
    handleShiftHomeKey() {
        this.extendToLineStart();
        this.checkForCursorVisibility();
    }
    /**
     * Handles control shift end key.
     * @private
     */
    handleControlShiftEndKey() {
        let documentEnd = undefined;
        if (!isNullOrUndefined(this.owner.documentEnd)) {
            documentEnd = this.owner.documentEnd;
        }
        if (!isNullOrUndefined(documentEnd)) {
            this.end.setPosition(documentEnd.currentWidget, false);
            this.fireSelectionChanged(true);
        }
        this.checkForCursorVisibility();
    }
    /**
     * Handles control shift home key.
     * @private
     */
    handleControlShiftHomeKey() {
        let documentStart = undefined;
        if (!isNullOrUndefined(this.owner.documentStart)) {
            documentStart = this.owner.documentStart;
        }
        if (!isNullOrUndefined(documentStart)) {
            this.end.setPositionInternal(documentStart);
            this.fireSelectionChanged(true);
        }
        this.checkForCursorVisibility();
    }
    /**
     * Handles tab key.
     * @param isNavigateInCell
     * @param isShiftTab
     * @private
     */
    handleTabKey(isNavigateInCell, isShiftTab) {
        let start = this.start;
        if (isNullOrUndefined(start)) {
            return;
        }
        if (start.paragraph.isInsideTable && this.end.paragraph.isInsideTable && (isNavigateInCell || isShiftTab)) {
            //Perform tab navigation
            if (isShiftTab) {
                this.selectPreviousCell();
            }
            else {
                this.selectNextCell();
            }
        }
        else if ((isNavigateInCell || isShiftTab) && !isNullOrUndefined(start) && start.offset === this.getStartOffset(start.paragraph)
            && !isNullOrUndefined(start.paragraph.paragraphFormat) && !isNullOrUndefined(start.paragraph.paragraphFormat.listFormat)
            && start.paragraph.paragraphFormat.listFormat.listId !== -1 && !this.owner.isReadOnlyMode) {
            this.owner.editorModule.updateListLevel(isShiftTab ? false : true);
        }
        else if (!this.owner.isReadOnlyMode) {
            this.owner.editorModule.handleTextInput('\t');
        }
        this.checkForCursorVisibility();
    }
    selectPreviousCell() {
        let tableCell = this.start.paragraph.associatedCell;
        let tableRow = tableCell.ownerRow;
        let tableAdv = tableRow.ownerTable;
        if (isNullOrUndefined(tableCell.previousWidget)) {
            if (!isNullOrUndefined(tableRow.previousRenderedWidget)) {
                //Move text selection or cursor to previous row's last cell
                let prevRow = undefined;
                if (tableRow.previousRenderedWidget instanceof TableRowWidget) {
                    prevRow = tableRow.previousRenderedWidget;
                }
                this.selectTableCellInternal(prevRow.childWidgets[prevRow.childWidgets.length - 1], true);
            }
        }
        else {
            //Move text selection or cursor to next cell in current row
            let prevCell = undefined;
            if (tableCell.previousWidget instanceof TableCellWidget) {
                prevCell = tableCell.previousWidget;
            }
            this.selectTableCellInternal(prevCell, true);
        }
    }
    selectNextCell() {
        let tableCell = this.start.paragraph.associatedCell;
        let tableRow = tableCell.ownerRow;
        let tableAdv = tableRow.ownerTable;
        if (isNullOrUndefined(tableCell.nextWidget)) {
            if (isNullOrUndefined(tableRow.nextRenderedWidget) && !this.owner.isReadOnlyMode) {
                //Insert new row below                  
                this.owner.editorModule.insertRow(false);
            }
            else {
                //Move text selection or cursor to next row's first cell
                let nextRow = undefined;
                if (tableRow.nextRenderedWidget instanceof TableRowWidget) {
                    nextRow = tableRow.nextRenderedWidget;
                }
                this.selectTableCellInternal(nextRow.childWidgets[0], true);
            }
            // }
        }
        else {
            //Move text selection or cursor to next cell in current row
            let nextCell = undefined;
            if (tableCell.nextRenderedWidget instanceof TableCellWidget) {
                nextCell = tableCell.nextRenderedWidget;
            }
            this.selectTableCellInternal(nextCell, true);
        }
    }
    /**
     * Select given table cell
     * @private
     */
    selectTableCellInternal(tableCell, clearMultiSelection) {
        let firstParagraph = this.getFirstParagraph(tableCell);
        let lastParagraph = this.getLastParagraph(tableCell);
        if (firstParagraph === lastParagraph && lastParagraph.isEmpty()) {
            this.selectParagraph(lastParagraph, true);
        }
        else {
            let firstLineWidget = lastParagraph.childWidgets[0];
            this.start.setPosition(firstParagraph.childWidgets[0], true);
            this.end.setPositionParagraph(firstLineWidget, firstLineWidget.getEndOffset());
            this.fireSelectionChanged(true);
        }
    }
    /**
     * Select while table
     * @private
     */
    selectTableInternal() {
        let start = this.start;
        let end = this.end;
        if (!this.isForward) {
            start = this.end;
            end = this.start;
        }
        if (!isNullOrUndefined(start) && !isNullOrUndefined(end) && !isNullOrUndefined(this.getTable(start, end))) {
            let containerCell = this.getContainerCellOf(start.paragraph.associatedCell, end.paragraph.associatedCell);
            let table = containerCell.ownerTable;
            let firstPara = this.getFirstParagraphBlock(table);
            let lastPara = this.getLastParagraphBlock(table);
            let offset = lastPara.lastChild.getEndOffset();
            this.start.setPosition(firstPara.childWidgets[0], true);
            this.end.setPositionParagraph(lastPara.lastChild, offset + 1);
        }
        this.selectPosition(this.start, this.end);
    }
    /**
     * Select single column
     * @private
     */
    selectColumnInternal() {
        let startTextPos = this.start;
        let endTextPos = this.end;
        if (!this.isForward) {
            startTextPos = this.end;
            endTextPos = this.start;
        }
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(startTextPos) && !isNullOrUndefined(endTextPos) && !isNullOrUndefined(this.getTable(startTextPos, endTextPos))) {
            let containerCell = this.getContainerCellOf(startTextPos.paragraph.associatedCell, endTextPos.paragraph.associatedCell);
            if (containerCell.ownerTable.contains(endTextPos.paragraph.associatedCell)) {
                let startCell = this.getSelectedCell(startTextPos.paragraph.associatedCell, containerCell);
                let endCell = this.getSelectedCell(endTextPos.paragraph.associatedCell, containerCell);
                if (this.containsCell(containerCell, endTextPos.paragraph.associatedCell)) {
                    let row = startCell.ownerRow;
                    let columnCells = containerCell.ownerTable.getColumnCellsForSelection(containerCell, containerCell);
                    if (columnCells.length > 0) {
                        let firstPara = this.getFirstParagraph(columnCells[0]);
                        let lastPara = this.getLastParagraph(columnCells[columnCells.length - 1]);
                        this.start.setPosition(firstPara.firstChild, true);
                        let lastLine = lastPara.lastChild;
                        this.end.setPositionParagraph(lastLine, lastLine.getEndOffset() + 1);
                    }
                }
                else {
                    let startCellColumnCells = containerCell.ownerTable.getColumnCellsForSelection(startCell, startCell);
                    let endCellColumnCells = containerCell.ownerTable.getColumnCellsForSelection(endCell, endCell);
                    if (startCellColumnCells.length > 0 && endCellColumnCells.length > 0) {
                        let firstPara = this.getFirstParagraph(startCellColumnCells[0]);
                        // tslint:disable-next-line:max-line-length
                        let lastPara = this.getLastParagraph(endCellColumnCells[endCellColumnCells.length - 1]);
                        this.start.setPosition(firstPara.firstChild, true);
                        let lastLine = lastPara.lastChild;
                        this.end.setPositionParagraph(lastLine, lastLine.getEndOffset() + 1);
                    }
                }
            }
        }
        this.selectPosition(this.start, this.end);
    }
    /**
     * Select single row
     * @private
     */
    selectTableRow() {
        let startPos = this.start;
        let endPos = this.end;
        if (!this.isForward) {
            startPos = this.end;
            endPos = this.start;
        }
        if (!isNullOrUndefined(startPos) && !isNullOrUndefined(endPos) && !isNullOrUndefined(this.getTable(startPos, endPos))) {
            let containerCell;
            containerCell = this.getContainerCellOf(startPos.paragraph.associatedCell, endPos.paragraph.associatedCell);
            if (containerCell.ownerTable.contains(endPos.paragraph.associatedCell)) {
                let startCell = this.getSelectedCell(startPos.paragraph.associatedCell, containerCell);
                let endCell = this.getSelectedCell(endPos.paragraph.associatedCell, containerCell);
                if (this.containsCell(containerCell, endPos.paragraph.associatedCell)) {
                    let row = startCell.ownerRow;
                    let firstPara = this.getFirstParagraph(row.childWidgets[0]);
                    let lastPara = this.getLastParagraph(row.childWidgets[row.childWidgets.length - 1]);
                    this.start.setPosition(firstPara.firstChild, true);
                    this.end.setPositionParagraph(lastPara.lastChild, lastPara.lastChild.getEndOffset() + 1);
                }
                else {
                    let firstPara = this.getFirstParagraph(startCell.ownerRow.childWidgets[0]);
                    let lastPara;
                    // tslint:disable-next-line:max-line-length
                    lastPara = this.getLastParagraph(endCell.ownerRow.childWidgets[endCell.ownerRow.childWidgets.length - 1]);
                    this.start.setPosition(firstPara.firstChild, true);
                    this.end.setPositionParagraph(lastPara.lastChild, lastPara.lastChild.getEndOffset() + 1);
                }
            }
        }
        this.selectPosition(this.start, this.end);
    }
    /**
     * Select single cell
     * @private
     */
    selectTableCell() {
        let start = this.start;
        let end = this.end;
        if (!this.isForward) {
            start = this.end;
            end = this.start;
        }
        if (isNullOrUndefined(this.getTable(start, end))) {
            return;
        }
        if (this.isEmpty) {
            if (start.paragraph.isInsideTable && !isNullOrUndefined(start.paragraph.associatedCell)) {
                let firstPara = this.getFirstParagraph(start.paragraph.associatedCell);
                let lastPara = this.getLastParagraph(end.paragraph.associatedCell);
                if (firstPara === lastPara) {
                    this.start.setPosition(lastPara.firstChild, true);
                    this.end.setPositionParagraph(lastPara.lastChild, lastPara.lastChild.getEndOffset() + 1);
                }
                else {
                    this.start.setPosition(firstPara.firstChild, true);
                    this.end.setPositionParagraph(lastPara.lastChild, lastPara.lastChild.getEndOffset() + 1);
                }
            }
        }
        else {
            let containerCell = this.getContainerCell(start.paragraph.associatedCell);
            // tslint:disable-next-line:max-line-length
            if (this.containsCell(containerCell, start.paragraph.associatedCell) && this.containsCell(containerCell, end.paragraph.associatedCell)) {
                let firstPara = this.getFirstParagraph(containerCell);
                let lastPara = this.getLastParagraph(containerCell);
                if (!isNullOrUndefined(firstPara) && !isNullOrUndefined(lastPara)) {
                    this.start.setPosition(firstPara.firstChild, true);
                    this.end.setPositionParagraph(lastPara.lastChild, lastPara.lastChild.getEndOffset() + 1);
                }
            }
        }
        this.selectPosition(this.start, this.end);
    }
    /**
     * @private
     * Selects the entire document.
     */
    selectAll() {
        let documentStart;
        let documentEnd;
        if (this.owner.enableHeaderAndFooter) {
            let headerFooter = this.getContainerWidget(this.start.paragraph);
            documentStart = this.setPositionForBlock(headerFooter.firstChild, true);
            documentEnd = this.setPositionForBlock(headerFooter.lastChild, false);
        }
        else {
            documentStart = this.owner.documentStart;
            documentEnd = this.owner.documentEnd;
        }
        //Selects the entire document.        
        if (!isNullOrUndefined(documentStart)) {
            this.start.setPositionInternal(documentStart);
            this.end.setPositionParagraph(documentEnd.currentWidget, documentEnd.offset + 1);
            this.upDownSelectionLength = this.end.location.x;
            this.fireSelectionChanged(true);
        }
    }
    /**
     * Extend selection backward
     * @private
     */
    extendBackward() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.moveBackward();
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Extent selection forward
     * @private
     */
    extendForward() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.moveForward();
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Extend selection to word start and end
     * @private
     */
    extendToWordStartEnd() {
        if ((this.start.paragraph.isInsideTable || this.end.paragraph.isInsideTable)
            && (this.start.paragraph.associatedCell !== this.end.paragraph.associatedCell
                || this.isCellSelected(this.start.paragraph.associatedCell, this.start, this.end))) {
            return true;
        }
        return false;
    }
    /**
     * Extend selection to word start
     * @private
     */
    extendToWordStart(isNavigation) {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        let isCellSelected = this.extendToWordStartEnd();
        if (isCellSelected) {
            this.end.moveToPreviousParagraphInTable(this);
        }
        else {
            this.end.moveToWordStartInternal(isNavigation ? 0 : 1);
        }
        if (isNavigation) {
            this.start.setPositionInternal(this.end);
        }
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Extent selection to word end
     * @private
     */
    extendToWordEnd(isNavigation) {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        let isCellSelect = this.extendToWordStartEnd();
        if (isCellSelect) {
            this.end.moveToNextParagraphInTable();
        }
        else {
            this.end.moveToWordEndInternal(isNavigation ? 0 : 1, false);
        }
        if (isNavigation) {
            this.start.setPositionInternal(this.end);
        }
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Extend selection to next line
     * @private
     */
    extendToNextLine() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.moveToNextLine(this.upDownSelectionLength);
        this.fireSelectionChanged(true);
    }
    //Selection Text get API
    //Selection add, Highlight, remove API enda
    getTextPosition(hierarchicalIndex) {
        let textPosition = new TextPosition(this.owner);
        textPosition.setPositionForCurrentIndex(hierarchicalIndex);
        return textPosition;
    }
    /**
     * Get Selected text
     * @private
     */
    getText(includeObject) {
        if (isNullOrUndefined(this.start) || isNullOrUndefined(this.end)
            || isNullOrUndefined(this.start.paragraph) || isNullOrUndefined(this.end.paragraph)) {
            return undefined;
        }
        let startPosition = this.start;
        let endPosition = this.end;
        if (startPosition.isAtSamePosition(endPosition)) {
            return '';
        }
        return this.getTextInternal(startPosition, endPosition, includeObject);
    }
    /**
     * Get selected text
     * @private
     */
    getTextInternal(start, end, includeObject) {
        if (start.isExistAfter(end)) {
            let temp = end;
            end = start;
            start = temp;
        }
        let startPosition = start;
        let endPosition = end;
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(start) && !isNullOrUndefined(end) && !isNullOrUndefined(start.paragraph) && !isNullOrUndefined(end.paragraph)) {
            let startIndex = 0;
            let endIndex = 0;
            let startOffset = start.offset;
            let endOffset = end.offset;
            let startInlineObj = start.currentWidget.getInline(startOffset, startIndex);
            startIndex = startInlineObj.index;
            let inline = startInlineObj.element;
            // If the start position is at the beginning of field begin that has field end, then field code should be skipped.
            if (inline instanceof FieldElementBox && !isNullOrUndefined(inline.fieldEnd)) {
                let elementInfo = this.getRenderedInline(inline, startIndex);
                inline = elementInfo.element;
                startIndex = elementInfo.index;
            }
            let endInlineObj = end.currentWidget.getInline(endOffset, endIndex);
            let endInline = endInlineObj.element;
            endIndex = endInlineObj.index;
            let text = '';
            // Retrieves the text from start inline.
            if (inline instanceof ImageElementBox && includeObject && startIndex === 0) {
                text = ElementBox.objectCharacter;
            }
            else if (inline instanceof TextElementBox) {
                // tslint:disable-next-line:max-line-length
                text = ((isNullOrUndefined(inline.text)) || (inline.text) === '') || inline.text.length < startIndex ? text : inline.text.substring(startIndex);
            }
            if (startPosition.paragraph === endPosition.paragraph) {
                if (inline instanceof ElementBox) {
                    if (inline === endInline && inline instanceof TextElementBox) {
                        text = text.length < endIndex - startIndex ? text : text.substring(0, endIndex - startIndex);
                    }
                    else if (inline.nextNode instanceof ElementBox) {
                        // tslint:disable-next-line:max-line-length
                        text = text + this.getTextInline(inline.nextNode, endPosition.paragraph, endInline, endIndex, includeObject);
                    }
                }
            }
            else {
                if (inline instanceof ElementBox && inline.nextNode instanceof ElementBox) {
                    text = text + this.getTextInline(inline.nextNode, endPosition.paragraph, undefined, 0, includeObject);
                }
                else {
                    // tslint:disable-next-line:max-line-length
                    let nextParagraphWidget = this.viewer.selection.getNextParagraphBlock(startPosition.paragraph);
                    text = text + '\r';
                    while (!isNullOrUndefined(nextParagraphWidget) && nextParagraphWidget.isEmpty()) {
                        text = text + '\r';
                        if (nextParagraphWidget === endPosition.paragraph) {
                            return text;
                        }
                        nextParagraphWidget = this.viewer.selection.getNextParagraphBlock(nextParagraphWidget);
                    }
                    if (!isNullOrUndefined(nextParagraphWidget) && !nextParagraphWidget.isEmpty()) {
                        // tslint:disable-next-line:max-line-length
                        text = text + this.getTextInline(nextParagraphWidget.childWidgets[0].children[0], endPosition.paragraph, endInline, endIndex, includeObject);
                    }
                }
            }
            // If the selection includes end paragraph mark.
            if (endOffset === (endPosition.currentWidget).getEndOffset() + 1) {
                text = text + '\r';
            }
            return text;
        }
        return undefined;
    }
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getTextInline(inlineElement, endParagraphWidget, endInline, endIndex, includeObject) {
        let text = '';
        do {
            if (inlineElement === endInline) {
                if (inlineElement instanceof TextElementBox) {
                    let span = inlineElement;
                    if (!(isNullOrUndefined(span.text) || span.text === '')) {
                        if (span.text.length < endIndex) {
                            text = text + span.text;
                        }
                        else {
                            text = text + span.text.substring(0, endIndex);
                        }
                    }
                    // tslint:disable-next-line:max-line-length
                }
                else if (inlineElement instanceof ImageElementBox && includeObject && endIndex === inlineElement.length) {
                    text = text + ElementBox.objectCharacter;
                }
                return text;
            }
            if (inlineElement instanceof TextElementBox) {
                text = text + inlineElement.text;
            }
            else if (inlineElement instanceof ImageElementBox && includeObject) {
                text = text + ElementBox.objectCharacter;
            }
            else if (inlineElement instanceof FieldElementBox && !isNullOrUndefined(inlineElement.fieldEnd)) {
                if (!isNullOrUndefined(inlineElement.fieldSeparator)) {
                    inlineElement = inlineElement.fieldSeparator;
                }
                else {
                    inlineElement = inlineElement.fieldEnd;
                }
            }
            if (isNullOrUndefined(inlineElement.nextNode)) {
                break;
            }
            inlineElement = inlineElement.nextNode;
        } while (!isNullOrUndefined(inlineElement));
        if (endParagraphWidget === inlineElement.line.paragraph) {
            return text;
        }
        // tslint:disable-next-line:max-line-length
        let nextParagraphWidget = this.viewer.selection.getNextParagraphBlock(inlineElement.line.paragraph);
        while (!isNullOrUndefined(nextParagraphWidget) && nextParagraphWidget.isEmpty()) {
            text = text + '\r';
            if (nextParagraphWidget === endParagraphWidget) {
                return text;
            }
            nextParagraphWidget = this.viewer.selection.getNextParagraphBlock(nextParagraphWidget);
        }
        if (!isNullOrUndefined(nextParagraphWidget) && !nextParagraphWidget.isEmpty()) {
            let lineWidget = nextParagraphWidget.childWidgets[0];
            // tslint:disable-next-line:max-line-length
            text = text + '\r' + this.getTextInline(lineWidget.children[0], endParagraphWidget, endInline, endIndex, includeObject);
        }
        return text;
    }
    /**
     * Returns field code.
     * @private
     * @param fieldBegin
     */
    getFieldCode(fieldBegin) {
        let fieldCode = '';
        if (!(fieldBegin.fieldEnd instanceof FieldElementBox)) {
            return fieldCode;
        }
        let paragraph = fieldBegin.paragraph;
        let endParagraph = fieldBegin.fieldEnd.paragraph;
        if (fieldBegin.fieldSeparator instanceof FieldElementBox) {
            endParagraph = fieldBegin.fieldSeparator.paragraph;
        }
        let startLineIndex = fieldBegin.line.indexInOwner;
        let startIndex = fieldBegin.indexInOwner;
        do {
            fieldCode += this.getFieldCodeInternal(paragraph, startLineIndex, startIndex);
            if (paragraph === endParagraph) {
                break;
            }
            paragraph = this.getNextParagraphBlock(paragraph);
            startLineIndex = 0;
            startIndex = 0;
        } while (paragraph instanceof ParagraphWidget);
        return fieldCode.trim();
    }
    getFieldCodeInternal(paragraph, startLineIndex, inlineIndex) {
        let fieldCode = '';
        for (let i = startLineIndex; i < paragraph.childWidgets.length; i++) {
            let line = paragraph.childWidgets[i];
            for (let i = inlineIndex; i < line.children.length; i++) {
                let element = line.children[i];
                if (element instanceof TextElementBox) {
                    fieldCode += element.text;
                }
                if (element instanceof FieldElementBox
                    && (element.fieldType === 2 || element.fieldType === 1)) {
                    return fieldCode;
                }
            }
            inlineIndex = 0;
        }
        return fieldCode;
    }
    /**
     * @private
     */
    getTocFieldInternal() {
        let paragraph = this.start.paragraph;
        if (!this.isEmpty && !this.isForward) {
            paragraph = this.end.paragraph;
        }
        while (paragraph instanceof ParagraphWidget && paragraph.childWidgets.length > 0) {
            let line = paragraph.firstChild;
            if (line.children.length > 0) {
                let element = line.children[0];
                let nextElement = element.nextNode;
                if (element instanceof FieldElementBox && element.fieldType === 0 && nextElement instanceof TextElementBox
                    && nextElement.text.trim().toLowerCase().indexOf('toc') === 0) {
                    return element;
                }
            }
            paragraph = paragraph.previousRenderedWidget;
        }
        return undefined;
    }
    /**
     * Get next paragraph in bodyWidget
     * @private
     */
    getNextParagraph(section) {
        if (section.nextRenderedWidget instanceof BodyWidget) {
            let block = section.nextRenderedWidget.childWidgets[0];
            return this.getFirstParagraphBlock(block);
        }
        return undefined;
    }
    /**
     * @private
     */
    getPreviousParagraph(section) {
        if (section.previousRenderedWidget instanceof BodyWidget) {
            let bodyWidget = section.previousRenderedWidget;
            let block = bodyWidget.childWidgets[bodyWidget.childWidgets.length - 1];
            return this.getLastParagraphBlock(block);
        }
        return undefined;
    }
    /**
     * Get first paragraph in cell
     * @private
     */
    getFirstParagraphInCell(cell) {
        let firstBlock = cell.childWidgets[0];
        if (firstBlock instanceof ParagraphWidget) {
            return firstBlock;
        }
        else {
            return this.getFirstParagraphInFirstCell(firstBlock);
        }
    }
    /**
     * Get first paragraph in first cell
     * @private
     */
    getFirstParagraphInFirstCell(table) {
        if (table.childWidgets.length > 0) {
            let firstRow = table.childWidgets[0];
            let cell = firstRow.childWidgets[0];
            let block = cell.childWidgets[0];
            return this.getFirstParagraphBlock(block);
        }
        return undefined;
    }
    /**
     * Get last paragraph in last cell
     * @private
     */
    getLastParagraphInLastCell(table) {
        if (table.childWidgets.length > 0) {
            let lastrow = table.lastChild;
            let lastcell = lastrow.lastChild;
            let lastBlock = lastcell.lastChild;
            return this.getLastParagraphBlock(lastBlock);
        }
        return undefined;
    }
    /**
     * Get last paragraph in first row
     * @private
     */
    getLastParagraphInFirstRow(table) {
        if (table.childWidgets.length > 0) {
            let row = table.firstChild;
            let lastcell = row.lastChild;
            let lastBlock = lastcell.lastChild;
            return this.getLastParagraphBlock(lastBlock);
        }
        return undefined;
    }
    /**
     * Get Next start inline
     * @private
     */
    getNextStartInline(line, offset) {
        let indexInInline = 0;
        let inlineObj = line.getInline(offset, indexInInline);
        let inline = inlineObj.element;
        indexInInline = inlineObj.index;
        if (!isNullOrUndefined(inline) && indexInInline === inline.length && inline.nextNode instanceof FieldElementBox) {
            let nextValidInline = this.getNextValidElement(inline.nextNode);
            if (nextValidInline instanceof FieldElementBox && nextValidInline.fieldType === 0) {
                inline = nextValidInline;
            }
        }
        return inline;
    }
    /**
     * Get previous text inline
     * @private
     */
    getPreviousTextInline(inline) {
        if (inline.previousNode instanceof TextElementBox) {
            return inline.previousNode;
        }
        if (inline.previousNode instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(inline.previousNode)) {
            if (inline.previousNode.fieldType === 0 || inline.previousNode.fieldType === 1) {
                return inline.previousNode;
            }
            return inline.previousNode.fieldBegin;
        }
        if (!isNullOrUndefined(inline.previousNode)) {
            return this.getPreviousTextInline((inline.previousNode));
        }
        return undefined;
    }
    /**
     * Get next text inline
     * @private
     */
    getNextTextInline(inline) {
        if (inline.nextNode instanceof TextElementBox) {
            return inline.nextNode;
        }
        if (inline.nextNode instanceof FieldElementBox && (HelperMethods.isLinkedFieldCharacter(inline.nextNode))) {
            if (inline.nextNode.fieldType === 1 || inline.nextNode.fieldType === 0) {
                return inline.nextNode;
            }
            return inline.nextNode.fieldEnd;
        }
        if (!isNullOrUndefined(inline.nextNode)) {
            return this.getNextTextInline((inline.nextNode));
        }
        return undefined;
    }
    /**
     * Get container table
     * @private
     */
    getContainerTable(block) {
        if (block.isInsideTable) {
            if (block.associatedCell.ownerTable.isInsideTable) {
                block = this.getContainerTable(block.associatedCell.ownerTable);
            }
            else {
                block = block.associatedCell.ownerTable;
            }
        }
        if (block instanceof TableWidget) {
            return block;
        }
        return undefined;
    }
    /**
     * @private
     */
    isExistBefore(start, block) {
        if (start.isInsideTable) {
            let cell1 = start.associatedCell;
            if (block.isInsideTable) {
                let cell2 = block.associatedCell;
                if (cell1 === cell2) {
                    return cell1.childWidgets.indexOf(start) < cell1.childWidgets.indexOf(block);
                }
                if (cell1.ownerRow === cell2.ownerRow) {
                    return cell1.cellIndex < cell2.cellIndex;
                }
                if (cell1.ownerTable === cell2.ownerTable) {
                    return cell1.ownerRow.rowIndex < cell2.ownerRow.rowIndex;
                }
                //Checks if current block exists before the block.
                let containerCell = this.getContainerCellOf(cell1, cell2);
                if (containerCell.ownerTable.contains(cell2)) {
                    cell1 = this.getSelectedCell(cell1, containerCell);
                    cell2 = this.getSelectedCell(cell2, containerCell);
                    if (cell1 === containerCell) {
                        return this.isExistBefore(start, cell2.ownerTable);
                    }
                    if (cell2 === containerCell) {
                        return this.isExistBefore(cell1.ownerTable, block);
                    }
                    if (containerCell.ownerRow === cell2.ownerRow) {
                        return containerCell.cellIndex < cell2.cellIndex;
                    }
                    if (containerCell.ownerTable === cell2.ownerTable) {
                        return containerCell.ownerRow.rowIndex < cell2.ownerRow.rowIndex;
                    }
                    return this.isExistBefore(cell1.ownerTable, cell2.ownerTable);
                }
                return this.isExistBefore(containerCell.ownerTable, this.getContainerTable(cell2.ownerTable));
            }
            else {
                let ownerTable = this.getContainerTable(start);
                return this.isExistBefore(ownerTable, block);
            }
        }
        else if (block.isInsideTable) {
            let ownerTable = this.getContainerTable(block);
            return this.isExistBefore(start, ownerTable);
        }
        else {
            {
                if (start.containerWidget === block.containerWidget) {
                    return start.index <
                        block.index;
                }
                if (start.containerWidget instanceof BodyWidget && block.containerWidget instanceof BodyWidget) {
                    //Splitted blocks                     
                    let startPage = this.viewer.pages.indexOf(start.containerWidget.page);
                    let endPage = this.viewer.pages.indexOf(block.containerWidget.page);
                    return startPage < endPage;
                }
            }
        }
        return false;
    }
    /**
     * @private
     */
    isExistAfter(start, block) {
        if (start.isInsideTable) {
            let cell1 = start.associatedCell;
            //Current paragraph in cell, paragraph in cell
            if (block.isInsideTable) {
                let cell2 = block.associatedCell;
                if (cell1 === cell2) {
                    return cell1.childWidgets.indexOf(start) > cell1.childWidgets.indexOf(block);
                }
                if (cell1.ownerRow === cell2.ownerRow) {
                    return cell1.cellIndex > cell2.cellIndex;
                }
                if (cell1.ownerTable === cell2.ownerTable) {
                    return cell1.ownerRow.rowIndex > cell2.ownerRow.rowIndex;
                }
                //Checks if this block exists before block.
                let containerCell = this.getContainerCellOf(cell1, cell2);
                if (containerCell.ownerTable.contains(cell2)) {
                    cell1 = this.getSelectedCell(cell1, containerCell);
                    cell2 = this.getSelectedCell(cell2, containerCell);
                    if (cell1 === containerCell) {
                        return this.isExistAfter(start, cell2.ownerTable);
                    }
                    if (cell2 === containerCell) {
                        return this.isExistAfter(cell1.ownerTable, block);
                    }
                    if (containerCell.ownerRow === cell2.ownerRow) {
                        return containerCell.cellIndex > cell2.cellIndex;
                    }
                    if (containerCell.ownerTable === cell2.ownerTable) {
                        return containerCell.ownerRow.rowIndex > cell2.ownerRow.rowIndex;
                    }
                    return this.isExistAfter(cell1.ownerTable, cell2.ownerTable);
                }
                return this.isExistAfter(containerCell.ownerTable, this.getContainerTable(cell2.ownerTable));
            }
            else {
                let ownerTable = this.getContainerTable(start);
                return this.isExistAfter(ownerTable, block);
            }
        }
        else if (block.isInsideTable) {
            let ownerTable = this.getContainerTable(block);
            return this.isExistAfter(start, ownerTable);
        }
        else {
            if (start.containerWidget === block.containerWidget) {
                return start.index >
                    block.index;
            }
            if (start.containerWidget instanceof BodyWidget && block.containerWidget instanceof BodyWidget) {
                //Splitted blocks                     
                let startPage = this.viewer.pages.indexOf(start.containerWidget.page);
                let endPage = this.viewer.pages.indexOf(block.containerWidget.page);
                return startPage > endPage;
            }
            //     if (start.owner instanceof WHeaderFooter) {
            //         return (start.owner as WHeaderFooter).childWidgets.indexOf(start) 
            // > (block.owner as WHeaderFooter).childWidgets.indexOf(block);
            //     } else if (start.section === block.section && start.section instanceof WSection) {
            //         return (start.section as WSection).childWidgets.indexOf(start)
            //  > (start.section as WSection).childWidgets.indexOf(block);
            //     } else if (start.wordDocument instanceof WordDocument) {
            // tslint:disable-next-line:max-line-length
            //         return (start.wordDocument as WordDocument).sections.indexOf(start.section as WSection) > (start.wordDocument as WordDocument).sections.indexOf(block.section as WSection);
        }
        return false;
    }
    /**
     * Return true if current inline in exist before inline
     * @private
     */
    isExistBeforeInline(currentInline, inline) {
        if (currentInline.line === inline.line) {
            return currentInline.line.children.indexOf(currentInline) <
                inline.line.children.indexOf(inline);
        }
        if (currentInline.line.paragraph === inline.line.paragraph) {
            return currentInline.line.paragraph.childWidgets.indexOf(currentInline.line)
                < inline.line.paragraph.childWidgets.indexOf(inline.line);
        }
        let startParagraph = currentInline.line.paragraph;
        let endParagraph = inline.line.paragraph;
        if (startParagraph.containerWidget === endParagraph.containerWidget) {
            if (startParagraph.isInsideTable) {
                return startParagraph.associatedCell.childWidgets.indexOf(startParagraph) <
                    endParagraph.associatedCell.childWidgets.indexOf(endParagraph);
            }
            else if (startParagraph.containerWidget instanceof HeaderFooterWidget) {
                // return ((currentInline.owner as WParagraph).owner as WHeaderFooter).blocks.indexOf(currentInline.owner as WParagraph) <
                //     ((inline.owner as WParagraph).owner as WHeaderFooter).blocks.indexOf(inline.owner as WParagraph);
            }
            else {
                return startParagraph.containerWidget.childWidgets.indexOf(startParagraph) <
                    endParagraph.containerWidget.childWidgets.indexOf(endParagraph);
            }
        }
        return this.isExistBefore(startParagraph, endParagraph);
    }
    /**
     * Return true id current inline is exist after inline
     * @private
     */
    isExistAfterInline(currentInline, inline) {
        if (currentInline.line === inline.line) {
            return currentInline.line.children.indexOf(currentInline) >
                inline.line.children.indexOf(inline);
        }
        if (currentInline.line.paragraph === inline.line.paragraph) {
            return currentInline.line.paragraph.childWidgets.indexOf(currentInline.line)
                > inline.line.paragraph.childWidgets.indexOf(inline.line);
        }
        let startParagraph = currentInline.line.paragraph;
        let endParagraph = inline.line.paragraph;
        if (startParagraph.containerWidget === endParagraph.containerWidget) {
            if (startParagraph.isInsideTable) {
                return startParagraph.associatedCell.childWidgets.indexOf(startParagraph) >
                    endParagraph.associatedCell.childWidgets.indexOf(endParagraph);
            }
            else if (startParagraph.containerWidget instanceof HeaderFooterWidget) {
                // return ((currentInline.owner as WParagraph).owner as WHeaderFooter).blocks.indexOf(currentInline.owner as WParagraph) <
                //     ((inline.owner as WParagraph).owner as WHeaderFooter).blocks.indexOf(inline.owner as WParagraph);
            }
            else {
                return startParagraph.containerWidget.childWidgets.indexOf(startParagraph) >
                    endParagraph.containerWidget.childWidgets.indexOf(endParagraph);
            }
        }
        return this.isExistAfter(startParagraph, endParagraph);
    }
    /**
     * Get next rendered block
     * @private
     */
    getNextRenderedBlock(block) {
        if (isNullOrUndefined(block.nextWidget)) {
            return block.nextRenderedWidget;
        }
        return block.nextWidget;
    }
    /**
     * Get next rendered block
     * @private
     */
    getPreviousRenderedBlock(block) {
        if (isNullOrUndefined(block.previousWidget)) {
            return block.previousRenderedWidget;
        }
        return block.previousWidget;
    }
    /**
     * Get Next paragraph in block
     * @private
     */
    getNextParagraphBlock(block) {
        if (block.nextRenderedWidget instanceof ParagraphWidget) {
            return block.nextRenderedWidget;
        }
        else if (block.nextRenderedWidget instanceof TableWidget) {
            return this.getFirstParagraphInFirstCell(block.nextRenderedWidget);
        }
        if (block.containerWidget instanceof TableCellWidget) {
            return this.getNextParagraphCell(block.containerWidget);
        }
        else if (block.containerWidget instanceof BodyWidget) {
            let bodyWidget = block.containerWidget;
            return this.getNextParagraph(block.containerWidget);
        }
        else if (block.containerWidget instanceof HeaderFooterWidget && this.isMoveDownOrMoveUp) {
            return this.getFirstBlockInNextHeaderFooter(block);
        }
        return undefined;
    }
    /**
     * @private
     */
    getFirstBlockInNextHeaderFooter(block) {
        let headerFooter = block.containerWidget;
        let nextBlock;
        if (headerFooter.headerFooterType.indexOf('Header') !== -1) {
            nextBlock = headerFooter.page.footerWidget.firstChild;
        }
        else if (headerFooter.page.nextPage) {
            nextBlock = headerFooter.page.nextPage.headerWidget.firstChild;
        }
        else {
            return undefined;
        }
        if (nextBlock instanceof ParagraphWidget) {
            return nextBlock;
        }
        else {
            return this.getFirstBlockInFirstCell(nextBlock);
        }
    }
    /**
     * @private
     */
    getLastBlockInPreviousHeaderFooter(block) {
        let headerFooter = block.containerWidget;
        let previousBlock;
        if (headerFooter.headerFooterType.indexOf('Footer') !== -1) {
            previousBlock = headerFooter.page.headerWidget.lastChild;
        }
        else if (headerFooter.page.previousPage) {
            previousBlock = headerFooter.page.previousPage.footerWidget.lastChild;
        }
        else {
            return undefined;
        }
        if (previousBlock instanceof ParagraphWidget) {
            return previousBlock;
        }
        else {
            return this.getFirstBlockInFirstCell(previousBlock);
        }
    }
    /**
     * Get previous paragraph in block
     * @private
     */
    getPreviousParagraphBlock(block) {
        if (block.previousRenderedWidget instanceof ParagraphWidget) {
            return block.previousRenderedWidget;
        }
        else if (block.previousRenderedWidget instanceof TableWidget) {
            return this.getLastParagraphInLastCell((block.previousRenderedWidget));
        }
        if (block.containerWidget instanceof TableCellWidget) {
            return this.getPreviousParagraphCell((block.containerWidget));
        }
        else if (block.containerWidget instanceof BodyWidget) {
            return this.getPreviousParagraph(block.containerWidget);
        }
        else if (block.containerWidget instanceof HeaderFooterWidget && this.isMoveDownOrMoveUp) {
            return this.getLastBlockInPreviousHeaderFooter(block);
        }
        return undefined;
    }
    /**
     * Get first paragraph in block
     * @private
     */
    getFirstParagraphBlock(block) {
        if (block instanceof ParagraphWidget) {
            return block;
        }
        else if (block instanceof TableWidget) {
            return this.getFirstParagraphInFirstCell(block);
        }
        return undefined;
    }
    /**
     * Get last paragraph in block
     * @private
     */
    getLastParagraphBlock(block) {
        if (block instanceof ParagraphWidget) {
            return block;
        }
        else if (block instanceof TableWidget) {
            return this.getLastParagraphInLastCell(block);
        }
        return undefined;
    }
    /**
     * Return true if paragraph has valid inline
     * @private
     */
    hasValidInline(paragraph, start, end) {
        let index = paragraph.childWidgets.indexOf(start.line);
        for (let i = index; i < paragraph.childWidgets.length; i++) {
            for (let j = 0; j < paragraph.childWidgets[i].children.length; j++) {
                let inline = paragraph.childWidgets[i].children[j];
                if (inline.length === 0) {
                    continue;
                }
                if (inline === end) {
                    return false;
                }
                if (inline instanceof TextElementBox || inline instanceof ImageElementBox
                    || (inline instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(inline))) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Get paragraph length
     * @private
     */
    getParagraphLength(paragraph, endLine, elementInfo) {
        let length = 0;
        for (let j = 0; j < paragraph.childWidgets.length; j++) {
            let line = paragraph.childWidgets[j];
            if (endLine instanceof LineWidget && endLine === line) {
                if (elementInfo) {
                    length += this.getLineLength(line, elementInfo);
                }
                break;
            }
            length += this.getLineLength(line);
        }
        return length;
    }
    /**
     * Get Line length
     * @private
     */
    getLineLength(line, elementInfo) {
        let length = 0;
        for (let i = 0; i < line.children.length; i++) {
            let element = line.children[i];
            if (element instanceof ListTextElementBox) {
                continue;
            }
            if (elementInfo && elementInfo.element instanceof ElementBox && elementInfo.element === element) {
                length += elementInfo.index;
                break;
            }
            length += element.length;
        }
        return length;
    }
    /**
     * Get line information
     * @private
     */
    getLineInfo(paragraph, offset) {
        let line = undefined;
        let length = 0;
        let childLength = paragraph.childWidgets.length;
        for (let j = 0; j < childLength; j++) {
            line = paragraph.childWidgets[j];
            length = this.getLineLength(line);
            if (offset <= length || j === childLength - 1) {
                break;
            }
            else {
                offset = offset - length;
            }
        }
        return { 'line': line, 'offset': offset };
    }
    /**
     * @private
     */
    getElementInfo(line, offset) {
        let element = undefined;
        for (let i = 0; i < line.children.length; i++) {
            element = line.children[i];
            if (element instanceof ListTextElementBox) {
                continue;
            }
            if (offset > element.length
                && (!(offset === element.length + 1 && isNullOrUndefined(element.nextNode)))) {
                offset = offset - element.length;
            }
            else {
                break;
            }
        }
        return { 'element': element, 'index': offset };
    }
    /**
     * Get paragraph start offset
     * @private
     */
    getStartOffset(paragraph) {
        let startOffset = 0;
        if (paragraph.childWidgets.length > 0) {
            let childWidgets = paragraph.childWidgets[0];
            return this.getStartLineOffset(childWidgets);
        }
        return startOffset;
    }
    /**
     * @private
     */
    getStartLineOffset(line) {
        let startOffset = 0;
        for (let i = 0; i < line.children.length; i++) {
            let inline = line.children[i];
            if (inline.length === 0) {
                continue;
            }
            if (inline instanceof TextElementBox || inline instanceof ImageElementBox || inline instanceof BookmarkElementBox
                || (inline instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(inline))) {
                return startOffset;
            }
            if (inline instanceof ListTextElementBox) {
                continue;
            }
            startOffset += inline.length;
        }
        return startOffset;
    }
    /**
     * Get previous paragraph from selection
     * @private
     */
    getPreviousSelectionCell(cell) {
        if (!isNullOrUndefined(cell.previousRenderedWidget)) {
            if (!this.isForward) {
                let block = cell.previousRenderedWidget.childWidgets[0];
                if (block instanceof ParagraphWidget) {
                    return block;
                }
                else {
                    return this.getFirstParagraphInLastRow(block);
                }
            }
            else {
                let widgets = cell.previousRenderedWidget.childWidgets;
                let block = widgets[widgets.length - 1];
                if (block instanceof ParagraphWidget) {
                    return block;
                }
                else {
                    // tslint:disable-next-line:max-line-length
                    return this.getPreviousParagraphSelection(block.childWidgets[block.childWidgets.length - 1]);
                }
            }
        }
        return this.getPreviousSelectionRow(cell.ownerRow);
    }
    /**
     * Get previous paragraph selection in selection
     * @private
     */
    getPreviousSelectionRow(row) {
        if (!isNullOrUndefined(row.previousRenderedWidget)) {
            if (!this.isForward) {
                let cell = row.previousRenderedWidget.childWidgets[0];
                let block = cell.childWidgets[0];
                return this.getFirstParagraphBlock(block);
            }
            else {
                return this.getPreviousParagraphSelection(row.previousRenderedWidget);
            }
        }
        return this.getPreviousSelectionBlock(row.ownerTable);
    }
    /**
     * @private
     */
    getNextSelectionBlock(block) {
        if (block.nextRenderedWidget instanceof ParagraphWidget) {
            return block.nextRenderedWidget;
        }
        else if (block.nextRenderedWidget instanceof TableWidget) {
            if (this.isEmpty || this.isForward) {
                return this.getLastParagraphInFirstRow(block.nextRenderedWidget);
            }
            else {
                return this.getNextParagraphSelection(block.nextRenderedWidget.childWidgets[0]);
            }
        }
        if (block.containerWidget instanceof TableCellWidget) {
            return this.getNextSelectionCell(block.containerWidget);
        }
        else if (block.containerWidget instanceof BodyWidget) {
            return this.getNextSelection(block.containerWidget);
        }
        return undefined;
    }
    /**
     * Get next paragraph from selected cell
     * @private
     */
    getNextSelectionCell(cell) {
        if (!isNullOrUndefined(cell.nextRenderedWidget)) {
            if (this.isEmpty || this.isForward) {
                // tslint:disable-next-line:max-line-length
                let block = cell.nextRenderedWidget.childWidgets[cell.nextRenderedWidget.childWidgets.length - 1];
                return this.getLastParagraphBlock(block);
            }
            else {
                //Return first paragraph in cell. 
                let block = cell.nextRenderedWidget.childWidgets[0];
                if (block instanceof ParagraphWidget) {
                    return block;
                }
                else {
                    return this.getNextParagraphSelection(block.childWidgets[0]);
                }
            }
        }
        return this.getNextSelectionRow(cell.ownerRow);
    }
    /**
     * Get next paragraph in selection
     * @private
     */
    getNextSelectionRow(row) {
        if (!isNullOrUndefined(row.nextRenderedWidget)) {
            let isForwardSelection = this.isEmpty || this.isForward;
            if (isForwardSelection) {
                // tslint:disable-next-line:max-line-length
                let cell = row.nextRenderedWidget.childWidgets[row.nextRenderedWidget.childWidgets.length - 1];
                let block = cell.childWidgets[cell.childWidgets.length - 1];
                return this.getLastParagraphBlock(block);
            }
            else {
                return this.getNextParagraphSelection(row.nextRenderedWidget);
            }
        }
        return this.getNextSelectionBlock(row.ownerTable);
    }
    /**
     * Get next block with selection
     * @private
     */
    getNextSelection(section) {
        if (section.nextRenderedWidget instanceof BodyWidget) {
            let block = section.nextRenderedWidget.childWidgets[0];
            if (block instanceof ParagraphWidget) {
                return block;
            }
            else {
                if (this.isEmpty || this.isForward) {
                    return this.getLastParagraphInFirstRow(block);
                }
                else {
                    return this.getNextParagraphSelection(block.childWidgets[0]);
                }
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    getNextParagraphSelection(row) {
        //Iterate the exact cell based on UP/Down selection length.
        let cell = row.childWidgets[0];
        if (this.start.paragraph.isInsideTable
            && row.ownerTable.contains(this.start.paragraph.associatedCell)) {
            let startCell = this.getCellInTable(row.ownerTable, this.start.paragraph.associatedCell);
            cell = this.getFirstCellInRegion(row, startCell, this.upDownSelectionLength, false);
        }
        let block = cell.childWidgets[0];
        return this.getFirstParagraphBlock(block);
    }
    /**
     * @private
     */
    getPreviousSelectionBlock(block) {
        if (block.previousRenderedWidget instanceof ParagraphWidget) {
            return block.previousRenderedWidget;
        }
        else if (block.previousRenderedWidget instanceof TableWidget) {
            if (!this.isForward) {
                return this.getFirstParagraphInLastRow(block.previousRenderedWidget);
            }
            else {
                // tslint:disable-next-line:max-line-length
                return this.getPreviousParagraphSelection(block.previousRenderedWidget.childWidgets[block.previousRenderedWidget.childWidgets.length - 1]);
            }
        }
        if (block.containerWidget instanceof TableCellWidget) {
            return this.getPreviousSelectionCell(block.containerWidget);
        }
        else if (block.containerWidget instanceof BodyWidget) {
            return this.getPreviousSelection(block.containerWidget);
        }
        return undefined;
    }
    /**
     * Get previous paragraph in selection
     * @private
     */
    getPreviousSelection(section) {
        if (section.previousRenderedWidget instanceof BodyWidget) {
            let prevBodyWidget = section.previousRenderedWidget;
            let block = prevBodyWidget.childWidgets[prevBodyWidget.childWidgets.length - 1];
            if (block instanceof ParagraphWidget) {
                return block;
            }
            else {
                if (!this.isForward) {
                    return this.getFirstParagraphInLastRow(block);
                }
                else {
                    let tableWidget = block;
                    // tslint:disable-next-line:max-line-length
                    return this.getPreviousParagraphSelection(tableWidget.childWidgets[tableWidget.childWidgets.length - 1]);
                }
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    getPreviousParagraphSelection(row) {
        //Iterate the exact cell based on UP/Down selection length.
        let cell = row.childWidgets[row.childWidgets.length - 1];
        if (this.start.paragraph.isInsideTable
            && row.ownerTable.contains(this.start.paragraph.associatedCell)) {
            let startCell = this.getCellInTable(row.ownerTable, this.start.paragraph.associatedCell);
            cell = this.getLastCellInRegion(row, startCell, this.upDownSelectionLength, true);
        }
        let block = cell.childWidgets[cell.childWidgets.length - 1];
        return this.getLastParagraphBlock(block);
    }
    /**
     * Get last cell in the selected region
     * @private
     */
    getLastCellInRegion(row, startCell, selLength, isMovePrev) {
        let start = this.getCellLeft(row, startCell);
        let end = start + startCell.cellFormat.cellWidth;
        let flag = true;
        if (start <= selLength && selLength < end) {
            for (let i = row.childWidgets.length - 1; i >= 0; i--) {
                let left = this.getCellLeft(row, row.childWidgets[i]);
                if (HelperMethods.round(start, 2) <= HelperMethods.round(left, 2) &&
                    HelperMethods.round(left, 2) < HelperMethods.round(end, 2)) {
                    flag = false;
                    return row.childWidgets[i];
                }
            }
        }
        else {
            for (let i = row.childWidgets.length - 1; i >= 0; i--) {
                let left = this.getCellLeft(row, row.childWidgets[i]);
                if (left <= selLength && left + row.childWidgets[i].cellFormat.cellWidth > selLength) {
                    flag = false;
                    return row.childWidgets[i];
                }
            }
        }
        if (flag) {
            if (!isNullOrUndefined(row.previousRenderedWidget) && isMovePrev) {
                return this.getLastCellInRegion(row.previousRenderedWidget, startCell, selLength, isMovePrev);
            }
            else if (!isNullOrUndefined(row.nextRenderedWidget) && !isMovePrev) {
                return this.getLastCellInRegion(row.nextRenderedWidget, startCell, selLength, isMovePrev);
            }
        }
        return row.childWidgets[row.childWidgets.length - 1];
    }
    /**
     * Get Container table
     * @private
     */
    getCellInTable(table, tableCell) {
        while (tableCell.ownerTable.isInsideTable) {
            if (table.equals(tableCell.ownerTable)) {
                return tableCell;
            }
            tableCell = tableCell.ownerTable.associatedCell;
        }
        return tableCell;
    }
    /**
     * Get first paragraph in last row
     * @private
     */
    getFirstParagraphInLastRow(table) {
        if (table.childWidgets.length > 0) {
            let lastRow = table.childWidgets[table.childWidgets.length - 1];
            let lastCell = lastRow.childWidgets[0];
            let lastBlock = lastCell.childWidgets[0];
            return this.getFirstParagraphBlock(lastBlock);
        }
        return undefined;
    }
    /**
     * Get previous valid offset
     * @private
     */
    getPreviousValidOffset(paragraph, offset) {
        if (offset === 0) {
            return 0;
        }
        let validOffset = 0;
        let count = 0;
        for (let i = 0; i < paragraph.childWidgets.length; i++) {
            let lineWidget = paragraph.childWidgets[i];
            for (let j = 0; j < lineWidget.children.length; j++) {
                let inline = lineWidget.children[j];
                if (inline.length === 0) {
                    continue;
                }
                if (offset <= count + inline.length) {
                    return offset - 1 === count ? validOffset : offset - 1;
                }
                if (inline instanceof TextElementBox || inline instanceof ImageElementBox
                    || (inline instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(inline))) {
                    validOffset = count + inline.length;
                }
                count += inline.length;
            }
        }
        return offset - 1 === count ? validOffset : offset - 1;
    }
    /**
     * Get next valid offset
     * @private
     */
    getNextValidOffset(line, offset) {
        let count = 0;
        for (let i = 0; i < line.children.length; i++) {
            let inline = line.children[i];
            if (inline.length === 0 || inline instanceof ListTextElementBox) {
                continue;
            }
            if (offset < count + inline.length) {
                if (inline instanceof TextElementBox || inline instanceof ImageElementBox
                    || (inline instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(inline))) {
                    return (offset > count ? offset : count) + 1;
                }
            }
            count += inline.length;
        }
        return offset;
    }
    /**
     * Get paragraph mark size info
     * @private
     */
    getParagraphMarkSize(paragraph, topMargin, bottomMargin) {
        let size = this.viewer.textHelper.getParagraphMarkSize(paragraph.characterFormat);
        let baselineOffset = size.BaselineOffset;
        let maxHeight = size.Height;
        let maxBaselineOffset = baselineOffset;
        if (paragraph instanceof ParagraphWidget) {
            // let paragraphWidget: ParagraphWidget[] = paragraph.renderedElement() as ParagraphWidget[];
            if (paragraph.childWidgets.length > 0) {
                let lineWidget = paragraph.childWidgets[0];
            }
            //Gets line spacing.
            let lineSpacing = this.viewer.layout.getLineSpacing(paragraph, maxHeight);
            let beforeSpacing = this.viewer.layout.getBeforeSpacing(paragraph);
            topMargin = maxBaselineOffset - baselineOffset;
            bottomMargin = maxHeight - maxBaselineOffset - (size.Height - baselineOffset);
            //Updates line spacing, paragraph after/ before spacing and aligns the text to base line offset.
            let lineSpacingType = paragraph.paragraphFormat.lineSpacingType;
            if (lineSpacingType === 'Multiple') {
                if (lineSpacing > maxHeight) {
                    bottomMargin += lineSpacing - maxHeight;
                }
                else {
                    topMargin += lineSpacing - maxHeight;
                }
            }
            else if (lineSpacingType === 'Exactly') {
                topMargin += lineSpacing - (topMargin + size.Height + bottomMargin);
            }
            else if (lineSpacing > topMargin + size.Height + bottomMargin) {
                topMargin += lineSpacing - (topMargin + size.Height + bottomMargin);
            }
            topMargin += beforeSpacing;
            bottomMargin += paragraph.paragraphFormat.afterSpacing;
        }
        return { 'width': size.Width, 'height': size.Height, 'topMargin': topMargin, 'bottomMargin': bottomMargin };
    }
    /**
     * @private
     */
    getPhysicalPositionInternal(line, offset, moveNextLine) {
        if (line.paragraph.isEmpty()) {
            let paragraphWidget = line.paragraph;
            let left = paragraphWidget.x;
            if (paragraphWidget.childWidgets.length > 0) {
                let lineWidget = paragraphWidget.childWidgets[0];
                left = this.getLeft(lineWidget);
            }
            let topMargin = 0;
            let bottomMargin = 0;
            let size = this.getParagraphMarkSize(line.paragraph, topMargin, bottomMargin);
            if (offset > 0) {
                left += size.width;
            }
            return new Point(left, paragraphWidget.y + topMargin);
        }
        else {
            let indexInInline = 0;
            let inlineObj = line.getInline(offset, indexInInline);
            let inline = inlineObj.element; //return indexInInline must
            indexInInline = inlineObj.index;
            // tslint:disable-next-line:max-line-length
            // if (inline.length === indexInInline && !isNullOrUndefined(inline.nextNode) && this.viewer.renderedElements.containsKey(inline) &&
            //     this.viewer.renderedElements.get(inline).length > 0 && this.viewer.renderedElements.containsKey(inline.nextNode as WInline)
            //     && this.viewer.renderedElements.get(inline.nextNode as WInline).length > 0 &&
            // tslint:disable-next-line:max-line-length
            //     (this.viewer.renderedElements.get(inline)[this.viewer.renderedElements.get(inline).length - 1] as ElementBox).line !== (this.viewer.renderedElements.get(inline.nextNode as WInline)[0] as ElementBox).line) {
            //     //Handled specifically to move the cursor at start of next line.
            //     inline = inline.nextNode as WInline;
            //     indexInInline = 0;
            // }
            return this.getPhysicalPositionInline(inline, indexInInline, moveNextLine);
        }
    }
    /**
     * Highlight selected content
     * @private
     */
    highlightSelectedContent(start, end) {
        if (start.paragraph.isInsideTable && (!end.paragraph.isInsideTable
            || (!start.paragraph.associatedCell.equals(end.paragraph.associatedCell))
            || this.isCellSelected(start.paragraph.associatedCell, start, end))) {
            this.highlightCell(start.paragraph.associatedCell, this, start, end);
        }
        else {
            let inline = undefined;
            let index = 0;
            if (!this.owner.isReadOnlyMode && start.paragraph === end.paragraph) {
                if (start.offset + 1 === end.offset) {
                    let inlineObj = end.currentWidget.getInline(end.offset, index);
                    inline = inlineObj.element; // return index value
                    index = inlineObj.index;
                    if (inline instanceof ImageElementBox) {
                        let startOffset = start.currentWidget.getOffset(inline, 0);
                        if (startOffset !== start.offset) {
                            inline = undefined;
                        }
                    }
                }
                else {
                    let indexInInline = 0;
                    let startInlineObj = start.currentWidget.getInline(start.offset, indexInInline);
                    let startInline = startInlineObj.element; //return indexInInline
                    indexInInline = startInlineObj.index;
                    if (indexInInline === startInline.length) {
                        startInline = this.getNextRenderedElementBox(startInline, indexInInline);
                    }
                    let endInlineObj = end.currentWidget.getInline(end.offset, indexInInline);
                    let endInline = endInlineObj.element; //return indexInInline
                    indexInInline = endInlineObj.index;
                    // tslint:disable-next-line:max-line-length
                    if (startInline instanceof FieldElementBox && endInline instanceof FieldElementBox && !isNullOrUndefined(startInline.fieldSeparator)) {
                        let fieldValue = startInline.fieldSeparator.nextNode;
                        if (fieldValue instanceof ImageElementBox && fieldValue.nextNode === endInline) {
                            inline = fieldValue;
                        }
                    }
                }
            }
            if (!this.owner.isReadOnlyMode && inline instanceof ImageElementBox && this.owner.isDocumentLoaded) {
                let elementBoxObj = this.getElementBoxInternal(inline, index);
                let elementBox = elementBoxObj.element; //return index 
                index = elementBoxObj.index;
                if (this.owner.enableImageResizerMode) {
                    this.owner.imageResizerModule.positionImageResizer(elementBox);
                    this.owner.imageResizerModule.showImageResizer();
                }
                if (this.viewer.isTouchInput) {
                    this.viewer.touchStart.style.display = 'none';
                    this.viewer.touchEnd.style.display = 'none';
                }
            }
            else {
                this.highlight(start.paragraph, start, end);
            }
        }
    }
    /**
     * @private
     */
    highlight(paragraph, start, end) {
        let selectionStartIndex = 0;
        let selectionEndIndex = 0;
        let startElement = undefined;
        let endElement = undefined;
        let startLineWidget = undefined;
        let endLineWidget = undefined;
        //return start Element and selection start index
        let startLineObj = this.getStartLineWidget(paragraph, start, startElement, selectionStartIndex);
        startElement = startLineObj.element;
        if (isNullOrUndefined(startElement)) {
            startLineWidget = paragraph.childWidgets[0];
        }
        else {
            startLineWidget = startElement.line;
        }
        selectionStartIndex = startLineObj.index;
        let endLineObj = this.getEndLineWidget(end, endElement, selectionEndIndex);
        endElement = endLineObj.element;
        if (endElement) {
            endLineWidget = endElement.line;
        }
        else {
            endLineWidget = end.paragraph.childWidgets[end.paragraph.childWidgets.length - 1];
        }
        selectionEndIndex = endLineObj.index;
        let top = 0;
        let left = 0;
        if (!isNullOrUndefined(startLineWidget)) {
            top = this.getTop(startLineWidget);
            left = this.getLeftInternal(startLineWidget, startElement, selectionStartIndex);
        }
        if (!isNullOrUndefined(startLineWidget) && startLineWidget === endLineWidget) {
            //Selection ends in current line.
            let right = this.getLeftInternal(endLineWidget, endElement, selectionEndIndex);
            this.createHighlightBorder(startLineWidget, right - left, left, top);
        }
        else {
            if (!isNullOrUndefined(startLineWidget)) {
                let x = startLineWidget.paragraph.x;
                this.createHighlightBorder(startLineWidget, this.getWidth(startLineWidget, true) - (left - x), left, top);
                let lineIndex = startLineWidget.paragraph.childWidgets.indexOf(startLineWidget);
                //Iterates to last item of paragraph or selection end.                                             
                this.highlightParagraph(paragraph, lineIndex + 1, endLineWidget, endElement, selectionEndIndex);
                if (paragraph.childWidgets.indexOf(end.currentWidget) !== -1) {
                    return;
                }
            }
            this.highlightNextBlock(paragraph, start, end);
        }
    }
    highlightNextBlock(paragraph, start, end) {
        let block = paragraph.nextRenderedWidget;
        if (!isNullOrUndefined(block)) {
            if (block instanceof ParagraphWidget) {
                this.highlight(block, start, end);
            }
            else {
                this.highlightTable(block, start, end);
            }
        }
    }
    /**
     * Get start line widget
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getStartLineWidget(paragraph, start, startElement, selectionStartIndex) {
        let offset = paragraph === start.paragraph ? start.offset : this.getStartOffset(paragraph);
        let startInlineObj = undefined;
        if (paragraph === start.paragraph) {
            startInlineObj = start.currentWidget.getInline(offset, selectionStartIndex);
        }
        else {
            startInlineObj = paragraph.firstChild.getInline(offset, selectionStartIndex);
        }
        startElement = startInlineObj.element; //return selectionStartIndex
        selectionStartIndex = startInlineObj.index;
        if (startElement instanceof FieldElementBox) {
            let inlineInfo = this.getRenderedInline(startElement, selectionStartIndex);
            startElement = inlineInfo.element;
            selectionStartIndex = inlineInfo.index;
        }
        if (offset === this.getParagraphLength(start.paragraph) + 1) {
            selectionStartIndex++;
        }
        return {
            'index': selectionStartIndex, 'element': startElement
        };
    }
    /**
     * Get end line widget
     * @private
     */
    getEndLineWidget(end, endElement, selectionEndIndex) {
        let endInlineObj = end.currentWidget.getInline(end.offset, selectionEndIndex);
        endElement = endInlineObj.element; //return selection end index
        selectionEndIndex = endInlineObj.index;
        if (endElement instanceof FieldElementBox) {
            let inlineInfo = this.getRenderedInline(endElement, selectionEndIndex);
            endElement = inlineInfo.element;
            selectionEndIndex = inlineInfo.index;
        }
        let lineIndex = end.paragraph.childWidgets.indexOf(end.currentWidget);
        if (lineIndex === end.paragraph.childWidgets.length - 1 && end.offset === this.getLineLength(end.currentWidget) + 1) {
            selectionEndIndex = endElement ? endElement.length + 1 : 1;
        }
        return { 'index': selectionEndIndex, 'element': endElement };
    }
    /**
     * Get line widget
     * @private
     */
    getLineWidgetInternal(line, offset, moveToNextLine) {
        let lineWidget = undefined;
        if (line.children.length === 0 && line instanceof LineWidget) {
            lineWidget = line;
        }
        else {
            let indexInInline = 0;
            let inlineInfo = line.getInline(offset, indexInInline);
            let inline = inlineInfo.element;
            indexInInline = inlineInfo.index;
            lineWidget = inline instanceof ElementBox ? inline.line
                : this.getLineWidgetInternalInline(inline, indexInInline, moveToNextLine);
        }
        return lineWidget;
    }
    /**
     * Get last line widget
     * @private
     */
    getLineWidgetParagraph(offset, line) {
        let linewidget = undefined;
        if (line.children.length === 0) {
            linewidget = line;
        }
        else {
            let indexInInline = 0;
            let inlineInfo = line.getInline(offset, indexInInline);
            let inline = inlineInfo.element;
            indexInInline = inlineInfo.index;
            linewidget = this.getLineWidget(inline, indexInInline);
        }
        return linewidget;
    }
    /**
     * Highlight selected cell
     * @private
     */
    /* tslint:disable */
    // tslint:disable-next-line:max-line-length    
    highlightCells(table, startCell, endCell) {
        let start = this.getCellLeft(startCell.ownerRow, startCell);
        let end = start + startCell.cellFormat.cellWidth;
        let endCellLeft = this.getCellLeft(endCell.ownerRow, endCell);
        let endCellRight = endCellLeft + endCell.cellFormat.cellWidth;
        if (start > endCellLeft) {
            start = endCellLeft;
        }
        if (end < endCellRight) {
            end = endCellRight;
        }
        if (start > this.upDownSelectionLength) {
            start = this.upDownSelectionLength;
        }
        if (end < this.upDownSelectionLength) {
            end = this.upDownSelectionLength;
        }
        let tableWidgetCollection = table.getSplitWidgets();
        let startTableIndex = tableWidgetCollection.indexOf(startCell.ownerRow.ownerTable);
        let endTableIndex = tableWidgetCollection.indexOf(endCell.ownerRow.ownerTable);
        if (startTableIndex === endTableIndex) {
            let count = table.childWidgets.indexOf(endCell.ownerRow);
            for (let i = table.childWidgets.indexOf(startCell.ownerRow); i <= count; i++) {
                this.highlightRow(table.childWidgets[i], start, end);
            }
        }
        else {
            let startRowIndex = 0;
            let endRowIndex = 0;
            for (let i = startTableIndex; i <= endTableIndex; i++) {
                table = tableWidgetCollection[i];
                if (i === startTableIndex) {
                    startRowIndex = table.childWidgets.indexOf(startCell.ownerRow);
                }
                else {
                    startRowIndex = 0;
                }
                if (i === endTableIndex) {
                    endRowIndex = table.childWidgets.indexOf(endCell.ownerRow);
                }
                else {
                    endRowIndex = table.childWidgets.length - 1;
                }
                for (let j = startRowIndex; j <= endRowIndex; j++) {
                    this.highlightRow(table.childWidgets[j], start, end);
                }
            }
        }
    }
    /* tslint:enable */
    /**
     * highlight selected table
     * @private
     */
    highlightTable(table, start, end) {
        this.highlightInternal(table.childWidgets[0], start, end);
        if (!end.paragraph.isInsideTable //Selection end is outside the table cell.
            || !table.contains(end.paragraph.associatedCell)) {
            this.highlightNextBlock(table, start, end);
        }
    }
    /**
     * Get cell left
     * @private
     */
    getCellLeft(row, cell) {
        let left = 0;
        left += cell.x - cell.margin.left;
        return left;
    }
    /**
     * Get next paragraph for row
     * @private
     */
    getNextParagraphRow(row) {
        if (!isNullOrUndefined(row.nextRenderedWidget)) {
            let cell = row.nextRenderedWidget.childWidgets[0];
            let block = cell.childWidgets[0];
            return this.getFirstParagraphBlock(block);
        }
        return this.getNextParagraphBlock(row.ownerTable);
    }
    /**
     * Get previous paragraph from row
     * @private
     */
    getPreviousParagraphRow(row) {
        if (!isNullOrUndefined(row.previousRenderedWidget)) {
            // tslint:disable-next-line:max-line-length
            let cell = row.previousRenderedWidget.lastChild;
            let block = cell.lastChild ? cell.lastChild : (cell.previousSplitWidget).lastChild;
            return this.getLastParagraphBlock(block);
        }
        return this.getPreviousParagraphBlock(row.ownerTable);
    }
    /**
     * Return true if row contain cell
     * @private
     */
    containsRow(row, tableCell) {
        if (row.childWidgets.indexOf(tableCell) !== -1) {
            return true;
        }
        while (tableCell.ownerTable.isInsideTable) {
            if (row.childWidgets.indexOf(tableCell) !== -1) {
                return true;
            }
            tableCell = tableCell.ownerTable.associatedCell;
        }
        return row.childWidgets.indexOf(tableCell) !== -1;
    }
    /**
     * Highlight selected row
     * @private
     */
    highlightRow(row, start, end) {
        for (let i = 0; i < row.childWidgets.length; i++) {
            let left = this.getCellLeft(row, row.childWidgets[i]);
            if (HelperMethods.round(start, 2) <= HelperMethods.round(left, 2) &&
                HelperMethods.round(left, 2) < HelperMethods.round(end, 2)) {
                this.highlightCellWidget(row.childWidgets[i]);
            }
        }
    }
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    highlightInternal(row, start, end) {
        for (let i = 0; i < row.childWidgets.length; i++) {
            this.highlightCellWidget(row.childWidgets[i]);
        }
        if (end.paragraph.isInsideTable && this.containsRow(row, end.paragraph.associatedCell)) {
            return;
        }
        else if (row.nextRenderedWidget instanceof TableRowWidget) {
            this.highlightInternal(row.nextRenderedWidget, start, end);
        }
    }
    /**
     * Get last paragraph in cell
     * @private
     */
    getLastParagraph(cell) {
        while (cell.nextSplitWidget) {
            if (cell.nextSplitWidget.childWidgets.length > 0) {
                cell = cell.nextSplitWidget;
            }
            else {
                break;
            }
        }
        let lastBlock;
        if (cell.childWidgets.length > 0) {
            lastBlock = cell.lastChild;
        }
        else {
            lastBlock = cell.previousSplitWidget.lastChild;
        }
        return this.getLastParagraphBlock(lastBlock);
    }
    /**
     * Return true is source cell contain cell
     * @private
     */
    containsCell(sourceCell, cell) {
        if (sourceCell.equals(cell)) {
            return true;
        }
        while (cell.ownerTable.isInsideTable) {
            if (sourceCell.equals(cell.ownerTable.associatedCell)) {
                return true;
            }
            cell = cell.ownerTable.associatedCell;
        }
        return false;
    }
    /**
     * Return true if cell is selected
     * @private
     */
    isCellSelected(cell, startPosition, endPosition) {
        let lastParagraph = this.getLastParagraph(cell);
        // tslint:disable-next-line:max-line-length
        let isAtCellEnd = lastParagraph === endPosition.paragraph && endPosition.offset === this.getParagraphLength(lastParagraph) + 1;
        return isAtCellEnd || (!this.containsCell(cell, startPosition.paragraph.associatedCell) ||
            !this.containsCell(cell, endPosition.paragraph.associatedCell));
    }
    /**
     * Return Container cell
     * @private
     */
    getContainerCellOf(cell, tableCell) {
        while (cell.ownerTable.isInsideTable) {
            if (cell.ownerTable.contains(tableCell)) {
                return cell;
            }
            cell = cell.ownerTable.associatedCell;
        }
        return cell;
    }
    /**
     * Get Selected cell
     * @private
     */
    getSelectedCell(cell, containerCell) {
        if (cell.ownerTable.equals(containerCell.ownerTable)) {
            return cell;
        }
        while (cell.ownerTable.isInsideTable) {
            if (cell.ownerTable.associatedCell.equals(containerCell)) {
                return cell;
            }
            cell = cell.ownerTable.associatedCell;
        }
        return cell;
    }
    /**
     * @private
     */
    getSelectedCells() {
        let cells = [];
        for (let i = 0; i < this.selectedWidgets.keys.length; i++) {
            let widget = this.selectedWidgets.keys[i];
            if (widget instanceof TableCellWidget) {
                cells.push(widget);
            }
        }
        return cells;
    }
    /**
     * Get Next paragraph from cell
     * @private
     */
    getNextParagraphCell(cell) {
        if (cell.nextRenderedWidget && cell.nextRenderedWidget instanceof TableCellWidget) {
            //Return first paragraph in cell.            
            cell = cell.nextRenderedWidget;
            let block = cell.firstChild;
            if (block) {
                return this.getFirstParagraphBlock(block);
            }
            else {
                return this.getNextParagraphCell(cell);
            }
        }
        return this.getNextParagraphRow(cell.containerWidget);
    }
    /**
     * Get previous paragraph from cell
     * @private
     */
    getPreviousParagraphCell(cell) {
        if (!isNullOrUndefined(cell.previousRenderedWidget) && cell.previousRenderedWidget instanceof TableCellWidget) {
            cell = cell.previousRenderedWidget;
            let block = cell.lastChild;
            return this.getLastParagraphBlock(block);
        }
        return this.getPreviousParagraphRow(cell.ownerRow);
    }
    /**
     * Get cell's container cell
     * @private
     */
    getContainerCell(cell) {
        while (!isNullOrUndefined(cell.ownerTable) && cell.ownerTable.isInsideTable) {
            cell = cell.ownerTable.associatedCell;
        }
        return cell;
    }
    /**
     * Highlight selected cell
     * @private
     */
    /* tslint:disable */
    highlightCell(cell, selection, start, end) {
        if (end.paragraph.isInsideTable) {
            let containerCell = this.getContainerCellOf(cell, end.paragraph.associatedCell);
            if (containerCell.ownerTable.contains(end.paragraph.associatedCell)) {
                let startCell = this.getSelectedCell(cell, containerCell);
                let endCell = this.getSelectedCell(end.paragraph.associatedCell, containerCell);
                if (this.containsCell(containerCell, end.paragraph.associatedCell)) {
                    /* tslint:enable */
                    //Selection end is in container cell.
                    if (this.isCellSelected(containerCell, start, end)) {
                        this.highlightCellWidget(containerCell);
                    }
                    else {
                        if (startCell === containerCell) {
                            this.highlight(start.paragraph, start, end);
                        }
                        else {
                            this.highlightContainer(startCell, start, end);
                        }
                    }
                }
                else {
                    //Selection end is not in container cell.
                    this.highlightCellWidget(containerCell);
                    if (containerCell.ownerRow.equals(endCell.ownerRow)) {
                        //Highlight other selected cells in current row.
                        startCell = containerCell;
                        while (!isNullOrUndefined(startCell.nextRenderedWidget)) {
                            startCell = startCell.nextRenderedWidget;
                            this.highlightCellWidget(startCell);
                            if (startCell === endCell) {
                                break;
                            }
                        }
                    }
                    else {
                        this.highlightCells(containerCell.ownerTable, containerCell, endCell);
                    }
                }
            }
            else {
                this.highlightContainer(containerCell, start, end);
            }
        }
        else {
            let cell1 = this.getContainerCell(cell);
            this.highlightContainer(cell1, start, end);
        }
    }
    /**
     * @private
     */
    highlightContainer(cell, start, end) {
        this.highlightInternal(cell.containerWidget, start, end);
        this.highlightNextBlock(cell.ownerTable, start, end);
    }
    /**
     * Get previous valid element
     * @private
     */
    getPreviousValidElement(inline) {
        let previousValidInline = undefined;
        while (inline instanceof FieldElementBox) {
            if (HelperMethods.isLinkedFieldCharacter(inline)) {
                if (inline instanceof FieldElementBox && inline.fieldType === 0) {
                    previousValidInline = inline;
                }
                else if (inline instanceof FieldElementBox && inline.fieldType === 1) {
                    previousValidInline = inline;
                    if (isNullOrUndefined(inline.fieldSeparator)) {
                        inline = inline.fieldBegin;
                        previousValidInline = inline;
                    }
                }
                else {
                    inline = inline.fieldBegin;
                    previousValidInline = inline;
                }
            }
            inline = inline.previousNode;
        }
        return isNullOrUndefined(previousValidInline) ? inline : previousValidInline;
    }
    /**
     * Get next valid element
     * @private
     */
    getNextValidElement(inline) {
        let nextValidInline = undefined;
        while (inline instanceof FieldElementBox) {
            if (inline.fieldType === 0 && !isNullOrUndefined(inline.fieldEnd)) {
                return isNullOrUndefined(nextValidInline) ? inline : nextValidInline;
            }
            else if (inline.fieldType === 1 && !isNullOrUndefined(inline.fieldBegin)) {
                nextValidInline = inline;
            }
            inline = inline.nextNode;
        }
        return (isNullOrUndefined(nextValidInline) ? inline : nextValidInline);
    }
    /**
     * Return next valid inline with index
     * @private
     */
    validateTextPosition(inline, index) {
        if (inline.length === index && inline.nextNode instanceof FieldElementBox) {
            //If inline is last item within field, then set field end as text position.
            let nextInline = this.getNextValidElement(inline.nextNode);
            if (nextInline instanceof FieldElementBox && nextInline.fieldType === 1) {
                inline = nextInline;
                index = 1;
            }
        }
        else if (index === 0 && inline.previousNode instanceof FieldElementBox) {
            let prevInline = this.getPreviousValidElement(inline.previousNode);
            inline = prevInline;
            index = inline instanceof FieldElementBox ? 0 : inline.length;
            if (inline instanceof FieldElementBox && inline.fieldType === 1) {
                index++;
            }
        }
        return { 'element': inline, 'index': index };
    }
    /**
     * Get inline physical location
     * @private
     */
    getPhysicalPositionInline(inline, index, moveNextLine) {
        let element = undefined;
        element = this.getElementBox(inline, index, moveNextLine).element;
        let lineWidget = undefined;
        if (isNullOrUndefined(element) || isNullOrUndefined(element.line)) {
            if (inline instanceof FieldElementBox || inline instanceof BookmarkElementBox) {
                return this.getFieldCharacterPosition(inline);
            }
            return new Point(0, 0);
        }
        let margin = element.margin;
        let top = 0;
        let left = 0;
        if (element instanceof TextElementBox && element.text === '\v' && isNullOrUndefined(inline.nextNode)) {
            lineWidget = this.getNextLineWidget(element.line.paragraph, element);
            index = 0;
        }
        else {
            lineWidget = element.line;
        }
        top = this.getTop(lineWidget);
        if (element instanceof ImageElementBox) {
            let format = element.line.paragraph.characterFormat;
            let previousInline = this.getPreviousTextElement(inline);
            if (!isNullOrUndefined(previousInline)) {
                format = previousInline.characterFormat;
            }
            else {
                let nextInline = this.getNextTextElement(inline);
                if (!isNullOrUndefined(nextInline)) {
                    format = nextInline.characterFormat;
                }
            }
            let measureObj = this.viewer.textHelper.getHeight(format);
            if (element.margin.top + element.height - measureObj.BaselineOffset > 0) {
                top += element.margin.top + element.height - measureObj.BaselineOffset;
            }
        }
        else if (!(element instanceof FieldElementBox)) {
            top += margin.top > 0 ? margin.top : 0;
        }
        left = (isNullOrUndefined(element) || isNullOrUndefined(lineWidget)) ? 0 : this.getLeftInternal(lineWidget, element, index);
        return new Point(left, top);
    }
    /**
     * Get field character position
     * @private
     */
    getFieldCharacterPosition(firstInline) {
        let nextValidInline = this.getNextValidElementForField(firstInline);
        //If field separator/end exists at end of paragraph, then move to next paragraph.
        if (isNullOrUndefined(nextValidInline)) {
            let nextParagraph = firstInline.line.paragraph;
            return this.getEndPosition(nextParagraph);
        }
        else {
            return this.getPhysicalPositionInline(nextValidInline, 0, true);
        }
    }
    /**
     * @private
     */
    getNextValidElementForField(firstInline) {
        if (firstInline instanceof FieldElementBox && firstInline.fieldType === 0
            && HelperMethods.isLinkedFieldCharacter(firstInline)) {
            let fieldBegin = firstInline;
            if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
                firstInline = fieldBegin.fieldEnd;
            }
            else {
                firstInline = fieldBegin.fieldSeparator;
            }
        }
        let nextValidInline = undefined;
        if (!isNullOrUndefined(firstInline.nextNode)) {
            nextValidInline = this.getNextValidElement(firstInline.nextNode);
        }
        return nextValidInline;
    }
    /**
     * Get paragraph end position
     * @private
     */
    getEndPosition(widget) {
        let left = widget.x;
        let top = widget.y;
        let lineWidget = undefined;
        if (widget.childWidgets.length > 0) {
            lineWidget = widget.childWidgets[widget.childWidgets.length - 1];
            left += this.getWidth(lineWidget, false);
        }
        if (!isNullOrUndefined(lineWidget)) {
            top = this.getTop(lineWidget);
        }
        let topMargin = 0;
        let bottomMargin = 0;
        let size = this.getParagraphMarkSize(widget, topMargin, bottomMargin);
        return new Point(left, top + size.topMargin);
    }
    /**
     * Get element box
     * @private
     */
    getElementBox(currentInline, index, moveToNextLine) {
        let elementBox = undefined;
        if (!(currentInline instanceof FieldElementBox || currentInline instanceof BookmarkElementBox)) {
            elementBox = currentInline;
        }
        return { 'element': elementBox, 'index': index };
    }
    /**
     * @private
     */
    getPreviousTextElement(inline) {
        if (inline.previousNode instanceof TextElementBox) {
            return inline.previousNode;
        }
        if (!isNullOrUndefined(inline.previousNode)) {
            return this.getPreviousTextElement(inline.previousNode);
        }
        return undefined;
    }
    /**
     * Get next text inline
     * @private
     */
    getNextTextElement(inline) {
        if (inline.nextNode instanceof TextElementBox) {
            return inline.nextNode;
        }
        if (!isNullOrUndefined(inline.nextNode)) {
            return this.getNextTextElement(inline.nextNode);
        }
        return undefined;
    }
    /**
     * @private
     */
    getNextRenderedElementBox(inline, indexInInline) {
        if (inline instanceof FieldElementBox) {
            let fieldBegin = inline;
            if (fieldBegin.fieldType === 0) {
                inline = this.getRenderedField(fieldBegin);
                if (fieldBegin === inline) {
                    return fieldBegin;
                }
            }
            indexInInline = 1;
        }
        while (!isNullOrUndefined(inline) && indexInInline === inline.length && inline.nextNode instanceof FieldElementBox) {
            let nextValidInline = this.getNextValidElement((inline.nextNode));
            if (nextValidInline instanceof FieldElementBox && nextValidInline.fieldType === 0) {
                let fieldBegin = nextValidInline;
                inline = this.getRenderedField(fieldBegin);
                if (!isNullOrUndefined(inline) && fieldBegin === inline) {
                    return fieldBegin;
                }
                indexInInline = 1;
            }
            else {
                inline = nextValidInline;
            }
        }
        return inline;
    }
    /**
     * @private
     */
    getElementBoxInternal(inline, index) {
        let element = undefined;
        element = inline;
        return {
            'element': element, 'index': index
        };
    }
    /**
     * Get Line widget
     * @private
     */
    getLineWidget(inline, index) {
        return this.getLineWidgetInternalInline(inline, index, true);
    }
    /**
     * @private
     */
    getLineWidgetInternalInline(inline, index, moveToNextLine) {
        let elementObj = this.getElementBox(inline, index, moveToNextLine);
        let element = elementObj.element; //return index
        index = elementObj.index;
        if (!isNullOrUndefined(element)) {
            if (moveToNextLine && element instanceof TextElementBox && element.text === '\v' && index === 1) {
                return this.getNextLineWidget(element.line.paragraph, element);
            }
            else {
                return element.line;
            }
        }
        let startInline = inline;
        //ToDo: Check previous inline here.
        let nextValidInline = this.getNextValidElementForField(startInline);
        //If field separator/end exists at end of paragraph, then move to next paragraph.
        if (isNullOrUndefined(nextValidInline)) {
            let lineWidget = undefined;
            let widget = startInline.line.paragraph;
            if (widget.childWidgets.length > 0) {
                lineWidget = widget.childWidgets[widget.childWidgets.length - 1];
            }
            return lineWidget;
        }
        else {
            return this.getLineWidget(nextValidInline, 0);
        }
    }
    /**
     * Get next line widget
     * @private
     */
    getNextLineWidget(paragraph, element) {
        let lineWidget = undefined;
        let widget = paragraph;
        if (widget.childWidgets.length > 0) {
            let widgetIndex = widget.childWidgets.indexOf(element.line);
            if (widgetIndex === widget.childWidgets.length - 1) {
                widget = paragraph;
                // widget = paragraph.leafWidgets[paragraph.leafWidgets.length - 1];
                widgetIndex = -1;
            }
            else if (widgetIndex > widget.childWidgets.length - 1) {
                widget = this.getNextParagraphBlock(paragraph);
                widgetIndex = -1;
            }
            else if (widgetIndex < 0) {
                // widget = paragraph.leafWidgets[paragraph.leafWidgets.length - 1];
                widget = paragraph;
                widgetIndex = widget.childWidgets.indexOf(element.line);
            }
            lineWidget = widget.childWidgets[widgetIndex + 1];
        }
        return lineWidget;
    }
    /**
     * Get Caret height
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getCaretHeight(inline, index, format, isEmptySelection, topMargin, isItalic) {
        let elementBoxInfo = this.getElementBox(inline, index, false);
        let element = elementBoxInfo.element;
        let currentInline = inline;
        if (isNullOrUndefined(element)) {
            if (currentInline instanceof FieldElementBox) {
                return this.getFieldCharacterHeight(currentInline, format, isEmptySelection, topMargin, isItalic);
            }
            return { 'height': this.viewer.textHelper.getHeight(format).Height, 'topMargin': topMargin, 'isItalic': isItalic };
        }
        let margin = element.margin;
        let heightElement = element.height;
        let maxLineHeight = 0;
        if (element instanceof ImageElementBox) {
            let previousInline = this.getPreviousTextElement(inline);
            let nextInline = this.getNextTextElement(inline);
            if (isNullOrUndefined(previousInline) && isNullOrUndefined(nextInline)) {
                let top = 0;
                let bottom = 0;
                let paragarph = inline.line.paragraph;
                let sizeInfo = this.getParagraphMarkSize(paragarph, top, bottom);
                top = sizeInfo.topMargin;
                bottom = sizeInfo.bottomMargin;
                maxLineHeight = sizeInfo.height;
                isItalic = paragarph.characterFormat.italic;
                if (!isEmptySelection) {
                    maxLineHeight += paragarph.paragraphFormat.afterSpacing;
                }
            }
            else if (isNullOrUndefined(previousInline)) {
                isItalic = nextInline.characterFormat.italic;
                return this.getCaretHeight(nextInline, 0, nextInline.characterFormat, isEmptySelection, topMargin, isItalic);
            }
            else {
                if (!isNullOrUndefined(nextInline) && element instanceof ImageElementBox) {
                    //Calculates the caret size using image character format.
                    let textSizeInfo = this.viewer.textHelper.getHeight(element.characterFormat);
                    let charHeight = textSizeInfo.Height;
                    let baselineOffset = textSizeInfo.BaselineOffset;
                    // tslint:disable-next-line:max-line-length
                    maxLineHeight = (element.margin.top < 0 && baselineOffset > element.margin.top + element.height) ? element.margin.top + element.height + charHeight - baselineOffset : charHeight;
                    if (!isEmptySelection) {
                        maxLineHeight += element.margin.bottom;
                    }
                }
                else {
                    isItalic = previousInline.characterFormat.italic;
                    // tslint:disable-next-line:max-line-length
                    return this.getCaretHeight(previousInline, previousInline.length, previousInline.characterFormat, isEmptySelection, topMargin, isItalic);
                }
            }
        }
        else {
            let baselineAlignment = format.baselineAlignment;
            let elementHeight = heightElement;
            if (baselineAlignment !== 'Normal' && isEmptySelection) {
                //Set the caret height as sub/super script text height and updates the top margin for sub script text.
                elementHeight = elementHeight / 1.5;
                if (baselineAlignment === 'Subscript') {
                    topMargin = heightElement - elementHeight;
                }
            }
            maxLineHeight = (margin.top < 0 ? margin.top : 0) + elementHeight;
            if (!isEmptySelection) {
                maxLineHeight += margin.bottom;
            }
        }
        if (!isEmptySelection) {
            return { 'height': maxLineHeight, 'topMargin': topMargin, 'isItalic': isItalic };
        }
        let height = this.viewer.textHelper.getHeight(format).Height;
        if (height > maxLineHeight) {
            height = maxLineHeight;
        }
        return { 'height': height, 'topMargin': topMargin, 'isItalic': isItalic };
    }
    /**
     * Get field characters height
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getFieldCharacterHeight(startInline, format, isEmptySelection, topMargin, isItalic) {
        let nextValidInline = this.getNextValidElementForField(startInline);
        //If field separator/end exists at end of paragraph, then move to next paragraph.
        if (isNullOrUndefined(nextValidInline)) {
            let nextParagraph = startInline.line.paragraph;
            let height = this.viewer.textHelper.getParagraphMarkSize(format).Height;
            let top = 0;
            let bottom = 0;
            let sizeInfo = this.getParagraphMarkSize(nextParagraph, top, bottom);
            let maxLineHeight = sizeInfo.height;
            top = sizeInfo.topMargin;
            bottom = sizeInfo.bottomMargin;
            if (!isEmptySelection) {
                maxLineHeight += bottom;
                return { 'height': maxLineHeight, 'topMargin': topMargin, 'isItalic': isItalic };
            }
            if (height > maxLineHeight) {
                height = maxLineHeight;
            }
            return { 'height': height, 'topMargin': topMargin, 'isItalic': isItalic };
        }
        else {
            return this.getCaretHeight(nextValidInline, 0, format, isEmptySelection, topMargin, isItalic);
        }
    }
    /**
     * Get rendered inline
     * @private
     */
    //FieldCharacter
    getRenderedInline(inline, inlineIndex) {
        let prevInline = this.getPreviousValidElement(inline);
        while (prevInline instanceof FieldElementBox) {
            prevInline = this.getPreviousTextElement(prevInline);
            if (prevInline instanceof FieldElementBox) {
                prevInline = prevInline.previousNode;
            }
        }
        if (!isNullOrUndefined(prevInline)) {
            inlineIndex = prevInline.length;
            return { 'element': prevInline, 'index': inlineIndex };
        }
        inlineIndex = 0;
        let nextInline = this.getNextRenderedElementBox(inline, 0);
        if (nextInline instanceof FieldElementBox && nextInline.fieldType === 0) {
            nextInline = nextInline.fieldSeparator;
            nextInline = nextInline.nextNode;
            while (nextInline instanceof FieldElementBox) {
                if (nextInline instanceof FieldElementBox && nextInline.fieldType === 0
                    && HelperMethods.isLinkedFieldCharacter(nextInline)) {
                    if (isNullOrUndefined(nextInline.fieldSeparator)) {
                        nextInline = nextInline.fieldEnd;
                    }
                    else {
                        nextInline = nextInline.fieldSeparator;
                    }
                }
                nextInline = nextInline.nextNode;
            }
        }
        return { 'element': nextInline, 'index': inlineIndex };
    }
    //Field Begin
    /**
     * Get rendered field
     * @private
     */
    getRenderedField(fieldBegin) {
        let inline = fieldBegin;
        if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
            inline = fieldBegin.fieldEnd;
        }
        else {
            inline = fieldBegin.fieldSeparator;
            let paragraph = inline.line.paragraph;
            if (paragraph === fieldBegin.fieldEnd.line.paragraph
                && !this.hasValidInline(paragraph, inline, fieldBegin.fieldEnd)) {
                inline = fieldBegin.fieldEnd;
            }
            else {
                return inline;
            }
        }
        return inline;
    }
    /**
     * Return true is inline is tha last inline
     * @private
     */
    isLastRenderedInline(inline, index) {
        while (index === inline.length && inline.nextNode instanceof FieldElementBox) {
            let nextValidInline = this.getNextValidElement(inline.nextNode);
            index = 0;
            if (nextValidInline instanceof FieldElementBox && nextValidInline.fieldType === 0) {
                inline = nextValidInline;
            }
            if (inline instanceof FieldElementBox && inline.fieldType === 0 && !isNullOrUndefined(inline.fieldEnd)) {
                let fieldBegin = inline;
                if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
                    inline = fieldBegin.fieldEnd;
                    index = 1;
                }
                else {
                    inline = fieldBegin.fieldSeparator;
                    let paragraph = inline.line.paragraph;
                    index = 1;
                    if (paragraph === fieldBegin.fieldEnd.line.paragraph
                        && !this.hasValidInline(paragraph, inline, fieldBegin.fieldEnd)) {
                        inline = fieldBegin.fieldEnd;
                    }
                    else {
                        break;
                    }
                }
            }
        }
        return index === inline.length && isNullOrUndefined(inline.nextNode);
    }
    /**
     * Get page
     * @private
     */
    getPage(widget) {
        let page = undefined;
        if (widget.containerWidget instanceof BlockContainer) {
            let bodyWidget = widget.containerWidget;
            page = widget.containerWidget.page;
        }
        else if (!isNullOrUndefined(widget.containerWidget)) {
            page = this.getPage(widget.containerWidget);
        }
        return page;
    }
    /**
     * Clear Selection highlight
     * @private
     */
    clearSelectionHighlightInSelectedWidgets() {
        let isNonEmptySelection = false;
        let widgets = this.selectedWidgets.keys;
        for (let i = 0; i < widgets.length; i++) {
            this.removeSelectionHighlight(widgets[i]);
            isNonEmptySelection = true;
        }
        this.selectedWidgets.clear();
        return isNonEmptySelection;
    }
    /**
     * Clear selection highlight
     * @private
     */
    clearChildSelectionHighlight(widget) {
        for (let i = 0; i < widget.childWidgets.length; i++) {
            if (widget.childWidgets[i] instanceof LineWidget) {
                this.clearSelectionHighlightLineWidget(widget.childWidgets[i]);
            }
            else if (widget.childWidgets[i] instanceof TableCellWidget) {
                this.clearSelectionHighlight(widget.childWidgets[i]);
            }
            else if (widget.childWidgets[i] instanceof Widget) {
                this.clearChildSelectionHighlight(widget.childWidgets[i]);
            }
        }
    }
    /**
     * Get line widget from paragraph widget
     * @private
     */
    //Body Widget
    getLineWidgetBodyWidget(widget, point) {
        for (let i = 0; i < widget.childWidgets.length; i++) {
            let childWidget = widget.childWidgets[i];
            if (childWidget instanceof Widget && childWidget.y <= point.y
                && (childWidget.y + childWidget.height) >= point.y) {
                if (childWidget instanceof ParagraphWidget) {
                    return this.getLineWidgetParaWidget(childWidget, point);
                }
                else {
                    return this.getLineWidgetTableWidget(childWidget, point);
                }
            }
        }
        let line = undefined;
        if (widget.childWidgets.length > 0) {
            let firstChild = widget.childWidgets[0];
            if (firstChild instanceof Widget && firstChild.y <= point.y) {
                if (widget.childWidgets[widget.childWidgets.length - 1] instanceof ParagraphWidget) {
                    // tslint:disable-next-line:max-line-length
                    line = this.getLineWidgetParaWidget(widget.childWidgets[widget.childWidgets.length - 1], point);
                }
                else {
                    // tslint:disable-next-line:max-line-length
                    line = this.getLineWidgetTableWidget(widget.childWidgets[widget.childWidgets.length - 1], point);
                }
            }
            else {
                let childWidget = undefined;
                if (firstChild instanceof Widget) {
                    childWidget = firstChild;
                }
                if (!isNullOrUndefined(childWidget)) {
                    if (childWidget instanceof ParagraphWidget) {
                        line = this.getLineWidgetParaWidget(firstChild, point);
                    }
                    else {
                        line = this.getLineWidgetTableWidget(firstChild, point);
                    }
                }
            }
        }
        return line;
    }
    //ParagraphWidget
    /**
     * Get line widget from paragraph widget
     * @private
     */
    getLineWidgetParaWidget(widget, point) {
        let childWidgets = widget.childWidgets;
        let top = widget.y;
        for (let i = 0; i < childWidgets.length; i++) {
            if (top <= point.y
                && (top + childWidgets[i].height) >= point.y) {
                return childWidgets[i];
            }
            top += childWidgets[i].height;
        }
        let lineWidget = undefined;
        if (childWidgets.length > 0) {
            if (widget.y <= point.y) {
                lineWidget = childWidgets[childWidgets.length - 1];
            }
            else {
                lineWidget = childWidgets[0];
            }
        }
        return lineWidget;
    }
    /**
     * highlight paragraph widget
     * @private
     */
    // tslint:disable-next-line:max-line-length
    highlightParagraph(widget, startIndex, endLine, endElement, endIndex) {
        let top = 0;
        for (let i = startIndex; i < widget.childWidgets.length; i++) {
            let line = widget.childWidgets[i];
            if (i === startIndex) {
                top = this.getTop(line);
            }
            let left = this.getLeft(line);
            if (line === endLine) {
                //Selection ends in current line.
                let right = this.getLeftInternal(endLine, endElement, endIndex);
                this.createHighlightBorder(line, right - left, left, top);
                return;
            }
            this.createHighlightBorder(line, this.getWidth(line, true) - (left - widget.x), left, top);
            top += line.height;
        }
    }
    //Table Widget
    /**
     * Get line widget form table widget
     * @private
     */
    getLineWidgetTableWidget(widget, point) {
        let lineWidget = undefined;
        for (let i = 0; i < widget.childWidgets.length; i++) {
            //Removed the height condition check to handle the vertically merged cells.
            let childWidget = widget.childWidgets[i];
            if (childWidget instanceof TableRowWidget && childWidget.y <= point.y) {
                lineWidget = this.getLineWidgetRowWidget(childWidget, point);
                let cellWidget = undefined;
                if (!isNullOrUndefined(lineWidget) && lineWidget.paragraph.containerWidget instanceof TableCellWidget) {
                    cellWidget = lineWidget.paragraph.containerWidget;
                }
                let cellSpacing = 0;
                let rowSpan = 0;
                if (!isNullOrUndefined(cellWidget)) {
                    let tableWidget = cellWidget.ownerRow.containerWidget;
                    cellSpacing = HelperMethods.convertPointToPixel(tableWidget.tableFormat.cellSpacing);
                    rowSpan = cellWidget.cellFormat.rowSpan;
                }
                let leftCellSpacing = 0;
                let rightCellSpacing = 0;
                let topCellSpacing = 0;
                let bottomCellSpacing = 0;
                if (cellSpacing > 0) {
                    leftCellSpacing = cellWidget.cellIndex === 0 ? cellSpacing : cellSpacing / 2;
                    // tslint:disable-next-line:max-line-length
                    rightCellSpacing = cellWidget.cellIndex === cellWidget.ownerRow.childWidgets.length - 1 ? cellSpacing : cellSpacing / 2;
                    let rowWidget = undefined;
                    if (cellWidget.containerWidget instanceof TableRowWidget) {
                        rowWidget = cellWidget.containerWidget;
                    }
                    let tableWidget = undefined;
                    if (cellWidget.containerWidget.containerWidget instanceof TableWidget) {
                        tableWidget = cellWidget.containerWidget.containerWidget;
                    }
                    if (!isNullOrUndefined(rowWidget) && !isNullOrUndefined(tableWidget)) {
                        topCellSpacing = cellWidget.ownerRow.rowIndex === 0 ? cellSpacing : cellSpacing / 2;
                        if (cellWidget.ownerRow.rowIndex + rowSpan === cellWidget.ownerTable.childWidgets.length) {
                            bottomCellSpacing = cellSpacing;
                        }
                        else {
                            bottomCellSpacing = cellSpacing / 2;
                        }
                    }
                }
                if ((!isNullOrUndefined(lineWidget) && lineWidget.paragraph.x <= point.x
                    && lineWidget.paragraph.x + lineWidget.width >= point.x
                    && lineWidget.paragraph.y <= point.y && this.getTop(lineWidget) + lineWidget.height >= point.y)
                    || (!isNullOrUndefined(cellWidget) && cellWidget.x - cellWidget.margin.left - leftCellSpacing <= point.x
                        && cellWidget.x + cellWidget.width + cellWidget.margin.right + rightCellSpacing >= point.x
                        && cellWidget.y - cellWidget.margin.top - topCellSpacing <= point.y
                        && cellWidget.y + cellWidget.height + cellWidget.margin.bottom + bottomCellSpacing >= point.y)) {
                    break;
                }
            }
        }
        return lineWidget;
    }
    //TableRowWidget
    /**
     * Get line widget fom row
     * @private
     */
    getLineWidgetRowWidget(widget, point) {
        for (let i = 0; i < widget.childWidgets.length; i++) {
            let cellSpacing = 0;
            cellSpacing = HelperMethods.convertPointToPixel(widget.ownerTable.tableFormat.cellSpacing);
            let leftCellSpacing = 0;
            let rightCellSpacing = 0;
            if (cellSpacing > 0) {
                leftCellSpacing = widget.childWidgets[i].columnIndex === 0 ? cellSpacing : cellSpacing / 2;
                // tslint:disable-next-line:max-line-length
                rightCellSpacing = widget.childWidgets[i].cellIndex === widget.childWidgets[i].ownerRow.childWidgets.length - 1 ? cellSpacing : cellSpacing / 2;
            }
            if (widget.childWidgets[i].x -
                // tslint:disable-next-line:max-line-length
                widget.childWidgets[i].margin.left - leftCellSpacing <= point.x && (widget.childWidgets[i].x +
                // tslint:disable-next-line:max-line-length
                widget.childWidgets[i].width) + widget.childWidgets[i].margin.right + rightCellSpacing >= point.x) {
                return this.getLineWidgetCellWidget(widget.childWidgets[i], point);
            }
        }
        let lineWidget = undefined;
        if (widget.childWidgets.length > 0) {
            if (widget.childWidgets[0].x <= point.x) {
                lineWidget = this.getLineWidgetCellWidget(widget.childWidgets[widget.childWidgets.length - 1], point);
            }
            else {
                lineWidget = this.getLineWidgetCellWidget(widget.childWidgets[0], point);
            }
        }
        return lineWidget;
    }
    /**
     * @private
     */
    getFirstBlock(cell) {
        if (cell.childWidgets.length > 0) {
            return cell.childWidgets[0];
        }
        return undefined;
    }
    //Table Cell Widget
    /**
     * Highlight selected cell widget
     * @private
     */
    highlightCellWidget(widget) {
        let widgets = [];
        if (widget.previousSplitWidget || widget.nextSplitWidget) {
            widgets = widget.getSplitWidgets();
        }
        else {
            widgets.push(widget);
        }
        for (let i = 0; i < widgets.length; i++) {
            widget = widgets[i];
            //Clears Selection highlight of the child widgets.
            this.clearChildSelectionHighlight(widget);
            //Highlights the entire cell.
            this.createHighlightBorderInsideTable(widget);
        }
    }
    /**
     * Clear selection highlight
     * @private
     */
    clearSelectionHighlight(widget) {
        if (this.selectedWidgets.containsKey(widget)) {
            this.removeSelectionHighlight(widget);
            this.selectedWidgets.remove(widget);
        }
    }
    /**
     * Get line widget from cell widget
     * @private
     */
    getLineWidgetCellWidget(widget, point) {
        for (let i = 0; i < widget.childWidgets.length; i++) {
            if (widget.childWidgets[i].y <= point.y
                && (widget.childWidgets[i].y + widget.childWidgets[i].height) >= point.y) {
                if (widget.childWidgets[i] instanceof ParagraphWidget) {
                    return this.getLineWidgetParaWidget(widget.childWidgets[i], point);
                }
                else {
                    return this.getLineWidgetTableWidget(widget.childWidgets[i], point);
                }
            }
        }
        let lineWidget = undefined;
        if (widget.childWidgets.length > 0) {
            if (widget.childWidgets[0].y <= point.y) {
                if (widget.childWidgets[widget.childWidgets.length - 1] instanceof ParagraphWidget) {
                    // tslint:disable-next-line:max-line-length
                    lineWidget = this.getLineWidgetParaWidget(widget.childWidgets[widget.childWidgets.length - 1], point);
                }
                else {
                    lineWidget = this.getLineWidgetTableWidget(widget.childWidgets[0], point);
                }
            }
        }
        return lineWidget;
    }
    //LineWidget
    /**
     * update text position
     * @private
     */
    updateTextPosition(widget, point) {
        let caretPosition = point;
        let element = undefined;
        let index = 0;
        let isImageSelected = false;
        let isImageSelectedObj = this.updateTextPositionIn(widget, element, index, point, false);
        if (!isNullOrUndefined(isImageSelectedObj)) {
            element = isImageSelectedObj.element;
            index = isImageSelectedObj.index;
            caretPosition = isImageSelectedObj.caretPosition;
            isImageSelected = isImageSelectedObj.isImageSelected;
            this.isImageSelected = isImageSelected;
        }
        if (isImageSelected) {
            this.selectInternal(widget, element, index, caretPosition);
            if (index === 0) {
                this.extendForward();
            }
            else {
                this.extendBackward();
            }
        }
        else {
            this.selectInternal(widget, element, index, caretPosition);
        }
    }
    /**
     * @private
     */
    /* tslint:disable */
    updateTextPositionIn(widget, inline, index, caretPosition, includeParagraphMark) {
        let isImageSelected = false;
        let top = this.getTop(widget);
        let left = widget.paragraph.x;
        let elementValues = this.getFirstElement(widget, left);
        let element = elementValues.element;
        left = elementValues.left;
        if (isNullOrUndefined(element)) {
            let topMargin = 0;
            let bottomMargin = 0;
            let size = this.getParagraphMarkSize(widget.paragraph, topMargin, bottomMargin);
            topMargin = size.topMargin;
            bottomMargin = size.bottomMargin;
            let selectParaMark = this.viewer.mouseDownOffset.y >= top && this.viewer.mouseDownOffset.y < top + widget.height ? (this.viewer.mouseDownOffset.x < left + size.width) : true;
            if (selectParaMark && includeParagraphMark && caretPosition.x > left + size.width / 2) {
                left += size.width;
                if (widget.children.length > 0) {
                    inline = widget.children[widget.children.length - 1];
                    index = inline.length;
                }
                index++;
            }
            caretPosition = new Point(left, topMargin > 0 ? top + topMargin : top);
        }
        else {
            if (!isNullOrUndefined(element)) {
                if (caretPosition.x > left + element.margin.left) {
                    for (let i = widget.children.indexOf(element); i < widget.children.length; i++) {
                        element = widget.children[i];
                        if (caretPosition.x < left + element.margin.left + element.width || i === widget.children.length - 1) {
                            break;
                        }
                        left += element.margin.left + element.width;
                    }
                    if (caretPosition.x > left + element.margin.left + element.width) {
                        //Line End
                        index = element instanceof TextElementBox ? element.length : 1;
                        left += element.margin.left + element.width;
                    }
                    else if (element instanceof TextElementBox) {
                        let x = caretPosition.x - left - element.margin.left;
                        left += element.margin.left;
                        let prevWidth = 0;
                        let charIndex = 0;
                        for (let i = 1; i <= element.length; i++) {
                            let width = 0;
                            if (i === element.length) {
                                width = element.width;
                            }
                            else {
                                width = this.viewer.textHelper.getWidth(element.text.substr(0, i), element.characterFormat);
                            }
                            if (x < width || i === element.length) {
                                //Updates exact left position of the caret.
                                let charWidth = width - prevWidth;
                                if (x - prevWidth > charWidth / 2) {
                                    left += width;
                                    charIndex = i;
                                }
                                else {
                                    left += prevWidth;
                                    charIndex = i - 1;
                                    if (i === 1 && element !== widget.children[0]) {
                                        let curIndex = widget.children.indexOf(element);
                                        if (!(widget.children[curIndex - 1] instanceof ListTextElementBox)) {
                                            element = widget.children[curIndex - 1];
                                            charIndex = element instanceof TextElementBox ? element.length : 1;
                                        }
                                    }
                                }
                                break;
                            }
                            prevWidth = width;
                        }
                        index = charIndex;
                    }
                    else {
                        isImageSelected = element instanceof ImageElementBox;
                        if (caretPosition.x - left - element.margin.left > element.width / 2) {
                            index = 1;
                            left += element.margin.left + element.width;
                        }
                        else if (element !== widget.children[0] && !isImageSelected) {
                            let curIndex = widget.children.indexOf(element);
                            if (!(widget.children[curIndex - 1] instanceof ListTextElementBox)) {
                                element = widget.children[curIndex - 1];
                                index = element instanceof TextElementBox ? element.length : 1;
                            }
                        }
                    }
                    if (element instanceof TextElementBox && element.text === '\v') {
                        index = 0;
                    }
                }
                else {
                    left += element.margin.left;
                }
                if (element instanceof TextElementBox) {
                    top += element.margin.top > 0 ? element.margin.top : 0;
                }
                else {
                    let textMetrics = this.viewer.textHelper.getHeight(element.characterFormat); //for ascent and descent
                    let height = element.height;
                    if (element instanceof BookmarkElementBox) {
                        height = textMetrics.Height; //after text helper class
                    }
                    top += element.margin.top + height - textMetrics.BaselineOffset;
                }
                inline = element;
                let inlineObj = this.validateTextPosition(inline, index);
                inline = inlineObj.element;
                index = inlineObj.index;
                let isParagraphEnd = isNullOrUndefined(inline.nextNode) && index === inline.length;
                let isLineEnd = isNullOrUndefined(inline.nextNode)
                    && inline instanceof TextElementBox && inline.text === '\v';
                if (includeParagraphMark && inline.nextNode instanceof FieldElementBox && index === inline.length) {
                    isParagraphEnd = this.isLastRenderedInline(inline, index);
                }
                if (includeParagraphMark && isParagraphEnd || isLineEnd) {
                    let width = 0;
                    //Include width of Paragraph mark.
                    if (isParagraphEnd) {
                        width = this.viewer.textHelper.getParagraphMarkWidth(widget.paragraph.characterFormat);
                        let selectParaMark = this.viewer.mouseDownOffset.y >= top && this.viewer.mouseDownOffset.y < top + widget.height ? (this.viewer.mouseDownOffset.x < left + width) : true;
                        if (selectParaMark && caretPosition.x > left + width / 2) {
                            left += width;
                            index = inline.length + 1;
                        }
                        //Include width of line break mark.
                    }
                    else if (isLineEnd) {
                        width = element.width;
                        left += width;
                        index = inline.length;
                    }
                }
                caretPosition = new Point(left, top);
            }
        }
        return {
            'element': inline,
            'index': index,
            'caretPosition': caretPosition,
            'isImageSelected': isImageSelected
        };
    }
    /* tslint:enable */
    /**
     * Get text length if the line widget
     * @private
     */
    // public getTextLength(viewer: LayoutViewer, widget: LineWidget, element: ElementBox): number {
    //     let length: number = 0;
    //     let count: number = widget.children.indexOf(element);
    //     if (widget.children.length > 0 && widget.children[0] instanceof ListTextElementBox) {
    //         if (widget.children[1] instanceof ListTextElementBox) {
    //             count -= 2;
    //         } else {
    //             count -= 1;
    //         }
    //     }
    //     for (let i: number = 1; i < count; i++) {
    //         length += widget.children[i].length;
    //     }
    //     return length;
    // }
    /**
     * Get Line widget left
     * @private
     */
    getLeft(widget) {
        let left = widget.paragraph.x;
        let paragraphFormat = widget.paragraph.paragraphFormat;
        if (this.isParagraphFirstLine(widget) && !(paragraphFormat.textAlignment === 'Right')) {
            left += HelperMethods.convertPointToPixel(paragraphFormat.firstLineIndent);
        }
        for (let i = 0; i < widget.children.length; i++) {
            let element = widget.children[i];
            if (element instanceof ListTextElementBox) {
                if (i === 0) {
                    left += element.margin.left + element.width;
                }
                else {
                    left += element.width;
                }
            }
            else {
                left += element.margin.left;
                break;
            }
        }
        return left;
    }
    /**
     * Get line widget top
     * @private
     */
    getTop(widget) {
        let top = widget.paragraph.y;
        let count = widget.paragraph.childWidgets.indexOf(widget);
        for (let i = 0; i < count; i++) {
            top += widget.paragraph.childWidgets[i].height;
        }
        return top;
    }
    /**
     * Get first element the widget
     * @private
     */
    getFirstElement(widget, left) {
        let firstLineIndent = 0;
        if (this.isParagraphFirstLine(widget)) {
            firstLineIndent = HelperMethods.convertPointToPixel(widget.paragraph.paragraphFormat.firstLineIndent);
        }
        left += firstLineIndent;
        let element = undefined;
        for (let i = 0; i < widget.children.length; i++) {
            element = widget.children[i];
            if (element instanceof ListTextElementBox) {
                left += element.margin.left + element.width;
                element = undefined;
                // }
                //  else if (element instanceof FieldElementBox || element instanceof BookmarkElementBox
                //     || (element.nextNode instanceof FieldElementBox && ((element.nextNode as FieldElementBox).fieldType === 2))) {
                //     element = undefined;
            }
            else {
                break;
            }
        }
        return { 'element': element, 'left': left };
    }
    /**
     * Return inline index
     * @private
     */
    //ElementBox
    getIndexInInline(elementBox) {
        let indexInInline = 0;
        if (elementBox instanceof TextElementBox) {
            let count = elementBox.line.children.indexOf(elementBox);
            for (let i = 0; i < count; i++) {
                let element = elementBox.line.children[i];
                if (element instanceof FieldElementBox || element instanceof ListTextElementBox) {
                    continue;
                }
                indexInInline += element.length;
            }
        }
        return indexInInline;
    }
    /**
     * Return true if widget is first inline of paragraph
     * @private
     */
    isParagraphFirstLine(widget) {
        if (isNullOrUndefined(widget.paragraph.previousSplitWidget) &&
            widget === widget.paragraph.firstChild) {
            return true;
        }
        return false;
    }
    /**
     * @private
     */
    isParagraphLastLine(widget) {
        if (isNullOrUndefined(widget.paragraph.nextSplitWidget)
            && widget === widget.paragraph.lastChild) {
            return true;
        }
        return false;
    }
    /**
     * Return line widget width
     * @private
     */
    getWidth(widget, includeParagraphMark) {
        let width = 0;
        if (this.isParagraphFirstLine(widget)) {
            width += HelperMethods.convertPointToPixel(widget.paragraph.paragraphFormat.firstLineIndent);
        }
        for (let i = 0; i < widget.children.length; i++) {
            width += widget.children[i].margin.left + widget.children[i].width;
        }
        if (includeParagraphMark && widget.paragraph.childWidgets.indexOf(widget) === widget.paragraph.childWidgets.length - 1
            && isNullOrUndefined(widget.paragraph.nextSplitWidget)) {
            width += this.viewer.textHelper.getParagraphMarkWidth(widget.paragraph.characterFormat);
        }
        return width;
    }
    /**
     * Return line widget left
     * @private
     */
    getLeftInternal(widget, elementBox, index) {
        let left = widget.paragraph.x;
        if (this.isParagraphFirstLine(widget)) {
            // tslint:disable-next-line:max-line-length
            left += HelperMethods.convertPointToPixel(widget.paragraph.paragraphFormat.firstLineIndent);
        }
        let count = widget.children.indexOf(elementBox);
        if ((widget.children.length === 1 && widget.children[0] instanceof ListTextElementBox) || (widget.children.length === 2
            && widget.children[0] instanceof ListTextElementBox && widget.children[1] instanceof ListTextElementBox)) {
            count = widget.children.length;
        }
        for (let i = 0; i < count; i++) {
            let widgetInternal = widget.children[i];
            // if (widgetInternal instanceof FieldElementBox) {
            //     continue;
            // }
            if (i === 1 && widget.children[i] instanceof ListTextElementBox) {
                left += widget.children[i].width;
            }
            else {
                left += widget.children[i].margin.left + widget.children[i].width;
            }
        }
        if (!isNullOrUndefined(elementBox)) {
            left += elementBox.margin.left;
        }
        if (elementBox instanceof TextElementBox) {
            if (index === elementBox.length) {
                left += elementBox.width;
            }
            else if (index > elementBox.length) {
                // tslint:disable-next-line:max-line-length
                left += elementBox.width + this.viewer.textHelper.getParagraphMarkWidth(elementBox.line.paragraph.characterFormat);
            }
            else {
                // tslint:disable-next-line:max-line-length
                left += this.viewer.textHelper.getWidth(elementBox.text.substr(0, index), elementBox.characterFormat);
            }
        }
        else if (index > 0) {
            if (!isNullOrUndefined(elementBox) && !(elementBox instanceof ListTextElementBox)) {
                left += elementBox.width;
                if (index === 2) {
                    let paragraph = elementBox.line.paragraph;
                    left += this.viewer.textHelper.getParagraphMarkWidth(paragraph.characterFormat);
                }
            }
            else {
                left += this.viewer.textHelper.getParagraphMarkWidth(widget.paragraph.characterFormat);
            }
        }
        return left;
    }
    /**
     * Return line widget start offset
     * @private
     */
    getLineStartLeft(widget) {
        let left = widget.paragraph.x;
        if (this.isParagraphFirstLine(widget)) {
            left += HelperMethods.convertPointToPixel(widget.paragraph.paragraphFormat.firstLineIndent);
        }
        if (widget.children.length > 0) {
            left += widget.children[0].margin.left;
        }
        return left;
    }
    /**
     * Update text position
     * @private
     */
    updateTextPositionWidget(widget, point, textPosition, includeParagraphMark) {
        let caretPosition = point;
        let inline = undefined;
        let index = 0;
        let updatePositionObj;
        updatePositionObj = this.updateTextPositionIn(widget, inline, index, caretPosition, includeParagraphMark);
        inline = updatePositionObj.element;
        index = updatePositionObj.index;
        caretPosition = updatePositionObj.caretPosition;
        textPosition.setPositionForSelection(widget, inline, index, caretPosition);
    }
    /**
     * Clear selection highlight
     * @private
     */
    clearSelectionHighlightLineWidget(widget) {
        if (!isNullOrUndefined(this.owner) && this.selectedWidgets.length > 0) {
            this.clearSelectionHighlight(this);
        }
    }
    /**
     * Return first element from line widget
     * @private
     */
    getFirstElementInternal(widget) {
        let element = undefined;
        for (let i = 0; i < widget.children.length; i++) {
            element = widget.children[i];
            if (element instanceof ListTextElementBox) {
                element = undefined;
            }
            else {
                break;
            }
        }
        return element;
    }
    //Selection API    
    /**
     * Select content between given range
     * @private
     */
    selectRange(startPosition, endPosition) {
        this.start.setPositionInternal(startPosition);
        this.end.setPositionInternal(endPosition);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Selects current paragraph
     * @private
     */
    selectParagraph(paragraph, positionAtStart) {
        let line = paragraph.firstChild;
        if (positionAtStart) {
            this.start.setPosition(line, positionAtStart);
        }
        else {
            let endOffset = line.getEndOffset();
            this.start.setPositionParagraph(line, endOffset);
        }
        this.end.setPositionInternal(this.start);
        this.upDownSelectionLength = this.start.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * @private
     */
    setPositionForBlock(block, selectFirstBlock) {
        let position;
        if (block instanceof TableWidget) {
            if (selectFirstBlock) {
                block = this.getFirstParagraphInFirstCell(block);
            }
            else {
                block = this.getLastParagraphInLastCell(block);
            }
        }
        if (block instanceof ParagraphWidget) {
            position = new TextPosition(this.owner);
            if (selectFirstBlock) {
                position.setPosition(block.firstChild, true);
            }
            else {
                let line = block.lastChild;
                position.setPositionParagraph(line, line.getEndOffset());
            }
        }
        return position;
    }
    /**
     * Select content in given text position
     * @private
     */
    selectContent(textPosition, clearMultiSelection) {
        if (isNullOrUndefined(textPosition)) {
            throw new Error('textPosition is undefined.');
        }
        this.start.setPositionInternal(textPosition);
        this.end.setPositionInternal(textPosition);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Select paragraph
     * @private
     */
    selectInternal(lineWidget, element, index, physicalLocation) {
        this.start.setPositionForSelection(lineWidget, element, index, physicalLocation);
        this.end.setPositionInternal(this.start);
        this.upDownSelectionLength = physicalLocation.x;
        this.fireSelectionChanged(true);
    }
    /**
     * @private
     */
    selects(lineWidget, offset, skipSelectionChange) {
        this.viewer.clearSelectionHighlight();
        this.start.setPositionForLineWidget(lineWidget, offset);
        this.end.setPositionInternal(this.start);
        if (!skipSelectionChange) {
            this.fireSelectionChanged(true);
        }
    }
    /**
     * Select content between start and end position
     * @private
     */
    selectPosition(startPosition, endPosition) {
        if (isNullOrUndefined(startPosition) || isNullOrUndefined(endPosition)) {
            throw new Error('TextPosition cannot be undefined');
        }
        if (isNullOrUndefined(startPosition.paragraph)
            || startPosition.offset > this.getParagraphLength(startPosition.paragraph) + 1) {
            throw new Error('Start TextPosition is not valid.');
        }
        if (isNullOrUndefined(endPosition.paragraph)
            || endPosition.offset > this.getParagraphLength(endPosition.paragraph) + 1) {
            throw new Error('End TextPosition is not valid.');
        }
        if (startPosition.isAtSamePosition(endPosition)) {
            // Select start position.
            this.selectRange(startPosition, startPosition);
        }
        else {
            // If both text position exists within same comment or outside comment, and not at same position.
            if (startPosition.isExistBefore(endPosition)) {
                // tslint:disable-next-line:max-line-length
                endPosition.validateForwardFieldSelection(startPosition.getHierarchicalIndexInternal(), endPosition.getHierarchicalIndexInternal());
            }
            else {
                // tslint:disable-next-line:max-line-length
                startPosition.validateForwardFieldSelection(endPosition.getHierarchicalIndexInternal(), startPosition.getHierarchicalIndexInternal());
            }
            this.selectRange(startPosition, endPosition);
        }
    }
    /**
     * Notify selection change event
     * @private
     */
    fireSelectionChanged(isSelectionChanged) {
        if (!this.isEmpty) {
            if (this.isForward) {
                this.start.updatePhysicalPosition(true);
                this.end.updatePhysicalPosition(false);
            }
            else {
                this.start.updatePhysicalPosition(false);
                this.end.updatePhysicalPosition(true);
            }
        }
        if (!this.skipFormatRetrieval) {
            this.retrieveCurrentFormatProperties();
        }
        this.viewer.clearSelectionHighlight();
        this.hideToolTip();
        if (this.owner.isLayoutEnabled && !this.owner.isShiftingEnabled) {
            this.highlightSelection(true);
        }
        if (isSelectionChanged) {
            if (this.start.paragraph.isInHeaderFooter && !this.owner.enableHeaderAndFooter) {
                this.owner.enableHeaderAndFooter = true;
            }
            else if (!this.start.paragraph.isInHeaderFooter && this.owner.enableHeaderAndFooter) {
                this.owner.enableHeaderAndFooter = false;
            }
            this.owner.fireSelectionChange();
        }
        this.viewer.updateFocus();
    }
    //Formats Retrieval
    /**
     * Retrieve all current selection format
     * @private
     */
    retrieveCurrentFormatProperties() {
        this.isRetrieveFormatting = true;
        let startPosition = this.start;
        let endPosition = this.end;
        if (!this.isForward) {
            startPosition = this.end;
            endPosition = this.start;
        }
        this.retrieveImageFormat(startPosition, endPosition);
        this.retrieveCharacterFormat(startPosition, endPosition);
        this.retrieveParagraphFormat(startPosition, endPosition);
        this.retrieveSectionFormat(startPosition, endPosition);
        this.retrieveTableFormat(startPosition, endPosition);
        if (!this.isImageSelected) {
            this.imageFormat.clearImageFormat();
        }
        this.isRetrieveFormatting = false;
        this.setCurrentContextType();
    }
    /**
     * @private
     */
    retrieveImageFormat(start, end) {
        let image;
        if (start.currentWidget === end.currentWidget && start.offset + 1 === end.offset) {
            let elementInfo = end.currentWidget.getInline(end.offset, 0);
            image = elementInfo.element;
            let index = elementInfo.index;
            if (image instanceof ImageElementBox) {
                let startOffset = start.currentWidget.getOffset(image, 0);
                if (startOffset !== start.offset) {
                    image = undefined;
                }
            }
        }
        if (image instanceof ImageElementBox) {
            this.imageFormat.copyImageFormat(image);
        }
        else {
            this.imageFormat.clearImageFormat();
        }
    }
    setCurrentContextType() {
        let contextIsinImage = this.imageFormat.image ? true : false;
        let contextIsinTable = (isNullOrUndefined(this.tableFormat) || isNullOrUndefined(this.tableFormat.table)) ? false : true;
        let style = this.start.paragraph.paragraphFormat.baseStyle;
        if (style instanceof WParagraphStyle && style.name.toLowerCase().indexOf('toc') === 0) {
            let tocField = this.getTocFieldInternal();
            if (!isNullOrUndefined(tocField)) {
                this.contextTypeInternal = 'TableOfContents';
                return;
            }
        }
        if (this.start.paragraph.isInHeaderFooter) {
            let isInHeader = this.start.paragraph.bodyWidget.headerFooterType.indexOf('Header') !== -1;
            if (contextIsinTable) {
                if (contextIsinImage) {
                    this.contextTypeInternal = isInHeader ? 'HeaderTableImage' : 'FooterTableImage';
                }
                else {
                    this.contextTypeInternal = isInHeader ? 'HeaderTableText' : 'FooterTableText';
                }
            }
            else {
                if (contextIsinImage) {
                    this.contextTypeInternal = isInHeader ? 'HeaderImage' : 'FooterImage';
                }
                else {
                    this.contextTypeInternal = isInHeader ? 'HeaderText' : 'FooterText';
                }
            }
        }
        else {
            if (contextIsinTable) {
                this.contextTypeInternal = contextIsinImage ? 'TableImage' : 'TableText';
            }
            else {
                this.contextTypeInternal = contextIsinImage ? 'Image' : 'Text';
            }
        }
    }
    //Table Format retrieval starts
    /**
     * Retrieve selection table format
     * @private
     */
    retrieveTableFormat(start, end) {
        let tableAdv = this.getTable(start, end);
        if (!isNullOrUndefined(tableAdv)) {
            this.tableFormat.copyFormat(tableAdv.tableFormat);
            this.tableFormat.table = tableAdv;
            this.retrieveCellFormat(start, end);
            this.retrieveRowFormat(start, end);
        }
        else {
            //When the selection is out of table
            this.tableFormat.clearFormat();
        }
    }
    /**
     * Retrieve selection cell format
     * @private
     */
    retrieveCellFormat(start, end) {
        if (start.paragraph.isInsideTable && end.paragraph.isInsideTable) {
            this.cellFormat.copyFormat(start.paragraph.associatedCell.cellFormat);
            this.getCellFormat(start.paragraph.associatedCell.ownerTable, start, end);
        }
        else {
            //When the selection is out of table
            this.cellFormat.clearCellFormat();
        }
    }
    /**
     * Retrieve selection row format
     * @private
     */
    retrieveRowFormat(start, end) {
        if (start.paragraph.isInsideTable && end.paragraph.isInsideTable) {
            this.rowFormat.copyFormat(start.paragraph.associatedCell.ownerRow.rowFormat);
            this.getRowFormat(start.paragraph.associatedCell.ownerTable, start, end);
        }
        else {
            //When the selection is out of table
            this.rowFormat.clearRowFormat();
        }
    }
    /**
     * Get selected cell format
     * @private
     */
    getCellFormat(table, start, end) {
        if (start.paragraph.associatedCell.equals(end.paragraph.associatedCell)) {
            return;
        }
        let isStarted = false;
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            if (row === start.paragraph.associatedCell.ownerRow) {
                isStarted = true;
            }
            if (isStarted) {
                for (let j = 0; j < row.childWidgets.length; j++) {
                    let cell = row.childWidgets[j];
                    if (this.isCellSelected(cell, start, end)) {
                        this.cellFormat.combineFormat(cell.cellFormat);
                    }
                    if (cell === end.paragraph.associatedCell) {
                        this.cellFormat.combineFormat(cell.cellFormat);
                        return;
                    }
                }
            }
        }
    }
    /**
     * Get selected row format
     * @private
     */
    getRowFormat(table, start, end) {
        let tableRow = start.paragraph.associatedCell.ownerRow;
        if (tableRow === end.paragraph.associatedCell.ownerRow) {
            return;
        }
        for (let i = table.childWidgets.indexOf(tableRow) + 1; i < table.childWidgets.length; i++) {
            let tempTableRow = table.childWidgets[i];
            this.rowFormat.combineFormat(tempTableRow.rowFormat);
            if (tempTableRow === end.paragraph.associatedCell.ownerRow) {
                return;
            }
        }
    }
    /**
     * Return table with given text position
     * @private
     */
    getTable(startPosition, endPosition) {
        if (!isNullOrUndefined(startPosition.paragraph.associatedCell) && !isNullOrUndefined(endPosition.paragraph.associatedCell)) {
            let startTable = startPosition.paragraph.associatedCell.ownerTable;
            let endTable = startPosition.paragraph.associatedCell.ownerTable;
            if (startTable === endTable) {
                return startTable;
            }
            else {
                if (startTable.contains(startPosition.paragraph.associatedCell)) {
                    return startTable;
                }
                else if (endTable.contains(startPosition.paragraph.associatedCell)) {
                    return endTable;
                }
                else if (!startTable.isInsideTable || !endTable.isInsideTable) {
                    return undefined;
                }
                else {
                    do {
                        startTable = startTable.associatedCell.ownerTable;
                        if (startTable === endTable || startTable.contains(endTable.associatedCell)) {
                            return startTable;
                        }
                        else if (endTable.contains(startTable.associatedCell)) {
                            return endTable;
                        }
                    } while (!isNullOrUndefined(startTable.associatedCell));
                }
            }
        }
        return undefined;
    }
    getContainerWidget(block) {
        let bodyWidget;
        if (block.containerWidget instanceof BlockContainer) {
            bodyWidget = block.containerWidget;
        }
        else {
            bodyWidget = block.containerWidget;
            while (!(bodyWidget instanceof BlockContainer)) {
                bodyWidget = bodyWidget.containerWidget;
            }
        }
        return bodyWidget;
    }
    //Table format retrieval ends
    //Section format retrieval starts
    /**
     * Retrieve selection section format
     * @private
     */
    retrieveSectionFormat(start, end) {
        let startParaSection = this.getContainerWidget(start.paragraph);
        let endParaSection = this.getContainerWidget(end.paragraph);
        if (!isNullOrUndefined(startParaSection)) {
            this.sectionFormat.copyFormat(startParaSection.sectionFormat);
            let startPageIndex = this.viewer.pages.indexOf(startParaSection.page);
            let endPageIndex = this.viewer.pages.indexOf(endParaSection.page);
            for (let i = startPageIndex + 1; i <= endPageIndex; i++) {
                this.sectionFormat.combineFormat(this.viewer.pages[i].bodyWidgets[0].sectionFormat);
            }
        }
    }
    //section format retrieval ends.
    //Paragraph format retrieval implementation starts.
    /**
     * Retrieve selection paragraph format
     * @private
     */
    retrieveParagraphFormat(start, end) {
        this.getParagraphFormatForSelection(start.paragraph, this, start, end);
    }
    /**
     * @private
     */
    getParagraphFormatForSelection(paragraph, selection, start, end) {
        //Selection start in cell.
        if (start.paragraph.isInsideTable && (!end.paragraph.isInsideTable
            || start.paragraph.associatedCell !== end.paragraph.associatedCell
            || this.isCellSelected(start.paragraph.associatedCell, start, end))) {
            this.getParagraphFormatInternalInCell(start.paragraph.associatedCell, start, end);
        }
        else {
            this.getParagraphFormatInternalInParagraph(paragraph, start, end);
        }
    }
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getParagraphFormatInternalInParagraph(paragraph, start, end) {
        if (start.paragraph === paragraph) {
            this.paragraphFormat.copyFormat(paragraph.paragraphFormat);
        }
        else {
            this.paragraphFormat.combineFormat(paragraph.paragraphFormat);
        }
        if (end.paragraph === paragraph) {
            return;
        }
        let block = this.getNextRenderedBlock(paragraph);
        if (!isNullOrUndefined(block)) {
            this.getParagraphFormatInternalInBlock(block, start, end);
        }
    }
    /**
     * @private
     */
    getParagraphFormatInternalInBlock(block, start, end) {
        if (block instanceof ParagraphWidget) {
            this.getParagraphFormatInternalInParagraph(block, start, end);
        }
        else {
            this.getParagraphFormatInternalInTable(block, start, end);
        }
    }
    /**
     * @private
     */
    getParagraphFormatInternalInTable(table, start, end) {
        for (let i = 0; i < table.childWidgets.length; i++) {
            let tableRow = table.childWidgets[i];
            for (let j = 0; j < tableRow.childWidgets.length; j++) {
                this.getParagraphFormatInCell(tableRow.childWidgets[j]);
            }
            if (end.paragraph.isInsideTable && this.containsRow(tableRow, end.paragraph.associatedCell)) {
                return;
            }
        }
        let block = this.getNextRenderedBlock(table);
        //Goto the next block.
        this.getParagraphFormatInternalInBlock(block, start, end);
    }
    /**
     * Get paragraph format in cell
     * @private
     */
    getParagraphFormatInCell(cell) {
        for (let i = 0; i < cell.childWidgets.length; i++) {
            this.getParagraphFormatInBlock(cell.childWidgets[i]);
        }
    }
    /**
     * @private
     */
    getParagraphFormatInBlock(block) {
        if (block instanceof ParagraphWidget) {
            this.getParagraphFormatInParagraph(block);
        }
        else {
            this.getParagraphFormatInTable(block);
        }
    }
    /**
     * @private
     */
    getParagraphFormatInTable(tableAdv) {
        for (let i = 0; i < tableAdv.childWidgets.length; i++) {
            let tableRow = tableAdv.childWidgets[i];
            for (let j = 0; j < tableRow.childWidgets.length; j++) {
                this.getParagraphFormatInCell(tableRow.childWidgets[j]);
            }
        }
    }
    /**
     * @private
     */
    getParagraphFormatInParagraph(paragraph) {
        this.paragraphFormat.combineFormat(paragraph.paragraphFormat);
    }
    /**
     * Get paragraph format in cell
     * @private
     */
    getParagraphFormatInternalInCell(cellAdv, start, end) {
        if (end.paragraph.isInsideTable) {
            let containerCell = this.getContainerCellOf(cellAdv, end.paragraph.associatedCell);
            if (containerCell.ownerTable.contains(end.paragraph.associatedCell)) {
                let startCell = this.getSelectedCell(cellAdv, containerCell);
                let endCell = this.getSelectedCell(end.paragraph.associatedCell, containerCell);
                if (this.containsCell(containerCell, end.paragraph.associatedCell)) {
                    //Selection end is in container cell.
                    if (this.isCellSelected(containerCell, start, end)) {
                        this.getParagraphFormatInCell(containerCell);
                    }
                    else {
                        if (startCell === containerCell) {
                            this.getParagraphFormatInternalInParagraph(start.paragraph, start, end);
                        }
                        else {
                            this.getParagraphFormatInRow(startCell.ownerRow, start, end);
                        }
                    }
                }
                else {
                    //Format other selected cells in current table.
                    this.getParaFormatForCell(containerCell.ownerTable, containerCell, endCell);
                }
            }
            else {
                this.getParagraphFormatInRow(containerCell.ownerRow, start, end);
            }
        }
        else {
            let cell = this.getContainerCell(cellAdv);
            this.getParagraphFormatInRow(cell.ownerRow, start, end);
        }
    }
    /**
     * @private
     */
    getParaFormatForCell(table, startCell, endCell) {
        let startCellIn = this.getCellLeft(startCell.ownerRow, startCell);
        let endCellIn = startCellIn + startCell.cellFormat.cellWidth;
        let endCellLeft = this.getCellLeft(endCell.ownerRow, endCell);
        let endCellRight = endCellLeft + endCell.cellFormat.cellWidth;
        if (startCellIn > endCellLeft) {
            startCellIn = endCellLeft;
        }
        if (endCellIn < endCellRight) {
            endCellIn = endCellRight;
        }
        if (startCellIn > this.upDownSelectionLength) {
            startCellIn = this.upDownSelectionLength;
        }
        if (startCellIn < this.upDownSelectionLength) {
            startCellIn = this.upDownSelectionLength;
        }
        let count = table.childWidgets.indexOf(endCell.ownerRow);
        for (let i = table.childWidgets.indexOf(startCell.ownerRow); i <= count; i++) {
            let tableRow = table.childWidgets[i];
            for (let j = 0; j < tableRow.childWidgets.length; j++) {
                let cell = tableRow.childWidgets[j];
                let left = this.getCellLeft(tableRow, cell);
                if (HelperMethods.round(startCellIn, 2) <= HelperMethods.round(left, 2)
                    && HelperMethods.round(left, 2) < HelperMethods.round(endCellIn, 2)) {
                    this.getParagraphFormatInCell(cell);
                }
            }
        }
    }
    /**
     * Get paragraph format ins row
     * @private
     */
    getParagraphFormatInRow(tableRow, start, end) {
        for (let i = tableRow.rowIndex; i < tableRow.ownerTable.childWidgets.length; i++) {
            let row = tableRow.ownerTable.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                this.getParagraphFormatInCell(row.childWidgets[j]);
            }
            if (end.paragraph.isInsideTable && this.containsRow(row, end.paragraph.associatedCell)) {
                return;
            }
        }
        let block = this.getNextRenderedBlock(tableRow.ownerTable);
        //Goto the next block.
        this.getParagraphFormatInternalInBlock(block, start, end);
    }
    // paragraph format retrieval implementation ends
    // Character format retrieval implementation starts.
    /**
     * Retrieve Selection character format
     * @private
     */
    retrieveCharacterFormat(start, end) {
        this.characterFormat.copyFormat(start.paragraph.characterFormat);
        if (start.paragraph === end.paragraph && start.currentWidget.isLastLine()
            && start.offset === this.getLineLength(start.currentWidget) && start.offset + 1 === end.offset) {
            return;
        }
        let para = start.paragraph;
        if (start.offset === this.getParagraphLength(para) && !this.isEmpty) {
            para = this.getNextParagraphBlock(para);
        }
        while (!isNullOrUndefined(para) && para !== end.paragraph && para.isEmpty()) {
            para = this.getNextParagraphBlock(para);
        }
        let offset = para === start.paragraph ? start.offset : 0;
        let indexInInline = 0;
        if (!isNullOrUndefined(para) && !para.isEmpty()) {
            let position = new TextPosition(this.owner);
            let elemInfo = start.currentWidget.getInline(offset, indexInInline);
            let physicalLocation = this.getPhysicalPositionInternal(start.currentWidget, offset, true);
            position.setPositionForSelection(start.currentWidget, elemInfo.element, elemInfo.index, physicalLocation);
            this.getCharacterFormatForSelection(para, this, position, end);
        }
    }
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getCharacterFormatForSelection(paragraph, selection, startPosition, endPosition) {
        //Selection start in cell.
        if (startPosition.paragraph instanceof ParagraphWidget && startPosition.paragraph.isInsideTable
            && (!endPosition.paragraph.isInsideTable
                || startPosition.paragraph.associatedCell !== endPosition.paragraph.associatedCell
                || this.isCellSelected(startPosition.paragraph.associatedCell, startPosition, endPosition))) {
            this.getCharacterFormatInTableCell(startPosition.paragraph.associatedCell, selection, startPosition, endPosition);
        }
        else {
            this.getCharacterFormat(paragraph, startPosition, endPosition);
        }
    }
    /**
     * Get Character format
     * @private
     */
    //Format Retrieval
    getCharacterFormatForTableRow(tableRowAdv, start, end) {
        for (let i = tableRowAdv.rowIndex; i < tableRowAdv.ownerTable.childWidgets.length; i++) {
            let tableRow = tableRowAdv.ownerTable.childWidgets[i];
            for (let j = 0; j < tableRow.childWidgets.length; j++) {
                this.getCharacterFormatForSelectionCell(tableRow.childWidgets[j], start, end);
            }
            if (end.paragraph.isInsideTable && this.containsRow(tableRow, end.paragraph.associatedCell)) {
                return;
            }
        }
        let block = this.getNextRenderedBlock(tableRowAdv.ownerTable);
        // //Goto the next block.
        this.getCharacterFormatForBlock(block, start, end);
    }
    /**
     * Get Character format in table
     * @private
     */
    getCharacterFormatInTableCell(tableCell, selection, start, end) {
        if (end.paragraph.isInsideTable) {
            let containerCell = this.getContainerCellOf(tableCell, end.paragraph.associatedCell);
            if (containerCell.ownerTable.contains(end.paragraph.associatedCell)) {
                let startCell = this.getSelectedCell(tableCell, containerCell);
                let endCell = this.getSelectedCell(end.paragraph.associatedCell, containerCell);
                if (this.containsCell(containerCell, end.paragraph.associatedCell)) {
                    //Selection end is in container cell.
                    if (this.isCellSelected(containerCell, start, end)) {
                        this.getCharacterFormatForSelectionCell(containerCell, start, end);
                    }
                    else {
                        if (startCell === containerCell) {
                            this.getCharacterFormat(start.paragraph, start, end);
                        }
                        else {
                            this.getCharacterFormatForTableRow(startCell.ownerRow, start, end);
                        }
                    }
                }
                else {
                    //Format other selected cells in current table.
                    this.getCharacterFormatInternalInTable(containerCell.ownerTable, containerCell, endCell, start, end);
                }
            }
            else {
                this.getCharacterFormatForTableRow(containerCell.ownerRow, start, end);
            }
        }
        else {
            let cell = this.getContainerCell(tableCell);
            this.getCharacterFormatForTableRow(cell.ownerRow, start, end);
        }
    }
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getCharacterFormatInternalInTable(table, startCell, endCell, startPosition, endPosition) {
        let startIn = this.getCellLeft(startCell.ownerRow, startCell);
        let endIn = startIn + startCell.cellFormat.cellWidth;
        let endCellLeft = this.getCellLeft(endCell.ownerRow, endCell);
        let endCellRight = endCellLeft + endCell.cellFormat.cellWidth;
        if (startIn > endCellLeft) {
            startIn = endCellLeft;
        }
        if (endIn < endCellRight) {
            endIn = endCellRight;
        }
        if (startIn > this.upDownSelectionLength) {
            startIn = this.upDownSelectionLength;
        }
        if (endIn < this.upDownSelectionLength) {
            endIn = this.upDownSelectionLength;
        }
        let count = table.childWidgets.indexOf(endCell.ownerRow);
        for (let i = table.childWidgets.indexOf(startCell.ownerRow); i <= count; i++) {
            let row = table.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                let left = this.getCellLeft(row, cell);
                if (HelperMethods.round(startIn, 2) <= HelperMethods.round(left, 2) &&
                    HelperMethods.round(left, 2) < HelperMethods.round(endIn, 2)) {
                    this.getCharacterFormatForSelectionCell(cell, startPosition, endPosition);
                }
            }
        }
    }
    /**
     * Get character format with in selection
     * @private
     */
    getCharacterFormat(paragraph, start, end) {
        if (paragraph !== start.paragraph && paragraph !== end.paragraph) {
            this.getCharacterFormatInternal(paragraph, this);
            return;
        }
        if (end.paragraph === paragraph && start.paragraph !== paragraph && end.offset === 0) {
            return;
        }
        let startOffset = 0;
        let length = this.getParagraphLength(paragraph);
        if (paragraph === start.paragraph) {
            startOffset = start.offset;
            //Sets selection character format.            
            let isUpdated = this.setCharacterFormat(paragraph, start, end, length);
            if (isUpdated) {
                return;
            }
        }
        let startLineWidget = paragraph.childWidgets.indexOf(start.currentWidget) !== -1 ?
            paragraph.childWidgets.indexOf(start.currentWidget) : 0;
        let endLineWidget = paragraph.childWidgets.indexOf(end.currentWidget) !== -1 ?
            paragraph.childWidgets.indexOf(end.currentWidget) : paragraph.childWidgets.length - 1;
        let endOffset = end.offset;
        if (paragraph !== end.paragraph) {
            endOffset = length;
        }
        let isFieldStartSelected = false;
        for (let i = startLineWidget; i <= endLineWidget; i++) {
            let lineWidget = paragraph.childWidgets[i];
            if (i !== startLineWidget) {
                startOffset = this.getStartLineOffset(lineWidget);
            }
            if (lineWidget === end.currentWidget) {
                endOffset = end.offset;
            }
            else {
                endOffset = this.getLineLength(lineWidget);
            }
            let count = 0;
            for (let j = 0; j < lineWidget.children.length; j++) {
                let inline = lineWidget.children[j];
                if (startOffset >= count + inline.length) {
                    count += inline.length;
                    continue;
                }
                if (inline instanceof FieldElementBox && inline.fieldType === 0
                    && HelperMethods.isLinkedFieldCharacter(inline)) {
                    let nextInline = isNullOrUndefined(inline.fieldSeparator) ?
                        inline.fieldEnd : inline.fieldSeparator;
                    do {
                        count += inline.length;
                        inline = inline.nextNode;
                        i++;
                    } while (!isNullOrUndefined(inline) && inline !== nextInline);
                    isFieldStartSelected = true;
                }
                if (inline instanceof FieldElementBox && inline.fieldType === 1
                    && HelperMethods.isLinkedFieldCharacter(inline) && isFieldStartSelected) {
                    let fieldInline = inline.fieldBegin;
                    do {
                        this.characterFormat.combineFormat(fieldInline.characterFormat);
                        fieldInline = fieldInline.nextNode;
                    } while (!(fieldInline instanceof FieldElementBox));
                }
                if (inline instanceof TextElementBox) {
                    this.characterFormat.combineFormat(inline.characterFormat);
                }
                if (isNullOrUndefined(inline) || endOffset <= count + inline.length) {
                    break;
                }
                count += inline.length;
            }
        }
        if (end.paragraph === paragraph) {
            return;
        }
        let block = this.getNextRenderedBlock(paragraph);
        if (!isNullOrUndefined(block)) {
            this.getCharacterFormatForBlock(block, start, end);
        }
    }
    setCharacterFormat(para, startPos, endPos, length) {
        let index = 0;
        let startOffset = startPos.offset;
        let inlineAndIndex = startPos.currentWidget.getInline(startOffset, index);
        index = inlineAndIndex.index;
        let inline = inlineAndIndex.element;
        if (isNullOrUndefined(inline)) {
            let currentLineIndex = startPos.paragraph.childWidgets.indexOf(startPos.currentWidget);
            if (startPos.currentWidget.previousLine) {
                inline = startPos.currentWidget.previousLine.children[startPos.currentWidget.previousLine.children.length - 1];
                this.characterFormat.copyFormat(inline.characterFormat);
                return true;
            }
        }
        if (startOffset < length) {
            if (this.isEmpty) {
                if (inline instanceof TextElementBox || (inline instanceof FieldElementBox
                    && (inline.fieldType === 0 || inline.fieldType === 1))) {
                    let previousNode = this.getPreviousTextElement(inline);
                    if (startOffset === 0 && previousNode) {
                        inline = previousNode;
                    }
                    this.characterFormat.copyFormat(inline.characterFormat);
                }
                else {
                    if (!isNullOrUndefined(this.getPreviousTextElement(inline))) {
                        this.characterFormat.copyFormat(this.getPreviousTextElement(inline).characterFormat);
                    }
                    else if (!isNullOrUndefined(this.getNextTextElement(inline))) {
                        this.characterFormat.copyFormat(this.getNextTextElement(inline).characterFormat);
                    }
                    else {
                        this.characterFormat.copyFormat(para.characterFormat);
                    }
                }
                return true;
            }
            else {
                if (index === inline.length && !isNullOrUndefined(inline.nextNode)) {
                    this.characterFormat.copyFormat(this.getNextValidCharacterFormat(inline));
                }
                else if (inline instanceof TextElementBox) {
                    this.characterFormat.copyFormat(inline.characterFormat);
                }
                else if (inline instanceof FieldElementBox) {
                    this.characterFormat.copyFormat(this.getNextValidCharacterFormatOfField(inline));
                }
            }
        }
        else {
            if (length === endPos.offset) {
                if (inline instanceof TextElementBox || inline instanceof FieldElementBox) {
                    this.characterFormat.copyFormat(inline.characterFormat);
                }
                else if (!isNullOrUndefined(inline)) {
                    inline = this.getPreviousTextElement(inline);
                    if (!isNullOrUndefined(inline)) {
                        this.characterFormat.copyFormat(inline.characterFormat);
                    }
                }
                else {
                    this.characterFormat.copyFormat(para.characterFormat);
                }
                return true;
            }
        }
        return false;
    }
    /**
     * @private
     */
    getCharacterFormatForBlock(block, start, end) {
        if (block instanceof ParagraphWidget) {
            this.getCharacterFormat(block, start, end);
        }
        else {
            this.getCharacterFormatInTable(block, start, end);
        }
    }
    /**
     * @private
     */
    getCharacterFormatInTable(table, start, end) {
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                this.getCharacterFormatForSelectionCell(row.childWidgets[j], start, end);
            }
            if (end.paragraph.isInsideTable && this.containsRow(row, end.paragraph.associatedCell)) {
                return;
            }
        }
        let blockAdv = this.getNextRenderedBlock(table);
        // //Goto the next block.
        this.getCharacterFormatForBlock(blockAdv, start, end);
    }
    /**
     * Get character format in selection
     * @private
     */
    getCharacterFormatForSelectionCell(cell, start, end) {
        for (let i = 0; i < cell.childWidgets.length; i++) {
            this.getCharacterFormatForBlock(cell.childWidgets[i], start, end);
        }
    }
    /**
     * @private
     */
    getCharacterFormatInternal(paragraph, selection) {
        for (let i = 0; i < paragraph.childWidgets.length; i++) {
            let linewidget = paragraph.childWidgets[i];
            for (let j = 0; j < linewidget.children.length; j++) {
                let element = linewidget.children[j];
                if (!(element instanceof ImageElementBox || element instanceof FieldElementBox)) {
                    selection.characterFormat.combineFormat(element.characterFormat);
                }
            }
        }
    }
    /**
     * Get next valid character format from inline
     * @private
     */
    getNextValidCharacterFormat(inline) {
        let startInline = this.getNextTextElement(inline);
        if (isNullOrUndefined(startInline)) {
            return inline.characterFormat;
        }
        let fieldBegin = undefined;
        if (startInline instanceof FieldElementBox) {
            if (fieldBegin.fieldType === 0) {
                fieldBegin = startInline;
            }
        }
        if (isNullOrUndefined(fieldBegin)) {
            return startInline.characterFormat;
        }
        else {
            return this.getNextValidCharacterFormatOfField(fieldBegin);
        }
    }
    /**
     * Get next valid paragraph format from field
     * @private
     */
    getNextValidCharacterFormatOfField(fieldBegin) {
        let startInline = fieldBegin;
        if (HelperMethods.isLinkedFieldCharacter(fieldBegin)) {
            if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
                startInline = fieldBegin.fieldEnd;
            }
            else {
                startInline = fieldBegin.fieldSeparator;
            }
        }
        let nextValidInline = undefined;
        if (!isNullOrUndefined(startInline.nextNode)) {
            //Check the next node is a valid and returns inline.
            nextValidInline = this.getNextValidElement(startInline.nextNode);
        }
        //If field separator/end exists at end of paragraph, then move to next paragraph.
        if (isNullOrUndefined(nextValidInline)) {
            return startInline.characterFormat;
        }
        return nextValidInline.characterFormat;
    }
    /**
     * Return true if cursor point with in selection range
     * @private
     */
    checkCursorIsInSelection(widget, point) {
        if (isNullOrUndefined(this.start) || this.isEmpty || isNullOrUndefined(widget)) {
            return false;
        }
        let isSelected = false;
        do {
            if (this.selectedWidgets.containsKey(widget)) {
                let top;
                let left;
                if (widget instanceof LineWidget) {
                    top = this.owner.selection.getTop(widget);
                    left = this.owner.selection.getLeft(widget);
                }
                else {
                    top = widget.y;
                    left = widget.x;
                }
                let widgetInfo = this.selectedWidgets.get(widget);
                isSelected = widgetInfo.left <= point.x && top <= point.y &&
                    top + widget.height >= point.y && widgetInfo.left + widgetInfo.width >= point.x;
            }
            widget = (widget instanceof LineWidget) ? widget.paragraph : widget.containerWidget;
        } while (!isNullOrUndefined(widget) && !isSelected);
        return isSelected;
    }
    /**
     * Copy paragraph for to selection paragraph format
     * @private
     */
    copySelectionParagraphFormat() {
        let format = new WParagraphFormat();
        this.paragraphFormat.copyToFormat(format);
        return format;
    }
    /**
     * Get hyperlink display text
     * @private
     */
    // tslint:disable-next-line
    getHyperlinkDisplayText(paragraph, fieldSeparator, fieldEnd, isNestedField, format) {
        let para = paragraph;
        if (para !== fieldEnd.line.paragraph) {
            isNestedField = true;
            return { displayText: '<<Selection in Document>>', 'isNestedField': isNestedField, 'format': format };
        }
        let displayText = '';
        let lineIndex = para.childWidgets.indexOf(fieldSeparator.line);
        let index = para.childWidgets[lineIndex].children.indexOf(fieldSeparator);
        for (let j = lineIndex; j < para.childWidgets.length; j++) {
            let lineWidget = para.childWidgets[j];
            if (j !== lineIndex) {
                index = -1;
            }
            for (let i = index + 1; i < lineWidget.children.length; i++) {
                let inline = lineWidget.children[i];
                if (inline === fieldEnd) {
                    return { 'displayText': displayText, 'isNestedField': isNestedField, 'format': format };
                }
                if (inline instanceof TextElementBox) {
                    displayText += inline.text;
                    format = inline.characterFormat;
                }
                else if (inline instanceof FieldElementBox) {
                    if (inline instanceof FieldElementBox && inline.fieldType === 0
                        && !isNullOrUndefined(inline.fieldEnd)) {
                        if (isNullOrUndefined(inline.fieldSeparator)) {
                            index = lineWidget.children.indexOf(inline.fieldEnd);
                        }
                        else {
                            index = lineWidget.children.indexOf(inline.fieldSeparator);
                        }
                    }
                }
                else {
                    isNestedField = true;
                    return { 'displayText': '<<Selection in Document>>', 'isNestedField': isNestedField, 'format': format };
                }
            }
        }
        return { 'displayText': displayText, 'isNestedField': isNestedField, 'format': format };
    }
    /**
     * Navigates hyperlink on mouse Event.
     * @private
     */
    navigateHyperLinkOnEvent(cursorPoint, isTouchInput) {
        let widget = this.viewer.getLineWidget(cursorPoint);
        if (!isNullOrUndefined(widget)) {
            let hyperLinkField = this.getHyperLinkFieldInCurrentSelection(widget, cursorPoint);
            //Invokes Hyperlink navigation events.
            if (!isNullOrUndefined(hyperLinkField)) {
                this.viewer.updateTextPositionForSelection(cursorPoint, 1);
                this.fireRequestNavigate(hyperLinkField);
                setTimeout(() => {
                    if (this.viewer) {
                        this.viewer.isTouchInput = isTouchInput;
                        this.viewer.updateFocus();
                        this.viewer.isTouchInput = false;
                    }
                });
            }
        }
    }
    /**
     * @private
     */
    getLinkText(fieldBegin) {
        let hyperlink = new Hyperlink(fieldBegin, this);
        let link = hyperlink.navigationLink;
        if (hyperlink.localReference.length > 0) {
            if (hyperlink.localReference[0] === '_' && (isNullOrUndefined(link) || link.length === 0)) {
                link = 'Current Document';
            }
            else {
                link += '#' + hyperlink.localReference;
            }
        }
        hyperlink.destroy();
        return link;
    }
    /**
     * Set Hyperlink content to tool tip element
     * @private
     */
    setHyperlinkContentToToolTip(fieldBegin, widget, xPos) {
        if (fieldBegin) {
            if (this.owner.contextMenuModule &&
                this.owner.contextMenuModule.contextMenuInstance.element.style.display === 'block') {
                return;
            }
            if (!this.toolTipElement) {
                this.toolTipElement = createElement('div', { className: 'e-de-tooltip' });
                this.viewer.viewerContainer.appendChild(this.toolTipElement);
            }
            this.toolTipElement.style.display = 'block';
            let l10n = new L10n('documenteditor', this.owner.defaultLocale);
            l10n.setLocale(this.owner.locale);
            let toolTipText = l10n.getConstant('Click to follow link');
            if (this.owner.useCtrlClickToFollowHyperlink) {
                toolTipText = 'Ctrl+' + toolTipText;
            }
            let linkText = this.getLinkText(fieldBegin);
            this.toolTipElement.innerHTML = linkText + '</br><b>' + toolTipText + '</b>';
            let widgetTop = this.getTop(widget) * this.viewer.zoomFactor;
            let page = this.getPage(widget.paragraph);
            let containerWidth = this.viewer.viewerContainer.getBoundingClientRect().width + this.viewer.viewerContainer.scrollLeft;
            let left = page.boundingRectangle.x + xPos * this.viewer.zoomFactor;
            if ((left + this.toolTipElement.clientWidth + 10) > containerWidth) {
                left = left - ((this.toolTipElement.clientWidth - (containerWidth - left)) + 15);
            }
            let top = this.getPageTop(page) + (widgetTop - this.toolTipElement.offsetHeight);
            top = top > this.viewer.viewerContainer.scrollTop ? top : top + widget.height + this.toolTipElement.offsetHeight;
            this.showToolTip(left, top);
            if (!isNullOrUndefined(this.toolTipField) && fieldBegin !== this.toolTipField) {
                this.toolTipObject.position = { X: left, Y: top };
            }
            this.toolTipObject.show();
            this.toolTipField = fieldBegin;
        }
        else {
            this.hideToolTip();
        }
    }
    /**
     * Show hyperlink tooltip
     * @private
     */
    showToolTip(x, y) {
        if (!this.toolTipObject) {
            this.toolTipObject = new Popup(this.toolTipElement, {
                height: 'auto',
                width: 'auto',
                relateTo: this.viewer.viewerContainer.parentElement,
                position: { X: x, Y: y }
            });
        }
    }
    /**
     * Hide tooltip object
     * @private
     */
    hideToolTip() {
        this.toolTipField = undefined;
        if (this.toolTipObject) {
            this.toolTipObject.hide();
            this.toolTipObject.destroy();
            this.toolTipObject = undefined;
            this.toolTipElement.style.display = 'none';
        }
    }
    /**
     * Return hyperlink field
     * @private
     */
    getHyperLinkFieldInCurrentSelection(widget, cursorPosition) {
        let inline = undefined;
        let top = this.getTop(widget);
        let lineStartLeft = this.getLineStartLeft(widget);
        if (cursorPosition.y < top || cursorPosition.y > top + widget.height
            || cursorPosition.x < lineStartLeft || cursorPosition.x > lineStartLeft + widget.paragraph.width) {
            return undefined;
        }
        let left = widget.paragraph.x;
        let elementValues = this.getFirstElement(widget, left);
        left = elementValues.left;
        let element = elementValues.element;
        if (isNullOrUndefined(element)) {
            let width = this.viewer.textHelper.getParagraphMarkWidth(widget.paragraph.characterFormat);
            if (cursorPosition.x <= lineStartLeft + width || cursorPosition.x >= lineStartLeft + width) {
                //Check if paragraph is within a field result.
                let checkedFields = [];
                let field = this.getHyperLinkFields(widget.paragraph, checkedFields);
                checkedFields = [];
                checkedFields = undefined;
                return field;
            }
        }
        else {
            if (cursorPosition.x > left + element.margin.left) {
                for (let i = widget.children.indexOf(element); i < widget.children.length; i++) {
                    element = widget.children[i];
                    if (cursorPosition.x < left + element.margin.left + element.width || i === widget.children.length - 1) {
                        break;
                    }
                    left += element.margin.left + element.width;
                }
            }
            inline = element;
            let width = element.margin.left + element.width;
            if (isNullOrUndefined(inline.nextNode)) {
                //Include width of Paragraph mark.
                width += this.viewer.textHelper.getParagraphMarkWidth(inline.line.paragraph.characterFormat);
            }
            if (cursorPosition.x <= left + width) {
                //Check if inline is within a field result.
                let checkedFields = [];
                let field = this.getHyperLinkFieldInternal(inline.line.paragraph, inline, checkedFields);
                checkedFields = [];
                checkedFields = undefined;
                return field;
            }
        }
        return undefined;
    }
    /**
     * Return field if paragraph contain hyperlink field
     * @private
     */
    getHyperlinkField() {
        if (isNullOrUndefined(this.end)) {
            return undefined;
        }
        let index = 0;
        let currentInline = this.end.currentWidget.getInline(this.end.offset, index);
        index = currentInline.index;
        let inline = currentInline.element;
        let checkedFields = [];
        let field = undefined;
        if (isNullOrUndefined(inline)) {
            field = this.getHyperLinkFields(this.end.paragraph, checkedFields);
        }
        else {
            let paragraph = inline.line.paragraph;
            field = this.getHyperLinkFieldInternal(paragraph, inline, checkedFields);
        }
        checkedFields = [];
        return field;
    }
    /**
     * @private
     */
    getHyperLinkFields(paragraph, checkedFields) {
        for (let i = 0; i < this.viewer.fields.length; i++) {
            if (checkedFields.indexOf(this.viewer.fields[i]) !== -1 || isNullOrUndefined(this.viewer.fields[i].fieldSeparator)) {
                continue;
            }
            else {
                checkedFields.push(this.viewer.fields[i]);
            }
            let field = this.getFieldCode(this.viewer.fields[i]);
            field = field.trim().toLowerCase();
            if (field.match('hyperlink ') && this.paragraphIsInFieldResult(this.viewer.fields[i], paragraph)) {
                return this.viewer.fields[i];
            }
        }
        // if (paragraph.containerWidget instanceof BodyWidget && !(paragraph instanceof WHeaderFooter)) {
        //     return this.getHyperLinkFields((paragraph.con as WCompositeNode), checkedFields);
        // }
        return undefined;
    }
    /**
     * @private
     */
    getHyperLinkFieldInternal(paragraph, inline, fields) {
        for (let i = 0; i < this.viewer.fields.length; i++) {
            if (fields.indexOf(this.viewer.fields[i]) !== -1 || isNullOrUndefined(this.viewer.fields[i].fieldSeparator)) {
                continue;
            }
            else {
                fields.push(this.viewer.fields[i]);
            }
            let fieldCode = this.getFieldCode(this.viewer.fields[i]);
            fieldCode = fieldCode.trim().toLowerCase();
            if (fieldCode.match('hyperlink ') && (this.inlineIsInFieldResult(this.viewer.fields[i], inline) || this.isImageField())) {
                return this.viewer.fields[i];
            }
        }
        if (paragraph.containerWidget instanceof BodyWidget && !(paragraph instanceof HeaderFooterWidget)) {
            return this.getHyperLinkFieldInternal(paragraph.containerWidget, inline, fields);
        }
        return undefined;
    }
    /**
     * @private
     */
    getBlock(currentIndex) {
        if (currentIndex === '' || isNullOrUndefined(currentIndex)) {
            return undefined;
        }
        let index = { index: currentIndex };
        let page = this.start.getPage(index);
        let bodyIndex = index.index.indexOf(';');
        let value = index.index.substring(0, bodyIndex);
        index.index = index.index.substring(bodyIndex).replace(';', '');
        let bodyWidget = page.bodyWidgets[parseInt(value, 10)];
        return this.getBlockInternal(bodyWidget, index.index);
    }
    /**
     * Return Block relative to position
     * @private
     */
    getBlockInternal(widget, position) {
        if (position === '' || isNullOrUndefined(position)) {
            return undefined;
        }
        let index = position.indexOf(';');
        let value = position.substring(0, index);
        position = position.substring(index).replace(';', '');
        let node = widget;
        // if (node instanceof Widget && value === 'HF') {
        //     //Gets the block in Header footers.
        //     let blockObj: BlockInfo = this.getBlock((node as WSection).headersFooters, position);
        // tslint:disable-next-line:max-line-length
        //     return { 'node': (!isNullOrUndefined(blockObj)) ? blockObj.node : undefined, 'position': (!isNullOrUndefined(blockObj)) ? blockObj.position : undefined };
        // }
        index = parseInt(value, 10);
        if (index >= 0 && index < widget.childWidgets.length) {
            let child = widget.childWidgets[(index)];
            if (position.indexOf(';') >= 0) {
                if (child instanceof ParagraphWidget) {
                    if (position.indexOf(';') >= 0) {
                        position = '0';
                    }
                    return child;
                }
                if (child instanceof BlockWidget) {
                    let blockObj = this.getBlockInternal(child, position);
                    return blockObj;
                }
            }
            else {
                return child;
            }
        }
        else {
            return node;
        }
        return node;
    }
    /**
     * Return true if inline is in field result
     * @private
     */
    inlineIsInFieldResult(fieldBegin, inline) {
        if (!isNullOrUndefined(fieldBegin.fieldEnd) && !isNullOrUndefined(fieldBegin.fieldSeparator)) {
            if (this.isExistBeforeInline(fieldBegin.fieldSeparator, inline)) {
                return this.isExistAfterInline(fieldBegin.fieldEnd, inline);
            }
        }
        return false;
    }
    /**
     * Retrieve true if paragraph is in field result
     * @private
     */
    paragraphIsInFieldResult(fieldBegin, paragraph) {
        if (!isNullOrUndefined(fieldBegin.fieldEnd) && !isNullOrUndefined(fieldBegin.fieldSeparator)) {
            let fieldParagraph = fieldBegin.fieldSeparator.line.paragraph;
            if (fieldBegin.fieldSeparator.line.paragraph === paragraph
                || this.isExistBefore(fieldParagraph, paragraph)) {
                let currentParagraph = fieldBegin.fieldEnd.line.paragraph;
                return (currentParagraph !== paragraph && this.isExistAfter(fieldParagraph, paragraph));
            }
        }
        return false;
    }
    /**
     * Return true if image is In field
     * @private
     */
    isImageField() {
        if (this.start.paragraph.isEmpty() || this.end.paragraph.isEmpty()) {
            return false;
        }
        let startPosition = this.start;
        let endPosition = this.end;
        if (!this.isForward) {
            startPosition = this.end;
            endPosition = this.start;
        }
        let indexInInline = 0;
        let inlineInfo = startPosition.paragraph.getInline(startPosition.offset, indexInInline);
        let inline = inlineInfo.element;
        indexInInline = inlineInfo.index;
        if (indexInInline === inline.length) {
            inline = this.getNextRenderedElementBox(inline, indexInInline);
        }
        inlineInfo = endPosition.paragraph.getInline(endPosition.offset, indexInInline);
        let endInline = inlineInfo.element;
        indexInInline = inlineInfo.index;
        if (inline instanceof FieldElementBox && inline.fieldType === 0
            && endInline instanceof FieldElementBox && endInline.fieldType === 1 && inline.fieldSeparator) {
            let fieldValue = inline.fieldSeparator.nextNode;
            if (fieldValue instanceof ImageElementBox && fieldValue.nextNode === endInline) {
                return true;
            }
        }
        return false;
    }
    /**
     * Select List Text
     * @private
     */
    selectListText() {
        let lineWidget = this.viewer.selectionLineWidget;
        let endOffset = '0';
        let selectionIndex = lineWidget.getHierarchicalIndex(endOffset);
        let startPosition = this.getTextPosition(selectionIndex);
        let endPosition = this.getTextPosition(selectionIndex);
        this.selectRange(startPosition, endPosition);
        this.highlightListText(this.viewer.selectionLineWidget);
        this.contextTypeInternal = 'List';
    }
    /**
     * Manually select the list text
     * @private
     */
    highlightListText(linewidget) {
        let width = linewidget.children[0].width;
        let left = this.viewer.getLeftValue(linewidget);
        let top = linewidget.paragraph.y;
        this.createHighlightBorder(linewidget, width, left, top);
        this.viewer.isListTextSelected = true;
    }
    /**
     * @private
     */
    updateImageSize(imageFormat) {
        this.owner.isShiftingEnabled = true;
        let startPosition = this.start;
        let endPosition = this.end;
        if (!this.isForward) {
            startPosition = this.end;
            endPosition = this.start;
        }
        let inline = null;
        let index = 0;
        let paragraph = startPosition.paragraph;
        if (paragraph === endPosition.paragraph
            && startPosition.offset + 1 === endPosition.offset) {
            let inlineObj = paragraph.getInline(endPosition.offset, index);
            inline = inlineObj.element;
            index = inlineObj.index;
        }
        if (inline instanceof ImageElementBox) {
            let width = inline.width;
            let height = inline.height;
            inline.width = imageFormat.width;
            inline.height = imageFormat.height;
            imageFormat.width = width;
            imageFormat.height = height;
            if (paragraph != null && paragraph.containerWidget != null && this.owner.editorModule) {
                let lineIndex = paragraph.childWidgets.indexOf(inline.line);
                let elementIndex = inline.line.children.indexOf(inline);
                this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, elementIndex);
                this.highlightSelection(false);
            }
        }
    }
    /**
     * Gets selected table content
     * @private
     */
    getSelectedCellsInTable(table, startCell, endCell) {
        let startColumnIndex = startCell.columnIndex;
        let endColumnIndex = endCell.columnIndex + endCell.cellFormat.columnSpan - 1;
        let startRowindex = startCell.ownerRow.index;
        let endRowIndex = endCell.ownerRow.index;
        let cells = [];
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            if (row.index >= startRowindex && row.index <= endRowIndex) {
                for (let j = 0; j < row.childWidgets.length; j++) {
                    let cell = row.childWidgets[j];
                    if (cell.columnIndex >= startColumnIndex && cell.columnIndex <= endColumnIndex) {
                        cells.push(cell);
                    }
                }
            }
            if (row.index > endRowIndex) {
                break;
            }
        }
        return cells;
        // return html;
    }
    /**
     * Copies the selected content to clipboard.
     */
    copy() {
        if (this.isEmpty) {
            return;
        }
        this.copySelectedContent(false);
    }
    /**
     * @private
     */
    copySelectedContent(isCut) {
        if (isNullOrUndefined(this.owner.sfdtExportModule)) {
            return;
        }
        let startPosition = this.start;
        let endPosition = this.end;
        if (!this.isForward) {
            startPosition = this.end;
            endPosition = this.start;
        }
        /* tslint:disable:no-any */
        // tslint:disable-next-line:max-line-length
        let document = this.owner.sfdtExportModule.write(startPosition.currentWidget, startPosition.offset, endPosition.currentWidget, endPosition.offset, true);
        /* tslint:enable:no-any */
        if (this.owner.editorModule) {
            this.owner.editorModule.copiedData = JSON.stringify(document);
        }
        let html = this.htmlWriter.writeHtml(document);
        this.copyToClipboard(html);
        if (isCut && this.owner.editorModule) {
            this.owner.editorModule.handleCut(this);
        }
        this.viewer.updateFocus();
    }
    /**
     * Copy content to clipboard
     * @private
     */
    copyToClipboard(htmlContent) {
        window.getSelection().removeAllRanges();
        let div = document.createElement('div');
        div.style.left = '-10000px';
        div.style.top = '-10000px';
        div.innerHTML = htmlContent;
        document.body.appendChild(div);
        let range = document.createRange();
        range.selectNodeContents(div);
        window.getSelection().addRange(range);
        let copySuccess = false;
        try {
            copySuccess = document.execCommand('copy');
        }
        catch (e) {
            // Copying data to Clipboard can potentially fail - for example, if another application is holding Clipboard open.
        }
        finally {
            window.getSelection().removeAllRanges();
            div.parentNode.removeChild(div);
            this.viewer.viewerContainer.focus();
        }
        return copySuccess;
    }
    // Caret implementation starts
    /**
     * Shows caret in current selection position.
     * @private
     */
    showCaret() {
        // tslint:disable-next-line:max-line-length
        let page = !isNullOrUndefined(this.viewer.currentPage) ? this.viewer.currentPage : this.viewer.currentRenderingPage;
        if (isNullOrUndefined(page) || this.viewer.isRowOrCellResizing || this.owner.enableImageResizerMode && this.owner.imageResizerModule.isImageResizerVisible) {
            return;
        }
        let left = page.boundingRectangle.x;
        let right = page.boundingRectangle.width * this.viewer.zoomFactor + left;
        if (!this.owner.enableImageResizerMode || !this.owner.imageResizerModule.isImageResizerVisible) {
            // tslint:disable-next-line:max-line-length
            if (this.isEmpty && (!this.owner.isReadOnlyMode || this.owner.enableCursorOnReadOnly)) {
                let caretLeft = parseInt(this.caret.style.left.replace('px', ''), 10);
                if (caretLeft < left || caretLeft > right) {
                    this.caret.style.display = 'none';
                }
                else {
                    this.caret.style.display = 'block';
                }
            }
            else if (this.isImageSelected && !this.owner.enableImageResizerMode) {
                this.caret.style.display = 'block';
            }
            else {
                if (this.caret.style.display === 'block' || isNullOrUndefined(this)) {
                    this.caret.style.display = 'none';
                }
            }
        }
        if (!isNullOrUndefined(this) && this.viewer.isTouchInput && !this.owner.isReadOnlyMode) {
            let caretStartLeft = parseInt(this.viewer.touchStart.style.left.replace('px', ''), 10) + 14;
            let caretEndLeft = parseInt(this.viewer.touchEnd.style.left.replace('px', ''), 10) + 14;
            let page = this.getSelectionPage(this.start);
            if (page) {
                if (caretEndLeft < left || caretEndLeft > right) {
                    this.viewer.touchEnd.style.display = 'none';
                }
                else {
                    this.viewer.touchEnd.style.display = 'block';
                }
                if (!this.isEmpty) {
                    left = page.boundingRectangle.x;
                    right = page.boundingRectangle.width * this.viewer.zoomFactor + left;
                }
                if (caretStartLeft < left || caretStartLeft > right) {
                    this.viewer.touchStart.style.display = 'none';
                }
                else {
                    this.viewer.touchStart.style.display = 'block';
                }
            }
        }
        else {
            this.viewer.touchStart.style.display = 'none';
            this.viewer.touchEnd.style.display = 'none';
        }
    }
    /**
     * To set the editable div caret position
     * @private
     */
    setEditableDivCaretPosition(index) {
        this.viewer.editableDiv.focus();
        let child = this.viewer.editableDiv.childNodes[this.viewer.editableDiv.childNodes.length - 1];
        if (child) {
            let range = document.createRange();
            range.setStart(child, index);
            range.collapse(true);
            window.getSelection().removeAllRanges();
            window.getSelection().addRange(range);
        }
    }
    /**
     * Initializes caret.
     * @private
     */
    initCaret() {
        this.caret = createElement('div', {
            styles: 'position:absolute',
            className: 'e-de-blink-cursor e-de-cursor-animation'
        });
        this.viewer.viewerContainer.appendChild(this.caret);
    }
    /**
     * Updates caret position.
     * @private
     */
    updateCaretPosition() {
        let caretPosition = this.end.location;
        let page = this.getSelectionPage(this.end);
        if (page) {
            this.caret.style.left = page.boundingRectangle.x + (Math.round(caretPosition.x) * this.viewer.zoomFactor) + 'px';
            let caretInfo = this.updateCaretSize(this.owner.selection.end);
            let topMargin = caretInfo.topMargin;
            let caretHeight = caretInfo.height;
            let viewer = this.viewer;
            // tslint:disable-next-line:max-line-length
            let pageTop = (page.boundingRectangle.y - viewer.pageGap * (this.viewer.pages.indexOf(page) + 1)) * this.viewer.zoomFactor + viewer.pageGap * (this.viewer.pages.indexOf(page) + 1);
            this.caret.style.top = pageTop + (Math.round(caretPosition.y + topMargin) * this.viewer.zoomFactor) + 'px';
            if (this.owner.selection.characterFormat.baselineAlignment === 'Subscript') {
                this.caret.style.top = parseFloat(this.caret.style.top) + (parseFloat(this.caret.style.height) / 2) + 'px';
            }
            if (this.viewer.isTouchInput || this.viewer.touchStart.style.display !== 'none') {
                // tslint:disable-next-line:max-line-length
                this.viewer.touchStart.style.left = page.boundingRectangle.x + (Math.round(caretPosition.x) * this.viewer.zoomFactor - 14) + 'px';
                this.viewer.touchStart.style.top = pageTop + ((caretPosition.y + caretInfo.height) * this.viewer.zoomFactor) + 'px';
                // tslint:disable-next-line:max-line-length
                this.viewer.touchEnd.style.left = page.boundingRectangle.x + (Math.round(caretPosition.x) * this.viewer.zoomFactor - 14) + 'px';
                this.viewer.touchEnd.style.top = pageTop + ((caretPosition.y + caretInfo.height) * this.viewer.zoomFactor) + 'px';
            }
        }
    }
    /**
     * Gets current selected page
     */
    getSelectionPage(position) {
        let lineWidget = this.getLineWidgetInternal(position.currentWidget, position.offset, true);
        if (lineWidget) {
            return this.getPage(lineWidget.paragraph);
        }
        return undefined;
    }
    /**
     * Updates caret size.
     * @private
     */
    updateCaretSize(textPosition, skipUpdate) {
        let topMargin = 0;
        let isItalic = false;
        let caret;
        let index = 0;
        let caretHeight = 0;
        if (this.characterFormat.italic) {
            isItalic = this.characterFormat.italic;
        }
        if (textPosition.paragraph.isEmpty()) {
            let paragraph = textPosition.paragraph;
            let bottomMargin = 0;
            let paragraphInfo = this.getParagraphMarkSize(paragraph, topMargin, bottomMargin);
            topMargin = paragraphInfo.topMargin;
            bottomMargin = paragraphInfo.bottomMargin;
            let height = paragraphInfo.height;
            caretHeight = topMargin < 0 ? topMargin + height : height;
            if (!skipUpdate) {
                this.caret.style.height = caretHeight * this.viewer.zoomFactor + 'px';
            }
            topMargin = 0;
        }
        else {
            let inlineInfo = textPosition.currentWidget.getInline(textPosition.offset, index);
            index = inlineInfo.index;
            let inline = inlineInfo.element;
            if (!isNullOrUndefined(inline)) {
                caret = this.getCaretHeight(inline, index, inline.characterFormat, true, topMargin, isItalic);
                caretHeight = caret.height;
                if (!skipUpdate) {
                    this.caret.style.height = caret.height * this.viewer.zoomFactor + 'px';
                }
            }
        }
        if (!skipUpdate) {
            if (isItalic) {
                this.caret.style.transform = 'rotate(13deg)';
            }
            else {
                this.caret.style.transform = '';
            }
        }
        return {
            'topMargin': topMargin,
            'height': caretHeight
        };
    }
    /**
     * Updates caret to page.
     * @private
     */
    updateCaretToPage(startPosition, endPage) {
        if (!isNullOrUndefined(endPage)) {
            this.viewer.selectionEndPage = endPage;
            if (this.owner.selection.isEmpty) {
                this.viewer.selectionStartPage = endPage;
            }
            else {
                // tslint:disable-next-line:max-line-length
                let startLineWidget = this.getLineWidgetParagraph(startPosition.offset, startPosition.paragraph.childWidgets[0]);
                //Gets start page.
                let startPage = this.getPage(startLineWidget.paragraph);
                if (!isNullOrUndefined(startPage)) {
                    this.viewer.selectionStartPage = startPage;
                }
            }
        }
        this.checkForCursorVisibility();
    }
    /**
     * Gets caret bottom position.
     * @private
     */
    getCaretBottom(textPosition, isEmptySelection) {
        let bottom = textPosition.location.y;
        if (textPosition.paragraph.isEmpty()) {
            let paragraph = textPosition.paragraph;
            let topMargin = 0;
            let bottomMargin = 0;
            let sizeInfo = this.getParagraphMarkSize(paragraph, topMargin, bottomMargin);
            topMargin = sizeInfo.topMargin;
            bottomMargin = sizeInfo.bottomMargin;
            bottom += sizeInfo.height;
            bottom += topMargin;
            if (!isEmptySelection) {
                bottom += bottomMargin;
            }
        }
        else {
            let index = 0;
            let inlineInfo = textPosition.paragraph.getInline(textPosition.offset, index);
            let inline = inlineInfo.element;
            index = inlineInfo.index;
            let topMargin = 0;
            let isItalic = false;
            // tslint:disable-next-line:max-line-length
            let caretHeightInfo = this.getCaretHeight(inline, index, inline.characterFormat, false, topMargin, isItalic);
            topMargin = caretHeightInfo.topMargin;
            isItalic = caretHeightInfo.isItalic;
            bottom += caretHeightInfo.height;
            if (isEmptySelection) {
                bottom -= HelperMethods.convertPointToPixel(textPosition.paragraph.paragraphFormat.afterSpacing);
            }
        }
        return bottom;
    }
    /**
     * Checks for cursor visibility.
     * @param isTouch
     * @private
     */
    checkForCursorVisibility() {
        this.showCaret();
    }
    // caret implementation ends
    /**
     * Keyboard shortcuts
     * @private
     */
    // tslint:disable:max-func-body-length
    onKeyDownInternal(event, ctrl, shift, alt) {
        let key = event.which || event.keyCode;
        if (ctrl && !shift && !alt) {
            this.viewer.isControlPressed = true;
            switch (key) {
                // case 9:
                //     event.preventDefault();
                //     if (this.owner.acceptTab) {
                //         this.selection.handleTabKey(false, false);
                //     }
                //     break;
                case 35:
                    this.handleControlEndKey();
                    break;
                case 36:
                    this.handleControlHomeKey();
                    break;
                case 37:
                    this.handleControlLeftKey();
                    break;
                case 38:
                    this.handleControlUpKey();
                    break;
                case 39:
                    this.handleControlRightKey();
                    break;
                case 40:
                    this.handleControlDownKey();
                    break;
                case 65:
                    this.owner.selection.selectAll();
                    break;
                case 67:
                    event.preventDefault();
                    this.copy();
                    break;
                case 70:
                    event.preventDefault();
                    if (!isNullOrUndefined(this.owner.optionsPaneModule)) {
                        this.owner.optionsPaneModule.showHideOptionsPane(true);
                    }
                    break;
            }
        }
        else if (shift && !ctrl && !alt) {
            switch (key) {
                case 35:
                    this.handleShiftEndKey();
                    event.preventDefault();
                    break;
                case 36:
                    this.handleShiftHomeKey();
                    event.preventDefault();
                    break;
                case 37:
                    this.handleShiftLeftKey();
                    event.preventDefault();
                    break;
                case 38:
                    this.handleShiftUpKey();
                    event.preventDefault();
                    break;
                case 39:
                    this.handleShiftRightKey();
                    event.preventDefault();
                    break;
                case 40:
                    this.handleShiftDownKey();
                    event.preventDefault();
                    break;
            }
        }
        else if (shift && ctrl && !alt) {
            switch (key) {
                case 35:
                    this.handleControlShiftEndKey();
                    break;
                case 36:
                    this.handleControlShiftHomeKey();
                    break;
                case 37:
                    this.handleControlShiftLeftKey();
                    break;
                case 38:
                    this.handleControlShiftUpKey();
                    break;
                case 39:
                    this.handleControlShiftRightKey();
                    break;
                case 40:
                    this.handleControlShiftDownKey();
                    break;
            }
        }
        else {
            switch (key) {
                // case 9:
                //     event.preventDefault();
                //     if (this.owner.acceptTab) {
                //         this.handleTabKey(true, false);
                //     }
                //     break;             
                case 33:
                    event.preventDefault();
                    this.viewer.viewerContainer.scrollTop -= this.viewer.visibleBounds.height;
                    break;
                case 34:
                    event.preventDefault();
                    this.viewer.viewerContainer.scrollTop += this.viewer.visibleBounds.height;
                    break;
                case 35:
                    this.handleEndKey();
                    event.preventDefault();
                    break;
                case 36:
                    this.handleHomeKey();
                    event.preventDefault();
                    break;
                case 37:
                    this.handleLeftKey();
                    event.preventDefault();
                    break;
                case 38:
                    this.handleUpKey();
                    event.preventDefault();
                    break;
                case 39:
                    this.handleRightKey();
                    event.preventDefault();
                    break;
                case 40:
                    this.handleDownKey();
                    event.preventDefault();
                    break;
            }
        }
        if (!this.owner.isReadOnlyMode) {
            this.owner.editorModule.onKeyDownInternal(event, ctrl, shift, alt);
        }
        if (this.owner.searchModule) {
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(this.owner.searchModule.searchHighlighters) && this.owner.searchModule.searchHighlighters.length > 0) {
                this.owner.searchModule.searchResults.clear();
            }
        }
        if (event.keyCode === 27 || event.which === 27) {
            if (!isNullOrUndefined(this.owner.optionsPaneModule)) {
                this.owner.optionsPaneModule.showHideOptionsPane(false);
            }
            if (this.owner.enableHeaderAndFooter) {
                this.disableHeaderFooter();
            }
        }
    }
    //#region Enable or disable Header Footer
    /**
     * @private
     */
    checkAndEnableHeaderFooter(point, pagePoint) {
        let page = this.viewer.currentPage;
        if (this.isCursorInsidePageRect(point, page)) {
            if (this.isCursorInHeaderRegion(point, page)) {
                if (this.owner.enableHeaderAndFooter) {
                    return false;
                }
                return this.enableHeadersFootersRegion(page.headerWidget);
            }
            if (this.isCursorInFooterRegion(point, page)) {
                if (this.owner.enableHeaderAndFooter) {
                    return false;
                }
                return this.enableHeadersFootersRegion(page.footerWidget);
            }
        }
        if (this.owner.enableHeaderAndFooter) {
            this.owner.enableHeaderAndFooter = false;
            this.viewer.updateTextPositionForSelection(pagePoint, 1);
            return true;
        }
        return false;
    }
    /**
     * @private
     */
    isCursorInsidePageRect(point, page) {
        if ((this.viewer.containerLeft + point.x) >= page.boundingRectangle.x &&
            (this.viewer.containerLeft + point.x) <= (page.boundingRectangle.x + (page.boundingRectangle.width * this.viewer.zoomFactor))) {
            return true;
        }
        return false;
    }
    /**
     * @private
     */
    isCursorInHeaderRegion(point, page) {
        let pageTop = this.getPageTop(page);
        let headerHeight = 0;
        if (page.headerWidget) {
            headerHeight = (page.headerWidget.y + page.headerWidget.height);
        }
        let height = Math.max(headerHeight, HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.topMargin))
            * this.viewer.zoomFactor;
        if ((this.viewer.containerTop + point.y) >= pageTop && (this.viewer.containerTop + point.y) <= pageTop + height) {
            return true;
        }
        return false;
    }
    /**
     * @private
     */
    isCursorInFooterRegion(point, page) {
        let pageRect = page.boundingRectangle;
        let pageTop = this.getPageTop(page);
        let pageBottom = pageTop + (pageRect.height * this.viewer.zoomFactor);
        let footerDistance = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.footerDistance);
        let footerHeight = 0;
        if (page.footerWidget) {
            footerHeight = page.footerWidget.height;
        }
        // tslint:disable-next-line:max-line-length
        let height = (pageRect.height -
            Math.max(footerHeight + footerDistance, HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.bottomMargin))) * this.viewer.zoomFactor;
        if ((this.viewer.containerTop + point.y) <= pageBottom && (this.viewer.containerTop + point.y) >= pageTop + height) {
            return true;
        }
        return false;
    }
    /**
     * @private
     */
    enableHeadersFootersRegion(widget) {
        this.owner.enableHeaderAndFooter = true;
        this.updateTextPositionForBlockContainer(widget);
        return true;
    }
    /**
     * @private
     */
    updateTextPositionForBlockContainer(widget) {
        let block = widget.firstChild;
        if (block instanceof TableWidget) {
            block = this.getFirstBlockInFirstCell(block);
        }
        this.selectParagraph(block, true);
    }
    /**
     * Disable Header footer
     * @private
     */
    disableHeaderFooter() {
        let page = this.getPage(this.start.paragraph);
        this.updateTextPositionForBlockContainer(page.bodyWidgets[0]);
        this.owner.enableHeaderAndFooter = false;
    }
    //#endregion
    /**
     * @private
     */
    destroy() {
        if (!isNullOrUndefined(this.contextTypeInternal)) {
            this.contextTypeInternal = undefined;
        }
        this.caret = undefined;
        this.contextTypeInternal = undefined;
        this.upDownSelectionLength = undefined;
        this.viewer = undefined;
        this.owner = undefined;
    }
    /**
     * Navigates to the specified bookmark.
     * @param name
     * @param moveToStart
     * @private
     */
    navigateBookmark(name, moveToStart) {
        let bookmarks = this.viewer.bookmarks;
        if (bookmarks.containsKey(name)) {
            //bookmark start element
            let bookmrkElmnt = bookmarks.get(name);
            let offset = bookmrkElmnt.line.getOffset(bookmrkElmnt, 1);
            let startPosition = new TextPosition(this.viewer.owner);
            startPosition.setPositionParagraph(bookmrkElmnt.line, offset);
            if (moveToStart) {
                this.viewer.selection.selectRange(startPosition, startPosition);
            }
            else {
                //bookmark end element
                let bookmrkEnd = bookmrkElmnt.reference;
                let endoffset = bookmrkEnd.line.getOffset(bookmrkEnd, 0);
                let endPosition = new TextPosition(this.viewer.owner);
                endPosition.setPositionParagraph(bookmrkEnd.line, endoffset);
                //selects the bookmark range
                this.viewer.selection.selectRange(startPosition, endPosition);
            }
        }
    }
    /**
     * Selects the specified bookmark.
     * @param name
     */
    selectBookmark(name) {
        this.navigateBookmark(name);
    }
    /**
     * Returns the toc field from the selection.
     * @private
     */
    getTocField() {
        let paragraph = this.start.paragraph;
        let tocPara = undefined;
        while ((paragraph !== undefined && this.isTocStyle(paragraph))) {
            tocPara = paragraph;
            paragraph = paragraph.previousRenderedWidget;
        }
        if (tocPara !== undefined) {
            let lineWidget = tocPara.childWidgets[0];
            if (lineWidget !== undefined) {
                return lineWidget.children[0];
            }
        }
        return undefined;
    }
    /**
     * Returns true if the paragraph has toc style.
     */
    isTocStyle(paragraph) {
        let style = paragraph.paragraphFormat.baseStyle;
        return (style !== undefined && (style.name.toLowerCase().indexOf('toc') !== -1));
    }
}

/**
 * Selection Export
 */

/**
 * @private
 */
class TextSearch {
    constructor(owner) {
        this.wordBefore = '\\b';
        this.wordAfter = '\\b';
        this.isHeader = false;
        this.isFooter = false;
        this.owner = owner;
    }
    get viewer() {
        return this.owner.viewer;
    }
    find(pattern, findOption) {
        return this.findNext(pattern, findOption, '0;0;0');
    }
    // tslint:disable-next-line:max-line-length   
    findNext(pattern, findOption, hierarchicalPosition) {
        if (typeof pattern === 'string') {
            pattern = this.stringToRegex(pattern, findOption);
        }
        if (hierarchicalPosition === undefined) {
            hierarchicalPosition = '0;0;0';
        }
        this.owner.searchModule.textSearchResults.clearResults();
        let results = this.owner.searchModule.textSearchResults;
        this.findDocument(results, pattern, true, findOption, hierarchicalPosition);
        return results.length > 0, results.currentSearchResult;
    }
    stringToRegex(textToFind, option) {
        if (textToFind.indexOf('\\') > -1) {
            textToFind = textToFind.split('\\').join('\\\\');
        }
        if (textToFind.indexOf('.') > -1) {
            textToFind = '\\' + textToFind;
        }
        if (option === 'WholeWord' || option === 'CaseSensitiveWholeWord') {
            textToFind = this.wordBefore + textToFind + this.wordAfter;
        }
        return new RegExp(textToFind, (option === 'CaseSensitive' || option === 'CaseSensitiveWholeWord') ? 'g' : 'ig');
    }
    isPatternEmpty(pattern) {
        let wordEmpty = this.wordBefore + this.wordAfter;
        let patternRegExp = pattern.toString();
        return (patternRegExp.length === 0 || patternRegExp === wordEmpty);
    }
    // tslint:disable-next-line:max-line-length     
    findAll(pattern, findOption, hierarchicalPosition) {
        if (typeof pattern === 'string') {
            pattern = this.stringToRegex(pattern, findOption);
        }
        if (hierarchicalPosition === undefined) {
            hierarchicalPosition = '0;0;0';
        }
        this.owner.searchModule.textSearchResults.clearResults();
        let results = this.owner.searchModule.textSearchResults;
        this.findDocument(results, pattern, false, findOption, hierarchicalPosition);
        if (results.length > 0 && results.currentIndex < 0) {
            results.currentIndex = 0;
        }
        if (!isNullOrUndefined(results.currentSearchResult)) {
            let eventArgs = { source: this.viewer.owner };
            this.viewer.owner.trigger('searchResultsChange', eventArgs);
            return results;
        }
        return undefined;
    }
    // tslint:disable-next-line:max-line-length     
    findDocument(results, pattern, isFirstMatch, findOption, hierachicalPosition) {
        if (this.isPatternEmpty(pattern)) {
            return;
        }
        if (findOption === undefined) {
            findOption = 'None';
        }
        let inline = undefined;
        let selectionEnd = undefined;
        if (hierachicalPosition !== undefined) {
            selectionEnd = this.owner.selection.end;
        }
        if (hierachicalPosition !== undefined && isFirstMatch && selectionEnd !== undefined && selectionEnd.paragraph !== undefined) {
            if (selectionEnd.paragraph instanceof ParagraphWidget) {
                let indexInInline = 0;
                // tslint:disable-next-line:max-line-length 
                // IndexInInline Handled specifically for simple find operation to start from starting point
                let inlineElement = selectionEnd.currentWidget.getInline(this.owner.selection.start.offset, indexInInline);
                inline = inlineElement.element;
                indexInInline = inlineElement.index;
                if (!isNullOrUndefined(inline)) {
                    let nextParagraphWidget = undefined;
                    // tslint:disable-next-line:max-line-length  
                    nextParagraphWidget = this.findInline(inline, pattern, findOption, indexInInline, isFirstMatch, results, selectionEnd);
                    while (results.length === 0 && !isNullOrUndefined(nextParagraphWidget)) {
                        while (!isNullOrUndefined(nextParagraphWidget) && nextParagraphWidget.childWidgets.length === 0) {
                            // tslint:disable-next-line:max-line-length 
                            nextParagraphWidget = this.owner.selection.getNextParagraph(nextParagraphWidget.containerWidget);
                        }
                        if (isNullOrUndefined(nextParagraphWidget)) {
                            break;
                        }
                        let lineWidget = nextParagraphWidget.childWidgets[0];
                        if (lineWidget.children[0] instanceof ListTextElementBox) {
                            inline = (lineWidget.children[2] instanceof TextElementBox) ? lineWidget.children[2] : undefined;
                        }
                        else {
                            inline = lineWidget.children[0];
                        }
                        if (isNullOrUndefined(inline)) {
                            break;
                        }
                        // tslint:disable-next-line:max-line-length  
                        nextParagraphWidget = this.findInline(inline, pattern, findOption, 0, isFirstMatch, results, selectionEnd);
                    }
                    if (results.length > 0) {
                        return;
                    }
                }
            }
        }
        let section;
        section = this.viewer.pages[0].bodyWidgets[0];
        while (!isNullOrUndefined(section) && section.childWidgets.length === 0) {
            section = section.nextWidget;
        }
        if (isNullOrUndefined(section) || section.childWidgets.length === 0) {
            return;
        }
        this.isHeader = false;
        this.isFooter = false;
        this.findInlineText(section, pattern, findOption, isFirstMatch, results, selectionEnd);
        for (let i = 0; i < this.viewer.pages.length; i++) {
            let headerWidget = this.viewer.pages[i].headerWidget;
            if (!isNullOrUndefined(headerWidget)) {
                this.isHeader = true;
                this.isFooter = false;
                this.findInlineText(headerWidget, pattern, findOption, isFirstMatch, results, selectionEnd);
            }
        }
        for (let i = 0; i < this.viewer.pages.length; i++) {
            let footerWidget = this.viewer.pages[i].footerWidget;
            if (!isNullOrUndefined(footerWidget)) {
                this.isHeader = false;
                this.isFooter = true;
                this.findInlineText(footerWidget, pattern, findOption, isFirstMatch, results, selectionEnd);
            }
        }
        if (isFirstMatch && !isNullOrUndefined(results) && results.length > 0) {
            return;
        }
    }
    // tslint:disable-next-line:max-line-length
    findInlineText(section, pattern, findOption, isFirstMatch, results, selectionEnd) {
        let paragraphWidget = this.owner.selection.getFirstParagraphBlock(section.childWidgets[0]);
        // tslint:disable-next-line:max-line-length 
        while (!isNullOrUndefined(paragraphWidget) && paragraphWidget.childWidgets.length === 1 && paragraphWidget.childWidgets[0].children.length === 0) {
            paragraphWidget = this.owner.selection.getNextParagraphBlock(paragraphWidget);
        }
        while (!isNullOrUndefined(paragraphWidget) && paragraphWidget.childWidgets.length > 0) {
            let inlineElement = paragraphWidget.childWidgets[0];
            let inlineEle = inlineElement.children[0];
            if (isNullOrUndefined(inlineEle)) {
                break;
            }
            this.findInline(inlineEle, pattern, findOption, 0, isFirstMatch, results, selectionEnd);
            paragraphWidget = this.owner.selection.getNextParagraphBlock(paragraphWidget);
            // tslint:disable-next-line:max-line-length 
            while (!isNullOrUndefined(paragraphWidget) && (paragraphWidget.childWidgets.length === 1) && paragraphWidget.childWidgets[0].children.length === 0) {
                paragraphWidget = this.owner.selection.getNextParagraphBlock(paragraphWidget);
            }
        }
        if (isFirstMatch && !isNullOrUndefined(results) && results.length > 0) {
            return;
        }
    }
    // tslint:disable-next-line:max-line-length     
    findInline(inlineElement, pattern, option, indexInInline, isFirstMatch, results, selectionEnd) {
        let inlines = inlineElement;
        let stringBuilder = '';
        let spans = new Dictionary();
        //tslint:disable no-constant-condition
        do {
            // tslint:disable-next-line:max-line-length 
            if (inlineElement instanceof TextElementBox && (!isNullOrUndefined(inlineElement.text) && inlineElement.text !== '')) {
                spans.add(inlineElement, stringBuilder.length);
                // IndexInInline Handled specifically for simple find operation to start from starting point
                if (inlineElement === inlines) {
                    stringBuilder = stringBuilder + (inlineElement.text.substring(indexInInline));
                }
                else {
                    stringBuilder = stringBuilder + (inlineElement.text);
                }
            }
            else if (inlineElement instanceof FieldElementBox) {
                let fieldBegin = inlineElement;
                if (!isNullOrUndefined(fieldBegin.fieldEnd)) {
                    // tslint:disable-next-line:max-line-length 
                    inlineElement = isNullOrUndefined(fieldBegin.fieldSeparator) ? fieldBegin.fieldEnd : fieldBegin.fieldSeparator;
                }
            }
            if (!isNullOrUndefined(inlineElement) && isNullOrUndefined(inlineElement.nextNode)) {
                break;
            }
            if (!isNullOrUndefined(inlineElement)) {
                inlineElement = inlineElement.nextNode;
            }
        } while (true);
        let text = stringBuilder.toString();
        let matches = [];
        let matchObject;
        //tslint:disable no-conditional-assignment
        while (!isNullOrUndefined(matchObject = pattern.exec(text))) {
            matches.push(matchObject);
        }
        for (let i = 0; i < matches.length; i++) {
            let match = matches[i];
            let result = results.addResult();
            let spanKeys = spans.keys;
            for (let i = 0; i < spanKeys.length; i++) {
                let span = spanKeys[i];
                let startIndex = spans.get(span);
                let spanLength = span.length;
                // IndexInInline Handled specifically for simple find operation to start from starting point
                if (span === inlines) {
                    spanLength -= indexInInline;
                }
                if (isNullOrUndefined(result.start) && match.index < startIndex + spanLength) {
                    let index = match.index - startIndex;
                    // IndexInInline Handled specifically for simple find operation to start from starting point
                    if (span === inlines) {
                        index += indexInInline;
                    }
                    let offset = (span.line).getOffset(span, index);
                    result.start = this.getTextPosition(span.line, offset.toString());
                    result.start.location = this.owner.selection.getPhysicalPositionInternal(span.line, offset, true);
                    result.start.setPositionParagraph(span.line, offset);
                }
                if (match.index + match[0].length <= startIndex + spanLength) {
                    let index = (match.index + match[0].length) - startIndex;
                    // IndexInInline Handled specifically for simple find operation to start from starting point
                    if (span === inlines) {
                        index += indexInInline;
                    }
                    let offset = (span.line).getOffset(span, index);
                    result.end = this.getTextPosition(span.line, offset.toString());
                    result.end.location = this.owner.selection.getPhysicalPositionInternal(span.line, offset, true);
                    result.end.setPositionParagraph(span.line, offset);
                    break;
                }
            }
            result.isHeader = this.isHeader;
            result.isFooter = this.isFooter;
            if (isFirstMatch) {
                results.currentIndex = 0;
                return undefined;
            }
            else if (results.currentIndex < 0 && selectionEnd.isExistBefore(result.start)) {
                results.currentIndex = results.indexOf(result);
            }
        }
        // tslint:disable-next-line:max-line-length
        let paragraphWidget = this.owner.selection.getNextParagraphBlock(inlineElement.line.paragraph);
        return paragraphWidget;
    }
    getTextPosition(lineWidget, hierarchicalIndex) {
        let textPosition = new TextPosition(this.owner);
        let index = textPosition.getHierarchicalIndex(lineWidget, hierarchicalIndex);
        textPosition.setPositionForCurrentIndex(index);
        return textPosition;
    }
}
/**
 * @private
 */
class SearchWidgetInfo {
    constructor(left, width) {
        this.leftInternal = 0;
        this.widthInternal = 0;
        this.leftInternal = left;
        this.widthInternal = width;
    }
    get left() {
        return this.leftInternal;
    }
    set left(value) {
        this.leftInternal = value;
    }
    get width() {
        return this.widthInternal;
    }
    set width(value) {
        this.widthInternal = value;
    }
}

/**
 * @private
 */
class TextSearchResult {
    constructor(owner) {
        this.startIn = undefined;
        this.endIn = undefined;
        this.owner = owner;
    }
    get viewer() {
        return this.owner.viewer;
    }
    get start() {
        return this.startIn;
    }
    set start(value) {
        this.startIn = value;
    }
    get end() {
        return this.endIn;
    }
    set end(value) {
        this.endIn = value;
    }
    get text() {
        return this.viewer.selection.getTextInternal(this.start, this.end, false);
    }
    destroy() {
        this.start = undefined;
        this.end = undefined;
    }
}

/**
 * @private
 */
class TextSearchResults {
    constructor(owner) {
        this.currentIndex = -1;
        this.owner = owner;
    }
    get length() {
        if (this.innerList === undefined) {
            return 0;
        }
        return this.innerList.length;
    }
    get currentSearchResult() {
        if (this.innerList === undefined || this.currentIndex < 0 || this.currentIndex >= this.length) {
            return undefined;
        }
        return this.innerList[this.currentIndex];
    }
    addResult() {
        let textSearchResult = new TextSearchResult(this.owner);
        if (isNullOrUndefined(this.innerList)) {
            this.innerList = [];
        }
        this.innerList.push(textSearchResult);
        return textSearchResult;
    }
    clearResults() {
        this.currentIndex = -1;
        if (!isNullOrUndefined(this.innerList)) {
            for (let i = this.innerList.length - 1; i >= 0; i--) {
                this.innerList[i].destroy();
                this.innerList.splice(i, 1);
            }
        }
    }
    indexOf(result) {
        if (isNullOrUndefined(this.innerList)) {
            return -1;
        }
        return this.innerList.indexOf(result);
    }
    destroy() {
        if (!isNullOrUndefined(this.innerList)) {
            this.clearResults();
        }
        this.innerList = undefined;
    }
}

/**
 * Search Result info
 */
class SearchResults {
    /**
     * Gets the length of search results.
     */
    get length() {
        return this.searchModule.textSearchResults.length;
    }
    /**
     * Gets the index of current search result.
     */
    get index() {
        return this.searchModule.textSearchResults.currentIndex;
    }
    /**
     * Set the index of current search result.
     */
    set index(value) {
        if (this.length === 0 || value < 0 || value > this.searchModule.textSearchResults.length - 1) {
            return;
        }
        this.searchModule.textSearchResults.currentIndex = value;
        this.navigate(value);
    }
    /**
     * @private
     */
    constructor(search) {
        this.searchModule = search;
    }
    /**
     * Replace text in current search result.
     * @param textToReplace text to replace
     * @private
     */
    replace(textToReplace) {
        if (this.index === -1) {
            return;
        }
        this.searchModule.replaceInternal(textToReplace);
    }
    /**
     * Replace all the instance of search result.
     * @param textToReplace text to replace
     */
    replaceAll(textToReplace) {
        if (this.index === -1) {
            return;
        }
        this.searchModule.replaceAllInternal(textToReplace);
    }
    /**
     * @private
     */
    navigate(index) {
        this.searchModule.navigate(this.searchModule.textSearchResults.currentSearchResult);
        this.searchModule.highlight(this.searchModule.textSearchResults);
    }
    /**
     * Clears all the instance of search result.
     */
    clear() {
        this.searchModule.textSearchResults.clearResults();
        this.searchModule.clearSearchHighlight();
        this.searchModule.viewer.renderVisiblePages();
    }
}

/**
 * Search module
 */
class Search {
    /**
     * @private
     */
    constructor(owner) {
        /**
         * @private
         */
        this.searchHighlighters = undefined;
        this.isHandledOddPageHeader = undefined;
        this.isHandledEvenPageHeader = undefined;
        this.isHandledOddPageFooter = undefined;
        this.isHandledEvenPageFooter = undefined;
        this.owner = owner;
        this.searchHighlighters = new Dictionary();
        this.textSearch = new TextSearch(this.owner);
        this.textSearchResults = new TextSearchResults(this.owner);
        this.searchResultsInternal = new SearchResults(this);
    }
    /**
     * @private
     */
    get viewer() {
        return this.owner.viewer;
    }
    /**
     * Gets the search results object.
     */
    get searchResults() {
        return this.searchResultsInternal;
    }
    /**
     * Get the module name.
     */
    getModuleName() {
        return 'Search';
    }
    //#region Find & Find All
    /**
     * Finds the immediate occurrence of specified text from cursor position in the document.
     * @param  {string} text
     * @param  {FindOption} findOption? - Default value of ‘findOptions’ parameter is 'None'.
     * @private
     */
    find(text, findOptions) {
        if (isNullOrUndefined(findOptions)) {
            findOptions = 'None';
        }
        let result = this.textSearch.find(text, findOptions);
        if (!isNullOrUndefined(result)) {
            this.navigate(result);
        }
    }
    /**
     * Finds all occurrence of specified text in the document.
     * @param  {string} text
     * @param  {FindOption} findOption? - Default value of ‘findOptions’ parameter is 'None'.
     */
    findAll(text, findOptions) {
        if (isNullOrUndefined(text || text === '')) {
            return;
        }
        if (isNullOrUndefined(findOptions)) {
            findOptions = 'None';
        }
        let results = this.textSearch.findAll(text, findOptions);
        if (!isNullOrUndefined(results) && results.length > 0) {
            this.navigate(results.innerList[results.currentIndex]);
            this.highlight(results);
        }
    }
    //#endregion
    //#region Replace and Replace All   
    /**
     * Replace the searched string with specified string
     * @param  {string} replaceText
     * @param  {TextSearchResult} result
     * @param  {TextSearchResults} results
     * @private
     */
    replace(replaceText, result, results) {
        if (isNullOrUndefined(this.viewer.owner) || this.viewer.owner.isReadOnlyMode || isNullOrUndefined(results)) {
            return 0;
        }
        if (!isNullOrUndefined(this.viewer)) {
            this.clearSearchHighlight();
        }
        this.navigate(result);
        let endPosition = this.viewer.selection.start;
        let index = results.indexOf(result);
        if (index < 0) {
            return 0;
        }
        this.owner.editorModule.insertText(replaceText, true);
        let endTextPosition = result.end;
        let startPosition = new TextPosition(this.viewer.owner);
        startPosition.setPositionParagraph(endTextPosition.currentWidget, endPosition.offset - replaceText.length);
        this.viewer.selection.selectRange(endPosition, startPosition);
        let eventArgs = { source: this.viewer.owner };
        this.viewer.owner.trigger('searchResultsChange', eventArgs);
        return 1;
    }
    /**
     * Find the textToFind string in current document and replace the specified string.
     * @param  {string} textToFind
     * @param  {string} textToReplace
     * @param  {FindOption} findOptions? - Default value of ‘findOptions’ parameter is FindOption.None.
     * @private
     */
    replaceInternal(textToReplace, findOptions) {
        if ((textToReplace === '' || isNullOrUndefined(textToReplace))) {
            return;
        }
        if (isNullOrUndefined(findOptions)) {
            findOptions = 'None';
        }
        let textToFind = this.textSearchResults.currentSearchResult.text;
        let pattern = this.viewer.owner.searchModule.textSearch.stringToRegex(textToFind, findOptions);
        let index = this.owner.selection.end.getHierarchicalIndexInternal();
        let result = this.viewer.owner.searchModule.textSearch.findNext(pattern, findOptions, index);
        if (!isNullOrUndefined(result)) {
            this.navigate(result);
            this.textSearchResults.addResult();
            this.textSearchResults.innerList[0] = result;
            this.replace(textToReplace, result, this.textSearchResults);
            index = this.owner.selection.end.getHierarchicalIndexInternal();
            result = this.textSearch.findNext(textToFind, findOptions, index);
            if (result) {
                this.textSearchResults.addResult();
                this.textSearchResults.innerList[0] = result;
                this.navigate(result);
            }
        }
    }
    /**
     * Replace all the searched string with specified string
     * @param  {string} replaceText
     * @param  {TextSearchResults} results
     * @private
     */
    replaceAll(replaceText, results) {
        if (isNullOrUndefined(this.viewer.owner) || this.viewer.owner.isReadOnlyMode || isNullOrUndefined(results)) {
            return 0;
        }
        if (this.owner.editorHistory) {
            this.owner.editorHistory.initComplexHistory(this.owner.selection, 'ReplaceAll');
        }
        let count = results.length;
        this.viewer.owner.isLayoutEnabled = false;
        for (let i = count - 1; i >= 0; i--) {
            this.navigate(results.innerList[i]);
            this.owner.editorModule.insertText(replaceText, true);
            results.innerList[i].destroy();
        }
        if (this.owner.editorHistory && !isNullOrUndefined(this.owner.editorHistory.currentHistoryInfo)) {
            this.owner.editorHistory.updateComplexHistory();
        }
        else {
            this.owner.editorModule.updateComplexWithoutHistory(2);
        }
        this.searchResults.clear();
        return count;
    }
    /**
     * Find the textToFind string in current document and replace the specified string.
     * @param  {string} textToFind
     * @param  {string} textToReplace
     * @param  {FindOption} findOptions? - Default value of ‘findOptions’ parameter is FindOption.None.
     * @private
     */
    replaceAllInternal(textToReplace, findOptions) {
        if ((textToReplace === '' || isNullOrUndefined(textToReplace))) {
            return;
        }
        if (isNullOrUndefined(findOptions)) {
            findOptions = 'None';
        }
        if (this.textSearchResults.length > 0) {
            this.navigate(this.textSearchResults.innerList[this.textSearchResults.currentIndex]);
            this.highlight(this.textSearchResults);
            this.replaceAll(textToReplace, this.textSearchResults);
        }
    }
    //#endregion
    //#region Highlight Search Result
    /**
     * @private
     */
    navigate(textSearchResult) {
        if (textSearchResult) {
            let start = textSearchResult.start;
            let end = textSearchResult.end;
            if (!isNullOrUndefined(this.owner) && !isNullOrUndefined(this.owner.selection) && !isNullOrUndefined(start) &&
                !isNullOrUndefined(end) && !isNullOrUndefined(start.paragraph) && !isNullOrUndefined(end.paragraph)) {
                this.owner.selection.selectRange(start, end);
            }
        }
    }
    /**
     * @private
     */
    highlight(textSearchResults) {
        this.searchHighlighters = new Dictionary();
        for (let i = 0; i < textSearchResults.innerList.length; i++) {
            let result = textSearchResults.innerList[i];
            this.highlightResult(result);
        }
        this.viewer.renderVisiblePages();
    }
    /**
     * @private
     */
    highlightResult(result) {
        this.highlightSearchResult(result.start.paragraph, result.start, result.end);
    }
    /**
     * Highlight search result
     * @private
     */
    highlightSearchResult(paragraph, start, end) {
        let selectionStartIndex = 0;
        let selectionEndIndex = 0;
        let startElement = null;
        let endElement = null;
        // tslint:disable-next-line:max-line-length
        let lineWidget = this.viewer.selection.getStartLineWidget(paragraph, start, startElement, selectionStartIndex);
        selectionStartIndex = lineWidget.index;
        startElement = lineWidget.element;
        let startLineWidget = startElement ? startElement.line : paragraph.childWidgets[0];
        let endLine = this.viewer.selection.getEndLineWidget(end, endElement, selectionEndIndex);
        selectionEndIndex = endLine.index;
        endElement = endLine.element;
        let endLineWidget = endElement ? endElement.line :
            end.paragraph.childWidgets[end.paragraph.childWidgets.length - 1];
        let top = this.viewer.selection.getTop(startLineWidget);
        let left = this.viewer.selection.getLeftInternal(startLineWidget, startElement, selectionStartIndex);
        if (!isNullOrUndefined(startLineWidget) && startLineWidget === endLineWidget) {
            //find result ends in current line.
            let right = this.viewer.selection.getLeftInternal(endLineWidget, endElement, selectionEndIndex);
            this.createHighlightBorder(startLineWidget, right - left, left, top);
        }
        else {
            if (!isNullOrUndefined(startLineWidget)) {
                if (paragraph !== startLineWidget.paragraph) {
                    paragraph = startLineWidget.paragraph;
                }
                // tslint:disable-next-line:max-line-length
                this.createHighlightBorder(startLineWidget, this.viewer.selection.getWidth(startLineWidget, true) - (left - startLineWidget.paragraph.x), left, top);
                let lineIndex = startLineWidget.paragraph.childWidgets.indexOf(startLineWidget);
                //Iterates to last item of paragraph or search result end.
                for (let i = 0; i < paragraph.childWidgets.length; i++) {
                    if (paragraph === startLineWidget.paragraph) {
                        lineIndex += 1;
                    }
                    this.highlightSearchResultParaWidget(paragraph, lineIndex, endLineWidget, endElement, selectionEndIndex);
                    if (paragraph === endLineWidget.paragraph) {
                        return;
                    }
                    else {
                        lineIndex = 0;
                    }
                }
            }
        }
    }
    /**
     * @private
     */
    createHighlightBorder(lineWidget, width, left, top) {
        let findHighLight = this.addSearchHighlightBorder(lineWidget);
        let page = this.viewer.owner.selection.getPage(lineWidget.paragraph);
        let pageTop = page.boundingRectangle.y;
        let pageLeft = page.boundingRectangle.x;
        findHighLight.left = Math.ceil(left);
        top = Math.ceil(top);
        findHighLight.width = Math.floor(width);
        let height = Math.floor(lineWidget.height);
        let context = this.viewer.containerContext;
    }
    /**
     * Adds search highlight border.
     * @private
     */
    addSearchHighlightBorder(lineWidget) {
        let highlighters = undefined;
        if (this.searchHighlighters.containsKey(lineWidget)) {
            highlighters = this.searchHighlighters.get(lineWidget);
        }
        else {
            highlighters = [];
            this.searchHighlighters.add(lineWidget, highlighters);
        }
        let searchHighlight = new SearchWidgetInfo(0, 0);
        highlighters.push(searchHighlight);
        return searchHighlight;
    }
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    highlightSearchResultParaWidget(widget, startIndex, endLine, endElement, endIndex) {
        let top = 0;
        for (let j = startIndex; j < widget.childWidgets.length; j++) {
            let lineWidget = widget.childWidgets[j];
            if (j === startIndex) {
                top = this.viewer.selection.getTop(lineWidget);
            }
            let left = this.viewer.selection.getLeft(lineWidget);
            if (lineWidget === endLine) {
                //Search result ends in current line.
                let right = this.viewer.selection.getLeftInternal(endLine, endElement, endIndex);
                this.createHighlightBorder(lineWidget, right - left, left, top);
                return;
            }
            this.createHighlightBorder(lineWidget, this.viewer.selection.getWidth(lineWidget, true) - (left - widget.x), left, top);
            top += lineWidget.height;
        }
    }
    //#endregion
    //#region Get find result view
    /**
     * @private
     */
    addSearchResultItems(result) {
        if (isNullOrUndefined(result) || result === '') {
            return;
        }
        if (isNullOrUndefined(this.owner.findResultsList)) {
            this.owner.findResultsList = [];
        }
        this.owner.findResultsList.push(result);
    }
    /**
     * @private
     */
    addFindResultView(textSearchResults) {
        for (let i = 0; i < textSearchResults.innerList.length; i++) {
            let result = textSearchResults.innerList[i];
            this.addFindResultViewForSearch(result);
        }
        this.isHandledOddPageHeader = true;
        this.isHandledOddPageFooter = true;
        this.isHandledEvenPageHeader = true;
        this.isHandledEvenPageFooter = true;
    }
    /**
     * @private
     */
    // tslint:disable:max-func-body-length
    addFindResultViewForSearch(result) {
        if (result.start != null && result.end != null && result.start.paragraph != null && result.end.paragraph != null) {
            let prefixText;
            let suffixtext;
            let currentText;
            let startIndex = 0;
            let inlineObj = result.start.currentWidget.getInline(result.start.offset, startIndex);
            let inline = inlineObj.element;
            startIndex = inlineObj.index;
            let prefix = '';
            let lastIndex = 0;
            if (inline instanceof FieldElementBox) {
                let elementInfo = this.owner.selection.getRenderedInline(inline, startIndex);
                if (elementInfo.element.nextNode instanceof TextElementBox) {
                    inline = elementInfo.element.nextNode;
                    startIndex = elementInfo.index;
                }
                else {
                    inline = elementInfo.element;
                    startIndex = elementInfo.index;
                }
            }
            let boxObj = this.owner.selection.getElementBoxInternal(inline, startIndex);
            let box = boxObj.element;
            startIndex = boxObj.index;
            if (box != null) {
                if (box instanceof TextElementBox && startIndex > 0) {
                    prefix = box.text.substring(0, startIndex);
                }
                let boxIndex = box.line.children.indexOf(box);
                // tslint:disable-next-line:max-line-length
                lastIndex = prefix.lastIndexOf(' ');
                while (lastIndex < 0 && boxIndex > 0 && box.line.children[boxIndex - 1] instanceof TextElementBox) {
                    prefix = box.line.children[boxIndex - 1].text + prefix;
                    boxIndex--;
                    lastIndex = prefix.lastIndexOf(' ');
                }
            }
            let shiftIndex = prefix.lastIndexOf('\v');
            if (shiftIndex > 0) {
                prefix = prefix.substring(0, shiftIndex);
            }
            else {
                lastIndex = prefix.lastIndexOf(' ');
                prefixText = lastIndex < 0 ? prefix : prefix.substring(lastIndex + 1);
            }
            currentText = result.text;
            let endIndex = 0;
            let endInlineObj = result.end.currentWidget.getInline(result.end.offset, endIndex);
            let endInline = endInlineObj.element;
            endIndex = endInlineObj.index;
            suffixtext = '';
            //Checks prefix element box is empty
            if (boxObj != null) {
                // Gets the element box using endIndex of the text and set as suffix
                boxObj = this.owner.selection.getElementBoxInternal(endInline, endIndex);
                box = boxObj.element;
                endIndex = boxObj.index;
            }
            //Checks suffix element box is empty.
            if (box != null) {
                if (box instanceof TextElementBox && endIndex < box.length) {
                    suffixtext = box.text.substring(endIndex);
                }
                let boxIndex = box.line.children.indexOf(box);
                // tslint:disable-next-line:max-line-length
                while (boxIndex + 1 < box.line.children.length && (box.line.children[boxIndex + 1] instanceof TextElementBox) || (box.line.children[boxIndex + 1] instanceof FieldElementBox)) {
                    if (box.line.children[boxIndex + 1] instanceof FieldElementBox) {
                        boxIndex = boxIndex + 2;
                    }
                    else {
                        suffixtext = suffixtext + box.line.children[boxIndex + 1].text;
                        boxIndex = boxIndex + 1;
                    }
                }
            }
            lastIndex = suffixtext.lastIndexOf(' ');
            suffixtext = suffixtext === '\v' ? suffixtext = '' : suffixtext;
            let headerFooterString = '';
            if (result.isHeader) {
                headerFooterString = '<span class="e-de-header-footer-list">' + 'Header' + ': ' + '</span>';
            }
            else if (result.isFooter) {
                headerFooterString = '<span class="e-de-header-footer-list">' + 'Footer' + ': ' + '</span>';
            }
            else {
                headerFooterString = '';
                headerFooterString = '';
                this.isHandledOddPageHeader = true;
                this.isHandledEvenPageHeader = true;
                this.isHandledOddPageFooter = true;
                this.isHandledEvenPageFooter = true;
            }
            let listElement = '';
            let page = result.viewer.selection.getPage(result.start.paragraph);
            if (isNullOrUndefined(this.isHandledEvenPageHeader) && isNullOrUndefined(this.isHandledEvenPageFooter)) {
                this.isHandledEvenPageHeader = true;
                this.isHandledEvenPageFooter = true;
            }
            else if (isNullOrUndefined(this.isHandledOddPageHeader) && isNullOrUndefined(this.isHandledOddPageFooter)) {
                this.isHandledOddPageHeader = true;
                this.isHandledOddPageFooter = true;
            }
            if (result.isHeader) {
                if (page.headerWidget.headerFooterType === 'FirstPageHeader' && page.bodyWidgets[0].sectionFormat.differentFirstPage) {
                    // tslint:disable-next-line:max-line-length
                    listElement = '<li tabindex=0 class="e-de-search-result-item e-de-op-search-txt">' + headerFooterString + prefix + '<span class="e-de-op-search-word" style="pointer-events:none">' + result.text + '</span>' + suffixtext + '</li>';
                }
                else if (page.headerWidget.headerFooterType === 'EvenHeader' && this.isHandledEvenPageHeader) {
                    // tslint:disable-next-line:max-line-length
                    listElement = '<li tabindex=0 class="e-de-search-result-item e-de-op-search-txt">' + headerFooterString + prefix + '<span class="e-de-op-search-word" style="pointer-events:none">' + result.text + '</span>' + suffixtext + '</li>';
                    this.isHandledEvenPageHeader = false;
                    // tslint:disable-next-line:max-line-length
                }
                else if (page.headerWidget.headerFooterType === 'OddHeader' && this.isHandledOddPageHeader) {
                    listElement = '<li tabindex=0 class="e-de-search-result-item e-de-op-search-txt">' + headerFooterString + prefix + '<span class="e-de-op-search-word" style="pointer-events:none">' + result.text + '</span>' + suffixtext + '</li>';
                    this.isHandledOddPageHeader = false;
                }
            }
            else if (result.isFooter) {
                if (page.footerWidget.headerFooterType === 'FirstPageFooter' && page.bodyWidgets[0].sectionFormat.differentFirstPage) {
                    // tslint:disable-next-line:max-line-length
                    listElement = '<li tabindex=0 class="e-de-search-result-item e-de-op-search-txt">' + headerFooterString + prefix + '<span class="e-de-op-search-word" style="pointer-events:none">' + result.text + '</span>' + suffixtext + '</li>';
                }
                else if (page.footerWidget.headerFooterType === 'EvenFooter' && this.isHandledEvenPageFooter) {
                    // tslint:disable-next-line:max-line-length
                    listElement = '<li tabindex=0 class="e-de-search-result-item e-de-op-search-txt">' + headerFooterString + prefix + '<span class="e-de-op-search-word" style="pointer-events:none">' + result.text + '</span>' + suffixtext + '</li>';
                    this.isHandledEvenPageFooter = false;
                    // tslint:disable-next-line:max-line-length
                }
                else if (page.footerWidget.headerFooterType === 'OddFooter' && this.isHandledOddPageFooter) {
                    listElement = '<li tabindex=0 class="e-de-search-result-item e-de-op-search-txt">' + headerFooterString + prefix + '<span class="e-de-op-search-word" style="pointer-events:none">' + result.text + '</span>' + suffixtext + '</li>';
                    this.isHandledOddPageFooter = false;
                }
                // tslint:disable-next-line:max-line-length
            }
            else if (!result.isHeader && !result.isFooter) {
                listElement = '<li tabindex=0 class="e-de-search-result-item e-de-op-search-txt">' + headerFooterString + prefix + '<span class="e-de-op-search-word" style="pointer-events:none">' + result.text + '</span>' + suffixtext + '</li>';
            }
            this.addSearchResultItems(listElement);
        }
    }
    //#endregion
    /**
     * Clears search highlight.
     * @private
     */
    clearSearchHighlight() {
        if (!isNullOrUndefined(this.searchHighlighters)) {
            this.searchHighlighters.clear();
            this.searchHighlighters = undefined;
        }
        let eventArgs = { source: this.viewer.owner };
        this.viewer.owner.trigger('searchResultsChange', eventArgs);
    }
    /**
     * @private
     */
    destroy() {
        if (this.textSearchResults) {
            this.textSearchResults.destroy();
        }
    }
}

/**
 * Options Pane class.
 */
class OptionsPane {
    /**
     * Constructor for Options pane module
     * @param {LayoutViewer} layoutViewer
     * @private
     */
    constructor(layoutViewer) {
        /**
         * @private
         */
        this.isOptionsPaneShow = false;
        this.findOption = 'None';
        this.matchCase = undefined;
        this.wholeWord = undefined;
        // private regular: CheckBox = undefined;
        this.searchText = 'Navigation';
        this.resultsText = 'Results';
        this.messageDivText = 'No matches';
        this.replaceButtonText = 'Replace';
        this.replaceAllButtonText = 'Replace All';
        this.focusedIndex = -1;
        this.focusedElement = [];
        this.isOptionsPane = true;
        this.replacePaneText = 'Replace';
        this.findPaneText = 'Find';
        this.matchDivReplaceText = 'No matches';
        /**
         * @private
         */
        this.tabInstance = undefined;
        /**
         * @private
         */
        this.isReplace = false;
        /**
         * Gets selected tab item which tab is selected.
         * @param {SelectEventArgs} args - Specifies which tab will be opened.
         * @private
         */
        this.selectedTabItem = (args) => {
            if (args.previousIndex !== args.selectedIndex) {
                let previousTab = document.querySelector('#e-content_' + args.previousIndex);
                let nextTab = document.querySelector('#e-content_' + args.selectedIndex);
                nextTab.insertBefore(previousTab.firstElementChild, nextTab.firstChild);
            }
            if (args.selectedIndex === 0 && !isNullOrUndefined(document.querySelector('#e-content_' + args.selectedIndex))) {
                this.isOptionsPane = true;
                this.onFindPane();
            }
            if (args.selectedIndex === 1 && !isNullOrUndefined(document.querySelector('#e-content_' + args.selectedIndex))) {
                this.isOptionsPane = false;
                this.onReplacePane();
            }
        };
        this.searchOptionChange = () => {
            this.clearSearchResultItems();
            this.viewer.owner.searchModule.clearSearchHighlight();
            let inputText = this.searchInput.value;
            if (inputText === '') {
                return;
            }
            let pattern = this.viewer.owner.searchModule.textSearch.stringToRegex(inputText, this.findOption);
            let endSelection = this.viewer.selection.end;
            let selectionIndex = endSelection.getHierarchicalIndexInternal();
            this.results = this.viewer.owner.searchModule.textSearch.findAll(pattern, this.findOption, selectionIndex);
            if (this.results != null && this.results.length > 0) {
                this.navigateSearchResult();
            }
            else {
                this.viewer.renderVisiblePages();
                this.messageDiv.innerHTML = this.localeValue.getConstant('No matches');
                this.resultContainer.style.display = 'block';
                this.resultsListBlock.style.display = 'none';
                this.clearFocusElement();
                this.resultsListBlock.innerHTML = '';
            }
        };
        /**
         * Apply find option based on whole words value.
         * @param {ChangeEventArgs} args - Specifies the search options value.
         * @private
         */
        this.wholeWordsChange = (args) => {
            if (this.matchInput.checked && this.wholeInput.checked) {
                this.findOption = 'CaseSensitiveWholeWord';
            }
            else if (this.matchInput.checked && !(this.wholeInput.checked)) {
                this.findOption = 'CaseSensitive';
            }
            else if (!(this.matchInput.checked) && this.wholeInput.checked) {
                this.findOption = 'WholeWord';
            }
            else {
                this.findOption = 'None';
            }
            this.searchOptionChange();
        };
        /**
         * Apply find option based on match value.
         * @param {ChangeEventArgs} args - Specifies the search options value.
         * @private
         */
        this.matchChange = (args) => {
            if (this.matchInput.checked && this.wholeInput.checked) {
                this.findOption = 'CaseSensitiveWholeWord';
            }
            else if (!(this.matchInput.checked) && this.wholeInput.checked) {
                this.findOption = 'WholeWord';
            }
            else if (this.matchInput.checked && !(this.wholeInput.checked)) {
                this.findOption = 'CaseSensitive';
            }
            else {
                this.findOption = 'None';
            }
            this.searchOptionChange();
        };
        /**
         * Apply find options based on regular value.
         * @param {ChangeEventArgs} args - Specifies the search options value.
         * @private
         */
        // public regularChange = (args: ChangeEventArgs): void => {
        //     if (args.checked) {
        //         this.matchCase.element.parentElement.parentElement.classList.add('e-checkbox-disabled');
        //         this.wholeWord.element.parentElement.parentElement.classList.add('e-checkbox-disabled');
        //         this.matchCase.checked = false;
        //         this.wholeWord.checked = false;
        //         this.findOption = 'None';
        //         this.onKeyDownInternal();
        //     } else {
        //         this.matchCase.element.parentElement.parentElement.classList.remove('e-checkbox-disabled');
        //         this.wholeWord.element.parentElement.parentElement.classList.remove('e-checkbox-disabled');
        //     }
        // }
        // tslint:enable:no-any 
        /**
         * Binding events from the element when optins pane creation.
         * @private
         */
        this.onWireEvents = () => {
            this.searchIcon.addEventListener('click', this.searchIconClickInternal);
            this.navigateToNextResult.addEventListener('click', this.navigateNextResultButtonClick);
            this.navigateToPreviousResult.addEventListener('click', this.navigatePreviousResultButtonClick);
            this.searchInput.addEventListener('keydown', this.onKeyDown);
            this.searchInput.addEventListener('keyup', this.onEnableDisableReplaceButton);
            this.resultsListBlock.addEventListener('click', this.resultListBlockClick);
            this.closeButton.addEventListener('click', this.close);
            this.replaceButton.addEventListener('click', this.onReplaceButtonClick);
            this.replaceAllButton.addEventListener('click', this.onReplaceAllButtonClick);
        };
        /**
         * Enable find pane only.
         * @private
         */
        this.onFindPane = () => {
            this.replaceDiv.style.display = 'none';
            this.occurrenceDiv.style.display = 'none';
            if (!isNullOrUndefined(this.results) && this.results.length === 0) {
                this.resultsListBlock.innerHTML = '';
                this.resultsListBlock.style.display = 'none';
                this.messageDiv.innerHTML = this.localeValue.getConstant('No matches');
            }
            this.resultsListBlock.style.height = this.resultsListBlock.offsetHeight + this.replaceTabContentDiv.offsetHeight + 'px';
            this.replaceTabContentDiv.style.display = 'none';
            this.findDiv.style.display = 'block';
            this.messageDiv.style.display = 'block';
            this.focusedElement = [];
            // tslint:disable-next-line:max-line-length
            this.focusedElement.push(this.closeButton, this.findTabButtonHeader, this.replaceTabButtonHeader, this.searchInput, this.searchIcon, this.navigateToPreviousResult, this.navigateToNextResult, this.matchInput, this.wholeInput);
            this.focusedIndex = 3;
            this.searchInput.select();
            this.getMessageDivHeight();
        };
        this.onEnableDisableReplaceButton = () => {
            if (this.searchInput.value.length !== 0) {
                this.replaceButton.disabled = false;
                this.replaceAllButton.disabled = false;
            }
            else {
                this.replaceButton.disabled = true;
                this.replaceAllButton.disabled = true;
            }
        };
        /**
         * Enable replace pane only.
         * @private
         */
        this.onReplacePane = () => {
            this.findDiv.style.display = 'block';
            this.replaceDiv.style.display = 'block';
            this.replaceTabContentDiv.style.display = 'block';
            this.resultsListBlock.style.height = this.resultsListBlock.offsetHeight - this.replaceTabContentDiv.offsetHeight + 'px';
            this.isOptionsPane = false;
            if (this.searchInput.value.length !== 0) {
                this.replaceButton.disabled = false;
                this.replaceAllButton.disabled = false;
            }
            else {
                this.replaceButton.disabled = true;
                this.replaceAllButton.disabled = true;
            }
            this.focusedElement = [];
            // tslint:disable-next-line:max-line-length
            this.focusedElement.push(this.closeButton, this.findTabButtonHeader, this.replaceTabButtonHeader, this.searchInput, this.searchIcon, this.navigateToPreviousResult, this.navigateToNextResult, this.matchInput, this.wholeInput, this.replaceWith, this.replaceButton, this.replaceAllButton);
            this.focusedIndex = 9;
            if (this.searchInput.value === '') {
                this.searchInput.select();
            }
            else {
                this.replaceWith.select();
            }
            this.getMessageDivHeight();
        };
        /**
         * Fires on key down on options pane.
         * @param {KeyboardEvent} event - Specifies the focus of current element.
         * @private
         */
        this.onKeyDownOnOptionPane = (event) => {
            // if (event.keyCode === 70) {
            //     event.preventDefault();
            //     return;
            // }
            if (event.keyCode === 9) {
                event.preventDefault();
                let focusIndex = undefined;
                if (event.shiftKey) {
                    focusIndex = (this.focusedIndex === 0 || isNullOrUndefined(this.focusedIndex)) ?
                        this.focusedElement.length - 1 : this.focusedIndex - 1;
                }
                else {
                    focusIndex = (this.focusedElement.length - 1 === this.focusedIndex || isNullOrUndefined(this.focusedIndex)) ?
                        0 : this.focusedIndex + 1;
                }
                let element = this.focusedElement[focusIndex];
                element.focus();
                if (element instanceof HTMLInputElement) {
                    element.select();
                }
                this.focusedIndex = focusIndex;
                if (element instanceof HTMLLIElement) {
                    this.scrollToPosition(element);
                }
            }
            else if (event.keyCode === 13) {
                // tslint:disable-next-line:max-line-length
                if (event.target !== this.searchInput && event.target !== this.closeButton) {
                    event.preventDefault();
                    let index = this.focusedElement.indexOf(event.target);
                    if (index !== -1) {
                        let list = this.focusedElement[index];
                        list.click();
                        list.focus();
                        this.focusedIndex = index;
                    }
                }
            }
            else if (event.keyCode === 40 || event.keyCode === 38) {
                if (this.resultsListBlock.style.display !== 'none') {
                    let index;
                    let element;
                    if (event.keyCode === 40) {
                        if (this.focusedIndex > 7) {
                            if (this.focusedIndex + 1 < this.focusedElement.length) {
                                element = this.focusedElement[this.focusedIndex + 1];
                                element.focus();
                                this.focusedIndex = this.focusedIndex + 1;
                            }
                        }
                        else {
                            index = (this.focusedElement.length - this.resultsListBlock.children.length) + this.results.currentIndex + 1;
                            if (index < this.focusedElement.length) {
                                element = this.focusedElement[index];
                                element.focus();
                                this.focusedIndex = index;
                            }
                        }
                    }
                    else {
                        if (this.focusedIndex > 8) {
                            index = this.focusedIndex - 1;
                            element = this.focusedElement[index];
                            element.focus();
                            this.focusedIndex = index;
                        }
                    }
                }
            }
        };
        /**
         * Fires on replace.
         * @private
         */
        this.onReplaceButtonClick = () => {
            let optionsPane = this.optionsPane;
            let findText = this.searchInput.value;
            let replaceText = this.replaceWith.value;
            let results = this.viewer.owner.searchModule.textSearchResults;
            if (findText !== '' && !isNullOrUndefined(findText)) {
                if (this.viewer.owner.selection != null) {
                    let selectionText = this.viewer.owner.selection.text;
                    if (!this.viewer.owner.selection.isEmpty) {
                        if (this.viewer.owner.selection.isForward) {
                            this.viewer.owner.selection.selectContent(this.viewer.owner.selection.start, true);
                        }
                        else {
                            this.viewer.owner.selection.selectContent(this.viewer.owner.selection.end, true);
                        }
                    }
                    if (!isNullOrUndefined(results) && !isNullOrUndefined(results.currentSearchResult)) {
                        let result = results.currentSearchResult;
                        this.viewer.owner.searchModule.navigate(result);
                        if (result.text === selectionText) {
                            let replace = isNullOrUndefined(replaceText) ? '' : replaceText;
                            this.viewer.owner.searchModule.replace(replace, result, results);
                            let pattern = this.viewer.owner.searchModule.textSearch.stringToRegex(findText, this.findOption);
                            let endSelection = this.viewer.selection.end;
                            let index = endSelection.getHierarchicalIndexInternal();
                            // tslint:disable-next-line:max-line-length
                            this.viewer.owner.searchModule.textSearchResults = this.viewer.owner.searchModule.textSearch.findAll(pattern, this.findOption, index);
                            this.results = this.viewer.owner.searchModule.textSearchResults;
                            if (!isNullOrUndefined(this.results) && !isNullOrUndefined(this.results.currentSearchResult)) {
                                this.viewer.owner.searchModule.navigate(this.results.currentSearchResult);
                            }
                            else {
                                this.messageDiv.style.display = 'block';
                                this.messageDiv.innerHTML = this.localeValue.getConstant(this.matchDivReplaceText);
                            }
                            this.viewer.owner.findResultsList = [];
                            if (!isNullOrUndefined(this.results) && this.results.innerList.length > 0) {
                                this.navigateSearchResult();
                            }
                            else {
                                this.resultsListBlock.innerHTML = '';
                            }
                        }
                    }
                    else {
                        this.messageDiv.style.display = 'block';
                        this.messageDiv.innerHTML = this.localeValue.getConstant(this.matchDivReplaceText);
                    }
                }
            }
        };
        /**
         * Fires on replace all.
         * @private
         */
        this.onReplaceAllButtonClick = () => {
            this.replaceAll();
            this.resultsListBlock.style.display = 'none';
            this.messageDiv.innerHTML = '';
        };
        /**
         * Fires on search icon.
         * @private
         */
        this.searchIconClickInternal = () => {
            // tslint:disable:no-any 
            let inputElement = document.getElementById(this.viewer.owner.containerId + '_option_search_text_box');
            // tslint:enable:no-any
            let text = inputElement.value;
            if (text === '') {
                return;
            }
            if (this.searchIcon.classList.contains('e-de-op-search-close-icon')) {
                this.searchIcon.classList.add('e-de-op-search-icon');
                this.searchIcon.classList.remove('e-de-op-search-close-icon');
                inputElement.value = '';
                this.messageDiv.innerHTML = this.localeValue.getConstant('No matches');
                this.resultContainer.style.display = 'block';
                this.resultsListBlock.style.display = 'none';
                this.matchDiv.style.display = 'none';
                this.occurrenceDiv.style.display = 'none';
                this.onEnableDisableReplaceButton();
                this.clearFocusElement();
                this.resultsListBlock.innerHTML = '';
                this.clearSearchResultItems();
                this.viewer.owner.searchModule.clearSearchHighlight();
                this.viewer.renderVisiblePages();
                return;
            }
            if (this.searchIcon.classList.contains('e-de-op-search-icon') && text.length >= 1) {
                this.searchIcon.classList.add('e-de-op-search-close-icon');
                this.searchIcon.classList.remove('e-de-op-search-icon');
                this.onEnableDisableReplaceButton();
            }
            this.clearSearchResultItems();
            this.viewer.owner.searchModule.clearSearchHighlight();
            let patterns = this.viewer.owner.searchModule.textSearch.stringToRegex(text, this.findOption);
            let endSelection = this.viewer.selection.end;
            let index = endSelection.getHierarchicalIndexInternal();
            this.results = this.viewer.owner.searchModule.textSearch.findAll(patterns, this.findOption, index);
            if (this.results != null && this.results.length > 0) {
                this.navigateSearchResult();
                this.getMessageDivHeight();
                let resultsContainerHeight = this.viewer.owner.getDocumentEditorElement().offsetHeight - 215;
                this.resultsListBlock.style.height = resultsContainerHeight + 'px';
            }
            else {
                this.messageDiv.innerHTML = this.localeValue.getConstant('No matches');
                this.resultContainer.style.display = 'block';
                this.resultsListBlock.style.display = 'none';
                this.clearFocusElement();
                this.resultsListBlock.innerHTML = '';
            }
        };
        /**
         * Fires on getting next results.
         * @private
         */
        this.navigateNextResultButtonClick = () => {
            if (document.getElementById(this.viewer.owner.containerId + '_list_box_container') != null &&
                document.getElementById(this.viewer.owner.containerId + '_list_box_container').style.display !== 'none') {
                if (this.results.currentIndex < this.results.length - 1) {
                    this.results.currentIndex = this.results.currentIndex + 1;
                    let currentelement = this.results.innerList[this.results.currentIndex];
                    // tslint:disable-next-line:max-line-length
                    this.messageDiv.innerHTML = this.localeValue.getConstant('Result') + ' ' + (this.results.currentIndex + 1) + ' ' + this.localeValue.getConstant('of') + ' ' + this.resultsListBlock.children.length;
                    for (let i = 0; i < this.resultsListBlock.children.length; i++) {
                        let list = this.resultsListBlock.children[i];
                        if (list.classList.contains('e-de-search-result-hglt')) {
                            list.classList.remove('e-de-search-result-hglt');
                            list.children[0].classList.remove('e-de-op-search-word-text');
                            list.classList.add('e-de-search-result-item');
                        }
                    }
                    let listElement = this.resultsListBlock.children[this.results.currentIndex];
                    if (listElement.classList.contains('e-de-search-result-item')) {
                        listElement.classList.remove('e-de-search-result-item');
                        listElement.classList.add('e-de-search-result-hglt');
                        listElement.children[0].classList.add('e-de-op-search-word-text');
                        this.scrollToPosition(listElement);
                    }
                    this.viewer.owner.searchModule.navigate(currentelement);
                    this.viewer.owner.searchModule.highlight(this.results);
                }
                else {
                    let currentelement = this.results.innerList[0];
                    this.results.currentIndex = 0;
                    // tslint:disable-next-line:max-line-length
                    this.messageDiv.innerHTML = this.localeValue.getConstant('Result') + ' ' + (this.results.currentIndex + 1) + ' ' + this.localeValue.getConstant('of') + ' ' + this.resultsListBlock.children.length;
                    for (let j = 0; j < this.resultsListBlock.children.length; j++) {
                        let lists = this.resultsListBlock.children[j];
                        if (lists.classList.contains('e-de-search-result-hglt')) {
                            lists.classList.remove('e-de-search-result-hglt');
                            lists.children[0].classList.remove('e-de-op-search-word-text');
                            lists.classList.add('e-de-search-result-item');
                        }
                    }
                    let listElementsDiv = this.resultsListBlock.children[this.results.currentIndex];
                    if (listElementsDiv.classList.contains('e-de-search-result-item')) {
                        listElementsDiv.classList.remove('e-de-search-result-item');
                        listElementsDiv.classList.add('e-de-search-result-hglt');
                        listElementsDiv.children[0].classList.add('e-de-op-search-word-text');
                        this.scrollToPosition(listElementsDiv);
                    }
                    this.viewer.owner.searchModule.navigate(currentelement);
                    this.viewer.owner.searchModule.highlight(this.results);
                }
                this.focusedIndex = this.focusedElement.indexOf(this.navigateToNextResult);
            }
        };
        /**
         * Fires on getting previous results.
         * @private
         */
        this.navigatePreviousResultButtonClick = () => {
            if (document.getElementById(this.viewer.owner.containerId + '_list_box_container') != null &&
                document.getElementById(this.viewer.owner.containerId + '_list_box_container').style.display !== 'none') {
                if (this.results.currentIndex === 0) {
                    this.results.currentIndex = this.results.length - 1;
                    // tslint:disable-next-line:max-line-length
                    this.messageDiv.innerHTML = this.localeValue.getConstant('Result') + ' ' + (this.results.length) + ' ' + this.localeValue.getConstant('of') + ' ' + this.resultsListBlock.children.length;
                    for (let index = 0; index < this.resultsListBlock.children.length; index++) {
                        let list = this.resultsListBlock.children[index];
                        if (list.classList.contains('e-de-search-result-hglt')) {
                            list.classList.remove('e-de-search-result-hglt');
                            list.children[0].classList.remove('e-de-op-search-word-text');
                            list.classList.add('e-de-search-result-item');
                        }
                    }
                    let liElement = this.resultsListBlock.children[this.results.currentIndex];
                    if (liElement.classList.contains('e-de-search-result-item')) {
                        liElement.classList.remove('e-de-search-result-item');
                        liElement.classList.add('e-de-search-result-hglt');
                        liElement.children[0].classList.add('e-de-op-search-word-text');
                        this.scrollToPosition(liElement);
                    }
                    let currentelement = this.results.innerList[this.results.currentIndex];
                    this.viewer.owner.searchModule.navigate(currentelement);
                    this.viewer.owner.searchModule.highlight(this.results);
                }
                else {
                    // tslint:disable-next-line:max-line-length
                    this.messageDiv.innerHTML = this.localeValue.getConstant('Result') + ' ' + (this.results.currentIndex) + ' ' + this.localeValue.getConstant('of') + ' ' + this.resultsListBlock.children.length;
                    this.results.currentIndex = this.results.currentIndex - 1;
                    for (let j = 0; j < this.resultsListBlock.children.length; j++) {
                        let list = this.resultsListBlock.children[j];
                        if (list.classList.contains('e-de-search-result-hglt')) {
                            list.classList.remove('e-de-search-result-hglt');
                            list.children[0].classList.remove('e-de-op-search-word-text');
                            list.classList.add('e-de-search-result-item');
                        }
                    }
                    let listElements = this.resultsListBlock.children[this.results.currentIndex];
                    if (listElements.classList.contains('e-de-search-result-item')) {
                        listElements.classList.remove('e-de-search-result-item');
                        listElements.classList.add('e-de-search-result-hglt');
                        listElements.children[0].classList.add('e-de-op-search-word-text');
                        this.scrollToPosition(listElements);
                    }
                    let currentelement = this.results.innerList[this.results.currentIndex];
                    this.viewer.owner.searchModule.navigate(currentelement);
                    this.viewer.owner.searchModule.highlight(this.results);
                }
                this.focusedIndex = this.focusedElement.indexOf(this.navigateToPreviousResult);
            }
        };
        /**
         * Fires on key down
         * @param {KeyboardEvent} event - Speficies key down actions.
         * @private
         */
        this.onKeyDown = (event) => {
            let code = event.which || event.keyCode;
            if (code === 13 && event.keyCode !== 9 && event.keyCode !== 40) {
                event.preventDefault();
                this.findDiv.style.height = '';
                this.onKeyDownInternal();
            }
            else if (code === 8 && (this.searchInput.value.length === 0)) {
                this.resultContainer.style.display = 'block';
            }
            else if (event.keyCode !== 9 && event.keyCode !== 40 && event.keyCode !== 27) {
                this.viewer.owner.searchModule.clearSearchHighlight();
                this.clearSearchResultItems();
                this.viewer.renderVisiblePages();
                this.resultsListBlock.style.display = 'none';
                this.messageDiv.innerHTML = this.localeValue.getConstant('No matches');
                this.resultContainer.style.display = 'none';
                this.clearFocusElement();
                this.resultsListBlock.innerHTML = '';
                if (this.searchIcon.classList.contains('e-de-op-search-close-icon')) {
                    this.searchIcon.classList.add('e-de-op-search-icon');
                    this.searchIcon.classList.remove('e-de-op-search-close-icon');
                }
            }
            else if (code === 27 && event.keyCode === 27) {
                this.showHideOptionsPane(false);
            }
        };
        /**
         * Close the optios pane.
         * @private
         */
        this.close = () => {
            this.clearFocusElement();
            this.showHideOptionsPane(false);
            this.resultsListBlock.innerHTML = '';
            this.focusedIndex = 1;
            this.isOptionsPane = true;
        };
        /**
         * Fires on results list block.
         * @param {MouseEvent} args - Specifies which list was clicked.
         * @private
         */
        this.resultListBlockClick = (args) => {
            let currentlist = args.target;
            let element = this.resultsListBlock.children;
            let index = 0;
            for (let i = 0; i < element.length; i++) {
                let list = element[i];
                if (list.classList.contains('e-de-search-result-hglt')) {
                    list.classList.remove('e-de-search-result-hglt');
                    list.children[0].classList.remove('e-de-op-search-word-text');
                    list.classList.add('e-de-search-result-item');
                }
            }
            let list;
            for (let i = 0; i < element.length; i++) {
                if (currentlist === element[i]) {
                    index = i;
                    list = element[i];
                    if (list.classList.contains('e-de-search-result-item')) {
                        list.classList.remove('e-de-search-result-item');
                        list.classList.add('e-de-search-result-hglt');
                        list.children[0].classList.add('e-de-op-search-word-text');
                        this.focusedIndex = this.focusedElement.indexOf(list);
                    }
                }
            }
            let currentelement = this.results.innerList[index];
            this.results.currentIndex = index;
            // tslint:disable-next-line:max-line-length
            this.messageDiv.innerHTML = this.localeValue.getConstant('Result') + ' ' + (index + 1) + ' ' + this.localeValue.getConstant('of') + ' ' + this.resultsListBlock.children.length;
            this.viewer.owner.searchModule.navigate(currentelement);
            this.viewer.owner.searchModule.highlight(this.results);
            list.focus();
        };
        this.viewer = layoutViewer;
    }
    /**
     * Get the module name.
     */
    getModuleName() {
        return 'OptionsPane';
    }
    /**
     * Initialize the options pane.
     * @param {L10n} localeValue - Specifies the localization based on culture.
     * @private
     */
    // tslint:disable:max-func-body-length
    initOptionsPane(localeValue) {
        let viewer = this.viewer;
        this.localeValue = localeValue;
        this.optionsPane = createElement('div', { className: 'e-de-op', styles: 'display:none;' });
        this.optionsPane.addEventListener('keydown', this.onKeyDownOnOptionPane);
        this.searchDiv = createElement('div', {
            className: this.viewer.owner.containerId + '_searchDiv e-de-op-header',
            innerHTML: localeValue.getConstant(this.searchText)
        });
        this.optionsPane.appendChild(this.searchDiv);
        // tslint:disable-next-line:max-line-length
        this.closeButton = createElement('button', { className: 'e-de-op-close-button e-de-op-icon-btn e-btn e-flat e-icon-btn', id: 'close' });
        this.optionsPane.appendChild(this.closeButton);
        let closeSpan = createElement('span', { className: 'e-de-op-close-icon e-btn-icon e-icons' });
        this.closeButton.appendChild(closeSpan);
        this.focusedElement.push(this.closeButton);
        this.findTab = createElement('div', { id: this.viewer.owner.containerId + '_findTabDiv', className: 'e-de-op-tab' });
        this.optionsPane.appendChild(this.findTab);
        let tabHeader = createElement('div', { className: 'e-tab-header' });
        this.findTab.appendChild(tabHeader);
        this.findTabButton = createElement('div', { innerHTML: localeValue.getConstant(this.findPaneText) });
        this.focusedElement.push(this.findTabButtonHeader);
        tabHeader.appendChild(this.findTabButton);
        this.replaceTabButton = createElement('div', { innerHTML: localeValue.getConstant(this.replacePaneText) });
        this.focusedElement.push(this.replaceTabButtonHeader);
        tabHeader.appendChild(this.replaceTabButton);
        let tabContent = createElement('div', { className: 'e-content' });
        let findTabContent = createElement('div', { id: 'findTabContent' });
        tabContent.appendChild(findTabContent);
        this.findTabContentDiv = createElement('div', { className: 'e-de-search-tab-content' });
        this.searchTextBoxContainer = createElement('div', { className: 'e-input-group e-de-op-input-group' });
        this.findTabContentDiv.appendChild(this.searchTextBoxContainer);
        // tslint:disable-next-line:max-line-length
        this.searchInput = createElement('input', { className: 'e-input e-de-search-input', id: this.viewer.owner.containerId + '_option_search_text_box', attrs: { placeholder: 'Search for' }, styles: 'font-size:14px;' });
        this.searchTextBoxContainer.appendChild(this.searchInput);
        this.searchIcon = createElement('span', {
            className: 'e-de-op-icon e-de-op-search-icon e-input-group-icon e-icon',
            id: this.viewer.owner.containerId + '_search-icon'
        });
        this.searchIcon.tabIndex = 0;
        this.searchTextBoxContainer.appendChild(this.searchIcon);
        this.focusedElement.push(this.searchIcon);
        // tslint:disable-next-line:max-line-length
        this.navigateToPreviousResult = createElement('span', { className: 'e-de-op-icon e-de-op-nav-btn e-arrow-up e-spin-up e-btn-icon e-icon e-input-group-icon' });
        this.navigateToPreviousResult.tabIndex = 0;
        this.searchTextBoxContainer.appendChild(this.navigateToPreviousResult);
        this.focusedElement.push(this.navigateToPreviousResult);
        // tslint:disable-next-line:max-line-length
        this.navigateToNextResult = createElement('span', { className: 'e-de-op-icon e-de-op-nav-btn e-arrow-down e-spin-down e-btn-icon e-icon e-input-group-icon' });
        this.navigateToNextResult.tabIndex = 0;
        this.searchTextBoxContainer.appendChild(this.navigateToNextResult);
        this.focusedElement.push(this.navigateToNextResult);
        let div = createElement('div', { className: 'e-de-op-more-less' });
        this.matchInput = createElement('input', {
            attrs: { type: 'checkbox' },
            id: this.viewer.owner.containerId + '_matchCase'
        });
        div.appendChild(this.matchInput);
        this.matchCase = new CheckBox({ label: 'Match case', checked: false, change: this.matchChange });
        this.matchCase.appendTo(this.matchInput);
        this.focusedElement.push(this.matchInput);
        this.matchInput.tabIndex = 0;
        this.wholeInput = createElement('input', {
            attrs: { type: 'checkbox' },
            id: this.viewer.owner.containerId + '_wholeWord',
        });
        div.appendChild(this.wholeInput);
        this.wholeWord = new CheckBox({ label: 'Whole words', checked: false, change: this.wholeWordsChange });
        this.wholeWord.appendTo(this.wholeInput);
        this.focusedElement.push(this.wholeInput);
        this.wholeInput.tabIndex = 0;
        this.findTabContentDiv.appendChild(div);
        let replaceTabContent = createElement('div');
        tabContent.appendChild(replaceTabContent);
        this.replaceTabContentDiv = createElement('div', { className: 'e-de-op-replacetabcontentdiv', styles: 'display:none;' });
        tabContent.appendChild(this.replaceTabContentDiv);
        this.findTabContentDiv.appendChild(this.replaceTabContentDiv);
        this.createReplacePane();
        this.findDiv = createElement('div', { className: 'findDiv', styles: 'height:250px;display:block;' });
        findTabContent.appendChild(this.findTabContentDiv);
        this.resultContainer = createElement('div', { styles: 'width:85%;display:block;', className: 'e-de-op-result-container' });
        this.findDiv.appendChild(this.resultContainer);
        // tslint:disable-next-line:max-line-length
        this.messageDiv = createElement('div', { className: this.viewer.owner.containerId + '_messageDiv e-de-op-msg', innerHTML: this.localeValue.getConstant(this.messageDivText), id: this.viewer.owner.containerId + '_search_status' });
        this.resultContainer.appendChild(this.messageDiv);
        // tslint:disable-next-line:max-line-length
        this.resultsListBlock = createElement('div', { id: this.viewer.owner.containerId + '_list_box_container', styles: 'display:none;width:270px;list-style:none;padding-right:5px;overflow:auto;', className: 'e-de-result-list-block' });
        this.findDiv.appendChild(this.resultsListBlock);
        this.findTabContentDiv.appendChild(this.findDiv);
        this.findTab.appendChild(tabContent);
        this.tabInstance = new Tab({ selected: this.selectedTabItem });
        this.tabInstance.appendTo(this.findTab);
        let findHeader = this.tabInstance.element.getElementsByClassName('e-item e-toolbar-item')[0];
        this.findTabButtonHeader = findHeader.getElementsByClassName('e-tab-wrap')[0];
        this.findTabButtonHeader.classList.add('e-de-op-find-tab-header');
        this.findTabButtonHeader.tabIndex = 0;
        let replaceHeader = this.tabInstance.element.getElementsByClassName('e-item e-toolbar-item')[1];
        this.replaceTabButtonHeader = replaceHeader.getElementsByClassName('e-tab-wrap')[0];
        this.replaceTabButtonHeader.classList.add('e-de-op-replace-tab-header');
        this.replaceTabButtonHeader.tabIndex = 0;
        this.onWireEvents();
    }
    /**
     * Create replace pane instances.
     */
    createReplacePane() {
        this.replaceDiv = createElement('div');
        this.replaceTabContentDiv.appendChild(this.replaceDiv);
        this.replaceWith = createElement('input', {
            className: 'e-de-op-replacewith e-input', styles: 'font-size:14px;',
            attrs: { placeholder: 'Replace with' }
        });
        this.replaceDiv.appendChild(this.replaceWith);
        let replaceButtonDiv = createElement('div', { styles: 'text-align:right;', className: 'e-de-op-dlg-footer' });
        this.replaceDiv.appendChild(replaceButtonDiv);
        this.replaceButton = createElement('button', {
            className: 'e-control e-btn e-flat e-replace',
            styles: 'font-size:12px;margin-right:10px;',
            innerHTML: this.localeValue.getConstant(this.replaceButtonText)
        });
        replaceButtonDiv.appendChild(this.replaceButton);
        this.replaceAllButton = createElement('button', {
            className: 'e-control e-btn e-flat e-replaceall',
            styles: 'font-size:12px;',
            innerHTML: this.localeValue.getConstant(this.replaceAllButtonText)
        });
        replaceButtonDiv.appendChild(this.replaceAllButton);
        this.matchDiv = createElement('div', { styles: 'display:none;padding-top:10px;' });
        this.replaceDiv.appendChild(this.matchDiv);
        let emptyDiv6 = createElement('div', { className: 'e-de-op-search-replacediv' });
        this.replaceDiv.appendChild(emptyDiv6);
        this.occurrenceDiv = createElement('div', { styles: 'display:none;' });
        this.replaceDiv.appendChild(this.occurrenceDiv);
    }
    navigateSearchResult() {
        this.viewer.owner.searchModule.navigate(this.results.innerList[this.results.currentIndex]);
        this.viewer.owner.searchModule.highlight(this.results);
        this.viewer.owner.searchModule.addFindResultView(this.results);
        this.resultsListBlock.style.display = 'block';
        this.resultContainer.style.display = 'block';
        let lists = this.viewer.owner.findResultsList;
        let text = '';
        for (let i = 0; i < lists.length; i++) {
            text += lists[i];
        }
        this.clearFocusElement();
        this.resultsListBlock.innerHTML = text;
        for (let i = 0; i < this.resultsListBlock.children.length; i++) {
            this.focusedElement.push(this.resultsListBlock.children[i]);
        }
        let currentIndexValue = this.results.currentIndex;
        // tslint:disable-next-line:max-line-length
        this.messageDiv.innerHTML = this.localeValue.getConstant('Result') + ' ' + (currentIndexValue + 1) + ' ' + this.localeValue.getConstant('of') + ' ' + this.resultsListBlock.children.length;
        let listElement = this.resultsListBlock.children[currentIndexValue];
        if (listElement.classList.contains('e-de-search-result-item')) {
            listElement.classList.remove('e-de-search-result-item');
            listElement.classList.add('e-de-search-result-hglt');
            listElement.children[0].classList.add('e-de-op-search-word-text');
            this.scrollToPosition(listElement);
        }
    }
    /**
     * Fires on key down actions done.
     * @private
     */
    onKeyDownInternal() {
        // tslint:disable-next-line:max-line-length
        let inputElement = document.getElementById(this.viewer.owner.containerId + '_option_search_text_box');
        inputElement.blur();
        let text = inputElement.value;
        if (text === '') {
            return;
        }
        if (text.length >= 1 && this.searchIcon.classList.contains('e-de-op-search-icon')) {
            this.searchIcon.classList.add('e-de-op-search-close-icon');
            this.searchIcon.classList.remove('e-de-op-search-icon');
        }
        let resultsContainerHeight = this.viewer.owner.getDocumentEditorElement().offsetHeight - 215;
        this.clearSearchResultItems();
        this.viewer.owner.searchModule.clearSearchHighlight();
        let pattern = this.viewer.owner.searchModule.textSearch.stringToRegex(text, this.findOption);
        let endSelection = this.viewer.selection.end;
        let index = endSelection.getHierarchicalIndexInternal();
        this.results = this.viewer.owner.searchModule.textSearch.findAll(pattern, this.findOption, index);
        let results = this.results;
        if (isNullOrUndefined(results)) {
            this.viewer.renderVisiblePages();
        }
        if (results != null && results.length > 0) {
            if ((this.focusedElement.indexOf(this.navigateToPreviousResult) === -1) && this.isOptionsPane) {
                this.focusedElement.push(this.navigateToPreviousResult);
            }
            if ((this.focusedElement.indexOf(this.navigateToNextResult) === -1) && this.isOptionsPane) {
                this.focusedElement.push(this.navigateToNextResult);
            }
            this.viewer.owner.searchModule.navigate(this.results.innerList[this.results.currentIndex]);
            this.viewer.owner.searchModule.highlight(results);
            this.viewer.owner.searchModule.addFindResultView(results);
            // if (this.isOptionsPane) {
            this.resultsListBlock.style.display = 'block';
            this.resultsListBlock.style.height = resultsContainerHeight + 'px';
            this.resultContainer.style.display = 'block';
            let list = this.viewer.owner.findResultsList;
            let text = '';
            this.clearFocusElement();
            this.resultsListBlock.innerHTML = '';
            for (let i = 0; i < list.length; i++) {
                text += list[i];
            }
            this.resultsListBlock.innerHTML = text;
            for (let i = 0; i < this.resultsListBlock.children.length; i++) {
                this.focusedElement.push(this.resultsListBlock.children[i]);
            }
            let lists = this.resultsListBlock.children;
            let currentIndex = this.results.currentIndex;
            // tslint:disable-next-line:max-line-length
            this.messageDiv.innerHTML = this.localeValue.getConstant('Result') + ' ' + (currentIndex + 1) + ' ' + this.localeValue.getConstant('of') + ' ' + this.resultsListBlock.children.length;
            let listElement = this.resultsListBlock.children[currentIndex];
            if (listElement.classList.contains('e-de-search-result-item')) {
                listElement.classList.remove('e-de-search-result-item');
                listElement.classList.add('e-de-search-result-hglt');
                listElement.children[0].classList.add('e-de-op-search-word-text');
            }
            this.navigateToNextResult.focus();
            this.focusedIndex = 6;
            this.getMessageDivHeight();
            // } else {
            //this.focusedIndex = 4;
            // }
        }
        else {
            this.messageDiv.innerHTML = this.localeValue.getConstant('No matches');
            this.resultContainer.style.display = 'block';
            this.resultsListBlock.style.display = 'none';
            this.clearFocusElement();
            this.resultsListBlock.innerHTML = '';
        }
    }
    getMessageDivHeight() {
        if (!this.isOptionsPane && this.messageDiv.classList.contains('e-de-op-msg')) {
            this.messageDiv.classList.add('e-de-op-replace-messagediv');
            this.messageDiv.classList.remove('e-de-op-msg');
        }
        else if (this.isOptionsPane && this.messageDiv.classList.contains('e-de-op-replace-messagediv')) {
            this.messageDiv.classList.add('e-de-op-msg');
            this.messageDiv.classList.remove('e-de-op-replace-messagediv');
        }
    }
    /**
     * Replace all.
     * @private
     */
    replaceAll() {
        let optionsPane = this.optionsPane;
        let findText = this.searchInput.value;
        let replaceText = this.replaceWith.value;
        if (findText !== '' && !isNullOrUndefined(findText)) {
            let pattern = this.viewer.owner.searchModule.textSearch.stringToRegex(findText, this.findOption);
            let endSelection = this.viewer.selection.end;
            let index = endSelection.getHierarchicalIndexInternal();
            let results = this.viewer.owner.searchModule.textSearch.findAll(pattern, this.findOption, index);
            let replace = isNullOrUndefined(replaceText) ? '' : replaceText;
            let count = isNullOrUndefined(results) ? 0 : results.length;
            this.viewer.owner.searchModule.replaceAll(replace, results);
            this.matchDiv.style.display = 'block';
            this.matchDiv.innerHTML = this.localeValue.getConstant('All Done') + '!';
            this.occurrenceDiv.style.display = 'block';
            // tslint:disable-next-line:max-line-length
            this.occurrenceDiv.innerHTML = this.localeValue.getConstant('We replaced all') + ' ' + count + ' ' + this.localeValue.getConstant('instances') + ' ' + this.localeValue.getConstant('of') + ' "' + findText + '" ' + this.localeValue.getConstant('with') + ' "' + replaceText + '" ';
        }
    }
    /**
     * Scrolls to position.
     * @param {HTMLElement} list - Specifies the list element.
     * @private
     */
    scrollToPosition(list) {
        let rect = list.getBoundingClientRect();
        let top;
        if (rect.top > 0) {
            top = rect.top - list.parentElement.getBoundingClientRect().top;
            if ((list.parentElement.offsetHeight - top) <= list.offsetHeight) {
                if (Math.ceil(top + list.offsetHeight) === list.parentElement.scrollHeight) {
                    list.parentElement.scrollTop = top;
                }
                list.parentElement.scrollTop = list.parentElement.scrollTop + (list.parentElement.offsetHeight / 100) * 30;
            }
            else if (top < 0) {
                list.parentElement.scrollTop = list.parentElement.scrollTop - (list.parentElement.offsetHeight / 100) * 30;
            }
        }
        else {
            list.parentElement.scrollTop = 0;
        }
    }
    /**
     * Clear the focus elements.
     * @private
     */
    clearFocusElement() {
        for (let i = 0; i < this.resultsListBlock.children.length; i++) {
            let index = this.focusedElement.indexOf(this.resultsListBlock.children[i]);
            if (index !== -1) {
                this.focusedElement.splice(index, 1);
            }
        }
        this.focusedIndex = 0;
    }
    /**
     * Show or hide option pane based on boolean value.
     * @param {boolean} show - Specifies showing or hiding the options pane.
     * @private
     */
    showHideOptionsPane(show) {
        if (!isNullOrUndefined(this.viewer.owner.selectionModule)) {
            if (show) {
                this.localeValue = new L10n('documenteditor', this.viewer.owner.defaultLocale);
                this.localeValue.setLocale(this.viewer.owner.locale);
                setCulture(this.viewer.owner.locale);
                if (isNullOrUndefined(this.optionsPane)) {
                    this.initOptionsPane(this.localeValue);
                    //Add Option Pane
                    let element = document.getElementById(this.viewer.owner.element.id);
                    let optionPaneContainer = document.createElement('div');
                    optionPaneContainer.className = 'e-documenteditor-optionspane';
                    optionPaneContainer.setAttribute('style', 'display:inline-flex');
                    optionPaneContainer.appendChild(this.viewer.owner.optionsPaneModule.optionsPane);
                    this.viewer.owner.getDocumentEditorElement().appendChild(optionPaneContainer);
                    optionPaneContainer.appendChild(this.viewer.viewerContainer);
                    element.appendChild(optionPaneContainer);
                }
                this.optionsPane.style.display = 'block';
                if (this.viewer.owner.isReadOnlyMode) {
                    this.tabInstance.hideTab(1);
                }
                else {
                    this.tabInstance.hideTab(1, false);
                }
                if (this.isReplace && !this.viewer.owner.isReadOnlyMode) {
                    this.tabInstance.select(1);
                    this.isReplace = false;
                    this.isOptionsPane = false;
                }
                else {
                    this.tabInstance.select(0);
                }
                this.searchDiv.innerHTML = this.localeValue.getConstant(this.searchText);
                this.isOptionsPaneShow = true;
                // tslint:disable-next-line:max-line-length
                let textBox = document.getElementById(this.viewer.owner.getDocumentEditorElement().id + '_option_search_text_box');
                let selectedText = this.viewer.owner.selection.text;
                if (!isNullOrUndefined(selectedText)) {
                    let char = ['\v', '\r'];
                    let index = HelperMethods.indexOfAny(selectedText, char);
                    selectedText = index < 0 ? selectedText : selectedText.substring(0, index);
                }
                textBox.value = selectedText;
                textBox.select();
                this.messageDiv.innerHTML = '';
                if (this.searchIcon.classList.contains('e-de-op-search-close-icon')) {
                    this.searchIcon.classList.add('e-de-op-search-icon');
                    this.searchIcon.classList.remove('e-de-op-search-close-icon');
                }
                this.viewer.selection.caret.style.display = 'none';
                this.focusedIndex = 3;
                this.focusedElement = [];
                if (this.isOptionsPane) {
                    // tslint:disable-next-line:max-line-length
                    this.focusedElement.push(this.closeButton, this.findTabButtonHeader, this.replaceTabButtonHeader, this.searchInput, this.searchIcon, this.navigateToPreviousResult, this.navigateToNextResult, this.matchInput, this.wholeInput);
                }
                else {
                    // tslint:disable-next-line:max-line-length
                    this.focusedElement.push(this.closeButton, this.findTabButtonHeader, this.replaceTabButtonHeader, this.searchInput, this.searchIcon, this.navigateToPreviousResult, this.navigateToNextResult, this.matchInput, this.wholeInput, this.replaceWith, this.replaceButton, this.replaceAllButton);
                }
                this.viewer.updateViewerSize();
            }
            else {
                if (!isNullOrUndefined(this.optionsPane)) {
                    this.clearSearchResultItems();
                    this.viewer.owner.searchModule.clearSearchHighlight();
                    this.isOptionsPaneShow = false;
                    let resultListBox = document.getElementById(this.viewer.owner.containerId + '_list_box_container');
                    let message = document.getElementById(this.viewer.owner.containerId + '_search_status');
                    if (!isNullOrUndefined(resultListBox) && !isNullOrUndefined(message)) {
                        resultListBox.style.display = 'none';
                        this.clearFocusElement();
                        resultListBox.innerHTML = '';
                        message.innerHTML = this.localeValue.getConstant('No matches');
                    }
                }
                this.viewer.updateViewerSize();
                if (!isNullOrUndefined(this.optionsPane)) {
                    if (this.optionsPane.style.display !== 'none') {
                        this.viewer.selection.updateCaretPosition();
                        this.optionsPane.style.display = 'none';
                    }
                }
                this.viewer.updateFocus();
                this.viewer.selection.caret.style.display = 'block';
            }
        }
    }
    /**
     * Clears search results.
     * @private
     */
    clearSearchResultItems() {
        if (!isNullOrUndefined(this.viewer.owner.findResultsList)) {
            this.viewer.owner.findResultsList = [];
        }
    }
    /**
     * Dispose the internal objects which are maintained.
     * @private
     */
    destroy() {
        if (this.optionsPane) {
            this.optionsPane.innerHTML = '';
            this.optionsPane = undefined;
        }
        if (this.resultsListBlock) {
            this.resultsListBlock.innerHTML = '';
            this.resultsListBlock = undefined;
        }
        if (this.messageDiv) {
            this.messageDiv.innerHTML = '';
            this.messageDiv = undefined;
        }
        if (this.resultContainer) {
            this.resultContainer.innerHTML = '';
        }
        this.resultContainer = undefined;
        if (this.searchInput) {
            this.searchInput.value = '';
            this.searchInput = undefined;
        }
        if (this.searchDiv) {
            this.searchDiv.innerHTML = '';
            this.searchDiv = undefined;
        }
        if (this.searchTextBoxContainer) {
            this.searchTextBoxContainer.innerHTML = '';
            this.searchTextBoxContainer = undefined;
        }
        if (this.replaceWith) {
            this.replaceWith.innerHTML = '';
            this.replaceWith = undefined;
        }
        if (this.findDiv) {
            this.findDiv.innerHTML = '';
            this.findDiv = undefined;
        }
        if (this.replaceButton) {
            this.replaceButton.innerHTML = '';
            this.replaceButton = undefined;
        }
        if (this.replaceAllButton) {
            this.replaceAllButton.innerHTML = '';
            this.replaceAllButton = undefined;
        }
        if (this.matchInput) {
            this.matchInput.innerHTML = '';
            this.matchCase = undefined;
        }
        if (this.wholeInput) {
            this.wholeInput.innerHTML = '';
            this.wholeWord = undefined;
        }
        // if (this.regularInput) {
        //     this.regularInput.innerHTML = '';
        //     this.regular = undefined;
        // }
        if (!isNullOrUndefined(this.results)) {
            this.results.destroy();
        }
        if (this.focusedElement) {
            this.focusedElement = [];
        }
        this.focusedElement = undefined;
        this.destroyInternal();
    }
    /**
     * Dispose the internal objects which are maintained.
     */
    destroyInternal() {
        if (this.searchText) {
            this.searchText = undefined;
        }
        if (this.resultsText) {
            this.resultsText = undefined;
        }
        if (this.messageDivText) {
            this.messageDivText = undefined;
        }
        if (this.replaceButtonText) {
            this.replaceButtonText = undefined;
        }
        if (this.replaceAllButtonText) {
            this.replaceAllButtonText = undefined;
        }
    }
}

/**
 * Search Export
 */

/**
 * @private
 */
class TableResizer {
    /**
     * @private
     */
    constructor(node) {
        this.resizeNode = 0;
        this.resizerPosition = 0;
        this.currentResizingTable = undefined;
        this.owner = node;
        this.startingPoint = new Point(0, 0);
    }
    /**
     * @private
     */
    get viewer() {
        return this.owner.viewer;
    }
    /**
     * Gets module name.
     */
    getModuleName() {
        return 'TableResizer';
    }
    /**
     * @private
     */
    updateResizingHistory(touchPoint) {
        if (this.owner.editorHistory) {
            this.owner.editorHistory.updateResizingHistory(touchPoint, this);
        }
        this.viewer.isRowOrCellResizing = false;
        this.resizerPosition = -1;
    }
    handleResize(point) {
        this.owner.viewer.isRowOrCellResizing = true;
        this.startingPoint.x = point.x;
        this.startingPoint.y = point.y;
        //Initialize resizing history.
        this.owner.editorHistory.initResizingHistory(point, this);
    }
    //Table Resizing implementation starts
    /**
     * @private
     */
    isInRowResizerArea(touchPoint) {
        let position = this.getRowReSizerPosition(undefined, touchPoint);
        if (position === -1) {
            return false;
        }
        else {
            this.resizeNode = 1;
            this.resizerPosition = position;
            return true;
        }
    }
    isInCellResizerArea(touchPoint) {
        let position = this.getCellReSizerPosition(touchPoint);
        if (position === -1) {
            return false;
        }
        else {
            this.resizeNode = 0;
            this.resizerPosition = position;
            return true;
        }
    }
    /**
     * Gets cell resizer position.
     * @param {Point} point
     * @private
     */
    getCellReSizerPosition(touchPoint) {
        let position = -1;
        let resizerBoundaryWidth = 2;
        let tableWidget = this.getTableWidget(touchPoint);
        let cellWidget = this.getTableCellWidget(touchPoint);
        let cellSpacing = isNullOrUndefined(tableWidget) ? 0 : tableWidget.tableFormat.cellSpacing;
        if (tableWidget && cellSpacing > 0) {
            this.currentResizingTable = tableWidget;
            // tslint:disable-next-line:max-line-length
            if (this.viewer.isInsideRect(tableWidget.x - HelperMethods.convertPointToPixel(tableWidget.leftBorderWidth) - 0.25, tableWidget.y, HelperMethods.convertPointToPixel(tableWidget.leftBorderWidth) + 0.5, tableWidget.height, touchPoint)) {
                return position = 0;
            }
            let startingPointX = tableWidget.x;
            for (let i = 0; i < tableWidget.tableHolder.columns.length; i++) {
                let preferredWidth = HelperMethods.convertPointToPixel(tableWidget.tableHolder.columns[i].preferredWidth);
                // tslint:disable-next-line:max-line-length
                if ((this.viewer.isInsideRect(startingPointX - 1, tableWidget.y, tableWidget.leftBorderWidth + resizerBoundaryWidth, tableWidget.height, touchPoint))) {
                    return position = i > 0 ? i : 0;
                    // tslint:disable-next-line:max-line-length
                }
                else if (i > 0 && (this.viewer.isInsideRect(startingPointX + preferredWidth - resizerBoundaryWidth / 2, tableWidget.y, resizerBoundaryWidth, tableWidget.height, touchPoint))) {
                    return position = (i + 1);
                }
                startingPointX = startingPointX + preferredWidth;
            }
        }
        else {
            if (!isNullOrUndefined(cellWidget)) {
                this.currentResizingTable = cellWidget.ownerTable;
                // tslint:disable-next-line:max-line-length
                if (this.viewer.isInsideRect(cellWidget.x - cellWidget.margin.left - resizerBoundaryWidth / 2, cellWidget.y - cellWidget.margin.top, resizerBoundaryWidth, cellWidget.height, touchPoint)) {
                    return position = cellWidget.columnIndex;
                    // tslint:disable-next-line:max-line-length
                }
                else if (isNullOrUndefined(cellWidget.nextRenderedWidget)
                    && this.viewer.isInsideRect(cellWidget.x + cellWidget.margin.right + cellWidget.width - resizerBoundaryWidth / 2, cellWidget.y - cellWidget.margin.top, resizerBoundaryWidth, cellWidget.height, touchPoint)) {
                    return position = (cellWidget.columnIndex + cellWidget.cellFormat.columnSpan);
                }
                else if (cellWidget.childWidgets.length > 0) {
                    return this.getCellReSizerPositionInternal(cellWidget, touchPoint); // Gets the nested table resizer position.
                }
            }
        }
        return position;
    }
    /**
     * Gets cell resizer position.
     * @param {TableCellWidget} cellWidget
     * @param {Point} touchPoint
     */
    getCellReSizerPositionInternal(cellWidget, touchPoint) {
        let position = -1;
        let childTableWidget = this.getTableWidgetFromWidget(touchPoint, cellWidget);
        let childCellWidget = undefined;
        if (!isNullOrUndefined(childTableWidget) && childTableWidget.tableFormat.cellSpacing > 0) {
            this.currentResizingTable = childTableWidget;
            // tslint:disable-next-line:max-line-length
            if (this.viewer.isInsideRect(childTableWidget.x - childTableWidget.leftBorderWidth - 0.25, childTableWidget.y, childTableWidget.leftBorderWidth + 0.5, childTableWidget.height, touchPoint)) {
                return position = 0;
            }
            let startingPointX = childTableWidget.x;
            for (let i = 0; i < childTableWidget.tableHolder.columns.length; i++) {
                // tslint:disable-next-line:max-line-length
                let preferredWidth = HelperMethods.convertPointToPixel(childTableWidget.tableHolder.columns[i].preferredWidth);
                // tslint:disable-next-line:max-line-length
                if ((this.viewer.isInsideRect(startingPointX - 1, childTableWidget.y, childTableWidget.leftBorderWidth + 2, childTableWidget.height, touchPoint))) {
                    return position = i > 0 ? i : 0;
                    // tslint:disable-next-line:max-line-length
                }
                else if (i > 0 && (this.viewer.isInsideRect(startingPointX + preferredWidth - 1, childTableWidget.y, 2, childTableWidget.height, touchPoint))) {
                    return position = (i + 1);
                }
                startingPointX = startingPointX + preferredWidth;
            }
        }
        else {
            if (!isNullOrUndefined(childTableWidget)) {
                childCellWidget = childTableWidget.getTableCellWidget(touchPoint);
            }
            if (!isNullOrUndefined(childCellWidget)) {
                this.currentResizingTable = childCellWidget.ownerTable;
                // tslint:disable-next-line:max-line-length
                if (this.viewer.isInsideRect(childCellWidget.x - childCellWidget.margin.left - 1, childCellWidget.y - childCellWidget.margin.top, 2, childCellWidget.height, touchPoint)) {
                    return position = childCellWidget.columnIndex;
                }
                else if (isNullOrUndefined(childCellWidget.nextRenderedWidget)
                    // tslint:disable-next-line:max-line-length
                    && this.viewer.isInsideRect(childCellWidget.x + childCellWidget.margin.right + childCellWidget.width - 1, childCellWidget.y - childCellWidget.margin.top, 2, childCellWidget.height, touchPoint)) {
                    return position = (childCellWidget.columnIndex + childCellWidget.cellFormat.columnSpan);
                }
                else if (childCellWidget.childWidgets.length > 0) {
                    return this.getCellReSizerPositionInternal(childCellWidget, touchPoint);
                }
            }
        }
        return position;
    }
    getRowReSizerPosition(widget, touchPoint) {
        let tableWidget = undefined;
        let cellWidget = undefined;
        if (isNullOrUndefined(widget)) {
            tableWidget = this.getTableWidget(touchPoint);
            cellWidget = this.getTableCellWidget(touchPoint);
        }
        else {
            tableWidget = this.getTableWidgetFromWidget(touchPoint, widget);
        }
        let cellSpacing = isNullOrUndefined(tableWidget) ? 0 : tableWidget.tableFormat.cellSpacing;
        if (tableWidget && cellSpacing > 0) {
            this.currentResizingTable = tableWidget;
            // tslint:disable-next-line:max-line-length
            if (this.owner.viewer.isInsideRect(tableWidget.x, tableWidget.y + tableWidget.height - cellSpacing, this.getActualWidth(tableWidget.lastChild), (isNullOrUndefined(tableWidget.nextSplitWidget) ? tableWidget.bottomBorderWidth + cellSpacing : 0), touchPoint)) {
                return tableWidget.lastChild.rowIndex;
            }
            for (let i = 0; i < tableWidget.childWidgets.length; i++) {
                //Need to consider for splitted widgets
                let rowWidget = tableWidget.childWidgets[i];
                if (tableWidget.childWidgets.indexOf(rowWidget) > -1
                    // tslint:disable-next-line:max-line-length
                    && (this.owner.viewer.isInsideRect(rowWidget.x, rowWidget.y + rowWidget.height + cellSpacing / 2, this.getActualWidth(rowWidget), cellSpacing / 2, touchPoint))) {
                    return rowWidget.rowIndex;
                }
            }
        }
        else {
            if (tableWidget && cellWidget) {
                cellWidget = this.getTableCellWidget(touchPoint);
            }
            if (cellWidget) {
                let rowWidget = cellWidget.containerWidget;
                let height = 0;
                if (rowWidget.rowIndex === rowWidget.ownerTable.childWidgets.length - 1) {
                    height = rowWidget.bottomBorderWidth + 2;
                }
                else {
                    height = rowWidget.nextRenderedWidget.topBorderWidth + 2;
                }
                // tslint:disable-next-line:max-line-length
                if (this.owner.viewer.isInsideRect(rowWidget.x, rowWidget.y + rowWidget.height - height, rowWidget.width, height * 2, touchPoint)) {
                    this.currentResizingTable = rowWidget.ownerTable;
                    return rowWidget.rowIndex;
                }
                else {
                    if (cellWidget.childWidgets.length > 0) {
                        return this.getRowReSizerPosition(cellWidget, touchPoint);
                    }
                }
            }
        }
        return -1;
    }
    /**
     * To handle Table Row and cell resize
     * @param touchPoint
     * @private
     */
    handleResizing(touchPoint) {
        let dragValue = 0;
        if (this.resizeNode === 0) {
            dragValue = touchPoint.x - this.startingPoint.x;
            this.resizeTableCellColumn(dragValue);
        }
        else {
            dragValue = touchPoint.y - this.startingPoint.y;
            this.resizeTableRow(dragValue);
        }
    }
    resizeTableRow(dragValue) {
        let table = this.currentResizingTable;
        if (isNullOrUndefined(table) || dragValue === 0) {
            return;
        }
        let selection = this.owner.selection;
        if (table.isInsideTable) {
            this.owner.isLayoutEnabled = false; //Layouting is disabled to skip the child table layouting. 
        }
        if (this.resizerPosition > -1) {
            let row = table.childWidgets[this.resizerPosition];
            this.updateRowHeight(row, dragValue);
            selection.selectPosition(selection.start, selection.end);
        }
        if (table.isInsideTable) {
            let parentTable = this.owner.viewer.layout.getParentTable(table);
            this.owner.isLayoutEnabled = true; //layouting is enabled to layout the parent table of the nested table.
            table = parentTable;
        }
        this.startingPoint.y += HelperMethods.convertPointToPixel(dragValue);
        this.owner.viewer.layout.reLayoutTable(table);
        this.owner.editorModule.reLayout(this.owner.selection);
    }
    /**
     * Gets the table widget from given cursor point
     * @param cursorPoint
     */
    getTableWidget(cursorPoint) {
        let widget = undefined;
        let currentPage = this.owner.viewer.currentPage;
        if (!isNullOrUndefined(currentPage)) {
            for (let i = 0; i < currentPage.bodyWidgets.length; i++) {
                let bodyWidget = currentPage.bodyWidgets[i];
                widget = this.getTableWidgetFromWidget(cursorPoint, bodyWidget);
                if (!isNullOrUndefined(widget)) {
                    break;
                }
            }
        }
        return widget;
    }
    getTableWidgetFromWidget(point, widget) {
        for (let j = 0; j < widget.childWidgets.length; j++) {
            if (widget.childWidgets[j] instanceof TableWidget) {
                let childWidget = widget.childWidgets[j];
                if (childWidget.y <= point.y && (childWidget.y + childWidget.height) >= point.y) {
                    return childWidget;
                }
            }
        }
        return undefined;
    }
    /**
     * Return the table cell widget from the given cursor point
     * @param cursorPoint
     * @private
     */
    getTableCellWidget(cursorPoint) {
        let widget = undefined;
        let currentPage = this.owner.viewer.currentPage;
        if (!isNullOrUndefined(currentPage)) {
            for (let i = 0; i < currentPage.bodyWidgets.length; i++) {
                let bodyWidget = currentPage.bodyWidgets[i];
                widget = bodyWidget.getTableCellWidget(cursorPoint);
                if (!isNullOrUndefined(widget)) {
                    break;
                }
            }
        }
        return widget;
    }
    updateRowHeight(row, dragValue) {
        let rowFormat = row.rowFormat;
        if (rowFormat.heightType === 'Auto') {
            rowFormat.heightType = 'AtLeast';
            let row = rowFormat.ownerBase;
            let currentHeight = this.owner.viewer.layout.getRowHeight(row, [row]);
            //the minimum height of the Row in MS word is 2.7 points which is equal to 3.6 pixel.
            if (currentHeight + dragValue >= 2.7 && rowFormat.height !== currentHeight + dragValue) {
                rowFormat.height = currentHeight + dragValue;
            }
        }
        else {
            //the minimum height of the Row in MS word is 2.7 points which is equal to 3.6 pixel.
            if (rowFormat.height + dragValue >= 2.7 && rowFormat.height !== rowFormat.height + dragValue) {
                rowFormat.height = rowFormat.height + dragValue;
            }
        }
    }
    //Resize Table cell
    resizeTableCellColumn(dragValue) {
        let table = this.currentResizingTable;
        if (isNullOrUndefined(table) || dragValue === 0 || isNullOrUndefined(table.childWidgets)) {
            return;
        }
        let selectionFlag = true;
        let selection = this.owner.selection;
        this.owner.editor.setOffsetValue(selection);
        table = table.combineWidget(this.viewer);
        this.owner.isLayoutEnabled = false;
        // table.PreserveGrid = true;
        this.setPreferredWidth(table);
        let containerWidth = table.getOwnerWidth(true);
        let newIndent = table.leftIndent;
        let tableAlignment = table.tableFormat.tableAlignment;
        if (!selection.isEmpty) {
            selectionFlag = this.resizeColumnWithSelection(selection, table, dragValue);
        }
        if (!selectionFlag) {
            this.owner.isLayoutEnabled = true;
            return;
        }
        if (this.resizerPosition === 0) {
            // Todo: need to handle the resizing of first column and table indent.
            let columnIndex = this.resizerPosition;
            let rightColumn = table.tableHolder.columns[columnIndex];
            let width = rightColumn.preferredWidth;
            if (dragValue > 0) {
                let prevDragValue = dragValue;
                do {
                    let newWidth = HelperMethods.round(rightColumn.preferredWidth - dragValue, 1);
                    if (newWidth >= rightColumn.minWidth) {
                        rightColumn.preferredWidth = newWidth;
                        newIndent = table.leftIndent + dragValue;
                        newIndent = newIndent >= -1440 ? (newIndent <= 1440 ? newIndent : 1440) : -1440;
                        break;
                    }
                    else {
                        prevDragValue = dragValue;
                        dragValue += newWidth - rightColumn.minWidth;
                    }
                } while (dragValue !== prevDragValue);
            }
            else {
                let prevDragValue = dragValue;
                do {
                    let newWidth = HelperMethods.round(rightColumn.preferredWidth - dragValue, 1);
                    if (newWidth <= 2112) {
                        rightColumn.preferredWidth = newWidth;
                        newIndent = table.leftIndent + dragValue;
                        newIndent = newIndent >= -1440 ? (newIndent <= 1440 ? newIndent : 1440) : -1440;
                        break;
                    }
                    else {
                        prevDragValue = dragValue;
                        dragValue -= newWidth - 2112;
                    }
                } while (dragValue !== prevDragValue);
            }
            let dragOffset = dragValue;
            // tslint:disable-next-line:max-line-length
            if (tableAlignment !== 'Left' && (table.tableHolder.getTotalWidth() > containerWidth) && table.tableFormat.preferredWidthType === 'Auto') {
                if (table.tableHolder.isFitColumns(containerWidth, table.tableHolder.tableWidth, table.tableFormat.preferredWidthType === 'Auto')) {
                    // tslint:disable-next-line:max-line-length
                    table.tableHolder.fitColumns(containerWidth, table.tableHolder.tableWidth, table.tableFormat.preferredWidthType === 'Auto');
                }
                else {
                    rightColumn.preferredWidth = width;
                }
                dragOffset = 0;
            }
            if (tableAlignment === 'Center'
                && (table.tableHolder.getTotalWidth() < containerWidth || table.tableFormat.preferredWidthType !== 'Auto')) {
                dragOffset = dragOffset / 2;
            }
            table.tableFormat.leftIndent = tableAlignment === 'Left' ? newIndent : 0;
            table.tableHolder.tableWidth = table.tableHolder.getTotalWidth();
            this.updateCellPreferredWidths(table);
            this.updateGridValue(table, true, dragOffset);
        }
        else if (table !== null && this.resizerPosition === table.tableHolder.columns.length) {
            // Todo: need to handle the resizing of last column and table width.
            this.resizeColumnAtLastColumnIndex(table, dragValue, containerWidth);
        }
        else {
            if (this.resizerPosition === -1) {
                this.owner.isLayoutEnabled = true;
                return;
            }
            this.resizeCellAtMiddle(table, dragValue);
        }
        // table.PreserveGrid = false;
        this.owner.isLayoutEnabled = true;
        selection.selectPosition(selection.start, selection.end);
    }
    /**
     * Resize Selected Cells
     */
    resizeColumnWithSelection(selection, table, dragValue) {
        let newIndent = table.leftIndent;
        let cellwidget = this.getTableCellWidget(this.startingPoint);
        if (cellwidget && (selection.selectedWidgets.containsKey(cellwidget) || (cellwidget.previousWidget
            && selection.selectedWidgets.containsKey((cellwidget.previousWidget))))) {
            let selectedCells = selection.getSelectedCells();
            if (this.resizerPosition === 0) {
                this.resizeColumnAtStart(table, dragValue, selectedCells);
            }
            else if (table !== null && this.resizerPosition === table.tableHolder.columns.length) {
                let leftColumnCollection = this.getColumnCells(table, this.resizerPosition, true);
                for (let i = 0; i < leftColumnCollection.length; i++) {
                    let cell = leftColumnCollection[i];
                    if (selectedCells.indexOf(cell) !== -1) {
                        this.increaseOrDecreaseWidth(cell, dragValue, true);
                    }
                }
                //Updates the grid after value for all the rows.
                this.updateRowsGridAfterWidth(table);
                table.updateWidth(dragValue);
                this.updateGridValue(table, true, dragValue);
            }
            else {
                if (this.resizerPosition === -1) {
                    return false;
                }
                let columnIndex = this.resizerPosition;
                let leftColumnCollection = this.getColumnCells(table, columnIndex, true);
                let rightColumnCollection = this.getColumnCells(table, columnIndex, false);
                let isColumnResizing = this.isColumnSelected(table, columnIndex);
                if (leftColumnCollection.length > 0 && !isColumnResizing) {
                    for (let i = 0; i < leftColumnCollection.length; i++) {
                        if (selectedCells.indexOf(leftColumnCollection[i]) === -1) {
                            leftColumnCollection.splice(i, 1);
                            i--;
                        }
                    }
                }
                if (rightColumnCollection.length > 0 && !isColumnResizing) {
                    for (let i = 0; i < rightColumnCollection.length; i++) {
                        if (selectedCells.indexOf(rightColumnCollection[i]) === -1) {
                            rightColumnCollection.splice(i, 1);
                            i--;
                        }
                    }
                }
                //Getting the adjacent cell collections for left side selected cells in the right column collection.
                if (leftColumnCollection.length === 0 && rightColumnCollection.length > 0) {
                    for (let i = 0; i < rightColumnCollection.length; i++) {
                        let cell = rightColumnCollection[i];
                        if (cell.previousWidget) {
                            leftColumnCollection.push(cell.previousWidget);
                        }
                    }
                }
                else if (rightColumnCollection.length === 0 && leftColumnCollection.length > 0) {
                    for (let i = 0; i < leftColumnCollection.length; i++) {
                        let cell = leftColumnCollection[i];
                        if (cell.nextWidget) {
                            rightColumnCollection.push(cell.nextWidget);
                        }
                    }
                }
                this.changeWidthOfCells(table, leftColumnCollection, rightColumnCollection, dragValue, true);
                this.updateGridValue(table, true, dragValue);
            }
            selection.selectPosition(selection.start, selection.end);
        }
        return false;
    }
    /**
     * Resize selected cells at resizer position 0
     */
    resizeColumnAtStart(table, dragValue, selectedCells) {
        let newIndent = table.leftIndent;
        let rightColumnCollection = this.getColumnCells(table, this.resizerPosition, false);
        let offset = 0;
        let selectedRow = selectedCells[0].ownerRow;
        let rowFormat = selectedRow.rowFormat;
        if (rowFormat.beforeWidth > 0) {
            let newGridBefore = rowFormat.beforeWidth + dragValue;
            if (newGridBefore > 0) {
                this.updateGridBefore(selectedRow, dragValue);
            }
            else {
                let leastGridBefore = this.getLeastGridBefore(table, selectedRow);
                if (newGridBefore < leastGridBefore && offset !== newGridBefore) {
                    newIndent = table.leftIndent + newGridBefore;
                    table.tableFormat.leftIndent = newIndent >= -1440 ? (newIndent <= 1440 ? newIndent : 1440) : -1440;
                    for (let i = 0; i < table.childWidgets.length; i++) {
                        let tableRow = table.childWidgets[i];
                        if (selectedRow !== tableRow) {
                            this.updateGridBefore(tableRow, -newGridBefore);
                        }
                    }
                }
            }
        }
        else {
            if (dragValue < 0) {
                newIndent = table.leftIndent + dragValue;
                table.tableFormat.leftIndent = newIndent >= -1440 ? (newIndent <= 1440 ? newIndent : 1440) : -1440;
                this.updateWidthForCells(table, selectedCells, dragValue);
            }
            else {
                let leastGridBefore = this.getLeastGridBefore(table, selectedRow);
                let currentTableIndent = table.tableFormat.leftIndent;
                if (currentTableIndent === 0) {
                    for (let i = 0; i < table.childWidgets.length; i++) {
                        let tableRow = table.childWidgets[i];
                        if (selectedCells.indexOf(tableRow.childWidgets[0]) !== -1) {
                            this.updateGridBefore(tableRow, dragValue);
                            this.increaseOrDecreaseWidth(tableRow.childWidgets[0], dragValue, false);
                        }
                    }
                }
                else {
                    let difference = leastGridBefore - dragValue;
                    if (difference > 0) {
                        newIndent = table.leftIndent + dragValue;
                        table.tableFormat.leftIndent = newIndent >= -1440 ? (newIndent <= 1440 ? newIndent : 1440) : -1440;
                        this.updateWidthForCells(table, selectedCells, dragValue);
                    }
                    else {
                        newIndent = table.leftIndent + leastGridBefore;
                        table.tableFormat.leftIndent = newIndent >= -1440 ? (newIndent <= 1440 ? newIndent : 1440) : -1440;
                        for (let i = 0; i < table.childWidgets.length; i++) {
                            let tableRow = table.childWidgets[i];
                            if (selectedCells.indexOf(tableRow.childWidgets[0]) !== -1) {
                                this.increaseOrDecreaseWidth(tableRow.childWidgets[0], dragValue, false);
                                this.updateGridBefore(tableRow, dragValue - leastGridBefore);
                            }
                            else {
                                this.updateGridBefore(tableRow, -leastGridBefore);
                            }
                        }
                    }
                }
            }
        }
        this.updateGridValue(table, true, dragValue);
    }
    updateWidthForCells(table, selectedCells, dragValue) {
        for (let i = 0; i < table.childWidgets.length; i++) {
            let tableRow = table.childWidgets[i];
            if (selectedCells.indexOf(tableRow.childWidgets[0]) !== -1) {
                this.increaseOrDecreaseWidth(tableRow.childWidgets[0], dragValue, false);
            }
            else {
                this.updateGridBefore(tableRow, -dragValue);
            }
        }
    }
    /**
     * Resize selected cells at last column
     */
    resizeColumnAtLastColumnIndex(table, dragValue, containerWidth) {
        let tableAlignment = table.tableFormat.tableAlignment;
        let preferredWidth = table.tableFormat.preferredWidth;
        let hasTableWidth = preferredWidth;
        let columnIndex = this.resizerPosition;
        let leftColumn = table.tableHolder.columns[columnIndex - 1];
        let prevDragValue = 0;
        while (dragValue !== prevDragValue) {
            let newWidth = HelperMethods.round(leftColumn.preferredWidth + dragValue, 1);
            if (newWidth >= leftColumn.minWidth) {
                leftColumn.preferredWidth = newWidth;
                prevDragValue = dragValue;
            }
            else {
                prevDragValue = dragValue;
                dragValue -= newWidth - leftColumn.minWidth;
            }
        }
        this.updateCellPreferredWidths(table);
        if (hasTableWidth || table.tableHolder.getTotalWidth() > containerWidth) {
            table.updateWidth(dragValue);
            table.tableHolder.tableWidth = table.tableHolder.getTotalWidth();
        }
        let dragOffset = dragValue;
        if (tableAlignment === 'Right') {
            dragOffset = 0;
        }
        else if (tableAlignment === 'Center') {
            dragOffset = dragOffset / 2;
        }
        this.updateGridValue(table, true, dragOffset);
    }
    /**
     *  Resize selected cells at middle column
     */
    resizeCellAtMiddle(table, dragValue) {
        let columnIndex = this.resizerPosition;
        let leftColumn = table.tableHolder.columns[columnIndex - 1];
        let rightColumn = table.tableHolder.columns[columnIndex];
        if (dragValue > 0) {
            let isContinue = true;
            while (isContinue) {
                let newWidth = HelperMethods.round(rightColumn.preferredWidth - dragValue, 1);
                if (newWidth >= rightColumn.minWidth) {
                    rightColumn.preferredWidth = newWidth;
                    leftColumn.preferredWidth = leftColumn.preferredWidth + dragValue;
                    isContinue = false;
                }
                else {
                    dragValue += newWidth - rightColumn.minWidth;
                }
            }
        }
        else {
            let isContinue = true;
            while (isContinue) {
                let newWidth = HelperMethods.round(leftColumn.preferredWidth + dragValue, 1);
                if (newWidth >= leftColumn.minWidth) {
                    leftColumn.preferredWidth = newWidth;
                    rightColumn.preferredWidth = rightColumn.preferredWidth - dragValue;
                    isContinue = false;
                }
                else {
                    dragValue -= newWidth - leftColumn.minWidth;
                }
            }
        }
        // Update the cell widths based on the columns preferred width
        this.updateCellPreferredWidths(table);
        // table.tableFormat.AllowAutoFit = false;
        table.tableHolder.tableWidth = table.tableHolder.getTotalWidth();
        this.updateGridValue(table, false, dragValue);
    }
    updateGridValue(table, isUpdate, dragValue) {
        if (isUpdate) {
            table.calculateGrid();
            table.isGridUpdated = false;
        }
        table.buildTableColumns();
        table.isGridUpdated = true;
        this.viewer.owner.isLayoutEnabled = true;
        if (table.isInsideTable) {
            let parentTable = this.viewer.layout.getParentTable(table);
            this.viewer.layout.reLayoutTable(parentTable); // Need to optmize this.
        }
        else {
            this.viewer.layout.reLayoutTable(table);
        }
        this.owner.editor.getOffsetValue(this.viewer.selection);
        this.owner.editorModule.reLayout(this.owner.selection);
        if (dragValue) {
            this.startingPoint.x += HelperMethods.convertPointToPixel(dragValue);
            this.resizerPosition = this.getCellReSizerPosition(this.startingPoint);
        }
    }
    getColumnCells(table, columnIndex, isLeftSideCollection) {
        let cells = [];
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                if (isLeftSideCollection) {
                    if (cell.columnIndex + cell.cellFormat.columnSpan === columnIndex) {
                        cells.push(cell);
                    }
                }
                else {
                    if (cell.columnIndex === columnIndex) {
                        cells.push(cell);
                    }
                }
            }
        }
        return cells;
    }
    updateGridBefore(row, offset) {
        if (row.rowFormat.beforeWidth + offset !== row.rowFormat.beforeWidth) {
            row.rowFormat.beforeWidth = row.rowFormat.beforeWidth + offset;
            row.rowFormat.gridBeforeWidth = row.rowFormat.beforeWidth;
        }
    }
    getLeastGridBefore(table, ignoreRow) {
        let gridBefore = 0;
        let flag = 0;
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            if (row !== ignoreRow) {
                if (flag === 0) {
                    gridBefore = row.rowFormat.beforeWidth;
                    flag++;
                }
                if (row.rowFormat.beforeWidth <= gridBefore) {
                    gridBefore = row.rowFormat.beforeWidth;
                }
            }
        }
        return gridBefore;
    }
    increaseOrDecreaseWidth(cell, dragValue, isIncrease) {
        let preferredWidth = cell.cellFormat.preferredWidth;
        if (cell.cellFormat.preferredWidthType === 'Auto') {
            preferredWidth = cell.cellFormat.cellWidth;
            cell.cellFormat.preferredWidthType = 'Point';
        }
        let minimumWidth = cell.ownerColumn.minWidth;
        if (cell.cellFormat.preferredWidthType === 'Percent') {
            minimumWidth = cell.convertPointToPercent(minimumWidth);
        }
        // Margins properties usedd for internal purpose.
        if (isIncrease) {
            cell.cellFormat.preferredWidth = preferredWidth + dragValue > minimumWidth ? preferredWidth + dragValue : minimumWidth;
        }
        else {
            cell.cellFormat.preferredWidth = preferredWidth - dragValue > minimumWidth ? preferredWidth - dragValue : minimumWidth;
        }
    }
    // tslint:disable-next-line:max-line-length
    changeWidthOfCells(table, leftColumnCollection, rightColumnCollection, dragValue, isSelection) {
        if (leftColumnCollection.length > 0) {
            let flag = false;
            for (let i = 0; i < leftColumnCollection.length; i++) {
                let cell = leftColumnCollection[i];
                this.increaseOrDecreaseWidth(cell, dragValue, true);
                if (cell.cellIndex === cell.ownerRow.childWidgets.length - 1) {
                    flag = true;
                }
            }
            if (flag) {
                this.updateRowsGridAfterWidth(table);
            }
        }
        if (rightColumnCollection.length > 0) {
            let diff = 0;
            for (let i = 0; i < rightColumnCollection.length; i++) {
                let cell = rightColumnCollection[i];
                if (cell.cellIndex === 0) {
                    let newGridBefore = cell.ownerRow.rowFormat.beforeWidth + dragValue;
                    if (newGridBefore >= 0) {
                        this.updateGridBefore(cell.ownerRow, dragValue);
                    }
                    else {
                        if (diff !== newGridBefore) {
                            diff = newGridBefore;
                        }
                        cell.ownerRow.rowFormat.gridBeforeWidth = 0;
                        cell.ownerRow.rowFormat.gridBeforeWidthType = 'Auto';
                    }
                }
                this.increaseOrDecreaseWidth(cell, dragValue, false);
            }
            if (diff !== 0) {
                let newIndent = table.leftIndent + diff;
                table.tableFormat.leftIndent = newIndent >= -1440 ? (newIndent <= 1440 ? newIndent : 1440) : -1440;
                for (let j = 0; j < table.childWidgets.length; j++) {
                    let row = table.childWidgets[j];
                    if (rightColumnCollection.indexOf(row.childWidgets[0]) === -1) {
                        this.updateGridBefore(row, diff > 0 ? diff : -diff);
                    }
                }
            }
        }
    }
    updateRowsGridAfterWidth(table) {
        let maxRowWidth = this.getMaxRowWidth(table, true);
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            let currentRowWidth = this.getRowWidth(row, true);
            if (maxRowWidth >= currentRowWidth && row.rowFormat.afterWidth !== maxRowWidth - currentRowWidth) {
                let value = maxRowWidth - currentRowWidth;
                row.rowFormat.gridAfterWidth = value;
                row.rowFormat.afterWidth = value;
            }
        }
    }
    getRowWidth(row, toUpdateGridAfter) {
        let rowWidth = 0;
        if (toUpdateGridAfter) {
            rowWidth = rowWidth + row.rowFormat.beforeWidth;
        }
        for (let i = 0; i < row.childWidgets.length; i++) {
            let cell = row.childWidgets[i];
            rowWidth += cell.cellFormat.cellWidth;
        }
        return rowWidth;
    }
    getMaxRowWidth(table, toUpdateGridAfter) {
        let width = 0;
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            let rowWidth = 0;
            if (toUpdateGridAfter) {
                rowWidth = rowWidth + row.rowFormat.beforeWidth;
            }
            for (let i = 0; i < row.childWidgets.length; i++) {
                let cell = row.childWidgets[i];
                rowWidth += cell.cellFormat.cellWidth;
            }
            if (width < rowWidth) {
                width = rowWidth;
            }
        }
        return width;
    }
    isColumnSelected(table, columnIndex) {
        let selection = this.owner.selection;
        let selectedCells = selection.getSelectedCells();
        let leftColumnCells = this.getColumnCells(table, columnIndex, true);
        let rightColumnCells = this.getColumnCells(table, columnIndex, false);
        let isColumnSelected = false;
        for (let i = 0; i < leftColumnCells.length; i++) {
            let columnCell = leftColumnCells[i];
            isColumnSelected = selectedCells.indexOf(columnCell) !== -1 ? true : false;
        }
        if (!isColumnSelected) {
            for (let i = 0; i < rightColumnCells.length; i++) {
                let columnCell = rightColumnCells[i];
                isColumnSelected = selectedCells.indexOf(columnCell) !== -1 ? true : false;
            }
        }
        return isColumnSelected;
    }
    applyProperties(table, tableHistoryInfo) {
        if (isNullOrUndefined(tableHistoryInfo)) {
            return;
        }
        table = table;
        // PreserveGrid = true;
        if (tableHistoryInfo.tableHolder) {
            table.tableHolder = tableHistoryInfo.tableHolder.clone();
        }
        if (tableHistoryInfo.tableFormat !== null) {
            table.tableFormat.leftIndent = tableHistoryInfo.tableFormat.leftIndent;
            table.tableFormat.preferredWidth = tableHistoryInfo.tableFormat.preferredWidth;
            table.tableFormat.preferredWidthType = tableHistoryInfo.tableFormat.preferredWidthType;
        }
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            let rowFormat = tableHistoryInfo.rows[i];
            row.rowFormat.gridBefore = rowFormat.gridBefore;
            row.rowFormat.gridBeforeWidth = rowFormat.gridBeforeWidth;
            row.rowFormat.gridBeforeWidthType = rowFormat.gridBeforeWidthType;
            row.rowFormat.gridAfter = rowFormat.gridAfter;
            row.rowFormat.gridAfterWidth = rowFormat.gridAfterWidth;
            row.rowFormat.gridAfterWidthType = rowFormat.gridAfterWidthType;
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                let cellFormat = rowFormat.cells[j];
                cell.columnIndex = cellFormat.columnIndex;
                cell.cellFormat.columnSpan = cellFormat.columnSpan;
                cell.cellFormat.preferredWidth = cellFormat.preferredWidth;
                cell.cellFormat.preferredWidthType = cellFormat.preferredWidthType;
            }
        }
        let containerWidth = table.getOwnerWidth(true);
        let tableWidth = table.getTableClientWidth(containerWidth);
        //Sets the width to cells
        table.setWidthToCells(tableWidth, table.tableFormat.preferredWidthType === 'Auto');
        // PreserveGrid = false;
    }
    /**
     * Return table row width
     */
    getActualWidth(row) {
        let width = 0;
        if (row.childWidgets.length > 0) {
            for (let i = 0; i < row.childWidgets.length; i++) {
                width += row.childWidgets[i].cellFormat.cellWidth;
            }
        }
        return width;
    }
    setPreferredWidth(table) {
        for (let i = 0; i < table.childWidgets.length; i++) {
            let rw = table.childWidgets[i];
            let rowFormat = rw.rowFormat;
            if (rowFormat.gridBefore > 0) {
                rowFormat.gridBeforeWidth = rowFormat.beforeWidth;
                rowFormat.gridBeforeWidthType = 'Point';
            }
            for (let j = 0; j < rw.childWidgets.length; j++) {
                let cell = rw.childWidgets[j];
                cell.cellFormat.preferredWidth = cell.cellFormat.cellWidth;
                cell.cellFormat.preferredWidthType = 'Point';
            }
            if (rowFormat.gridAfter > 0) {
                rowFormat.gridAfterWidth = rowFormat.afterWidth;
                rowFormat.gridAfterWidthType = 'Point';
            }
        }
    }
    updateCellPreferredWidths(table) {
        let tableWidth = table.tableHolder.tableWidth;
        let isAutoFit = table.tableFormat.preferredWidthType === 'Auto';
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            if (row.rowFormat.gridBefore > 0) {
                let width = table.tableHolder.getCellWidth(0, row.rowFormat.gridBefore, tableWidth, isAutoFit);
                this.updateGridBeforeWidth(width, row);
            }
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                cell.updateWidth(table.tableHolder.getCellWidth(cell.columnIndex, cell.cellFormat.columnSpan, tableWidth, isAutoFit));
            }
            if (row.rowFormat.gridAfter > 0) {
                // tslint:disable-next-line:max-line-length
                this.updateGridAfterWidth(table.tableHolder.getCellWidth(row.childWidgets.length, row.rowFormat.gridAfter, tableWidth, isAutoFit), row);
            }
        }
    }
    /**
     * Update grid before width value
     */
    updateGridBeforeWidth(width, row) {
        let rowFormat = row.rowFormat;
        if (width !== rowFormat.beforeWidth) {
            rowFormat.beforeWidth = width;
            if (rowFormat.gridBeforeWidthType === 'Auto') {
                rowFormat.gridBeforeWidthType = 'Point';
            }
            if (rowFormat.gridBeforeWidthType === 'Point') {
                rowFormat.gridBeforeWidth = rowFormat.beforeWidth;
            }
            else {
                // The value is calculated from the pixel values hence, its converted to percent using method. 
                let ownerWidth = row.ownerTable.getTableClientWidth(row.ownerTable.getOwnerWidth(true));
                let value = row.ownerTable.convertPointToPercent(rowFormat.beforeWidth, ownerWidth);
                rowFormat.gridBeforeWidth = value;
            }
        }
    }
    /**
     * Update grid after width value
     */
    updateGridAfterWidth(width, row) {
        let rowFormat = row.rowFormat;
        if (width !== rowFormat.afterWidth) {
            rowFormat.afterWidth = width;
        }
        if (rowFormat.gridAfterWidthType === 'Auto') {
            rowFormat.gridAfterWidthType = 'Point';
        }
        if (rowFormat.gridAfterWidthType === 'Point') {
            rowFormat.gridAfterWidth = rowFormat.afterWidth;
        }
        else {
            // The value is calculated from the pixel values hence, its converted to percent using method. 
            let ownerWidth = row.ownerTable.getTableClientWidth(row.ownerTable.getOwnerWidth(true));
            let value = row.ownerTable.convertPointToPercent(rowFormat.afterWidth, ownerWidth);
            rowFormat.gridAfterWidth = value;
        }
    }
}

/**
 * Editor module
 */
class Editor {
    /**
     * Initialize the editor module
     * @param  {LayoutViewer} viewer
     * @private
     */
    constructor(viewer) {
        this.nodes = [];
        this.editHyperlinkInternal = false;
        this.startParagraph = undefined;
        this.endParagraph = undefined;
        /**
         * @private
         */
        this.isHandledComplex = false;
        /**
         * @private
         */
        this.tableResize = undefined;
        /**
         * @private
         */
        this.tocStyles = {};
        this.refListNumber = undefined;
        this.incrementListNumber = -1;
        this.removedBookmarkElements = [];
        /**
         * @private
         */
        this.tocBookmarkId = 0;
        /**
         * @private
         */
        this.copiedData = undefined;
        this.pageRefFields = {};
        /**
         * @private
         */
        this.isInsertingTOC = false;
        /**
         * @private
         */
        this.isBordersAndShadingDialog = false;
        /**
         * @private
         */
        this.onTextInputInternal = (event) => {
            if (Browser.isDevice) {
                let viewer = this.viewer;
                let nbsp = new RegExp(String.fromCharCode(160), 'g');
                let lineFeed = new RegExp(String.fromCharCode(10), 'g');
                viewer.prefix = viewer.prefix.replace(nbsp, ' ').replace(lineFeed, ' ');
                let text = viewer.editableDiv.textContent.replace(nbsp, ' ').replace(lineFeed, ' ');
                let textBoxText = text.substring(2);
                if (viewer.isCompositionStart && viewer.isCompositionUpdated) {
                    viewer.isCompositionUpdated = false;
                    if (!viewer.owner.isReadOnlyMode && viewer.owner.isDocumentLoaded) {
                        if (viewer.prefix.substring(2) !== textBoxText) {
                            if (this.selection.isEmpty) {
                                // tslint:disable-next-line:max-line-length
                                this.selection.start.setPositionForLineWidget(viewer.selection.start.currentWidget, this.selection.start.offset - (viewer.prefix.length - 2));
                                this.handleTextInput(textBoxText);
                                viewer.prefix = '@' + String.fromCharCode(160) + textBoxText;
                            }
                            else {
                                this.handleTextInput(textBoxText);
                                viewer.prefix = '@' + String.fromCharCode(160) + textBoxText;
                            }
                        }
                    }
                    return;
                }
                else if (viewer.isCompositionStart && viewer.isCompositionEnd && viewer.suffix === '') {
                    if (viewer.prefix.substring(2) !== textBoxText) {
                        if (this.selection.isEmpty && viewer.isCompositionStart) {
                            viewer.isCompositionStart = false;
                            // tslint:disable-next-line:max-line-length
                            this.selection.start.setPositionForLineWidget(viewer.selection.start.currentWidget, this.selection.start.offset - viewer.prefix.substring(2).length);
                            this.selection.retrieveCurrentFormatProperties();
                            if (viewer.suffix === '' || textBoxText === '') {
                                this.handleTextInput(textBoxText);
                            }
                        }
                        else if (!this.selection.isEmpty) {
                            viewer.isCompositionStart = false;
                            this.handleTextInput(textBoxText);
                        }
                    }
                    else if (textBoxText === '') {
                        viewer.isCompositionStart = false;
                        this.handleBackKey();
                    }
                    else if (viewer.prefix.substring(2) === textBoxText && viewer.suffix === '') {
                        viewer.isCompositionStart = false;
                        this.handleTextInput(' ');
                    }
                    viewer.isCompositionEnd = false;
                    return;
                }
                else if (viewer.isCompositionEnd || viewer.isCompositionStart && !viewer.compositionUpdated) {
                    if (textBoxText.length < viewer.prefix.length &&
                        textBoxText === viewer.prefix.substring(2, viewer.prefix.length - 1) || viewer.editableDiv.innerText.length < 2) {
                        this.handleBackKey();
                        return;
                    }
                    else if (viewer.suffix !== '' &&
                        viewer.editableDiv.innerText[viewer.editableDiv.innerText.length - 1] !== String.fromCharCode(160)) {
                        viewer.isCompositionStart = false;
                        //When cursor is placed in between a word and chosen a word from predicted words.
                        // tslint:disable-next-line:max-line-length
                        this.selection.start.setPositionForLineWidget(viewer.selection.start.currentWidget, this.selection.start.offset - (viewer.prefix.length - 2));
                        this.selection.end.setPositionForLineWidget(viewer.selection.end.currentWidget, this.selection.end.offset + viewer.suffix.length);
                        //Retrieve the character format properties. Since the selection was changed manually.
                        this.selection.retrieveCurrentFormatProperties();
                        this.handleTextInput(textBoxText);
                        return;
                    }
                }
                // tslint:disable-next-line:max-line-length
                if (text !== '\r' && text !== '\b' && text !== '\u001B' && !viewer.owner.isReadOnlyMode && viewer.isControlPressed === false) {
                    if (text === '@' || text[0] !== '@' || text === '' || text.length < viewer.prefix.length &&
                        textBoxText === viewer.prefix.substring(2, viewer.prefix.length - 1)) {
                        this.handleBackKey();
                        if (viewer.editableDiv.innerText.length < 2) {
                            this.predictText();
                        }
                    }
                    else if (text.indexOf(viewer.prefix) === 0 && text.length > viewer.prefix.length) {
                        this.handleTextInput(text.substring(viewer.prefix.length));
                    }
                    else if (text.indexOf(viewer.prefix) === -1 && text[text.length - 1] !== String.fromCharCode(160)
                        && text[text.length - 1] !== ' ') {
                        if ((textBoxText.charAt(0).toLowerCase() + textBoxText.slice(1)) === viewer.prefix.substring(2)) {
                            // tslint:disable-next-line:max-line-length
                            this.selection.start.setPositionParagraph(viewer.selection.start.currentWidget, this.selection.start.offset - (viewer.prefix.length - 2));
                        }
                        this.handleTextInput(textBoxText);
                    }
                    else if (text.length !== 2) {
                        this.handleTextInput(' ');
                    }
                }
            }
            else {
                let text = this.viewer.editableDiv.innerText;
                if (text !== String.fromCharCode(160)) {
                    // tslint:disable-next-line:max-line-length
                    if (text !== '\r' && text !== '\b' && text !== '\u001B' && !this.owner.isReadOnlyMode && this.viewer.isControlPressed === false) {
                        this.handleTextInput(text);
                    }
                }
                else {
                    this.handleTextInput(' ');
                }
                this.viewer.editableDiv.innerText = '';
            }
        };
        /**
         * Fired on paste.
         * @param {ClipboardEvent} event
         * @private
         */
        this.onPaste = (event) => {
            if (!this.owner.isReadOnlyMode) {
                this.pasteInternal(event);
            }
            event.preventDefault();
        };
        this.viewer = viewer;
        this.tableResize = new TableResizer(this.viewer.owner);
    }
    get editorHistory() {
        return this.viewer.owner.editorHistory;
    }
    get selection() {
        if (this.viewer) {
            return this.viewer.selection;
        }
        return undefined;
    }
    get owner() {
        return this.viewer.owner;
    }
    getModuleName() {
        return 'Editor';
    }
    insertField(code, result) {
        let fieldCode = code;
        if (isNullOrUndefined(result)) {
            fieldCode = HelperMethods.trimStart(fieldCode);
            if (fieldCode.substring(0, 10) === 'MERGEFIELD') {
                fieldCode = fieldCode.substring(10).trim();
                let index = fieldCode.indexOf('\\*');
                result = '«' + fieldCode.substring(0, index).trim() + '»';
            }
        }
        let paragraph = new ParagraphWidget();
        let line = new LineWidget(paragraph);
        let fieldBegin = new FieldElementBox(0);
        line.children.push(fieldBegin);
        let fieldCodeSpan = new TextElementBox();
        fieldCodeSpan.text = code;
        line.children.push(fieldCodeSpan);
        let fieldSeparator = new FieldElementBox(2);
        fieldSeparator.fieldBegin = fieldBegin;
        fieldBegin.fieldSeparator = fieldSeparator;
        line.children.push(fieldSeparator);
        let fieldResultSpan = new TextElementBox();
        fieldResultSpan.text = result;
        line.children.push(fieldResultSpan);
        let fieldEnd = new FieldElementBox(1);
        fieldEnd.fieldSeparator = fieldSeparator;
        fieldEnd.fieldBegin = fieldBegin;
        fieldBegin.fieldEnd = fieldEnd;
        fieldSeparator.fieldEnd = fieldEnd;
        line.children.push(fieldEnd);
        fieldBegin.line = line;
        paragraph.childWidgets.push(line);
        this.viewer.fields.push(fieldBegin);
        let widgets = [];
        widgets.push(paragraph);
        this.pasteContentsInternal(widgets);
    }
    /**
     * To update style for paragraph
     * @param style - style name
     * @param clearDirectFormatting - Removes manual formatting (formatting not applied using a style)
     * from the selected text, to match the formatting of the applied style. Default value is false.
     */
    applyStyle(style, clearDirectFormatting) {
        clearDirectFormatting = isNullOrUndefined(clearDirectFormatting) ? false : clearDirectFormatting;
        if (clearDirectFormatting) {
            this.initComplexHistory('ApplyStyle');
            this.clearFormatting();
        }
        let styleObj = this.viewer.styles.findByName(style);
        if (styleObj !== undefined) {
            this.onApplyParagraphFormat('styleName', styleObj, false, true);
        }
        else {
            // tslint:disable-next-line:max-line-length
            this.viewer.owner.parser.parseStyle(JSON.parse(this.getCompleteStyles()), JSON.parse(this.viewer.preDefinedStyles.get(style)), this.viewer.styles);
            this.applyStyle(style);
        }
        if (this.editorHistory && this.editorHistory.currentHistoryInfo && this.editorHistory.currentHistoryInfo.action === 'ApplyStyle') {
            this.editorHistory.updateComplexHistory();
        }
    }
    // Public Implementation Starts
    /**
     * Moves the selected content in the document editor control to clipboard.
     */
    cut() {
        if (this.owner.isReadOnlyMode || this.selection.isEmpty) {
            return;
        }
        this.selection.copySelectedContent(true);
    }
    /**
     * Notify content change event
     * @private
     */
    fireContentChange() {
        if (this.viewer.owner.isLayoutEnabled && !this.viewer.owner.isShiftingEnabled) {
            this.viewer.owner.fireContentChange();
        }
    }
    /**
     * Update physical location for text position
     * @private
     */
    updateSelectionTextPosition(isSelectionChanged) {
        this.getOffsetValue(this.selection);
        this.selection.start.updatePhysicalPosition(true);
        if (this.selection.isEmpty) {
            this.selection.end.setPositionInternal(this.selection.start);
        }
        else {
            this.selection.end.updatePhysicalPosition(true);
        }
        this.selection.upDownSelectionLength = this.selection.end.location.x;
        this.selection.fireSelectionChanged(isSelectionChanged);
    }
    /**
     * Predict text
     * @private
     */
    predictText() {
        this.viewer.suffix = '';
        if (this.selection.start.paragraph.isEmpty() || this.selection.start.offset === 0 &&
            this.selection.start.currentWidget.isFirstLine() || this.selection.end.offset === 0 &&
            this.selection.end.currentWidget.isFirstLine()) {
            this.viewer.prefix = '';
        }
        else {
            this.getPrefixAndSuffix();
        }
        this.viewer.prefix = '@' + String.fromCharCode(160) + this.viewer.prefix; // &nbsp;
        this.viewer.editableDiv.innerText = this.viewer.prefix;
        this.viewer.selection.setEditableDivCaretPosition(this.viewer.prefix.length);
    }
    /**
     * Gets prefix and suffix.
     * @private
     */
    /* tslint:disable:max-func-body-length */
    getPrefixAndSuffix() {
        let viewer = this.viewer;
        if (this.selection.text !== '') {
            viewer.prefix = '';
            return;
        }
        else {
            let startIndex = 0;
            let inlineInfo = this.selection.start.currentWidget.getInline(this.selection.start.offset, startIndex);
            let inline = inlineInfo.element;
            startIndex = inlineInfo.index;
            if (inline !== undefined) {
                let boxInfo = this.selection.getElementBoxInternal(inline, startIndex);
                let box = boxInfo.element;
                startIndex = boxInfo.index;
                let spaceIndex = 0;
                if (!isNullOrUndefined(box)) {
                    let prefixAdded = false;
                    if (box instanceof TextElementBox && startIndex > 0 && box.line.isFirstLine()) {
                        viewer.prefix = '';
                    }
                    if (!(inline instanceof TextElementBox)) {
                        inline = this.selection.getPreviousTextElement(inline);
                    }
                    /* tslint:disable:no-conditional-assignment */
                    while ((spaceIndex = viewer.prefix.lastIndexOf(' ')) < 0 && inline instanceof TextElementBox) {
                        if (inline.previousNode instanceof TextElementBox && viewer.prefix.indexOf(' ') === -1) {
                            if (!prefixAdded) {
                                viewer.prefix = inline.text.substring(0, startIndex);
                                prefixAdded = true;
                            }
                            else {
                                viewer.prefix = inline.text + viewer.prefix;
                            }
                            inline = inline.previousNode;
                            // If the line has no elements then break the loop to avoid the exception.
                            if (inline instanceof ListTextElementBox) {
                                break;
                            }
                            if (!(inline instanceof TextElementBox)) {
                                inline = this.selection.getPreviousTextElement(inline);
                            }
                        }
                        else if (!(inline.previousNode instanceof TextElementBox)) {
                            if (!prefixAdded) {
                                viewer.prefix = inline.text.substring(0, startIndex);
                                prefixAdded = true;
                            }
                            else {
                                viewer.prefix = inline.text + viewer.prefix;
                            }
                            break;
                        }
                    }
                    if (!(viewer.prefix.length > 1 && viewer.prefix[viewer.prefix.length - 1] === ' ' &&
                        viewer.prefix[viewer.prefix.length - 2] === '.')) {
                        spaceIndex = viewer.prefix.lastIndexOf(' ');
                    }
                    else {
                        spaceIndex = -1;
                        viewer.prefix = '';
                    }
                    viewer.prefix = spaceIndex < 0 ? viewer.prefix : viewer.prefix.substring(spaceIndex);
                    if (viewer.prefix.indexOf(' ') === 0 && viewer.prefix.length >= 1) {
                        viewer.prefix = viewer.prefix.substring(1);
                    }
                    // suffix text prediction
                    let endIndex = 0;
                    let endInlineInfo = this.selection.end.currentWidget.getInline(this.selection.end.offset, endIndex);
                    let endInline = endInlineInfo.element;
                    endIndex = endInlineInfo.index;
                    boxInfo = this.selection.getElementBoxInternal(endInline, endIndex);
                    box = boxInfo.element;
                    endIndex = boxInfo.index;
                    if (box) {
                        let suffixAdded = false;
                        if (box instanceof TextElementBox && endIndex < box.length) {
                            viewer.suffix = '';
                        }
                        // boxIndex = renderedElements.get(endInline).indexOf(box);
                        while ((spaceIndex = viewer.suffix.indexOf(' ')) < 0 && endInline instanceof TextElementBox) {
                            if (endInline.nextNode instanceof TextElementBox && viewer.suffix.indexOf(' ') === -1) {
                                if (!suffixAdded) {
                                    viewer.suffix = box.text.substring(endIndex);
                                    suffixAdded = true;
                                }
                                else {
                                    viewer.suffix = viewer.suffix + endInline.text;
                                }
                                endInline = endInline.nextNode;
                            }
                            else if (!(endInline.nextNode instanceof TextElementBox)) {
                                if (!suffixAdded) {
                                    viewer.suffix = box.text.substring(endIndex);
                                    suffixAdded = true;
                                }
                                else {
                                    viewer.suffix = viewer.suffix + endInline.text;
                                }
                                break;
                            }
                        }
                        spaceIndex = viewer.suffix.indexOf(' ');
                        viewer.suffix = spaceIndex < 0 ? viewer.suffix : viewer.suffix.substring(0, spaceIndex);
                    }
                }
            }
        }
    }
    /**
     * key action
     * @private
     */
    // tslint:disable:max-func-body-length
    onKeyDownInternal(event, ctrl, shift, alt) {
        let key = event.which || event.keyCode;
        if (ctrl && !shift && !alt) {
            this.viewer.isControlPressed = true;
            switch (key) {
                case 9:
                    event.preventDefault();
                    if (this.owner.acceptTab) {
                        this.selection.handleTabKey(false, false);
                    }
                    break;
                case 13:
                    event.preventDefault();
                    this.insertPageBreak();
                    break;
                case 48:
                    event.preventDefault();
                    this.onApplyParagraphFormat('beforeSpacing', 0, false, false);
                    break;
                case 49:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.onApplyParagraphFormat('lineSpacing', 1, false, false);
                    }
                    break;
                case 50:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.onApplyParagraphFormat('lineSpacing', 2, false, false);
                    }
                    break;
                case 53:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.onApplyParagraphFormat('lineSpacing', 1.5, false, false);
                    }
                    break;
                case 66:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleBold();
                    }
                    break;
                case 68:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode && this.owner.fontDialogModule) {
                        this.owner.fontDialogModule.showFontDialog();
                    }
                    break;
                case 69:
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleTextAlignment('Center');
                    }
                    event.preventDefault();
                    break;
                case 72:
                    event.preventDefault();
                    if (!this.owner.isReadOnly && this.owner.optionsPaneModule) {
                        this.owner.optionsPaneModule.isReplace = true;
                        this.owner.optionsPaneModule.showHideOptionsPane(true);
                    }
                    break;
                case 73:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleItalic();
                    }
                    break;
                case 74:
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleTextAlignment('Justify');
                    }
                    event.preventDefault();
                    break;
                case 75:
                    event.preventDefault();
                    if (this.owner.hyperlinkDialogModule && !this.owner.isReadOnlyMode) {
                        this.owner.hyperlinkDialogModule.show();
                    }
                    break;
                case 76:
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleTextAlignment('Left');
                    }
                    event.preventDefault();
                    break;
                case 77:
                    if (!this.owner.isReadOnlyMode) {
                        this.owner.selection.increaseIndent();
                    }
                    event.preventDefault();
                    break;
                case 78:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.owner.openBlank();
                    }
                    break;
                case 82:
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleTextAlignment('Right');
                    }
                    event.preventDefault();
                    break;
                case 85:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.owner.selection.toggleUnderline('Single');
                    }
                    break;
                case 88:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.owner.editor.cut();
                    }
                    break;
                case 89:
                    if (this.owner.enableEditorHistory) {
                        this.editorHistory.redo();
                        event.preventDefault();
                    }
                    break;
                case 90:
                    if (this.owner.enableEditorHistory) {
                        this.editorHistory.undo();
                        event.preventDefault();
                    }
                    break;
                case 219:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.onApplyCharacterFormat('fontSize', 'decrement', true);
                    }
                    break;
                case 221:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.onApplyCharacterFormat('fontSize', 'increment', true);
                    }
                    break;
                case 187:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleBaselineAlignment('Subscript');
                    }
                    break;
            }
        }
        else if (shift && !ctrl && !alt) {
            switch (key) {
                case 9:
                    event.preventDefault();
                    if (this.owner.acceptTab) {
                        this.selection.handleTabKey(false, true);
                    }
                    break;
                case 13:
                    this.handleShiftEnter();
                    event.preventDefault();
                    break;
            }
        }
        else if (shift && ctrl && !alt) {
            switch (key) {
                case 68:
                    if (!this.owner.isReadOnlyMode) {
                        this.owner.selection.toggleUnderline('Double');
                    }
                    break;
                case 77:
                    if (!this.owner.isReadOnlyMode) {
                        this.owner.selection.decreaseIndent();
                    }
                    event.preventDefault();
                    break;
                case 188:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.onApplyCharacterFormat('fontSize', 'decrement', true);
                    }
                    break;
                case 190:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.onApplyCharacterFormat('fontSize', 'increment', true);
                    }
                    break;
                case 187:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleBaselineAlignment('Superscript');
                    }
            }
        }
        else if (!shift && ctrl && alt) {
            switch (key) {
                case 72:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode && this.owner.isDocumentLoaded) {
                        this.toggleHighlightColor();
                    }
                    break;
            }
        }
        else {
            switch (key) {
                case 8:
                    event.preventDefault();
                    this.handleBackKey();
                    break;
                case 9:
                    event.preventDefault();
                    if (this.owner.acceptTab) {
                        this.selection.handleTabKey(true, false);
                    }
                    break;
                case 13:
                    event.preventDefault();
                    this.handleEnterKey();
                    break;
                case 46:
                    this.handleDelete();
                    event.preventDefault();
                    break;
            }
        }
    }
    /**
     * @private
     */
    handleShiftEnter() {
        if (!this.owner.isReadOnlyMode) {
            this.handleTextInput('\v');
        }
        this.selection.checkForCursorVisibility();
    }
    /**
     * Handles back key.
     * @private
     */
    handleBackKey() {
        if (!this.owner.isReadOnlyMode) {
            this.owner.editorModule.onBackSpace();
        }
        this.selection.checkForCursorVisibility();
    }
    /**
     * Handles delete
     * @private
     */
    handleDelete() {
        if (!this.owner.isReadOnlyMode) {
            this.owner.editorModule.onDelete();
        }
        this.selection.checkForCursorVisibility();
    }
    /**
     * Handles enter key.
     * @private
     */
    handleEnterKey() {
        if (!this.owner.isReadOnlyMode) {
            if (Browser.isDevice) {
                this.viewer.isCompositionStart = false;
            }
            this.owner.editorModule.onEnter();
        }
        this.selection.checkForCursorVisibility();
    }
    /**
     * @private
     */
    handleTextInput(text) {
        if (!this.owner.isReadOnlyMode) {
            if (this.animationTimer) {
                clearTimeout(this.animationTimer);
            }
            classList(this.selection.caret, [], ['e-de-cursor-animation']);
            this.owner.editorModule.insertText(text, false);
            /* tslint:disable:align */
            this.animationTimer = setTimeout(() => {
                if (this.animationTimer) {
                    clearTimeout(this.animationTimer);
                }
                if (this.selection && this.selection.caret) {
                    classList(this.selection.caret, ['e-de-cursor-animation'], []);
                }
            }, 600);
        }
        this.selection.checkForCursorVisibility();
    }
    /**
     * Copies to format.
     * @param  {WCharacterFormat} format
     * @private
     */
    copyInsertFormat(format, copy) {
        let insertFormat = new WCharacterFormat();
        let sFormat = this.selection.characterFormat;
        if (copy) {
            insertFormat.copyFormat(format);
        }
        if (!isNullOrUndefined(sFormat.bold) && format.bold !== sFormat.bold) {
            insertFormat.bold = sFormat.bold;
        }
        if (!isNullOrUndefined(sFormat.italic) && format.italic !== sFormat.italic) {
            insertFormat.italic = sFormat.italic;
        }
        if (sFormat.fontSize > 0 && format.fontSize !== sFormat.fontSize) {
            insertFormat.fontSize = sFormat.fontSize;
        }
        if (!isNullOrUndefined(sFormat.fontFamily) && format.fontFamily !== sFormat.fontFamily) {
            insertFormat.fontFamily = sFormat.fontFamily;
        }
        if (!isNullOrUndefined(sFormat.highlightColor) && format.highlightColor !== sFormat.highlightColor) {
            insertFormat.highlightColor = sFormat.highlightColor;
        }
        if (!isNullOrUndefined(sFormat.baselineAlignment) && format.baselineAlignment !== sFormat.baselineAlignment) {
            insertFormat.baselineAlignment = sFormat.baselineAlignment;
        }
        if (!isNullOrUndefined(sFormat.fontColor) && format.fontColor !== sFormat.fontColor) {
            insertFormat.fontColor = sFormat.fontColor;
        }
        if (!isNullOrUndefined(sFormat.underline) && format.underline !== sFormat.underline) {
            insertFormat.underline = sFormat.underline;
        }
        if (!isNullOrUndefined(sFormat.strikethrough) && format.strikethrough !== sFormat.strikethrough) {
            insertFormat.strikethrough = sFormat.strikethrough;
        }
        return insertFormat;
    }
    /**
     * Inserts the specified text at cursor position
     * @param  {string} text
     * @param  {boolean} isReplace
     * @private
     */
    //tslint:disable: max-func-body-length
    insertText(text, isReplace) {
        let selection = this.viewer.selection;
        let insertPosition;
        let isRemoved = true;
        this.isListTextSelected();
        this.initHistory('Insert');
        let paragraphInfo = this.getParagraphInfo(selection.start);
        this.viewer.selection.editPosition = this.getHierarchicalIndex(paragraphInfo.paragraph, paragraphInfo.offset.toString());
        if ((!selection.isEmpty && !this.viewer.selection.isImageSelected) ||
            this.viewer.isListTextSelected && selection.contextType === 'List') {
            selection.isSkipLayouting = true;
            selection.skipFormatRetrieval = true;
            isRemoved = this.removeSelectedContents(selection);
            selection.skipFormatRetrieval = false;
            selection.isSkipLayouting = false;
        }
        paragraphInfo = this.getParagraphInfo(selection.start);
        if (isRemoved) {
            selection.owner.isShiftingEnabled = true;
            this.updateInsertPosition();
            insertPosition = selection.start;
            if (insertPosition.paragraph.isEmpty()) {
                let span = new TextElementBox();
                let insertFormat = this.copyInsertFormat(insertPosition.paragraph.characterFormat, true);
                span.characterFormat.copyFormat(insertFormat);
                span.text = text;
                span.line = insertPosition.paragraph.childWidgets[0];
                span.margin = new Margin(0, 0, 0, 0);
                span.line.children.push(span);
                if ((insertPosition.paragraph.paragraphFormat.textAlignment === 'Center'
                    || insertPosition.paragraph.paragraphFormat.textAlignment === 'Right') &&
                    insertPosition.paragraph.paragraphFormat.listFormat.listId === -1) {
                    insertPosition.paragraph.x = this.viewer.clientActiveArea.x;
                }
                this.viewer.layout.reLayoutParagraph(insertPosition.paragraph, 0, 0);
            }
            else {
                let indexInInline = 0;
                let inlineObj = insertPosition.currentWidget.getInline(insertPosition.offset, indexInInline);
                let inline = inlineObj.element;
                indexInInline = inlineObj.index;
                // Todo: compare selection format
                let insertFormat = this.copyInsertFormat(inline.characterFormat, true);
                if (insertFormat.isSameFormat(inline.characterFormat)) {
                    this.insertTextInline(inline, selection, text, indexInInline);
                }
                else {
                    let tempSpan = new TextElementBox();
                    tempSpan.text = text;
                    tempSpan.line = inline.line;
                    tempSpan.characterFormat.copyFormat(insertFormat);
                    let insertIndex = inline.indexInOwner;
                    if (indexInInline === inline.length) {
                        inline.line.children.splice(insertIndex + 1, 0, tempSpan);
                    }
                    else if (indexInInline === 0) {
                        inline.line.children.splice(insertIndex, 0, tempSpan);
                    }
                    else {
                        if (inline instanceof TextElementBox) {
                            let splittedSpan = new TextElementBox();
                            splittedSpan.line = inline.line;
                            splittedSpan.characterFormat.copyFormat(inline.characterFormat);
                            splittedSpan.text = inline.text.substring(indexInInline);
                            inline.text = inline.text.slice(0, indexInInline);
                            inline.line.children.splice(insertIndex + 1, 0, splittedSpan);
                        }
                        inline.line.children.splice(insertIndex + 1, 0, tempSpan);
                    }
                    this.viewer.layout.reLayoutParagraph(insertPosition.paragraph, inline.line.indexInOwner, 0);
                }
            }
            this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset + text.length, true);
            this.updateEndPosition();
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentHistoryInfo) && (this.editorHistory.currentHistoryInfo.action === 'ListSelect') &&
                this.viewer.isListTextSelected) {
                this.editorHistory.updateHistory();
                this.editorHistory.updateComplexHistory();
            }
            // if (!isNullOrUndefined(selection.currentHistoryInfo) && (selection.currentHistoryInfo.action === 'MultiSelection')) {
            //     this.updateComplexHistory();
            // } else {           
            this.reLayout(selection);
            // }
        }
        else {
            // selection.selectContent(selection.start, true);
        }
        // insertFormat.destroy();
        if (!isReplace && isRemoved && (text === ' ' || text === '\t' || text === '\v')) {
            let hyperlinkField = selection.getHyperlinkField();
            let isSelectionOnHyperlink = !isNullOrUndefined(hyperlinkField);
            let isList = false;
            if (!(text === '\v')) {
                isList = this.checkAndConvertList(selection, text === '\t');
            }
            if (isSelectionOnHyperlink) {
                return;
            }
            if (!isList) {
                //Checks if the previous text is URL, then it is auto formatted to hyperlink.
                this.checkAndConvertToHyperlink(selection, false);
            }
        }
    }
    /**
     * Insert Section break at cursor position
     */
    insertSectionBreak() {
        let selection = this.viewer.selection;
        if (isNullOrUndefined(selection) || this.owner.isReadOnlyMode || selection.start.paragraph.isInHeaderFooter) {
            return;
        }
        this.initHistory('SectionBreak');
        if (!selection.isEmpty) {
            selection.selectContent(selection.isForward ? selection.start : selection.end, true);
        }
        this.viewer.owner.isShiftingEnabled = true;
        this.updateInsertPosition();
        this.insertSection(selection, true);
        this.updateEndPosition();
        this.reLayout(selection, true);
    }
    /**
     * @private
     */
    insertSection(selection, selectFirstBlock) {
        let newSectionFormat = this.selection.start.paragraph.bodyWidget.sectionFormat.cloneFormat();
        let lastBlock;
        let firstBlock;
        if (selection.start.paragraph.isInsideTable) {
            let table = this.viewer.layout.getParentTable(selection.start.paragraph);
            table = table.combineWidget(this.viewer);
            let insertBefore = false;
            if (selection.start.paragraph.associatedCell.rowIndex === 0) {
                insertBefore = true;
            }
            let newParagraph = new ParagraphWidget();
            let previousBlock = table.previousRenderedWidget;
            if (!insertBefore) {
                lastBlock = this.splitTable(table, selection.start.paragraph.associatedCell.ownerRow);
                this.viewer.layout.layoutBodyWidgetCollection(lastBlock.index, lastBlock.containerWidget, lastBlock, false);
                lastBlock = lastBlock.getSplitWidgets().pop();
            }
            else {
                lastBlock = table;
            }
            let insertIndex = 0;
            if ((isNullOrUndefined(previousBlock) || !previousBlock.bodyWidget.equals(lastBlock.bodyWidget)) && insertBefore) {
                insertIndex = 0;
                newParagraph.index = 0;
            }
            else {
                insertIndex = lastBlock.indexInOwner + 1;
                newParagraph.index = lastBlock.index + 1;
            }
            lastBlock.containerWidget.childWidgets.splice(insertIndex, 0, newParagraph);
            newParagraph.containerWidget = lastBlock.containerWidget;
            this.updateNextBlocksIndex(newParagraph, true);
            this.viewer.layout.layoutBodyWidgetCollection(newParagraph.index, newParagraph.containerWidget, newParagraph, false);
            lastBlock = newParagraph;
        }
        else {
            let paragraphInfo = this.getParagraphInfo(selection.start);
            let selectionStart = this.getHierarchicalIndex(paragraphInfo.paragraph, paragraphInfo.offset.toString());
            //Split Paragraph
            this.splitParagraphInternal(selection, selection.start.paragraph, selection.start.currentWidget, selection.start.offset);
            this.setPositionForCurrentIndex(selection.start, selectionStart);
            lastBlock = selection.start.paragraph.getSplitWidgets().pop();
        }
        //Split body widget
        firstBlock = this.splitBodyWidget(lastBlock.bodyWidget, newSectionFormat, lastBlock).firstChild;
        if (firstBlock instanceof TableWidget) {
            firstBlock.updateRowIndex(0);
        }
        this.viewer.layout.layoutBodyWidgetCollection(firstBlock.index, firstBlock.containerWidget, firstBlock, false);
        if (firstBlock instanceof TableWidget) {
            firstBlock = selection.getFirstParagraphInFirstCell(firstBlock);
        }
        if (selectFirstBlock) {
            selection.selectParagraph(firstBlock, true);
        }
        return firstBlock;
    }
    splitBodyWidget(bodyWidget, sectionFormat, startBlock) {
        let newBodyWidget = this.viewer.layout.moveBlocksToNextPage(startBlock);
        //Update SectionIndex for splitted body widget
        this.updateSectionIndex(sectionFormat, newBodyWidget, true);
        // insert New header footer widget in to section index 
        this.insertRemoveHeaderFooter(newBodyWidget.sectionIndex, true);
        //update header and footer for splitted widget
        this.viewer.layout.layoutHeaderFooter(newBodyWidget, this.viewer, newBodyWidget.page);
        //Update Child item index from 0 for new Section
        this.updateBlockIndex(0, newBodyWidget.firstChild);
        // Start sinfting from first block
        this.viewer.updateClientArea(newBodyWidget.sectionFormat, newBodyWidget.page);
        return newBodyWidget;
    }
    insertRemoveHeaderFooter(sectionIndex, insert) {
        if (this.viewer.headersFooters[sectionIndex]) {
            // Need to handle further
        }
        else {
            this.viewer.headersFooters[sectionIndex] = {};
        }
    }
    updateBlockIndex(blockIndex, block) {
        let blocks;
        let sectionIndex = block.bodyWidget.sectionIndex;
        do {
            blocks = block.getSplitWidgets();
            for (let i = 0; i < blocks.length; i++) {
                blocks[i].index = blockIndex;
            }
            blockIndex++;
            block = blocks.pop().nextRenderedWidget;
        } while (!isNullOrUndefined(block) && block.bodyWidget.sectionIndex === sectionIndex);
    }
    updateSectionIndex(sectionFormat, startBodyWidget, increaseIndex) {
        let currentSectionIndex = startBodyWidget.sectionIndex;
        let bodyWidget = startBodyWidget;
        do {
            if (bodyWidget.index === currentSectionIndex && sectionFormat) {
                bodyWidget.sectionFormat = sectionFormat;
            }
            if (increaseIndex) {
                bodyWidget.index++;
            }
            else {
                bodyWidget.index--;
            }
            bodyWidget = bodyWidget.nextRenderedWidget;
        } while (bodyWidget);
    }
    //Auto convert List
    checkAndConvertList(selection, isTab) {
        let list = selection.paragraphFormat.getList();
        if (!isNullOrUndefined(list)) {
            return false;
        }
        let convertList = false;
        let isLeadingZero = false;
        let indexInInline = 0;
        let inlineObj = selection.start.currentWidget.getInline(selection.start.offset - 1, indexInInline);
        let inline = inlineObj.element;
        indexInInline = inlineObj.index;
        if (!(inline instanceof TextElementBox)) {
            return false;
        }
        let span = inline;
        let text = span.text.substring(0, indexInInline);
        let tabValue = 0;
        let length = 0;
        while (!isNullOrUndefined(span.previousNode)) {
            // tslint:disable-next-line:max-line-length
            if (span.previousNode instanceof TextElementBox && (span.previousNode.text === '\t' || span.previousNode.text.trim().length === 0)) {
                (span.previousNode.text === '\t') ? tabValue += 36 : length = span.previousNode.text.length * 2.5;
                span = span.previousNode;
                continue;
            }
            return false;
        }
        span = inline;
        let index = 0;
        let tabIndex = text.lastIndexOf('\t');
        index = (tabIndex >= 0) ? tabIndex + 1 : text.lastIndexOf(' ') + 1;
        while (span.previousNode instanceof TextElementBox && index === 0) {
            span = span.previousNode;
            let previousText = span.text;
            tabIndex = previousText.lastIndexOf('\t');
            index = (tabIndex >= 0) ? tabIndex + 1 : previousText.lastIndexOf(' ') + 1;
            text = span.text + text;
            text = text.substring(index);
        }
        text = HelperMethods.trimStart(text);
        let numberFormat = text.substring(1, 2);
        let listLevelPattern = this.getListLevelPattern(text.substring(0, 1));
        if (listLevelPattern !== 'None' && this.checkNumberFormat(numberFormat, listLevelPattern === 'Bullet', text)) {
            convertList = true;
        }
        else if (this.checkLeadingZero(text)) {
            isLeadingZero = true;
            convertList = true;
        }
        if (convertList) {
            this.initComplexHistory('AutoList');
            let paragraph = inline.paragraph;
            // tslint:disable-next-line:max-line-length
            selection.start.setPositionParagraph(paragraph.childWidgets[0], paragraph.childWidgets[0].getOffset(inline, indexInInline + 1));
            selection.end.setPositionParagraph(paragraph.childWidgets[0], 0);
            this.initHistory('Delete');
            this.deleteSelectedContents(selection, false);
            this.reLayout(selection, false);
            let followCharacter = isTab ? 'Tab' : 'Space';
            numberFormat = !isLeadingZero ? '%1' + numberFormat : '%1' + text.substring(text.length - 1, text.length);
            let leadingZeroText = text.substring(text.length - 3, text.length - 1);
            listLevelPattern = !isLeadingZero ? listLevelPattern : this.getListLevelPattern(leadingZeroText);
            let listLevel = new WListLevel(undefined);
            listLevel.listLevelPattern = listLevelPattern;
            if (listLevelPattern === 'Bullet') {
                if (text === '*') {
                    listLevel.numberFormat = '\uf0b7';
                    listLevel.characterFormat.fontFamily = 'Symbol';
                }
                else if (text === '-') {
                    listLevel.numberFormat = '-';
                }
            }
            else {
                listLevel.numberFormat = numberFormat;
            }
            listLevel.followCharacter = followCharacter;
            let leftIndent = selection.paragraphFormat.leftIndent;
            if (tabValue !== 0 || length !== 0) {
                listLevel.paragraphFormat.leftIndent = leftIndent + 18 + tabValue + length;
            }
            else if (indexInInline > 2) {
                listLevel.paragraphFormat.leftIndent = leftIndent + (indexInInline - 2) * 2.5 + 18;
            }
            else if (leftIndent > 0) {
                listLevel.paragraphFormat.leftIndent = leftIndent + 18;
            }
            else {
                listLevel.paragraphFormat.leftIndent = 36;
            }
            listLevel.paragraphFormat.firstLineIndent = -18;
            if ((!isLeadingZero && text.substring(0, 1) === '0') || leadingZeroText === '00') {
                listLevel.startAt = 0;
            }
            else {
                listLevel.startAt = 1;
            }
            this.autoConvertList(selection, listLevel);
            if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentHistoryInfo)) {
                this.editorHistory.updateComplexHistory();
            }
            else {
                this.reLayout(selection);
            }
        }
        return convertList;
    }
    getListLevelPattern(value) {
        switch (value) {
            case '0':
            case '1':
                return 'Arabic';
            case 'I':
                return 'UpRoman';
            case 'i':
                return 'LowRoman';
            case 'A':
                return 'UpLetter';
            case 'a':
                return 'LowLetter';
            case '*':
            case '-':
                return 'Bullet';
            case '00':
            case '01':
                return 'LeadingZero';
            default:
                return 'None';
        }
    }
    autoConvertList(selection, listLevel) {
        let start = selection.start;
        if (!selection.isForward) {
            start = selection.end;
        }
        let newList = new WList();
        if (this.viewer.lists.length > 0) {
            newList.listId = this.viewer.lists[this.viewer.lists.length - 1].listId + 1;
        }
        else {
            newList.listId = 0;
        }
        let newAbstractList = new WAbstractList();
        let layout = this.viewer;
        if (layout.abstractLists.length > 0) {
            newAbstractList.abstractListId = layout.abstractLists[layout.abstractLists.length - 1].abstractListId + 1;
        }
        else {
            newAbstractList.abstractListId = 0;
        }
        newList.abstractListId = newAbstractList.abstractListId;
        layout.abstractLists.push(newAbstractList);
        newAbstractList.levels.push(listLevel);
        listLevel.ownerBase = newAbstractList;
        selection.paragraphFormat.setList(newList);
        selection.paragraphFormat.listLevelNumber = 0;
    }
    checkNumberFormat(numberFormat, isBullet, text) {
        if (isBullet) {
            return numberFormat === '';
        }
        else {
            let index = text.indexOf(numberFormat);
            return (numberFormat === '.' || numberFormat === ')'
                || numberFormat === '>' || numberFormat === '-') && text.substring(index, text.length - 1) === '';
        }
    }
    checkLeadingZero(text) {
        let j;
        let isZero = false;
        for (let i = 0; i <= text.length - 1; i++) {
            if (text.charAt(i) === '0') {
                isZero = true;
                continue;
            }
            j = i;
            break;
        }
        let numberFormat = undefined;
        if (text.charAt(j) === '1') {
            numberFormat = text.charAt(j + 1);
        }
        else {
            numberFormat = text.charAt(j);
        }
        return isZero && this.checkNumberFormat(numberFormat, false, text);
    }
    getPageFromBlockWidget(block) {
        let page = undefined;
        if (block.containerWidget instanceof BodyWidget) {
            page = block.containerWidget.page;
        }
        else if (block.containerWidget instanceof HeaderFooterWidget) {
            page = block.containerWidget.page;
        }
        else if (block.containerWidget instanceof TableCellWidget) {
            page = block.containerWidget.bodyWidget.page;
        }
        return page;
    }
    /**
     * @private
     */
    insertTextInline(element, selection, text, index) {
        if (element instanceof TextElementBox) {
            element.text = HelperMethods.insert(element.text, index, text);
            let paragraph = element.line.paragraph;
            let lineIndex = paragraph.childWidgets.indexOf(element.line);
            let elementIndex = element.line.children.indexOf(element);
            this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, elementIndex);
        }
        else if (element instanceof ImageElementBox) {
            this.insertImageText(element, selection, text, index);
        }
        else if (element instanceof FieldElementBox) {
            if (element.fieldType === 0) {
                this.insertFieldBeginText(element, selection, text, index);
            }
            else if (element.fieldType === 2) {
                this.insertFieldSeparatorText(element, selection, text, index);
            }
            else {
                this.insertFieldEndText(element, selection, text, index);
            }
        }
        else if (element instanceof BookmarkElementBox) {
            this.insertBookMarkText(element, selection, text, index);
        }
    }
    insertFieldBeginText(fieldBegin, selection, text, index) {
        let spanObj = new TextElementBox();
        spanObj.text = text;
        let lineIndex = fieldBegin.line.paragraph.childWidgets.indexOf(fieldBegin.line);
        let spanIndex = fieldBegin.line.children.indexOf(fieldBegin);
        spanObj.characterFormat.copyFormat(fieldBegin.characterFormat);
        fieldBegin.line.children.splice(spanIndex, 0, spanObj);
        spanObj.line = fieldBegin.line;
        this.viewer.layout.reLayoutParagraph(fieldBegin.line.paragraph, lineIndex, spanIndex);
    }
    insertBookMarkText(element, selection, text, index) {
        let spanObj = new TextElementBox();
        spanObj.text = text;
        let lineIndex = element.line.paragraph.childWidgets.indexOf(element.line);
        let spanIndex = element.line.children.indexOf(element);
        spanObj.characterFormat.copyFormat(element.characterFormat);
        element.line.children.splice(spanIndex, 0, spanObj);
        spanObj.line = element.line;
        this.viewer.layout.reLayoutParagraph(element.line.paragraph, lineIndex, spanIndex);
    }
    insertFieldSeparatorText(fieldSeparator, selection, text, index) {
        let previousInline = selection.getPreviousTextInline(fieldSeparator);
        let nextInline = selection.getNextTextInline(fieldSeparator);
        let span = new TextElementBox();
        span.text = text;
        let spanIndex = fieldSeparator.line.children.indexOf(fieldSeparator);
        if (index === fieldSeparator.length) {
            spanIndex++;
        }
        if (isNullOrUndefined(previousInline) && isNullOrUndefined(nextInline)) {
            span.characterFormat.copyFormat(fieldSeparator.line.paragraph.characterFormat);
        }
        else if (isNullOrUndefined(previousInline)) {
            span.characterFormat.copyFormat(nextInline.characterFormat);
        }
        else {
            span.characterFormat.copyFormat(previousInline.characterFormat);
        }
        fieldSeparator.line.children.splice(spanIndex, 0, span);
        span.line = fieldSeparator.line;
        let lineIndex = fieldSeparator.line.paragraph.childWidgets.indexOf(fieldSeparator.line);
        this.viewer.layout.reLayoutParagraph(fieldSeparator.line.paragraph, lineIndex, spanIndex);
    }
    insertFieldEndText(fieldEnd, selection, text, index) {
        let span = new TextElementBox();
        span.text = text;
        let spanIndex = fieldEnd.line.children.indexOf(fieldEnd);
        span.characterFormat.copyFormat(fieldEnd.characterFormat);
        fieldEnd.line.children.splice(spanIndex + 1, 0, span);
        span.line = fieldEnd.line;
        let lineIndex = fieldEnd.line.paragraph.childWidgets.indexOf(fieldEnd.line);
        this.viewer.layout.reLayoutParagraph(fieldEnd.line.paragraph, lineIndex, spanIndex);
    }
    insertImageText(image, selection, text, index) {
        let previousInlineObj = selection.getPreviousTextInline(image);
        let nextInlineObj = selection.getNextTextInline(image);
        let line = image.line;
        let element = new TextElementBox();
        let paragraph = line.paragraph;
        let lineIndex = paragraph.childWidgets.indexOf(line);
        element.text = text;
        let spanIndex = line.children.indexOf(image);
        if (index === image.length) {
            spanIndex++;
        }
        if (isNullOrUndefined(previousInlineObj) && isNullOrUndefined(nextInlineObj)) {
            element.characterFormat.copyFormat(paragraph.characterFormat);
        }
        else if (isNullOrUndefined(previousInlineObj)) {
            element.characterFormat.copyFormat(nextInlineObj.characterFormat);
        }
        else {
            element.characterFormat.copyFormat(previousInlineObj.characterFormat);
        }
        line.children.splice(spanIndex, 0, element);
        element.line = line;
        this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, spanIndex);
    }
    /**
     * @private
     */
    isListTextSelected() {
        if (this.viewer.isListTextSelected) {
            this.initComplexHistory('ListSelect');
            // tslint:disable-next-line:max-line-length
            if (this.viewer.selection.start.paragraph.paragraphFormat.listFormat && this.viewer.selection.start.paragraph.paragraphFormat.listFormat.listId !== -1) {
                this.onApplyList(undefined);
            }
        }
    }
    //Auto Format and insert Hyperlink Implementation starts
    checkAndConvertToHyperlink(selection, isEnter, paragraph) {
        let text;
        let span;
        if (isEnter) {
            span = paragraph.lastChild.children[paragraph.lastChild.children.length - 1];
            text = span.text;
        }
        else {
            let indexInInline = 0;
            let inlineObj = selection.start.currentWidget.getInline(selection.start.offset - 1, indexInInline);
            let inline = inlineObj.element;
            indexInInline = inlineObj.index;
            if (!(inline instanceof TextElementBox)) {
                return;
            }
            span = inline;
            text = span.text.substring(0, indexInInline);
        }
        let index = 0;
        let tabCharIndex = text.lastIndexOf('\t');
        index = (tabCharIndex >= 0) ? tabCharIndex + 1 : text.lastIndexOf(' ') + 1;
        while (span.previousNode instanceof TextElementBox && index === 0) {
            span = span.previousNode;
            let previousText = span.text;
            tabCharIndex = previousText.lastIndexOf('\t');
            index = (tabCharIndex >= 0) ? tabCharIndex + 1 : previousText.lastIndexOf(' ') + 1;
            text = span.text + text;
        }
        text = text.substring(index);
        let lowerCaseText = text.toLowerCase();
        let containsURL = false;
        if (lowerCaseText.substring(0, 8) === 'file:///'
            || (lowerCaseText.substring(0, 7) === 'http://' && lowerCaseText.length > 7)
            || (lowerCaseText.substring(0, 8) === 'https://' && lowerCaseText.length > 8)
            || (lowerCaseText.substring(0, 4) === 'www.' && lowerCaseText.length > 4)
            || (lowerCaseText.substring(0, 3) === '\\' && lowerCaseText.length > 3)
            || (lowerCaseText.substring(0, 7) === 'mailto:' && lowerCaseText.length > 7)) {
            containsURL = true;
            if (lowerCaseText.substring(0, 4) === 'www.' && lowerCaseText.length > 4) {
                text = 'http://' + text;
            }
        }
        else {
            let atIndex = text.indexOf('@');
            let dotIndex = text.indexOf('.');
            if (atIndex > 0 && atIndex < dotIndex && dotIndex < text.length - 1) {
                containsURL = true;
                text = 'mailto:' + text;
            }
        }
        if (containsURL) {
            let startPos = new TextPosition(this.viewer.owner);
            startPos.setPositionParagraph(span.line, span.line.getOffset(span, index));
            let endPos = new TextPosition(this.viewer.owner);
            if (isEnter) {
                endPos.setPositionParagraph(span.line, span.line.getEndOffset());
            }
            else {
                if (selection.end.currentWidget.children.length === 0 && selection.end.offset === 0) {
                    let prevLine = selection.end.currentWidget.previousLine;
                    endPos.setPositionParagraph(prevLine, prevLine.getEndOffset());
                }
                else {
                    endPos.setPositionParagraph(selection.end.currentWidget, selection.end.offset - 1);
                }
            }
            this.autoFormatHyperlink(selection, text, startPos, endPos);
        }
    }
    autoFormatHyperlink(selection, url, startPosition, endPosition) {
        this.initComplexHistory('AutoFormatHyperlink');
        let blockInfo = this.getParagraphInfo(startPosition);
        let start = this.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
            this.editorHistory.currentHistoryInfo.insertPosition = start;
        }
        // Moves the selection to URL text start and end position.
        selection.start.setPositionInternal(startPosition);
        selection.end.setPositionInternal(endPosition);
        // Preserves the character format for hyperlink field.
        let temp = this.getCharacterFormat(selection);
        let format = new WCharacterFormat();
        format.copyFormat(temp);
        let fieldEnd = this.createHyperlinkElement(url, startPosition, endPosition, format);
        // Moves the selection to the end of field end position.
        selection.start.setPositionParagraph(fieldEnd.line, (fieldEnd.line).getOffset(fieldEnd, 1));
        // Moves to next text position. (To achieve common behavior for space and enter).
        selection.start.moveNextPosition();
        selection.end.setPositionInternal(selection.start);
        blockInfo = this.getParagraphInfo(selection.end);
        let end = this.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
            this.editorHistory.currentHistoryInfo.endPosition = end;
            this.editorHistory.updateComplexHistory();
            this.reLayout(selection);
        }
        else {
            this.updateComplexWithoutHistory(0, start, end);
        }
    }
    appylingHyperlinkFormat(selection) {
        this.initHistory('Underline');
        this.updateCharacterFormatWithUpdate(selection, 'underline', 'Single', false);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.reLayout(selection, false);
        // Applies font color for field result.
        this.initHistory('FontColor');
        this.updateCharacterFormatWithUpdate(selection, 'fontColor', '#0563c1', false);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.reLayout(selection, false);
    }
    // tslint:disable-next-line:max-line-length
    createHyperlinkElement(url, startPosition, endPosition, format) {
        let selection = this.selection;
        this.viewer.layout.allowLayout = false;
        this.appylingHyperlinkFormat(selection);
        this.viewer.layout.allowLayout = true;
        // Adds the field end at the URL text end position.
        let fieldEnd = new FieldElementBox(1);
        fieldEnd.characterFormat.copyFormat(format);
        fieldEnd.line = selection.end.currentWidget;
        selection.start.setPositionInternal(selection.end);
        // this.insertElementInCurrentLine(selection, fieldEnd, true);
        this.initInsertInline(fieldEnd);
        // Moves the selection to URL text start position.        
        selection.start.setPositionInternal(startPosition);
        selection.end.setPositionInternal(selection.start);
        // Adds field begin, field code and field separator at the URL text start position.
        let begin = this.insertHyperlinkfield(selection, format, url);
        let lineIndex = selection.start.paragraph.childWidgets.indexOf(begin.line);
        let index = begin.line.children.indexOf(begin);
        fieldEnd.linkFieldCharacter(this.viewer);
        this.viewer.layout.reLayoutParagraph(selection.start.paragraph, lineIndex, index);
        return fieldEnd;
    }
    insertHyperlinkfield(selection, format, url, isBookmark) {
        // Adds field begin, field code and field separator at the URL text start position.
        let begin = new FieldElementBox(0);
        begin.characterFormat.copyFormat(format);
        begin.line = selection.start.currentWidget;
        this.initInsertInline(begin);
        let span = new TextElementBox();
        span.characterFormat.copyFormat(format);
        if (isBookmark) {
            span.text = ' HYPERLINK \\l \"' + url + '\" ';
        }
        else {
            span.text = ' HYPERLINK \"' + url + '\" ';
        }
        span.line = selection.start.currentWidget;
        this.initInsertInline(span);
        let separator = new FieldElementBox(2);
        separator.characterFormat.copyFormat(format);
        separator.line = selection.start.currentWidget;
        this.initInsertInline(separator);
        return begin;
    }
    unLinkFieldCharacter(inline) {
        if (inline instanceof FieldElementBox && inline.fieldType === 0) {
            if (inline.fieldEnd) {
                if (this.viewer) {
                    this.viewer.fieldToLayout = inline;
                    this.viewer.fieldEndParagraph = inline.line.paragraph;
                }
                // inline.line.paragraph.addFieldCharacter(inline.fieldEnd);
                inline.fieldEnd = undefined;
            }
        }
        if (inline instanceof FieldElementBox && inline.fieldType === 2) {
            if (!isNullOrUndefined(inline.fieldEnd)) {
                if (this.viewer) {
                    this.viewer.fieldToLayout = inline.fieldBegin;
                    this.viewer.fieldEndParagraph = inline.line.paragraph;
                }
                inline.fieldBegin.fieldSeparator = undefined;
                inline.fieldEnd.fieldSeparator = undefined;
            }
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 1) {
            if (inline.fieldBegin) {
                if (!isNullOrUndefined(this.viewer)) {
                    this.viewer.fieldToLayout = inline.fieldBegin;
                    this.viewer.fieldEndParagraph = inline.line.paragraph;
                }
                let fieldIndex = this.viewer.fields.indexOf(inline.fieldBegin);
                if (fieldIndex !== -1) {
                    this.viewer.fields.splice(fieldIndex, 1);
                }
                inline.fieldBegin = undefined;
            }
        }
    }
    getCharacterFormat(selection) {
        if (selection.start.paragraph.isEmpty()) {
            return selection.start.paragraph.characterFormat;
        }
        else {
            let info = selection.start.currentWidget.getInline(selection.start.offset, 0);
            return info.element.characterFormat;
        }
    }
    /**
     * Insert Hyperlink
     * @param  {string} url
     * @param  {string} displayText
     * @param  {boolean} remove
     * @private
     */
    insertHyperlink(url, displayText, remove, isBookmark) {
        let selection = this.viewer.selection;
        if (selection.start.paragraph.associatedCell !== selection.end.paragraph.associatedCell) {
            return;
        }
        if (remove) {
            //Empty selection Hyperlink insert
            this.insertHyperlinkInternal(selection, url, displayText, isBookmark);
        }
        else {
            //Non-Empty Selection- change the selected text to Field       
            // this.preservedFontCol = this.getFontColor();
            let startPosition = selection.start;
            let endPosition = selection.end;
            if (!selection.isForward) {
                startPosition = selection.end;
                endPosition = selection.start;
            }
            let fieldStartPosition = new TextPosition(this.viewer.owner);
            fieldStartPosition.setPositionInternal(startPosition);
            let temp = this.getCharacterFormat(selection);
            let format = new WCharacterFormat(undefined);
            format.copyFormat(temp);
            this.initComplexHistory('InsertHyperlink');
            let blockInfo = this.getParagraphInfo(startPosition);
            let start = this.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
            if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
                // tslint:disable-next-line:max-line-length
                this.editorHistory.currentHistoryInfo.insertPosition = this.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
            }
            this.appylingHyperlinkFormat(selection);
            this.viewer.layout.allowLayout = true;
            startPosition.setPositionInternal(endPosition);
            // Adds the field end at the URL text end position.
            let fieldEnd = new FieldElementBox(1);
            fieldEnd.characterFormat.copyFormat(format);
            fieldEnd.line = selection.end.currentWidget;
            startPosition.setPositionInternal(endPosition);
            // this.insertElementInCurrentLine(selection, fieldEnd, true);
            this.initInsertInline(fieldEnd);
            // Moves the selection to URL text start position.        
            startPosition.setPositionInternal(fieldStartPosition);
            endPosition.setPositionInternal(startPosition);
            // Adds field begin, field code and field separator at the URL text start position.
            let begin = this.insertHyperlinkfield(selection, format, url, isBookmark);
            fieldEnd.linkFieldCharacter(this.viewer);
            let lineIndex = selection.start.paragraph.childWidgets.indexOf(begin.line);
            let index = begin.line.children.indexOf(begin);
            this.viewer.layout.reLayoutParagraph(selection.start.paragraph, lineIndex, index);
            let lineWidget = fieldEnd.line;
            selection.selects(lineWidget, lineWidget.getOffset(fieldEnd, fieldEnd.length), true);
            blockInfo = this.getParagraphInfo(endPosition);
            let end = this.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
            if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
                // tslint:disable-next-line:max-line-length
                this.editorHistory.currentHistoryInfo.endPosition = this.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
                this.editorHistory.updateComplexHistory();
            }
            else {
                this.updateComplexWithoutHistory(1, start, end);
            }
        }
    }
    insertHyperlinkInternal(selection, url, displayText, isBookmark) {
        if (isNullOrUndefined(selection.start)) {
            return;
        }
        if (this.editHyperlink(selection, url, displayText)) {
            return;
        }
        this.initHistory('InsertHyperlink');
        let isRemoved = true;
        if (!selection.isEmpty) {
            isRemoved = this.removeSelectedContents(selection);
        }
        if (isRemoved) {
            // Preserves the character format for hyperlink field.
            let temp = this.getCharacterFormat(selection);
            let format = new WCharacterFormat();
            format.copyFormat(temp);
            this.insertHyperlinkByFormat(selection, url, displayText, format, isBookmark);
        }
        //else
        //    this.Select(Start, true);
    }
    // tslint:disable-next-line:max-line-length
    insertHyperlinkByFormat(selection, url, displayText, format, isBookmark) {
        this.updateInsertPosition();
        selection.owner.isShiftingEnabled = true;
        let element = [];
        let fieldBegin = new FieldElementBox(0);
        element.push(fieldBegin);
        let span = new TextElementBox();
        if (isBookmark) {
            span.text = ' HYPERLINK \\l \"' + url + '\" ';
        }
        else {
            span.text = ' HYPERLINK \"' + url + '\" ';
        }
        element.push(span);
        let fieldSeparator = new FieldElementBox(2);
        element.push(fieldSeparator);
        if (!isNullOrUndefined(displayText) && displayText !== '') {
            span = new TextElementBox();
            span.characterFormat.underline = 'Single';
            span.characterFormat.fontColor = '#0563c1';
            span.text = displayText;
            element.push(span);
        }
        let fieldEnd = new FieldElementBox(1);
        element.push(fieldEnd);
        this.insertElement(element);
        let paragraph = selection.start.paragraph;
        fieldEnd.linkFieldCharacter(this.viewer);
        if (this.viewer.fields.indexOf(fieldBegin) === -1) {
            this.viewer.fields.push(fieldBegin);
        }
        let offset = fieldEnd.line.getOffset(fieldEnd, 1);
        selection.selects(fieldEnd.line, fieldEnd.line.getOffset(fieldEnd, fieldEnd.length), true);
        this.updateEndPosition();
        this.reLayout(selection, true);
    }
    initInsertInline(element, insertHyperlink) {
        this.initHistory('InsertInline');
        this.insertInlineInSelection(this.viewer.selection, element);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
    }
    /**
     * @private
     */
    insertElementInCurrentLine(selection, inline, isReLayout) {
        if (this.checkIsNotRedoing()) {
            selection.owner.isShiftingEnabled = true;
        }
        if (!selection.isEmpty) {
            this.removeSelectedContents(selection);
        }
        this.updateInsertPosition();
        this.insertElement([inline]);
        if (this.checkEndPosition(selection)) {
            this.updateHistoryPosition(selection.start, false);
        }
        this.fireContentChange();
    }
    /**
     * Edit Hyperlink
     * @param  {Selection} selection
     * @param  {string} url
     * @param  {string} displayText
     * @private
     */
    editHyperlink(selection, url, displayText, isBookmark) {
        let fieldBegin = selection.getHyperlinkField();
        if (isNullOrUndefined(fieldBegin)) {
            return false;
        }
        this.initHistory('InsertHyperlink');
        this.editHyperlinkInternal = isNullOrUndefined(this.editorHistory)
            || (this.editorHistory && isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo));
        let fieldResult = '';
        let isNestedField = false;
        // Preserves the character format for hyperlink field.
        let temp = this.getCharacterFormat(selection);
        let format = new WCharacterFormat();
        format.copyFormat(temp);
        let fieldSeparator = undefined;
        if (!isNullOrUndefined(fieldBegin.fieldSeparator)) {
            fieldSeparator = fieldBegin.fieldSeparator;
            // tslint:disable-next-line:max-line-length
            let fieldObj = selection.getHyperlinkDisplayText(fieldBegin.fieldSeparator.line.paragraph, fieldBegin.fieldSeparator, fieldBegin.fieldEnd, isNestedField, format);
            fieldResult = fieldObj.displayText;
            isNestedField = fieldObj.isNestedField;
            format = fieldObj.format;
        }
        let offset = fieldBegin.line.getOffset(fieldBegin, 0);
        selection.start.setPositionParagraph(fieldBegin.line, offset);
        offset = fieldBegin.fieldEnd.line.getOffset(fieldBegin.fieldEnd, 1);
        selection.end.setPositionParagraph(fieldBegin.fieldEnd.line, offset);
        this.deleteSelectedContents(selection, false);
        if (!isNestedField && fieldResult !== displayText || isNullOrUndefined(fieldSeparator)) {
            this.insertHyperlinkByFormat(selection, url, displayText, format, isBookmark);
        }
        else {
            //Modify the new hyperlink url. Inserts field begin, url and field separator.
            this.updateInsertPosition();
            let newFieldBegin = new FieldElementBox(0);
            newFieldBegin.characterFormat.copyFormat(fieldBegin.characterFormat);
            newFieldBegin.line = selection.start.currentWidget;
            this.insertInlineInternal(newFieldBegin);
            let span = new TextElementBox();
            span.characterFormat.copyFormat(fieldBegin.characterFormat);
            if (isBookmark) {
                span.text = ' HYPERLINK \\l \"' + url + '\" ';
            }
            else {
                span.text = ' HYPERLINK \"' + url + '\" ';
            }
            span.line = selection.start.currentWidget;
            this.insertInlineInternal(span);
            let nodes = this.editorHistory && this.editorHistory.currentBaseHistoryInfo ?
                this.editorHistory.currentBaseHistoryInfo.removedNodes : this.nodes;
            this.insertClonedFieldResult(selection, nodes, fieldSeparator);
            let fieldEnd = selection.end.currentWidget.getInline(selection.end.offset, 0).element;
            fieldEnd.linkFieldCharacter(this.viewer);
            let paragraph = newFieldBegin.line.paragraph;
            let lineIndex = newFieldBegin.line.paragraph.childWidgets.indexOf(newFieldBegin.line);
            let elementIndex = newFieldBegin.line.children.indexOf(newFieldBegin);
            this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, elementIndex);
            selection.selects(newFieldBegin.fieldEnd.line, offset, true);
            this.updateEndPosition();
            this.reLayout(selection, true);
        }
        this.editHyperlinkInternal = false;
        this.nodes = [];
        return true;
    }
    /* tslint:disable:no-any */
    insertClonedFieldResult(selection, nodes, fieldSeparator) {
        let isStarted = false;
        for (let i = nodes.length - 1; i > -1; i--) {
            let node = nodes[i];
            /* tslint:enable:no-any */
            if (!isStarted) {
                if (fieldSeparator === node) {
                    isStarted = true;
                }
                else {
                    if (node instanceof ParagraphWidget && node === fieldSeparator.line.paragraph) {
                        isStarted = true;
                        let paragraph = undefined;
                        if (i === nodes.length - 1) {
                            paragraph = selection.start.paragraph;
                            let fieldParagraph = fieldSeparator.line.paragraph;
                            this.getClonedFieldResultWithSel(fieldParagraph, selection, fieldSeparator);
                        }
                        else {
                            paragraph = this.getClonedFieldResult(fieldSeparator.line.paragraph, fieldSeparator);
                            this.insertParagraph(paragraph, true);
                        }
                        selection.selectParagraph(selection.getNextParagraphBlock(paragraph), true);
                    }
                    continue;
                }
            }
            if (node instanceof ElementBox) {
                this.insertInlineInternal(node.clone());
            }
            else if (node instanceof BlockWidget) {
                this.insertBlock(node.clone());
            }
            // else if (node instanceof WSection)
            //     editor.insertSection((node as WSection)._Clone());
        }
    }
    getClonedFieldResultWithSel(paragraph, selection, fieldSeparator) {
        let lineIndex = paragraph.childWidgets.indexOf(fieldSeparator.line);
        let elementIndex = paragraph.childWidgets[lineIndex].children.indexOf(fieldSeparator);
        for (let j = lineIndex; j < paragraph.childWidgets.length; j++) {
            let lineWidget = paragraph.childWidgets[j];
            if (j !== lineIndex) {
                elementIndex = 0;
            }
            for (let i = elementIndex; i < lineWidget.children.length; i++) {
                this.insertInlineInternal(lineWidget.children[i].clone());
            }
        }
    }
    getClonedFieldResult(curParagraph, fieldSeparator) {
        let paragraph = new ParagraphWidget();
        paragraph.characterFormat.copyFormat(curParagraph.characterFormat);
        paragraph.paragraphFormat.copyFormat(curParagraph.paragraphFormat);
        let lineIndex = curParagraph.childWidgets.indexOf(fieldSeparator.line);
        let elementIndex = curParagraph.childWidgets[lineIndex].children.indexOf(fieldSeparator);
        for (let j = lineIndex; j < curParagraph.childWidgets.length; j++) {
            let lineWidget = curParagraph.childWidgets[j];
            if (j !== lineIndex) {
                elementIndex = 0;
            }
            for (let i = elementIndex; i < lineWidget.children.length; i++) {
                paragraph.childWidgets[0].children.push(lineWidget.children[i]);
            }
        }
        return paragraph;
    }
    /**
     * Removes the hyperlink if selection is within hyperlink.
     */
    removeHyperlink() {
        if (this.owner.isReadOnlyMode) {
            return;
        }
        let selection = this.selection;
        let fieldBegin = selection.getHyperlinkField();
        if (isNullOrUndefined(fieldBegin)) {
            return;
        }
        let fieldEnd = fieldBegin.fieldEnd;
        let fieldSeparator = fieldBegin.fieldSeparator;
        let fieldStartPosition = new TextPosition(selection.owner);
        // tslint:disable-next-line:max-line-length
        fieldStartPosition.setPositionParagraph(fieldBegin.line, (fieldBegin.line).getOffset(fieldBegin, 0));
        let fieldSeparatorPosition = new TextPosition(selection.owner);
        // tslint:disable-next-line:max-line-length
        fieldSeparatorPosition.setPositionParagraph(fieldSeparator.line, (fieldSeparator.line).getOffset(fieldSeparator, fieldSeparator.length));
        this.initComplexHistory('RemoveHyperlink');
        selection.start.setPositionParagraph(fieldEnd.line, (fieldEnd.line).getOffset(fieldEnd, 0));
        selection.end.setPositionInternal(selection.start);
        this.onDelete();
        selection.start.setPositionInternal(fieldSeparatorPosition);
        this.initHistory('Underline');
        this.updateCharacterFormatWithUpdate(selection, 'underline', 'None', false);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        // Applies font color for field result.
        this.initHistory('FontColor');
        this.updateCharacterFormatWithUpdate(selection, 'fontColor', undefined, false);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.reLayout(selection, false);
        selection.end.setPositionInternal(selection.start);
        selection.start.setPositionInternal(fieldStartPosition);
        this.initHistory('Delete');
        this.deleteSelectedContents(selection, false);
        this.reLayout(selection, true);
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentHistoryInfo)) {
            this.editorHistory.updateComplexHistory();
        }
    }
    //Paste Implementation starts
    /**
     * Paste copied clipboard content on Paste event
     * @param  {ClipboardEvent} event
     * @param  {any} pasteWindow?
     * @private
     */
    /* tslint:disable:no-any */
    pasteInternal(event, pasteWindow) {
        if (this.viewer.owner.enableLocalPaste) {
            this.pasteLocal();
        }
        else {
            if (isNullOrUndefined(pasteWindow)) {
                pasteWindow = window;
            }
            /* tslint:enable:no-any */
            let textContent = '';
            let clipbordData = pasteWindow.clipboardData ? pasteWindow.clipboardData : event.clipboardData;
            textContent = clipbordData.getData('Text');
            if (textContent !== '') {
                this.pasteContents(textContent);
                this.viewer.editableDiv.innerHTML = '';
            }
        }
        this.viewer.updateFocus();
    }
    /**
     * Pastes the data present in local clipboard if any.
     */
    pasteLocal() {
        /* tslint:disable:no-any */
        if (this.copiedData && this.owner.enableLocalPaste) {
            let document = JSON.parse(this.copiedData);
            this.pasteContents(document);
        }
    }
    getBlocks(pasteContent) {
        let widgets = [];
        if (typeof (pasteContent) === 'string') {
            let startParagraph = this.selection.start.paragraph;
            if (!this.selection.isForward) {
                startParagraph = this.selection.end.paragraph;
            }
            let arr = [];
            let txt = pasteContent;
            txt = txt.replace(/\r\n/g, '\r');
            arr = txt.split('\r');
            for (let i = 0; i < arr.length; i++) {
                let insertFormat = this.copyInsertFormat(startParagraph.characterFormat, false);
                let insertParaFormat = this.viewer.selection.copySelectionParagraphFormat();
                let paragraph = new ParagraphWidget();
                paragraph.paragraphFormat.copyFormat(insertParaFormat);
                let line = new LineWidget(paragraph);
                if (arr[i].length > 0) {
                    let textElement = new TextElementBox();
                    textElement.characterFormat.copyFormat(insertFormat);
                    textElement.text = arr[i];
                    line.children.push(textElement);
                    textElement.line = line;
                }
                paragraph.childWidgets.push(line);
                widgets.push(paragraph);
            }
        }
        else {
            for (let i = 0; i < pasteContent.sections.length; i++) {
                this.viewer.owner.parser.parseBody(pasteContent.sections[i].blocks, widgets);
            }
        }
        return widgets;
    }
    pasteContents(content) {
        this.pasteContentsInternal(this.getBlocks(content));
    }
    pasteContentsInternal(widgets) {
        /* tslint:enable:no-any */
        let selection = this.viewer.selection;
        let isRemoved = true;
        this.initComplexHistory('Paste');
        if (this.viewer.isListTextSelected) {
            let paragraph = selection.start.paragraph;
            if (paragraph.paragraphFormat.listFormat && paragraph.paragraphFormat.listFormat.listId !== -1) {
                this.onApplyList(undefined);
            }
        }
        this.initHistory('Paste');
        if (!selection.isEmpty || this.viewer.isListTextSelected) {
            isRemoved = this.removeSelectedContentInternal(selection, selection.start, selection.end);
        }
        if (isRemoved) {
            this.pasteContent(widgets);
        }
        else if (this.editorHistory) {
            this.editorHistory.currentBaseHistoryInfo = undefined;
        }
        if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
            this.editorHistory.updateHistory();
            this.editorHistory.updateComplexHistory();
        }
        else {
            this.reLayout(selection, selection.isEmpty);
        }
    }
    /* tslint:disable:no-any */
    pasteContent(widgets) {
        /* tslint:enable:no-any */
        this.viewer.owner.isShiftingEnabled = true;
        this.updateInsertPosition();
        this.viewer.owner.isLayoutEnabled = true;
        this.viewer.owner.isPastingContent = true;
        this.pasteCopiedData(widgets);
        this.updateEndPosition();
        this.viewer.owner.isPastingContent = false;
        this.viewer.selection.fireSelectionChanged(true);
    }
    pasteCopiedData(widgets) {
        for (let j = 0; j < widgets.length; j++) {
            let widget = widgets[j];
            if (widget instanceof ParagraphWidget && widget.childWidgets.length === 0) {
                widget.childWidgets[0] = new LineWidget(widget);
            }
            if (j === widgets.length - 1 && widget instanceof ParagraphWidget) {
                let newParagraph = widget;
                if (newParagraph.childWidgets.length > 0
                    && newParagraph.childWidgets[0].children.length > 0) {
                    this.insertElement(newParagraph.childWidgets[0].children);
                }
            }
            else if (widget instanceof BlockWidget) {
                let startParagraph = this.selection.start.paragraph;
                if (widget instanceof TableWidget && startParagraph.isInsideTable) {
                    let table = widget;
                    //Handled to resize table based on parent cell width.
                    let clientWidth = startParagraph.getContainerWidth();
                    table.fitCellsToClientArea(clientWidth);
                }
                if (widget instanceof TableWidget && startParagraph.isEmpty()
                    && startParagraph.previousWidget instanceof TableWidget) {
                    this.insertTableRows(widget, startParagraph.previousWidget);
                }
                else {
                    this.insertBlockInternal(widget);
                }
            }
        }
    }
    /**
     * Insert Table on undo
     * @param  {WTable} table
     * @param  {WTable} newTable
     * @param  {boolean} moveRows
     * @private
     */
    insertTableInternal(table, newTable, moveRows) {
        //Gets the index of current table.
        let insertIndex = table.getIndex();
        if (moveRows) {
            //Moves the rows to table.
            for (let i = 0, index = 0; i < table.childWidgets.length; i++, index++) {
                let row = table.childWidgets[i];
                newTable.childWidgets.splice(index, 0, row);
                row.containerWidget = newTable;
                table.childWidgets.splice(i, 1);
                i--;
            }
        }
        let owner = table.containerWidget;
        this.removeBlock(table);
        //Inserts table in the current table position.        
        let blockAdvCollection = owner.childWidgets;
        blockAdvCollection.splice(insertIndex, 0, newTable);
        newTable.index = table.index;
        table.containerWidget = undefined;
        newTable.containerWidget = owner;
        newTable.isGridUpdated = false;
        newTable.buildTableColumns();
        newTable.isGridUpdated = true;
        this.viewer.layout.clearTableWidget(newTable, true, true);
        this.updateNextBlocksIndex(newTable, true);
        this.viewer.layout.linkFieldInTable(newTable);
        this.viewer.layout.layoutBodyWidgetCollection(newTable.index, owner, newTable, false);
    }
    /**
     * Insert Table on undo
     * @param  {Selection} selection
     * @param  {WBlock} block
     * @param  {WTable} table
     * @private
     */
    insertBlockTable(selection, block, table) {
        let offset = selection.start.offset;
        let lineIndex = selection.start.paragraph.childWidgets.indexOf(selection.start.currentWidget);
        if (block instanceof ParagraphWidget && offset > 0) {
            //Moves the inline items before selection start to the inserted paragraph.
            // tslint:disable-next-line:max-line-length
            this.moveInlines(selection.start.paragraph, block, 0, 0, selection.start.paragraph.firstChild, offset, selection.start.currentWidget);
            selection.selectParagraph(selection.start.paragraph, true);
            if (this.checkInsertPosition(selection)) {
                this.updateHistoryPosition(this.getHierarchicalIndex(block, offset.toString()), true);
            }
        }
        if (offset > 0 && this.checkInsertPosition(selection)) {
            this.updateHistoryPosition(selection.start, true);
        }
        let index = table.indexInOwner;
        table.containerWidget.childWidgets.splice(index, 0, block);
        block.containerWidget = table.containerWidget;
        block.index = table.index;
        this.updateNextBlocksIndex(block, true);
        this.viewer.layout.layoutBodyWidgetCollection(block.index, block.containerWidget, block, false);
        if (this.checkInsertPosition(selection)) {
            let paragraph = undefined;
            if (block instanceof ParagraphWidget) {
                paragraph = block;
            }
            if (block instanceof TableWidget) {
                paragraph = selection.getFirstParagraphInFirstCell(block);
            }
            this.updateHistoryPosition(this.getHierarchicalIndex(paragraph, '0'), true);
        }
    }
    /**
     * On cut handle selected content remove and relayout
     * @param  {Selection} selection
     * @param  {TextPosition} startPosition
     * @param  {TextPosition} endPosition
     * @private
     */
    handleCut(selection) {
        let startPosition = selection.start;
        let endPosition = selection.end;
        if (!selection.isForward) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        // this.owner.isShiftingEnabled = true;
        let blockInfo = this.getParagraphInfo(startPosition);
        selection.editPosition = this.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        if (startPosition.paragraph === endPosition.paragraph && startPosition.offset + 1 === endPosition.offset) {
            //Gets selected image and copy image to clipboard.
            let index = 0;
            let currentInline = startPosition.paragraph.getInline(endPosition.offset, index);
            let inline = currentInline.element;
            
        }
        this.initHistory('Cut');
        selection.owner.isShiftingEnabled = true;
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            if (this.checkInsertPosition(selection)) {
                this.updateHistoryPosition(selection.editPosition, true);
            }
        }
        this.deleteSelectedContent(endPosition.paragraph, selection, startPosition, endPosition, 3);
        let textPosition = new TextPosition(selection.owner);
        this.setPositionForCurrentIndex(textPosition, selection.editPosition);
        selection.selectContent(textPosition, true);
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            if (this.checkEndPosition(selection)) {
                this.updateHistoryPosition(selection.end, false);
            }
        }
        this.reLayout(selection);
    }
    insertInlineInternal(element) {
        let selection = this.selection;
        let length = element.length;
        let paragraphInfo = this.getParagraphInfo(selection.start);
        if (selection.start.paragraph.isEmpty()) {
            let paragraph = selection.start.paragraph;
            if ((paragraph.paragraphFormat.textAlignment === 'Center' || paragraph.paragraphFormat.textAlignment === 'Right')
                && paragraph.paragraphFormat.listFormat.listId === -1) {
                paragraph.x = this.viewer.clientActiveArea.x;
            }
            paragraph.childWidgets[0].children.push(element);
            element.line = paragraph.childWidgets[0];
            element.linkFieldCharacter(this.viewer);
            this.viewer.layout.reLayoutParagraph(paragraph, 0, 0);
        }
        else {
            let indexInInline = 0;
            let inlineObj = selection.start.currentWidget.getInline(selection.start.offset, indexInInline);
            let curInline = inlineObj.element;
            indexInInline = inlineObj.index;
            this.insertElementInternal(curInline, element, indexInInline, true);
        }
        this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset + length, true);
    }
    insertElement(element) {
        let selection = this.selection;
        let length = 0;
        let paragraph = undefined;
        let lineIndex = -1;
        let lineWidget = undefined;
        let insertIndex = 0;
        let paragraphInfo = this.getParagraphInfo(selection.start);
        if (selection.start.paragraph.isEmpty()) {
            paragraph = selection.start.paragraph;
            lineWidget = paragraph.childWidgets[0];
            lineIndex = 0;
        }
        else {
            let indexInInline = 0;
            let inlineObj = selection.start.currentWidget.getInline(selection.start.offset, indexInInline);
            let curInline = inlineObj.element;
            indexInInline = inlineObj.index;
            paragraph = curInline.line.paragraph;
            lineIndex = paragraph.childWidgets.indexOf(curInline.line);
            insertIndex = curInline.indexInOwner;
            lineWidget = curInline.line;
            if (indexInInline === curInline.length) {
                insertIndex++;
            }
            else if (indexInInline === 0) {
                if (isNullOrUndefined(curInline.previousNode)) {
                    insertIndex = 0;
                }
            }
            else {
                insertIndex++;
                let prevElement = new TextElementBox();
                prevElement.characterFormat.copyFormat(curInline.characterFormat);
                prevElement.text = curInline.text.substring(indexInInline);
                curInline.text = curInline.text.substr(0, indexInInline);
                lineWidget.children.splice(insertIndex, 0, prevElement);
                prevElement.line = curInline.line;
            }
        }
        for (let i = 0; i < element.length; i++) {
            length += element[i].length;
            lineWidget.children.splice(insertIndex, 0, element[i]);
            element[i].line = lineWidget;
            element[i].linkFieldCharacter(this.viewer);
            insertIndex++;
        }
        this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, 0);
        this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset + length, true);
    }
    insertElementInternal(element, newElement, index, relayout) {
        let line = element.line;
        let paragraph = line.paragraph;
        let lineIndex = line.indexInOwner;
        let insertIndex = element.indexInOwner;
        if (index === element.length) {
            insertIndex++;
            line.children.splice(insertIndex, 0, newElement);
        }
        else if (index === 0) {
            if (isNullOrUndefined(element.previousNode)) {
                element.line.children.splice(0, 0, newElement);
                insertIndex = 0;
            }
            else {
                element.line.children.splice(insertIndex, 0, newElement);
            }
        }
        else {
            insertIndex++;
            let textElement = new TextElementBox();
            textElement.characterFormat.copyFormat(element.characterFormat);
            textElement.text = element.text.substring(index);
            element.text = element.text.substr(0, index);
            line.children.splice(insertIndex, 0, textElement);
            textElement.line = element.line;
            //Inserts the new inline.
            line.children.splice(insertIndex, 0, newElement);
            insertIndex -= 1;
        }
        newElement.line = element.line;
        newElement.linkFieldCharacter(this.viewer);
        if (relayout) {
            this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, insertIndex);
        }
    }
    /**
     * Insert Block on undo
     * @param  {Selection} selection
     * @param  {WBlock} block
     * @private
     */
    insertBlock(block) {
        let isRemoved = true;
        let selection = this.selection;
        if (!selection.isEmpty) {
            isRemoved = this.removeSelectedContents(selection);
        }
        if (!isRemoved) {
            selection.selectContent(selection.start, false);
        }
        this.insertBlockInternal(block);
        if (this.checkInsertPosition(selection)) {
            let paragraph = undefined;
            if (block instanceof ParagraphWidget) {
                paragraph = block;
            }
            else {
                paragraph = this.selection.getFirstParagraphInFirstCell(block);
            }
            // tslint:disable-next-line:max-line-length
            this.updateHistoryPosition(this.getHierarchicalIndex(paragraph, '0'), true);
        }
        this.fireContentChange();
    }
    /**
     * Insert new Block on specific index
     * @param  {Selection} selection
     * @param  {BlockWidget} block
     * @private
     */
    insertBlockInternal(block) {
        let selection = this.selection;
        let startPara = this.selection.start.paragraph;
        if (!selection.start.isAtParagraphStart) {
            if (block instanceof ParagraphWidget) {
                this.insertNewParagraphWidget(block, false);
                return;
            }
            this.updateInsertPosition();
            startPara = startPara.combineWidget(this.viewer);
            // tslint:disable-next-line:max-line-length
            this.splitParagraph(startPara, startPara.firstChild, 0, selection.start.currentWidget, selection.start.offset, false);
            selection.selectParagraph(this.selection.start.paragraph, true);
        }
        let bodyWidget = selection.start.paragraph.containerWidget;
        let blockIndex = selection.start.paragraph.index;
        let insertIndex = bodyWidget.childWidgets.indexOf(selection.start.paragraph);
        if (!isNullOrUndefined(bodyWidget)) {
            bodyWidget.childWidgets.splice(insertIndex, 0, block);
            block.containerWidget = bodyWidget;
            block.index = blockIndex;
            block.height = 0;
            if (block instanceof TableWidget) {
                block.isGridUpdated = false;
                block.buildTableColumns();
                block.isGridUpdated = true;
            }
            this.updateNextBlocksIndex(block, true);
            this.viewer.layout.layoutBodyWidgetCollection(blockIndex, bodyWidget, block, false);
        }
    }
    /**
     * Inserts the image with specified size at cursor position in the document editor.
     * @param {string} imageString  Base64 string, web URL or file URL.
     * @param {number} width? Image width
     * @param {number} height? Image height
     */
    insertImage(imageString, width, height) {
        if (this.owner.isReadOnlyMode) {
            return;
        }
        if (isNullOrUndefined(width)) {
            width = 100;
        }
        if (isNullOrUndefined(height)) {
            height = 100;
        }
        this.insertPicture(imageString, width, height);
    }
    /**
     * Inserts a table of specified size at cursor position
     *  in the document editor.
     * @param {number} rows Default value of ‘rows’ parameter is 1.
     * @param {number} columns Default value of ‘columns’ parameter is 1.
     */
    insertTable(rows, columns) {
        let startPos = this.selection.start;
        if (this.owner.isReadOnlyMode) {
            return;
        }
        rows = rows || 1;
        columns = columns || 1;
        let table = this.createTable(rows, columns);
        let clientWidth = startPos.paragraph.getContainerWidth();
        table.splitWidthToTableCells(clientWidth);
        let prevBlock = startPos.paragraph.previousWidget;
        if (startPos.currentWidget.isFirstLine() && startPos.offset === 0 && prevBlock instanceof TableWidget) {
            this.insertTableRows(table, prevBlock);
            table.destroy();
            return;
        }
        else {
            this.initHistory('InsertTable');
            this.viewer.owner.isShiftingEnabled = true;
            this.insertBlock(table);
        }
        let startLine = this.selection.getFirstParagraphInFirstCell(table).childWidgets[0];
        startPos.setPosition(startLine, true);
        this.selection.end.setPositionInternal(startPos);
        let lastParagraph = this.selection.getLastParagraphInLastCell(table);
        let endOffset = lastParagraph.getLength() + 1;
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            // tslint:disable-next-line:max-line-length
            this.editorHistory.currentBaseHistoryInfo.endPosition = this.getHierarchicalIndex(lastParagraph, endOffset.toString());
        }
        this.reLayout(this.selection);
    }
    /**
     * Inserts the specified number of rows to the table above or below to the row at cursor position.
     * @param {boolean} above The above parameter is optional and if omitted,
     * it takes the value as false and inserts below the row at cursor position.
     * @param {number} count The count parameter is optional and if omitted, it takes the value as 1.
     */
    insertRow(above, count) {
        let rowPlacement = above ? 'Above' : 'Below';
        if (this.owner.isReadOnlyMode) {
            return;
        }
        let startPos = this.selection.isForward ? this.selection.start : this.selection.end;
        let endPos = this.selection.isForward ? this.selection.end : this.selection.start;
        if (startPos.paragraph.isInsideTable) {
            if (this.checkIsNotRedoing()) {
                this.initHistory(rowPlacement === 'Above' ? 'InsertRowAbove' : 'InsertRowBelow');
            }
            this.viewer.owner.isShiftingEnabled = true;
            let startCell = this.getOwnerCell(this.selection.isForward).getSplitWidgets()[0];
            let endCell = this.getOwnerCell(!this.selection.isForward).getSplitWidgets()[0];
            let table = startCell.ownerTable.combineWidget(this.viewer);
            let row = rowPlacement === 'Below' ? endCell.ownerRow : startCell.ownerRow;
            if (this.editorHistory) {
                let clonedTable = this.cloneTableToHistoryInfo(table);
            }
            let rowCount = count ? count : this.getRowCountToInsert();
            let rows = [];
            let index = row.rowIndex;
            if (rowPlacement === 'Below') {
                index++;
                let isAffectedByRowSpannedCell = isNullOrUndefined(endCell.previousWidget)
                    || endCell.columnIndex === endCell.previousWidget.columnIndex + 1;
                let isRowSpanEnd = endCell.cellIndex !== endCell.columnIndex && isAffectedByRowSpannedCell
                    && row.rowIndex + startCell.cellFormat.rowSpan - 1 === endCell.ownerRow.rowIndex;
                if (!isRowSpanEnd) {
                    if (endCell.cellFormat.rowSpan > 1) {
                        if (!isNullOrUndefined(row.nextWidget) && row.nextWidget instanceof TableRowWidget) {
                            endCell.cellFormat.rowSpan += rowCount;
                            row = row.nextWidget;
                        }
                    }
                }
            }
            for (let i = 0; i < rowCount; i++) {
                let cellCountInfo = this.updateRowspan(row, rowPlacement === 'Below' ? endCell : startCell, rowPlacement);
                let newRow = this.createRowAndColumn(cellCountInfo.count, i);
                newRow.rowFormat.copyFormat(row.rowFormat);
                this.updateCellFormatForInsertedRow(newRow, cellCountInfo.cellFormats);
                rows.push(newRow);
            }
            table.insertTableRowsInternal(rows, index);
            let cell = undefined;
            let paragraph = undefined;
            if ((table.childWidgets[index] instanceof TableRowWidget)) {
                cell = table.childWidgets[index].firstChild;
                paragraph = this.selection.getFirstParagraph(cell);
            }
            else {
                let widget = undefined;
                while (!(widget instanceof TableWidget)) {
                    widget = table.nextRenderedWidget;
                }
                paragraph = this.selection.getFirstParagraphInFirstCell(widget);
            }
            this.viewer.layout.reLayoutTable(table);
            this.selection.selectParagraph(paragraph, true);
        }
        this.reLayout(this.selection, true);
    }
    updateCellFormatForInsertedRow(newRow, cellFormats) {
        for (let i = 0; i < newRow.childWidgets.length; i++) {
            newRow.childWidgets[i].cellFormat.copyFormat(cellFormats[i]);
            newRow.childWidgets[i].cellFormat.rowSpan = 1;
        }
    }
    updateRowspan(row, startCell, rowPlacement) {
        let spannedCells = row.getPreviousRowSpannedCells(true);
        let count = 0;
        let cellFormats = [];
        for (let i = 0; i < row.childWidgets.length; i++) {
            let cell = row.childWidgets[i];
            let isCellIncluded = false;
            // Need to check with all the row spanned cells. if the start cell contains rowspan greater than 1, 
            // and when inserting below, need to increment rowspan for all row spanned cells by 1 except
            // if the spanned cells is placed in the same column or cell to be cloned has the same row index of cloned cell row index.
            // and when inserting above, if cloned cell placed in the same row of start cell or
            // if the cloned cell has equal column index, need to skip updating rowspan value of cloned cell.
            // else update row span value for spanned cell except 
            // if the spanned cells is placed in the same column or cell to be cloned has the same row index of cloned cell row index.
            let isRowSpanned = (isNullOrUndefined(cell.previousWidget)
                || cell.columnIndex !== cell.previousWidget.columnIndex + 1);
            for (let j = 0; j < spannedCells.length; j++) {
                if (isRowSpanned) {
                    let spannedCell = spannedCells[j];
                    let clonedRowIndex = spannedCell.ownerRow.rowIndex + spannedCell.cellFormat.rowSpan - 1;
                    if (cell.columnIndex < spannedCell.columnIndex && cell.cellIndex !== cell.columnIndex) {
                        isCellIncluded = true;
                        count++;
                        cellFormats.push(cell.cellFormat);
                    }
                    if (startCell.cellFormat.rowSpan === 1) {
                        // Need to check whether cell is affected by a row spanned cell. if cell is placed on the row where it is affected 
                        // by row spanned cell, then if we are inserting row below, need to add new cell with spanned cell width
                        // or if we are inserting above, need to update row span value of the spanned cell.
                        // if cell is placed inbetween the spanned cell , 
                        // then if we are inserting below, need to update row span value of spanned cell or
                        // if we are inserting above, need to skip updating row span value except
                        // if start cell is placed on the same row of spanned cell or if start cell placed in the same column.
                        if (clonedRowIndex > cell.ownerRow.rowIndex) {
                            if (rowPlacement === 'Above'
                                && spannedCell.ownerRow === startCell.ownerRow) {
                                continue;
                            }
                            else {
                                spannedCell.cellFormat.rowSpan += 1;
                                spannedCells.splice(j, 1);
                                j--;
                            }
                        }
                        else if (cell.cellIndex !== cell.columnIndex && isRowSpanned && clonedRowIndex === cell.ownerRow.rowIndex) {
                            if (rowPlacement === 'Above') {
                                spannedCell.cellFormat.rowSpan += 1;
                                spannedCells.splice(j, 1);
                                j--;
                            }
                            else {
                                count++;
                                cellFormats.push(spannedCell.cellFormat);
                                spannedCells.splice(j, 1);
                                j--;
                            }
                        }
                    }
                    else {
                        if (spannedCell !== startCell) {
                            if (rowPlacement === 'Above'
                                && (spannedCell.ownerRow === startCell.ownerRow || spannedCell.columnIndex === startCell.columnIndex)) {
                                continue;
                            }
                            else {
                                if (spannedCell.columnIndex !== startCell.columnIndex
                                    && spannedCell.ownerRow.rowIndex !== cell.ownerRow.rowIndex
                                    && (clonedRowIndex > startCell.ownerRow.rowIndex
                                        || (rowPlacement === 'Above' && clonedRowIndex === startCell.ownerRow.rowIndex))) {
                                    spannedCell.cellFormat.rowSpan += 1;
                                    spannedCells.splice(j, 1);
                                    j--;
                                }
                            }
                        }
                    }
                }
            }
            if (spannedCells.indexOf(cell) === -1 && cell.cellFormat.rowSpan > 1) {
                isCellIncluded = true;
            }
            if (!isCellIncluded) {
                count++;
                cellFormats.push(cell.cellFormat);
            }
        }
        return { count, cellFormats };
    }
    insertTableRows(table, prevBlock) {
        this.initHistory('InsertRowBelow');
        table.containerWidget = prevBlock.containerWidget;
        prevBlock = prevBlock.combineWidget(this.viewer);
        if (this.editorHistory) {
            let clonedTable = this.cloneTableToHistoryInfo(prevBlock);
        }
        let row = prevBlock.childWidgets[prevBlock.childWidgets.length - 1];
        prevBlock.insertTableRowsInternal(table.childWidgets, prevBlock.childWidgets.length);
        let paragraph = this.selection.getFirstParagraph(row.nextWidget.childWidgets[0]);
        this.viewer.layout.reLayoutTable(prevBlock);
        this.selection.selectParagraph(paragraph, true);
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            this.updateHistoryPosition(this.selection.start, true);
            this.updateHistoryPosition(this.selection.end, false);
        }
        this.reLayout(this.selection);
    }
    /**
     * Inserts the specified number of columns to the table left or right to the column at cursor position.
     * @param {number} left The left parameter is optional and if omitted, it takes the value as false and
     * inserts to the right of column at cursor position.
     * @param {number} count The count parameter is optional and if omitted, it takes the value as 1.
     */
    insertColumn(left, count) {
        if (this.owner.isReadOnlyMode) {
            return;
        }
        let columnPlacement = left ? 'Left' : 'Right';
        if (this.selection.start.paragraph.isInsideTable) {
            if (this.checkIsNotRedoing()) {
                this.initHistory(columnPlacement === 'Left' ? 'InsertColumnLeft' : 'InsertColumnRight');
            }
            this.selection.owner.isShiftingEnabled = true;
            let startCell = this.getOwnerCell(this.selection.isForward);
            let endCell = this.getOwnerCell(!this.selection.isForward);
            let table = startCell.ownerRow.ownerTable.combineWidget(this.viewer);
            if (this.editorHistory) {
                //Clones the entire table to preserve in history.
                let clonedTable = this.cloneTableToHistoryInfo(table);
            }
            this.selection.owner.isLayoutEnabled = false;
            let cellIndex = startCell.columnIndex;
            if (columnPlacement === 'Right') {
                cellIndex = endCell.columnIndex + endCell.cellFormat.columnSpan;
            }
            let startParagraph = undefined;
            let newCell = undefined;
            let columnCount = count ? count : this.getColumnCountToInsert();
            let rowSpannedCells = [];
            for (let i = 0; i < columnCount; i++) {
                for (let j = 0; j < table.childWidgets.length; j++) {
                    let row = table.childWidgets[j];
                    newCell = this.createColumn(this.selection.getLastParagraph(startCell));
                    newCell.index = j;
                    newCell.rowIndex = row.rowIndex;
                    newCell.containerWidget = row;
                    newCell.cellFormat.copyFormat(startCell.cellFormat);
                    newCell.cellFormat.rowSpan = 1;
                    if (isNullOrUndefined(startParagraph)) {
                        startParagraph = this.selection.getFirstParagraph(newCell);
                    }
                    if (cellIndex === 0) {
                        row.childWidgets.splice(cellIndex, 0, newCell);
                    }
                    else {
                        let isCellInserted = false;
                        for (let j = 0; j < row.childWidgets.length; j++) {
                            let rowCell = row.childWidgets[j];
                            // Add the row spanned cells to colection for adding column before / after row spnned cells.
                            if (rowCell.cellFormat.rowSpan > 1) {
                                rowSpannedCells.push(rowCell);
                            }
                            if (rowCell.columnIndex + rowCell.cellFormat.columnSpan === cellIndex) {
                                row.childWidgets.splice(rowCell.cellIndex + 1, 0, newCell);
                                isCellInserted = true;
                            }
                            else if (cellIndex > rowCell.columnIndex && rowCell.columnIndex + rowCell.cellFormat.columnSpan > cellIndex
                                && cellIndex < rowCell.columnIndex + rowCell.cellFormat.columnSpan) {
                                row.childWidgets.splice(rowCell.cellIndex, 0, newCell);
                                isCellInserted = true;
                            }
                            if (isCellInserted) {
                                break;
                            }
                        }
                        // If the cell is not inserted for row, then check for row spanned cells.
                        if (!isCellInserted) {
                            if (rowSpannedCells.length > 0) {
                                for (let k = 0; k < rowSpannedCells.length; k++) {
                                    let rowSpannedCell = rowSpannedCells[k];
                                    if (rowSpannedCell.ownerRow !== row
                                        && row.rowIndex <= rowSpannedCell.ownerRow.rowIndex + rowSpannedCell.cellFormat.rowSpan - 1) {
                                        if (rowSpannedCell.columnIndex + rowSpannedCell.cellFormat.columnSpan === cellIndex) {
                                            if (rowSpannedCell.cellIndex > row.childWidgets.length) {
                                                row.childWidgets.push(newCell);
                                            }
                                            else {
                                                row.childWidgets.splice(rowSpannedCell.cellIndex, 0, newCell);
                                            }
                                            isCellInserted = true;
                                        }
                                        else if (cellIndex > rowSpannedCell.columnIndex &&
                                            rowSpannedCell.columnIndex + rowSpannedCell.cellFormat.columnSpan > cellIndex
                                            && cellIndex < rowSpannedCell.columnIndex + rowSpannedCell.cellFormat.columnSpan) {
                                            row.childWidgets.splice(rowSpannedCell.columnIndex, 0, newCell);
                                            isCellInserted = true;
                                        }
                                    }
                                    if (isCellInserted) {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            table.updateRowIndex(0);
            let parentTable = this.viewer.layout.getParentTable(table);
            if (parentTable) {
                parentTable.fitChildToClientArea();
            }
            else {
                table.fitChildToClientArea();
            }
            this.selection.owner.isLayoutEnabled = true;
            table.isGridUpdated = false;
            table.buildTableColumns();
            table.isGridUpdated = true;
            this.viewer.layout.reLayoutTable(table);
            this.selection.start.setPosition(startParagraph.firstChild, true);
            this.selection.end.setPosition(this.selection.getLastParagraph(newCell).firstChild, false);
            if (this.checkIsNotRedoing() || isNullOrUndefined(this.editorHistory)) {
                this.reLayout(this.selection);
            }
        }
    }
    /**
     * Creates table with specified rows and columns.
     * @private
     */
    createTable(rows, columns) {
        let startPara = this.selection.start.paragraph;
        let table = new TableWidget();
        table.tableFormat = new WTableFormat(table);
        table.tableFormat.preferredWidthType = 'Auto';
        table.tableFormat.initializeTableBorders();
        let index = 0;
        while (index < rows) {
            let tableRow = this.createRowAndColumn(columns, index);
            tableRow.rowFormat.heightType = 'Auto';
            tableRow.containerWidget = table;
            table.childWidgets.push(tableRow);
            index++;
        }
        return table;
    }
    createRowAndColumn(columns, rowIndex) {
        let startPara = this.selection.start.paragraph;
        let tableRow = new TableRowWidget();
        tableRow.rowFormat = new WRowFormat(tableRow);
        tableRow.index = rowIndex;
        for (let i = 0; i < columns; i++) {
            let tableCell = this.createColumn(startPara);
            tableCell.index = i;
            tableCell.rowIndex = rowIndex;
            tableCell.containerWidget = tableRow;
            tableRow.childWidgets.push(tableCell);
        }
        return tableRow;
    }
    createColumn(paragraph) {
        let tableCell = new TableCellWidget();
        let para = new ParagraphWidget();
        para.paragraphFormat.copyFormat(paragraph.paragraphFormat);
        para.characterFormat.copyFormat(paragraph.characterFormat);
        para.containerWidget = tableCell;
        tableCell.childWidgets.push(para);
        tableCell.cellFormat = new WCellFormat(tableCell);
        return tableCell;
    }
    getColumnCountToInsert() {
        let count = 1;
        let start = this.selection.start;
        let end = this.selection.end;
        if (!this.selection.isForward) {
            start = this.selection.end;
            end = this.selection.start;
        }
        if (start && end && this.selection.getTable(start, end)) {
            if (start.paragraph.associatedCell === end.paragraph.associatedCell) {
                return count = 1;
            }
            if (start.paragraph.associatedCell.ownerRow === end.paragraph.associatedCell.ownerRow) {
                return count = count + end.paragraph.associatedCell.cellIndex - start.paragraph.associatedCell.cellIndex;
            }
            else {
                count = 0;
                // tslint:disable-next-line:max-line-length
                let selectedCells = start.paragraph.associatedCell.ownerTable.getColumnCellsForSelection(start.paragraph.associatedCell, end.paragraph.associatedCell);
                for (let i = 0; i < selectedCells.length; i++) {
                    if (start.paragraph.associatedCell.ownerRow === selectedCells[i].ownerRow) {
                        count++;
                    }
                }
            }
        }
        return count === 0 ? 1 : count;
    }
    getRowCountToInsert() {
        let count = 1;
        let start = this.selection.start;
        let end = this.selection.end;
        if (!this.selection.isForward) {
            start = this.selection.end;
            end = this.selection.start;
        }
        if (!isNullOrUndefined(start) && !isNullOrUndefined(end) && !isNullOrUndefined(this.selection.getTable(start, end))) {
            if (start.paragraph.associatedCell === end.paragraph.associatedCell ||
                start.paragraph.associatedCell.ownerRow === end.paragraph.associatedCell.ownerRow) {
                return count = 1;
            }
            else {
                return count = count +
                    this.getOwnerRow(!this.selection.isForward).rowIndex - this.getOwnerRow(this.selection.isForward).rowIndex;
            }
        }
        return count === 0 ? 1 : count;
    }
    getOwnerCell(isStart) {
        let cell = undefined;
        let startCell = isStart ? this.selection.start.paragraph.associatedCell
            : this.selection.end.paragraph.associatedCell;
        let endCell = isStart ? this.selection.end.paragraph.associatedCell
            : this.selection.start.paragraph.associatedCell;
        cell = startCell;
        let owner = cell.ownerTable;
        while (!isNullOrUndefined(owner) && owner.containerWidget instanceof TableCellWidget && owner !== endCell.ownerTable) {
            cell = owner.containerWidget;
            owner = cell.ownerTable;
        }
        return cell;
    }
    getOwnerRow(isStart) {
        let row;
        let startRow = isStart ? this.selection.start.paragraph.associatedCell.ownerRow
            : this.selection.end.paragraph.associatedCell.ownerRow;
        let endRow = isStart ? this.selection.end.paragraph.associatedCell.ownerRow
            : this.selection.start.paragraph.associatedCell.ownerRow;
        row = startRow;
        let owner = row.ownerTable;
        while (!isNullOrUndefined(owner) && owner.containerWidget instanceof TableCellWidget && owner !== endRow.ownerTable) {
            row = owner.containerWidget.ownerRow;
            owner = row.ownerTable;
        }
        return row;
    }
    getOwnerTable(isStart) {
        let table = undefined;
        let startTable = this.selection.start.paragraph.associatedCell.ownerTable;
        let endTable = this.selection.end.paragraph.associatedCell.ownerTable;
        table = isStart ? startTable : endTable;
        while (table.containerWidget instanceof TableCellWidget && table !== (isStart ? endTable : startTable)) {
            table = table.containerWidget.ownerTable;
        }
        return table;
    }
    /**
     * Merge Selected cells
     * @private
     */
    mergeSelectedCellsInTable() {
        if (!this.canMergeCells()) {
            return;
        }
        if (this.checkIsNotRedoing()) {
            this.initHistory('MergeCells');
        }
        this.selection.owner.isShiftingEnabled = true;
        let startPosition = this.selection.start;
        let endPosition = this.selection.end;
        if (!this.selection.isForward) {
            startPosition = this.selection.end;
            endPosition = this.selection.start;
        }
        let startOwnerCell = this.getOwnerCell(this.selection.isForward);
        let endOwnerCell = this.getOwnerCell(!this.selection.isForward);
        let containerCell = this.selection.getContainerCellOf(startOwnerCell, endOwnerCell);
        if (containerCell.ownerTable.contains(endOwnerCell)) {
            if (!this.selection.containsCell(containerCell, endOwnerCell)) {
                //Start and End are in different cells.               
                let table = startOwnerCell.ownerTable.combineWidget(this.viewer);
                startOwnerCell = this.selection.getSelectedCell(startOwnerCell, containerCell);
                endOwnerCell = this.selection.getSelectedCell(endOwnerCell, containerCell);
                //Merges the selected cells.               
                let mergedCell = this.mergeSelectedCells(table, startOwnerCell, endOwnerCell);
                let lastParagraph = this.selection.getLastParagraph(mergedCell);
                endPosition.setPosition(lastParagraph.lastChild, false);
            }
        }
        if (this.checkIsNotRedoing() || isNullOrUndefined(this.editorHistory)) {
            this.reLayout(this.selection, false);
        }
    }
    mergeSelectedCells(table, startCell, endCell) {
        //Clones the entire table to preserve in history.
        let clonedTable = this.cloneTableToHistoryInfo(table);
        this.selection.owner.isLayoutEnabled = false;
        //Merges the selected cells.
        let start = this.selection.getCellLeft(startCell.ownerRow, startCell);
        let end = start + startCell.cellFormat.cellWidth;
        let endCellLeft = this.selection.getCellLeft(endCell.ownerRow, endCell);
        let endCellRight = endCellLeft + endCell.cellFormat.cellWidth;
        let cellInfo = this.updateSelectedCellsInTable(start, end, endCellLeft, endCellRight);
        start = cellInfo.start;
        end = cellInfo.end;
        let count = table.childWidgets.indexOf(endCell.ownerRow);
        let rowStartIndex = table.childWidgets.indexOf(startCell.ownerRow);
        let mergedCell = undefined;
        for (let i = rowStartIndex; i <= count; i++) {
            let row = table.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                let cellStart = this.selection.getCellLeft(row, cell);
                if (HelperMethods.round(start, 2) <= HelperMethods.round(cellStart, 2)
                    && HelperMethods.round(cellStart, 2) < HelperMethods.round(end, 2)) {
                    if (isNullOrUndefined(mergedCell)) {
                        mergedCell = cell;
                    }
                    else {
                        if (i === rowStartIndex) {
                            mergedCell.cellFormat.preferredWidth += cell.cellFormat.preferredWidth;
                            mergedCell.cellFormat.columnSpan += cell.cellFormat.columnSpan;
                            this.mergeBorders(mergedCell, cell);
                        }
                        for (let k = 0; k < cell.childWidgets.length; k++) {
                            let block = cell.childWidgets[k];
                            if (cell.childWidgets.length === 1 && block instanceof ParagraphWidget
                                && block.childWidgets.length === 0) {
                                break;
                            }
                            mergedCell.childWidgets.push(block.clone());
                        }
                        row.childWidgets.splice(j, 1);
                        cell.destroy();
                        j--;
                    }
                }
            }
            if (row.childWidgets.length === 0) {
                let rowIndex = table.childWidgets.indexOf(row);
                row.updateRowBySpannedCells();
                table.childWidgets.splice(rowIndex, 1);
                row.destroy();
                count--;
                i--;
            }
        }
        if (!isNullOrUndefined(mergedCell) && rowStartIndex < count) {
            mergedCell.cellFormat.rowSpan = count - rowStartIndex + 1;
        }
        this.updateBlockIndexAfterMerge(mergedCell);
        table.updateRowIndex(0);
        table.calculateGrid();
        table.isGridUpdated = false;
        table.buildTableColumns();
        table.isGridUpdated = true;
        this.viewer.layout.reLayoutTable(table);
        //Layouts the table after merging cells.
        this.selection.owner.isLayoutEnabled = true;
        return mergedCell;
    }
    mergeBorders(mergedCell, tableCell) {
        let mergedCellborders = undefined;
        let cellBorders = null;
        if (!isNullOrUndefined(mergedCell.cellFormat.borders)) {
            mergedCellborders = mergedCell.cellFormat.borders;
        }
        if (!isNullOrUndefined(tableCell.cellFormat.borders)) {
            cellBorders = tableCell.cellFormat.borders;
        }
        if (isNullOrUndefined(mergedCellborders) && isNullOrUndefined(cellBorders)) {
            return;
        }
        if (isNullOrUndefined(mergedCellborders)) {
            mergedCellborders = new WBorders(mergedCell.cellFormat);
            mergedCellborders.copyFormat(cellBorders);
        }
        else if (isNullOrUndefined(cellBorders)) {
            return;
        }
        else {
            if (mergedCell.ownerRow.rowIndex === tableCell.ownerRow.rowIndex) {
                mergedCellborders.top = mergedCell.getBorderBasedOnPriority(mergedCellborders.top, cellBorders.bottom);
                mergedCellborders.bottom = mergedCell.getBorderBasedOnPriority(mergedCellborders.bottom, cellBorders.bottom);
            }
        }
    }
    updateBlockIndexAfterMerge(cell) {
        for (let i = 0; i < cell.childWidgets.length; i++) {
            cell.childWidgets[i].index = i;
        }
    }
    /**
     * Determines whether merge cell operation can be done.
     */
    canMergeCells() {
        if (this.selection.isEmpty || !this.selection.start.paragraph.isInsideTable || !this.selection.end.paragraph.isInsideTable) {
            return false;
        }
        let startPos = this.selection.start;
        let endPos = this.selection.end;
        if (!this.selection.isForward) {
            startPos = this.selection.end;
            endPos = this.selection.start;
        }
        let startCell = this.getOwnerCell(this.selection.isForward);
        let endCell = this.getOwnerCell(!this.selection.isForward);
        let containerCell = this.selection.getContainerCellOf(startCell, endCell);
        if (containerCell.ownerTable.contains(endCell)) {
            if (!this.selection.containsCell(containerCell, endCell)) {
                startCell = this.selection.getSelectedCell(startCell, containerCell);
                endCell = this.selection.getSelectedCell(endCell, containerCell);
                let rowSpan = 1;
                if (startCell.ownerRow === endCell.ownerRow) {
                    let startCellIndex = startCell.ownerRow.childWidgets.indexOf(startCell);
                    for (let i = startCellIndex; i <= startCell.ownerRow.childWidgets.indexOf(endCell); i++) {
                        let cell = startCell.ownerRow.childWidgets[i];
                        let prevCell = cell.previousWidget;
                        if (i !== startCellIndex) {
                            if (cell.cellFormat.rowSpan !== rowSpan) {
                                return false;
                            }
                            if (!isNullOrUndefined(prevCell)
                                && cell.columnIndex !== (prevCell.cellFormat.columnSpan + prevCell.columnIndex)) {
                                return false;
                            }
                        }
                        rowSpan = cell.cellFormat.rowSpan;
                    }
                    return true;
                }
                return this.canMergeSelectedCellsInTable(startCell.ownerTable, startCell, endCell);
            }
        }
        return false;
    }
    canMergeSelectedCellsInTable(table, startCell, endCell) {
        let count = table.childWidgets.indexOf(endCell.ownerRow);
        let rowStartIndex = table.childWidgets.indexOf(startCell.ownerRow);
        let startLeft = this.selection.getCellLeft(startCell.ownerRow, startCell);
        let endLeft = startLeft + startCell.cellFormat.cellWidth;
        let endCellLeft = this.selection.getCellLeft(endCell.ownerRow, endCell);
        let endCellRight = endCellLeft + endCell.cellFormat.cellWidth;
        let cellInfo = this.updateSelectedCellsInTable(startLeft, endLeft, endCellLeft, endCellRight);
        startLeft = cellInfo.start;
        endLeft = cellInfo.end;
        let selectionLeft = 0;
        let selectionRight = 0;
        let isRowLeftWithinSel = false;
        let isRowRightWithinSel = false;
        let rowSpannedCells = [];
        for (let i = rowStartIndex; i <= count; i++) {
            let row = table.childWidgets[i];
            let rowLeft = 0;
            let rowRight = 0;
            let isStarted = false;
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                let cellStart = this.selection.getCellLeft(row, cell);
                if (this.checkCellWithInSelection(startLeft, endLeft, cellStart)) {
                    isRowLeftWithinSel = false;
                    isRowRightWithinSel = false;
                    if (cell.cellFormat.rowSpan > 1) {
                        rowSpannedCells.push(cell);
                    }
                    if (!isStarted) {
                        rowLeft = cellStart;
                        rowRight = cellStart;
                        isStarted = true;
                    }
                    let prevCell = cell.previousWidget;
                    if (rowRight !== 0 && HelperMethods.round(rowRight, 0) !== HelperMethods.round(cellStart, 0)) {
                        rowRight = cellStart;
                    }
                    rowRight += HelperMethods.convertPointToPixel(cell.cellFormat.cellWidth);
                    let isPrevCellWithinSel = this.checkPrevOrNextCellIsWithinSel(startLeft, endLeft, cell, true);
                    let isNextCellWithinSel = this.checkPrevOrNextCellIsWithinSel(startLeft, endLeft, cell, false);
                    // When selected cell not having row spanned cells and column index is not having immediate cell index value,
                    // then returned false.
                    let isNoRowSpan = rowSpannedCells.length === 0 || rowSpannedCells.length === 1 && rowSpannedCells[0] === cell;
                    // checks whether current cell is with in selection.
                    let isCellWithInSel = this.checkCurrentCell(rowSpannedCells, cell, isPrevCellWithinSel, isNextCellWithinSel);
                    // when last selected row not having equal row span then returned false.
                    if (i === count && !isNullOrUndefined(prevCell) && cell.cellFormat.rowSpan > prevCell.cellFormat.rowSpan
                        && !isCellWithInSel) {
                        return false;
                    }
                    if (i !== rowStartIndex) {
                        for (let m = 0; m < rowSpannedCells.length; m++) {
                            {
                                let rowSpan = (rowSpannedCells[m].ownerRow.rowIndex + rowSpannedCells[m].cellFormat.rowSpan) - 1;
                                if (rowSpan >= row.rowIndex) {
                                    if (rowSpannedCells[m].columnIndex > cell.columnIndex) {
                                        isRowRightWithinSel = true;
                                    }
                                    else {
                                        isRowLeftWithinSel = true;
                                    }
                                    if (i === count && rowSpannedCells[m] !== cell
                                        && rowSpan > (cell.ownerRow.rowIndex + cell.cellFormat.rowSpan - 1)) {
                                        return false;
                                    }
                                    if (rowSpan === row.rowIndex && !this.checkPrevOrNextCellIsWithinSel(startLeft, endLeft, cell, false)) {
                                        rowSpannedCells.splice(rowSpannedCells.indexOf(rowSpannedCells[m]), 1);
                                    }
                                }
                            }
                        }
                    }
                    if (isPrevCellWithinSel && !isNullOrUndefined(prevCell)
                        && isNoRowSpan
                        && (cell.columnIndex !== prevCell.columnIndex + 1 && this.checkCellWidth(cell))) {
                        return false;
                    }
                }
            }
            if (i === rowStartIndex) {
                selectionLeft = rowLeft;
                selectionRight = rowRight;
            }
            else {
                if (rowRight > 0 && rowLeft > 0) {
                    if (!((isRowLeftWithinSel || Math.round(selectionLeft) === Math.round(rowLeft))
                        && (isRowRightWithinSel || Math.round(selectionRight) === Math.round(rowRight)))) {
                        return false;
                    }
                }
                if (i === count) {
                    return true;
                }
            }
        }
        return false;
    }
    checkCellWidth(cell) {
        let prevCell = cell.previousWidget;
        let cellLeft = this.viewer.selection.getCellLeft(cell.ownerRow, cell);
        let prevCellLeft = this.viewer.selection.getCellLeft(cell.ownerRow, prevCell);
        let left = prevCellLeft + HelperMethods.convertPointToPixel(prevCell.cellFormat.cellWidth);
        if (HelperMethods.round(left, 2) !== HelperMethods.round(cellLeft, 2)) {
            return true;
        }
        return false;
    }
    ;
    checkCellWithInSelection(startLeft, endLeft, cellStart) {
        if (HelperMethods.round(startLeft, 2) <= HelperMethods.round(cellStart, 2)
            && HelperMethods.round(cellStart, 2) < HelperMethods.round(endLeft, 2)) {
            return true;
        }
        return false;
    }
    ;
    checkPrevOrNextCellIsWithinSel(startLeft, endLeft, cell, isPrev) {
        let prevOrNextCell = isPrev ? cell.previousWidget : cell.nextWidget;
        let cellStart = 0;
        if (isNullOrUndefined(prevOrNextCell)) {
            return false;
        }
        cellStart = this.viewer.selection.getCellLeft(prevOrNextCell.ownerRow, prevOrNextCell);
        return this.checkCellWithInSelection(startLeft, endLeft, cellStart);
    }
    // tslint:disable-next-line:max-line-length
    checkCurrentCell(rowSpannedCells, cell, isPrevCellWithInSel, isNextCellWithinSel) {
        let cellOwner = cell.ownerRow;
        if (rowSpannedCells.length > 0) {
            for (let i = 0; i < rowSpannedCells.length; i++) {
                let spannedCellOwner = rowSpannedCells[i].ownerRow;
                let rowSpan = (spannedCellOwner.rowIndex + rowSpannedCells[i].cellFormat.rowSpan) - 1;
                if (rowSpannedCells[i] === cell && (rowSpannedCells.length === 1 || this.checkRowSpannedCells(rowSpannedCells, cell))
                    && !(isNextCellWithinSel || isPrevCellWithInSel)) {
                    return true;
                }
                if (rowSpannedCells[i] !== cell && spannedCellOwner.rowIndex < cellOwner.rowIndex
                    && rowSpan === (cellOwner.rowIndex + cell.cellFormat.rowSpan - 1)) {
                    return true;
                }
            }
        }
        return false;
    }
    checkRowSpannedCells(rowSpannedCells, cell) {
        for (let i = 0; i < rowSpannedCells.length; i++) {
            if (rowSpannedCells[i] !== cell && rowSpannedCells[i].columnIndex === cell.columnIndex) {
                return true;
            }
        }
        return false;
    }
    /**
     * @private
     */
    insertNewParagraphWidget(newParagraph, insertAfter) {
        this.updateInsertPosition();
        this.insertParagraph(newParagraph, insertAfter);
        if (!insertAfter) {
            let nextParagraph;
            let currentParagraph = newParagraph;
            do {
                nextParagraph = this.selection.getNextParagraphBlock(currentParagraph);
                currentParagraph = nextParagraph;
            } while (nextParagraph && nextParagraph.equals(newParagraph));
            if (!isNullOrUndefined(nextParagraph)) {
                this.selection.selectParagraph(nextParagraph, true);
            }
            else {
                this.selection.selectParagraph(newParagraph, true);
            }
        }
        this.fireContentChange();
    }
    insertParagraph(newParagraph, insertAfter) {
        let lineWidget = this.selection.start.currentWidget;
        let offset = this.selection.start.offset;
        let currentParagraph = this.selection.start.paragraph;
        currentParagraph = currentParagraph.combineWidget(this.viewer);
        if (insertAfter) {
            // tslint:disable-next-line:max-line-length
            let length = this.selection.getLineLength(currentParagraph.lastChild);
            let insertIndex = newParagraph.firstChild ? newParagraph.firstChild.children.length : 0;
            // tslint:disable-next-line:max-line-length
            this.moveInlines(currentParagraph, newParagraph, insertIndex, offset, lineWidget, length, currentParagraph.lastChild);
        }
        else if (offset > 0) {
            this.moveInlines(currentParagraph, newParagraph, 0, 0, currentParagraph.firstChild, offset, lineWidget);
        }
        let splittedWidget = currentParagraph.getSplitWidgets();
        currentParagraph = insertAfter ? splittedWidget[splittedWidget.length - 1] : splittedWidget[0];
        let insertIndex = currentParagraph.containerWidget.childWidgets.indexOf(currentParagraph);
        if (insertAfter) {
            insertIndex++;
        }
        let bodyWidget = currentParagraph.containerWidget;
        newParagraph.index = currentParagraph.index;
        newParagraph.containerWidget = bodyWidget;
        bodyWidget.childWidgets.splice(insertIndex, 0, newParagraph);
        this.updateNextBlocksIndex(insertAfter ? currentParagraph : newParagraph, true);
        newParagraph.height = 0;
        this.viewer.layout.layoutBodyWidgetCollection(newParagraph.index, bodyWidget, newParagraph, false);
    }
    // tslint:disable-next-line:max-line-length
    moveInlines(currentParagraph, newParagraph, insertIndex, startOffset, startLine, endOffset, endLine) {
        if (newParagraph.childWidgets.length === 0) {
            let line = new LineWidget(newParagraph);
            newParagraph.childWidgets.push(line);
        }
        let isMoved = false;
        this.viewer.layout.clearListElementBox(currentParagraph);
        this.viewer.layout.clearListElementBox(newParagraph);
        for (let j = 0; j < currentParagraph.childWidgets.length; j++) {
            let lineWidget = currentParagraph.childWidgets[j];
            if (startLine === lineWidget && endLine === lineWidget) {
                insertIndex = this.moveContent(lineWidget, startOffset, endOffset, insertIndex, newParagraph);
                break;
            }
            if (endLine === lineWidget) {
                insertIndex = this.moveContent(lineWidget, 0, endOffset, insertIndex, newParagraph);
                break;
            }
            else if (startLine === lineWidget) {
                isMoved = true;
                // tslint:disable-next-line:max-line-length
                insertIndex = this.moveContent(lineWidget, startOffset, this.viewer.selection.getLineLength(lineWidget), insertIndex, newParagraph);
            }
            else if (isMoved) {
                insertIndex = this.moveContent(lineWidget, 0, this.viewer.selection.getLineLength(lineWidget), insertIndex, newParagraph);
            }
        }
        this.removeEmptyLine(currentParagraph);
        if (!currentParagraph.isInsideTable) {
            this.viewer.layout.reLayoutParagraph(currentParagraph, 0, 0);
        }
    }
    /**
     * @private
     */
    //tslint:disable-next-line:max-line-length
    moveContent(lineWidget, startOffset, endOffset, insertIndex, paragraph) {
        let count = 0;
        let lineIndex = lineWidget.paragraph.childWidgets.indexOf(lineWidget);
        for (let i = 0; i < lineWidget.children.length; i++) {
            let inline = lineWidget.children[i];
            if (startOffset >= count + inline.length || inline instanceof ListTextElementBox) {
                if (!(inline instanceof ListTextElementBox)) {
                    count += inline.length;
                }
                continue;
            }
            let startIndex = 0;
            if (startOffset > count) {
                startIndex = startOffset - count;
            }
            let endIndex = endOffset - count;
            if (endIndex > inline.length) {
                endIndex = inline.length;
            }
            if (startIndex > 0) {
                count += startIndex;
            }
            if (startIndex === 0 && endIndex === inline.length) {
                paragraph.firstChild.children.splice(insertIndex, 0, inline);
                inline.line = paragraph.firstChild;
                insertIndex++;
                // if (editAction < 4) {
                // this.unLinkFieldCharacter(inline);
                lineWidget.children.splice(i, 1);
                i--;
                // }
            }
            else if (inline instanceof TextElementBox) {
                // if (editAction < 4) {
                let span = new TextElementBox();
                span.characterFormat.copyFormat(inline.characterFormat);
                span.text = inline.text.substr(startIndex, endIndex - startIndex);
                paragraph.firstChild.children.splice(insertIndex, 0, span);
                span.line = paragraph.firstChild;
                insertIndex++;
                inline.text = inline.text.slice(0, startIndex) + inline.text.slice(endIndex);
            }
            if (endOffset <= count + endIndex - startIndex) {
                break;
            }
            count += endIndex - startIndex;
        }
        return insertIndex;
    }
    /**
     * update complex changes when history is not preserved
     * @param  {number} action?
     * @param  {string} start?
     * @param  {string} end?
     * @private
     */
    updateComplexWithoutHistory(action, start, end) {
        let selection = this.viewer.selection;
        if (action === 0) {
            let startPosition = new TextPosition(selection.owner);
            this.setPositionForCurrentIndex(startPosition, start);
            this.viewer.layout.reLayoutParagraph(startPosition.paragraph, 0, 0);
            this.setPositionForCurrentIndex(selection.start, end);
            this.setPositionForCurrentIndex(selection.end, end);
        }
        if (action === 1) {
            let startPosition = new TextPosition(selection.owner);
            this.setPositionForCurrentIndex(startPosition, start);
            let endPosition = new TextPosition(selection.owner);
            this.setPositionForCurrentIndex(endPosition, end);
            this.viewer.layout.reLayoutParagraph(startPosition.paragraph, 0, 0);
            if (endPosition.paragraph !== startPosition.paragraph) {
                this.viewer.layout.reLayoutParagraph(endPosition.paragraph, 0, 0);
            }
        }
        if (selection.owner.isShiftingEnabled) {
            this.viewer.layout.shiftLayoutedItems();
            if (this.viewer.owner.enableHeaderAndFooter) {
                this.updateHeaderFooterWidget();
            }
        }
        selection.owner.isShiftingEnabled = false;
        selection.start.updatePhysicalPosition(true);
        if (selection.isEmpty) {
            selection.end.setPositionInternal(selection.start);
        }
        else {
            selection.end.updatePhysicalPosition(true);
        }
        selection.upDownSelectionLength = selection.end.location.x;
        selection.fireSelectionChanged(true);
        this.viewer.updateFocus();
        this.viewer.updateScrollBars();
        this.fireContentChange();
        this.isHandledComplex = true;
    }
    /**
     * reLayout
     * @param selection
     * @param isSelectionChanged
     * @private
     */
    reLayout(selection, isSelectionChanged) {
        if (this.editorHistory && this.editorHistory.isHandledComplexHistory()) {
            if (isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)
                || (this.editorHistory.currentBaseHistoryInfo
                    && !(this.editorHistory.currentBaseHistoryInfo.action === 'ClearCharacterFormat'
                        || this.editorHistory.currentBaseHistoryInfo.action === 'ClearParagraphFormat'))) {
                this.startParagraph = undefined;
                this.endParagraph = undefined;
            }
            this.isHandledComplex = false;
            return;
        }
        if (isNullOrUndefined(this.viewer.blockToShift)) {
            this.viewer.removeEmptyPages();
            this.viewer.layout.updateFieldElements();
            this.viewer.updateScrollBars();
            if (!selection.owner.isShiftingEnabled) {
                selection.fireSelectionChanged(true);
                this.startParagraph = undefined;
                this.endParagraph = undefined;
            }
        }
        if (isNullOrUndefined(isSelectionChanged)) {
            isSelectionChanged = selection.isEmpty;
        }
        if (selection.owner.isShiftingEnabled) {
            selection.owner.isShiftingEnabled = false;
            selection.owner.isLayoutEnabled = true;
            this.viewer.layout.shiftLayoutedItems();
            if (this.viewer.owner.enableHeaderAndFooter) {
                this.updateHeaderFooterWidget();
            }
            this.getOffsetValue(selection);
            selection.upDownSelectionLength = selection.end.location.x;
            selection.fireSelectionChanged(true);
            this.viewer.updateFocus();
            this.startParagraph = undefined;
            this.endParagraph = undefined;
            this.viewer.layout.allowLayout = true;
        }
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo &&
            ((this.editorHistory.currentBaseHistoryInfo.action !== 'RowResizing'
                && this.editorHistory.currentBaseHistoryInfo.action !== 'CellResizing')
                || (this.editorHistory.isUndoing || this.editorHistory.isRedoing))) {
            if (this.editorHistory.currentBaseHistoryInfo.modifiedProperties.length > 0) {
                this.editorHistory.currentBaseHistoryInfo.updateSelection();
            }
            this.editorHistory.updateHistory();
        }
        this.fireContentChange();
    }
    /**
     * @private
     */
    updateHeaderFooterWidget() {
        this.updateHeaderFooterWidgetToPage(this.selection.start.paragraph.bodyWidget);
        this.shiftPageContent(this.selection.start.paragraph.bodyWidget);
    }
    /**
     * @private
     */
    updateHeaderFooterWidgetToPage(node) {
        let currentPage = node.page;
        node = this.viewer.layout.updateHeaderFooterToParent(node);
        let isEvenPage = (node.headerFooterType === 'EvenHeader' || node.headerFooterType === 'EvenFooter');
        for (let i = 0; i < this.viewer.pages.length; i++) {
            let page = this.viewer.pages[i];
            if ((i + 1 === 1) && page.bodyWidgets[0].sectionFormat.differentFirstPage &&
                node.headerFooterType.indexOf('FirstPage') !== -1) {
                return;
            }
            if (page.index === 0 && page.bodyWidgets[0].sectionFormat.differentFirstPage &&
                node.headerFooterType.indexOf('FirstPage') === -1) {
                continue;
            }
            if (currentPage !== page) {
                if (page.bodyWidgets[0].sectionFormat.differentOddAndEvenPages) {
                    if (isEvenPage && (i + 1) % 2 === 0) {
                        this.updateHeaderFooterWidgetToPageInternal(page, node, node.headerFooterType.indexOf('Header') !== -1);
                    }
                    else if ((!isEvenPage && (i + 1) % 2 !== 0)) {
                        if (page.bodyWidgets[0].sectionFormat.differentFirstPage && (i + 1 !== 1)) {
                            this.updateHeaderFooterWidgetToPageInternal(page, node, node.headerFooterType.indexOf('Header') !== -1);
                        }
                    }
                }
                else {
                    this.updateHeaderFooterWidgetToPageInternal(page, node, node.headerFooterType.indexOf('Header') !== -1);
                }
            }
        }
    }
    /**
     * @private
     */
    updateHeaderFooterWidgetToPageInternal(page, widget, isHeader) {
        if (widget.page !== page) {
            let hfWidget = widget.clone();
            hfWidget.page = page;
            this.viewer.updateHFClientArea(hfWidget.sectionFormat, isHeader);
            hfWidget = this.viewer.layout.layoutHeaderFooterItems(this.viewer, hfWidget);
            let headerOrFooter;
            if (isHeader) {
                headerOrFooter = page.headerWidget;
                page.headerWidget = hfWidget;
            }
            else {
                headerOrFooter = page.footerWidget;
                page.footerWidget = hfWidget;
            }
            this.removeFieldInWidget(headerOrFooter);
            headerOrFooter.destroy();
        }
    }
    /**
     * @private
     */
    removeFieldInWidget(widget) {
        for (let i = 0; i < widget.childWidgets.length; i++) {
            this.removeFieldInBlock(widget.childWidgets[i]);
        }
    }
    /**
     * @private
     */
    removeFieldInBlock(block) {
        if (block instanceof TableWidget) {
            this.removeFieldTable(block);
        }
        else {
            this.removeField(block);
        }
    }
    /**
     * @private
     */
    removeFieldTable(table) {
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                this.removeFieldInWidget(row.childWidgets[j]);
            }
        }
    }
    /**
     * @private
     */
    shiftPageContent(headerFooter) {
        let type = headerFooter.headerFooterType;
        let pageIndex;
        if (type === 'FirstPageHeader' || type === 'FirstPageFooter') {
            pageIndex = 0;
        }
        else if (headerFooter.sectionFormat.differentOddAndEvenPages) {
            if (headerFooter.sectionFormat.differentFirstPage) {
                pageIndex = (type === 'EvenHeader' || type === 'EvenFooter') ? 1 : 2;
            }
            else {
                pageIndex = (type.indexOf('Even') === -1) ? 0 : 1;
            }
        }
        else {
            pageIndex = headerFooter.sectionFormat.differentFirstPage ? 1 : 0;
            if (pageIndex === 1 && this.viewer.pages.length === 1) {
                pageIndex = 0;
            }
        }
        let page = this.viewer.pages[pageIndex];
        if (type.indexOf('Header') !== -1) {
            let firstBlock = page.bodyWidgets[0].firstChild;
            let top = HelperMethods.convertPointToPixel(headerFooter.sectionFormat.topMargin);
            let headerDistance = HelperMethods.convertPointToPixel(headerFooter.sectionFormat.headerDistance);
            top = Math.max(headerDistance + page.headerWidget.height, top);
            if (firstBlock.y !== top) {
                this.viewer.updateClientArea(page.bodyWidgets[0].sectionFormat, page);
                firstBlock = firstBlock.combineWidget(this.viewer);
                let prevWidget = firstBlock.previousRenderedWidget;
                if (prevWidget) {
                    this.viewer.cutFromTop(prevWidget.y + prevWidget.height);
                    if (firstBlock.containerWidget !== prevWidget.containerWidget) {
                        // tslint:disable-next-line:max-line-length
                        this.viewer.layout.updateContainerWidget(firstBlock, prevWidget.containerWidget, prevWidget.indexInOwner + 1, false);
                    }
                }
                this.viewer.blockToShift = firstBlock;
            }
        }
        else {
            this.checkAndShiftFromBottom(page, headerFooter);
        }
        if (this.viewer.blockToShift) {
            this.viewer.renderedLists.clear();
            this.viewer.layout.shiftLayoutedItems();
        }
    }
    /**
     * @private
     */
    checkAndShiftFromBottom(page, footerWidget) {
        let bodyWidget = page.bodyWidgets[0];
        let blockToShift;
        for (let i = 0; i < bodyWidget.childWidgets.length; i++) {
            let block = bodyWidget.childWidgets[i];
            if (block.y + block.height > footerWidget.y) {
                blockToShift = block;
                break;
            }
            if (bodyWidget.childWidgets.length - 1 === i && block.y + block.height < footerWidget.y) {
                blockToShift = block;
                break;
            }
        }
        this.viewer.updateClientArea(bodyWidget.sectionFormat, page);
        this.viewer.cutFromTop(blockToShift.y);
        this.viewer.blockToShift = blockToShift;
    }
    //Paste Implementation ends
    //Character Format apply implementation starts
    /**
     * Change HighlightColor
     * @param  {HighlightColor} highlightColor
     * Applies character format for selection.
     * @param {string} property
     * @param {Object} value
     * @param {boolean} update
     * @private
     */
    onApplyCharacterFormat(property, value, update) {
        let selection = this.viewer.selection;
        if (selection.owner.isReadOnlyMode || !selection.owner.isDocumentLoaded) {
            return;
        }
        update = isNullOrUndefined(update) ? false : update;
        let action = (property[0].toUpperCase() + property.slice(1));
        let paragraph = selection.start.paragraph;
        let lastLine = paragraph.childWidgets[paragraph.childWidgets.length - 1];
        if (selection.isEmpty && selection.contextType !== 'List') {
            selection.skipFormatRetrieval = true;
            if (selection.end.isAtParagraphEnd) {
                this.initHistory(action);
                this.viewer.owner.isShiftingEnabled = true;
                this.applyCharFormatValue(paragraph.characterFormat, property, value, update);
                this.reLayout(this.viewer.selection);
                this.viewer.updateFocus();
            }
            else {
                selection.fireSelectionChanged(true);
            }
            selection.skipFormatRetrieval = false;
            return;
        }
        this.setOffsetValue(selection);
        this.initHistory(action);
        // Todo: Complete Microsoft Word behavior on apply formatting in empty selection
        // if (selection.isEmpty) {
        //     this.viewer.owner.isShiftingEnabled = true;
        //     this.applyCharFormatValue(paragraph.characterFormat, property, value, update);
        //     this.reLayout(this.viewer.selection);
        //     this.viewer.updateFocus();
        //     return;
        // }
        if (selection.contextType === 'List') {
            // this.updateCharacterFormatForListText(selection, action, value, update);
            this.applyCharacterFormatForListText(selection, property, value, update);
        }
        else {
            //Iterate and update format.
            this.updateSelectionCharacterFormatting(property, value, update);
        }
    }
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    applyCharacterFormatForListText(selection, property, values, update) {
        let listLevel = this.getListLevel(selection.start.paragraph);
        if (isNullOrUndefined(listLevel)) {
            return;
        }
        let characterFormat = listLevel.characterFormat;
        switch (property) {
            case 'bold':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'bold', !(characterFormat.bold));
                break;
            case 'italic':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'italic', !(characterFormat.italic));
                break;
            case 'fontColor':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'fontColor', values);
                break;
            case 'fontFamily':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'fontFamily', values);
                break;
            case 'fontSize':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'fontSize', values);
                break;
            case 'highlightColor':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'highlightColor', values);
                break;
            case 'baselineAlignment':
                if (characterFormat.baselineAlignment === values) {
                    values = 'Normal';
                }
                this.applyListCharacterFormatByValue(selection, characterFormat, 'baselineAlignment', values);
                break;
            case 'strikethrough':
                if (characterFormat.strikethrough === values) {
                    values = 'None';
                }
                this.applyListCharacterFormatByValue(selection, characterFormat, 'strikethrough', values);
                break;
            case 'underline':
                if (characterFormat.underline === values) {
                    values = 'None';
                }
                this.applyListCharacterFormatByValue(selection, characterFormat, 'underline', values);
                break;
            case 'characterFormat':
                this.applyListCharacterFormatByValue(selection, characterFormat, undefined, values);
                break;
        }
    }
    applyListCharacterFormatByValue(selection, format, property, value) {
        this.initHistory('ListCharacterFormat');
        this.applyCharFormatValue(format, property, value, false);
        this.editorHistory.updateHistory();
        this.reLayout(selection);
        this.fireContentChange();
    }
    /**
     * @private
     */
    updateListCharacterFormat(selection, property, value) {
        this.updateListTextSelRange(selection, property, value, false);
    }
    updateListTextSelRange(selection, property, value, update) {
        this.viewer.owner.isShiftingEnabled = true;
        let startPositionInternal = selection.start;
        let endPositionInternal = selection.end;
        if (!selection.isForward) {
            startPositionInternal = selection.end;
            endPositionInternal = selection.start;
        }
        this.initHistoryPosition(selection, startPositionInternal);
        let listLevel = this.getListLevel(selection.start.paragraph);
        this.applyCharFormatValue(listLevel.characterFormat, property, value, update);
        this.startSelectionReLayouting(startPositionInternal.paragraph, selection, startPositionInternal, endPositionInternal);
    }
    /**
     * @private
     */
    getListLevel(paragraph) {
        let currentList = undefined;
        let listLevelNumber = 0;
        if (!isNullOrUndefined(paragraph.paragraphFormat) && !isNullOrUndefined(paragraph.paragraphFormat.listFormat)) {
            currentList = this.viewer.getListById(paragraph.paragraphFormat.listFormat.listId);
            listLevelNumber = paragraph.paragraphFormat.listFormat.listLevelNumber;
        }
        if (!isNullOrUndefined(currentList) &&
            !isNullOrUndefined(this.viewer.getAbstractListById(currentList.abstractListId))
            // && !isNullOrUndefined(this.viewer.getAbstractListById(currentList.abstractListId).levels.getItem(listLevelNumber))) {
            && !isNullOrUndefined(this.viewer.getAbstractListById(currentList.abstractListId).levels)) {
            return this.viewer.layout.getListLevel(currentList, listLevelNumber);
        }
        return undefined;
    }
    updateInsertPosition() {
        let selection = this.viewer.selection;
        let position = selection.start;
        if (!selection.isForward) {
            position = selection.end;
        }
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)
            && !isNullOrUndefined(position)) {
            if (isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo.insertPosition)) {
                this.updateHistoryPosition(position, true);
            }
        }
    }
    /**
     * preserve paragraph and offset value for selection
     * @private
     */
    setOffsetValue(selection) {
        let info = this.getParagraphInfo(selection.start);
        this.startParagraph = info.paragraph;
        this.startOffset = info.offset;
        info = this.getParagraphInfo(selection.end);
        this.endParagraph = info.paragraph;
        this.endOffset = info.offset;
    }
    /**
     * Toggles the highlight color property of selected contents.
     * @param {HighlightColor} highlightColor Default value of ‘underline’ parameter is Yellow.
     */
    toggleHighlightColor(highlightColor) {
        let selection = this.viewer.selection;
        if (isNullOrUndefined(highlightColor) || highlightColor === 'NoColor') {
            highlightColor = 'Yellow';
        }
        //In Ms Word the highlight color is took from the ribbon. So we Have given yellow as constant.
        if (selection.characterFormat.highlightColor === highlightColor) {
            highlightColor = 'NoColor';
        }
        this.selection.characterFormat.highlightColor = highlightColor;
    }
    /**
     * Toggles the subscript formatting of selected contents.
     */
    toggleSubscript() {
        if (!this.owner.isReadOnlyMode) {
            let value = this.selection.characterFormat.baselineAlignment === 'Subscript' ? 'Normal' : 'Subscript';
            this.selection.characterFormat.baselineAlignment = value;
        }
    }
    /**
     * Toggles the superscript formatting of selected contents.
     */
    toggleSuperscript() {
        if (!this.owner.isReadOnlyMode) {
            let value = this.selection.characterFormat.baselineAlignment === 'Superscript' ? 'Normal' : 'Superscript';
            this.selection.characterFormat.baselineAlignment = value;
        }
    }
    /**
     * Toggles the text alignment property of selected contents.
     * @param {TextAlignment} textAlignment Default value of ‘textAlignment parameter is TextAlignment.Left.
     */
    /**
     * Increases the left indent of selected paragraphs to a factor of 36 points.
     */
    increaseIndent() {
        if (!this.owner.isReadOnlyMode) {
            this.onApplyParagraphFormat('leftIndent', this.viewer.defaultTabWidth, true, false);
        }
    }
    /**
     * Decreases the left indent of selected paragraphs to a factor of 36 points.
     */
    decreaseIndent() {
        if (!this.owner.isReadOnlyMode) {
            this.onApplyParagraphFormat('leftIndent', -this.viewer.defaultTabWidth, true, false);
        }
    }
    /**
     * Clears the list format for selected paragraphs.
     */
    clearList() {
        this.selection.owner.editorModule.onApplyList(undefined);
    }
    /**
     * Applies the bullet list to selected paragraphs.
     * @param {string} bullet Bullet character
     * @param {string} fontFamily Bullet font family
     */
    applyBullet(bullet, fontFamily) {
        if (!this.owner.isReadOnlyMode) {
            this.applyBulletOrNumbering(bullet, 'Bullet', fontFamily);
        }
    }
    /**
     * Applies the numbering list to selected paragraphs.
     * @param numberFormat  “%n” representations in ‘numberFormat’ parameter will be replaced by respective list level’s value.
     * `“%1)” will be displayed as “1)” `
     * @param listLevelPattern  Default value of ‘listLevelPattern’ parameter is ListLevelPattern.Arabic
     */
    applyNumbering(numberFormat, listLevelPattern) {
        if (!this.owner.isReadOnlyMode) {
            this.applyBulletOrNumbering(numberFormat, listLevelPattern, 'Verdana');
        }
    }
    /**
     * Toggles the baseline alignment property of selected contents.
     * @param  {Selection} selection
     * @param  {BaselineAlignment} baseAlignment
     */
    toggleBaselineAlignment(baseAlignment) {
        this.updateProperty(2, baseAlignment);
    }
    /**
     * Clears the formatting.
     */
    clearFormatting() {
        let selection = this.viewer.selection;
        this.initComplexHistory('ClearFormat');
        // let startIndex: string = selection.start.getHierarchicalIndexInternal();
        // let endIndex: string = selection.end.getHierarchicalIndexInternal();
        if (selection.isEmpty) {
            selection.start.moveToParagraphStartInternal(selection, false);
            selection.end.moveToParagraphEndInternal(selection, false);
        }
        this.setOffsetValue(selection);
        if (this.editorHistory) {
            this.editorHistory.initializeHistory('ClearCharacterFormat');
        }
        this.updateSelectionCharacterFormatting('ClearCharacterFormat', undefined, false);
        this.getOffsetValue(selection);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.setOffsetValue(selection);
        if (this.editorHistory) {
            this.editorHistory.initializeHistory('ClearParagraphFormat');
        }
        this.updateParagraphFormatInternal('ClearParagraphFormat', undefined, false);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.getOffsetValue(selection);
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentHistoryInfo)) {
            this.editorHistory.updateComplexHistory();
        }
        this.startParagraph = undefined;
        this.endParagraph = undefined;
        // else {
        //     this.checkAndUpdatedSelection(startIndex, endIndex);
        // }
    }
    /**
     * Toggles the specified property. If property is assigned already. Then property will be changed
     * @param  {Selection} selection
     * @param  {number} type
     * @param  {Object} value
     * @private
     */
    updateProperty(type, value) {
        let selection = this.selection;
        if (selection.owner.isReadOnlyMode || !selection.owner.isDocumentLoaded) {
            return;
        }
        let startPosition = selection.start;
        let endPosition = selection.end;
        if (!selection.isForward) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        let indexInInline = 0;
        let inlineObj = startPosition.currentWidget.getInline(startPosition.offset, indexInInline);
        let inline = inlineObj.element;
        indexInInline = inlineObj.index;
        let paragraph = startPosition.paragraph;
        if (!isNullOrUndefined(inline) && inline.length === indexInInline && !this.selection.isEmpty) {
            inline = inline.nextNode;
        }
        if (type === 1) {
            let currentUnderline = 'None';
            if (!isNullOrUndefined(inline)) {
                currentUnderline = inline.characterFormat.underline;
            }
            else if (!isNullOrUndefined(paragraph)) {
                currentUnderline = paragraph.characterFormat.underline;
            }
            this.selection.characterFormat.underline = value === currentUnderline ? 'None' : value;
        }
        else {
            let script = 'Normal';
            if (!isNullOrUndefined(inline)) {
                script = inline.characterFormat.baselineAlignment;
            }
            else if (!isNullOrUndefined(paragraph)) {
                script = paragraph.characterFormat.baselineAlignment;
            }
            if (script === value) {
                value = 'Normal';
            }
            this.selection.characterFormat.baselineAlignment = value;
        }
    }
    getCompleteStyles() {
        let completeStylesString = '{"styles":[';
        for (let name of this.viewer.preDefinedStyles.getItem()) {
            completeStylesString += (this.viewer.preDefinedStyles.get(name) + ',');
        }
        return completeStylesString.slice(0, -1) + ']}';
    }
    /**
     * Initialize default styles
     * @private
     */
    intializeDefaultStyles() {
        let existingStyles = this.owner.getStyleNames('Paragraph');
        let defaultStyleNames = ['Normal', 'Heading 1', 'Heading 2', 'Heading 3', 'Heading 4', 'Heading 5', 'Heading 6'];
        let styleNames = defaultStyleNames.filter((val) => {
            return existingStyles.indexOf(val) === -1;
        });
        for (let name of styleNames) {
            this.createStyle(this.viewer.preDefinedStyles.get(name));
        }
    }
    /**
     * Creates a new instance of Style.
     */
    createStyle(styleString) {
        this.createStyleIn(styleString);
    }
    /**
     * Create a Style.
     * @private
     */
    createStyleIn(styleString) {
        /* tslint:disable:no-any */
        let style = JSON.parse(styleString);
        let styleObj = this.viewer.styles.findByName(style.name);
        if (styleObj !== undefined) {
            //Create a new style with new name and add it to collection.
            style.name = this.getUniqueStyleName(style.name);
        }
        this.viewer.owner.parser.parseStyle(JSON.parse(this.getCompleteStyles()), style, this.viewer.styles);
        return this.viewer.styles.findByName(style.name);
    }
    /**
     * @private
     */
    getUniqueStyleName(name) {
        let uniqueName = this.getUniqueName(name);
        let style = this.viewer.styles.findByName(uniqueName);
        while (!isNullOrUndefined(style)) {
            uniqueName = this.getUniqueStyleName(style.name);
            style = this.viewer.styles.findByName(uniqueName);
        }
        return uniqueName;
    }
    getUniqueName(name) {
        let matchArray = name.match(/\d+$/);
        if (!isNullOrUndefined(matchArray) && matchArray.length > 0) {
            return name.replace(matchArray[0], (parseInt(matchArray[0], 10) + 1).toString());
        }
        else {
            return name + '_1';
        }
    }
    /**
     * Update Character format for selection
     * @private
     */
    updateSelectionCharacterFormatting(property, values, update) {
        if (isNullOrUndefined(property)) {
            property = 'CharacterFormat';
        }
        switch (property) {
            case 'bold':
                this.updateCharacterFormat('bold', values);
                break;
            case 'italic':
                this.updateCharacterFormat('italic', values);
                break;
            case 'fontColor':
                this.updateCharacterFormat('fontColor', values);
                break;
            case 'fontFamily':
                this.updateCharacterFormat('fontFamily', values);
                break;
            case 'fontSize':
                this.updateCharacterFormatWithUpdate(this.viewer.selection, 'fontSize', values, update);
                break;
            case 'highlightColor':
                this.updateCharacterFormat('highlightColor', values);
                break;
            case 'baselineAlignment':
                this.updateCharacterFormat('baselineAlignment', values);
                break;
            case 'strikethrough':
                this.updateCharacterFormat('strikethrough', values);
                break;
            case 'underline':
                this.updateCharacterFormat('underline', values);
                break;
            case 'styleName':
                this.updateCharacterFormatWithUpdate(this.viewer.selection, 'styleName', values, true);
                break;
            case 'CharacterFormat':
                this.updateCharacterFormat(undefined, values);
                break;
            case 'ClearCharacterFormat':
                this.updateCharacterFormat(undefined, values);
                break;
        }
        this.reLayout(this.viewer.selection);
    }
    /**
     * Update character format for selection range
     * @param  {SelectionRange} selectionRange
     * @param  {string} property
     * @param  {Object} value
     * @returns void
     * @private
     */
    updateCharacterFormat(property, value) {
        this.updateCharacterFormatWithUpdate(this.viewer.selection, property, value, false);
    }
    updateCharacterFormatWithUpdate(selection, property, value, update) {
        this.viewer.owner.isShiftingEnabled = true;
        let startPosition = selection.start;
        let endPosition = selection.end;
        if (!selection.isForward) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        this.applyCharFormatSelectedContent(startPosition.paragraph, selection, startPosition, endPosition, property, value, update);
    }
    // tslint:disable-next-line:max-line-length
    applyCharFormatSelectedContent(paragraph, selection, start, end, property, value, update) {
        //Selection start in cell.
        if (start.paragraph.isInsideTable && (!end.paragraph.isInsideTable
            || start.paragraph.associatedCell !== end.paragraph.associatedCell
            || selection.isCellSelected(start.paragraph.associatedCell, start, end))) {
            let cell;
            start.paragraph.associatedCell.ownerTable.combineWidget(this.viewer);
            if (this.checkInsertPosition(selection)) {
                this.updateHistoryPosition(start, true);
            }
            cell = start.paragraph.associatedCell;
            this.applyCharFormatCell(cell, selection, start, end, property, value, update);
            let table = cell.ownerTable;
            // tslint:disable-next-line:max-line-length
            this.viewer.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
        }
        else {
            this.applyCharFormat(paragraph, selection, start, end, property, value, update);
        }
    }
    // tslint:disable-next-line:max-line-length
    applyCharFormatForSelectedPara(paragraph, selection, property, value, update) {
        for (let i = 0; i < paragraph.childWidgets.length; i++) {
            let line = paragraph.childWidgets[i];
            for (let j = 0; j < line.children.length; j++) {
                let element = line.children[j];
                this.applyCharFormatValue(element.characterFormat, property, value, update);
            }
        }
        this.applyCharFormatValue(paragraph.characterFormat, property, value, update);
    }
    splittedLastParagraph(paragraph) {
        let splittedWidets = paragraph.getSplitWidgets();
        return splittedWidets[splittedWidets.length - 1];
    }
    // tslint:disable-next-line:max-line-length
    getNextParagraphForCharacterFormatting(block, start, end, property, value, update) {
        let widgetCollection = block.getSplitWidgets();
        block = widgetCollection[widgetCollection.length - 1];
        block = this.viewer.selection.getNextRenderedBlock(block);
        if (!isNullOrUndefined(block)) {
            if (block instanceof ParagraphWidget) {
                this.applyCharFormat(block, this.viewer.selection, start, end, property, value, update);
            }
            else {
                this.applyCharFormatForTable(0, block, this.viewer.selection, start, end, property, value, update);
            }
        }
    }
    // tslint:disable-next-line:max-line-length
    applyCharFormat(paragraph, selection, start, end, property, value, update) {
        paragraph = paragraph.combineWidget(this.viewer);
        let startOffset = 0;
        let length = selection.getParagraphLength(paragraph);
        let startLineWidget = paragraph.childWidgets.indexOf(start.currentWidget) !== -1 ?
            paragraph.childWidgets.indexOf(start.currentWidget) : 0;
        let endOffset = end.offset;
        let endLineWidget = paragraph.childWidgets.indexOf(end.currentWidget) !== -1 ?
            paragraph.childWidgets.indexOf(end.currentWidget) : paragraph.childWidgets.length - 1;
        if (!isNullOrUndefined(selection)) {
            if (paragraph === start.paragraph) {
                startOffset = start.offset;
            }
        }
        if (!paragraph.equals(end.paragraph)) {
            this.applyCharFormatValue(paragraph.characterFormat, property, value, update);
            endOffset = length;
        }
        else {
            let lastLine = paragraph.childWidgets[paragraph.childWidgets.length - 1];
            if (selection.isParagraphLastLine(lastLine) && end.currentWidget === lastLine
                && ((endOffset === selection.getLineLength(lastLine) + 1) || (selection.isEmpty && selection.end.isAtParagraphEnd))) {
                this.applyCharFormatValue(paragraph.characterFormat, property, value, update);
            }
        }
        // let count: number = 0;
        for (let i = startLineWidget; i <= endLineWidget; i++) {
            let line = paragraph.childWidgets[i];
            if (i !== startLineWidget) {
                startOffset = selection.getStartLineOffset(line);
            }
            if (line === end.currentWidget) {
                endOffset = end.offset;
            }
            else {
                endOffset = selection.getLineLength(line);
            }
            let count = 0;
            for (let j = 0; j < line.children.length; j++) {
                let inlineObj = line.children[j];
                if (inlineObj instanceof ListTextElementBox) {
                    continue;
                }
                if (startOffset >= count + inlineObj.length) {
                    count += inlineObj.length;
                    continue;
                }
                let startIndex = 0;
                if (startOffset > count) {
                    startIndex = startOffset - count;
                }
                let endIndex = endOffset - count;
                let inlineLength = inlineObj.length;
                if (endIndex > inlineLength) {
                    endIndex = inlineLength;
                }
                j += this.applyCharFormatInline(inlineObj, selection, startIndex, endIndex, property, value, update);
                if (endOffset <= count + inlineLength) {
                    break;
                }
                count += inlineLength;
            }
        }
        let endParagraph = end.paragraph;
        this.viewer.layout.reLayoutParagraph(paragraph, startLineWidget, 0);
        if (paragraph.equals(endParagraph)) {
            return;
        }
        this.getNextParagraphForCharacterFormatting(paragraph, start, end, property, value, update);
    }
    /**
     * Toggles the bold property of selected contents.
     */
    toggleBold() {
        if (this.viewer.owner.isReadOnlyMode) {
            return;
        }
        let value = this.getCurrentSelectionValue('bold');
        this.selection.characterFormat.bold = value;
    }
    /**
     * Toggles the bold property of selected contents.
     */
    toggleItalic() {
        if (this.viewer.owner.isReadOnlyMode) {
            return;
        }
        let value = this.getCurrentSelectionValue('italic');
        this.selection.characterFormat.italic = value;
    }
    getCurrentSelectionValue(property) {
        let value = false;
        if ((property === 'bold' || property === 'italic')) {
            let index = 0;
            let start = this.selection.start;
            if (!this.selection.isForward) {
                start = this.selection.end;
            }
            let lineWidget = start.currentWidget;
            let inlineObj = lineWidget.getInline(start.offset, index);
            let inline = inlineObj.element;
            // inline.ownerBase
            index = inlineObj.index;
            let characterFormat = lineWidget.paragraph.characterFormat;
            if (!isNullOrUndefined(inline)) {
                if (!this.selection.isEmpty && index === inline.length) {
                    characterFormat = isNullOrUndefined(inline.nextNode) ? lineWidget.paragraph.characterFormat
                        : inline.nextNode.characterFormat;
                }
                else {
                    characterFormat = inline.characterFormat;
                }
            }
            if (property === 'bold') {
                value = !(characterFormat.bold);
            }
            if (property === 'italic') {
                value = !(characterFormat.italic);
            }
        }
        return value;
    }
    /**
     * Toggles the underline property of selected contents.
     * @param underline Default value of ‘underline’ parameter is Single.
     */
    toggleUnderline(underline) {
        if (!this.owner.isReadOnlyMode) {
            this.updateProperty(1, underline);
        }
    }
    /**
     * Toggles the strike through property of selected contents.
     * @param {Strikethrough} strikethrough Default value of strikethrough parameter is SingleStrike.
     */
    toggleStrikethrough(strikethrough) {
        if (!this.owner.isReadOnlyMode) {
            let value;
            if (isNullOrUndefined(strikethrough)) {
                value = this.selection.characterFormat.strikethrough === 'SingleStrike' ? 'None' : 'SingleStrike';
            }
            else {
                value = strikethrough;
            }
            this.selection.characterFormat.strikethrough = value;
        }
    }
    updateFontSize(format, value) {
        if (typeof (value) === 'number' && !(value < 0 && format.fontSize === 1)) {
            return format.fontSize + value;
        }
        let fontsizeCollection = [8, 9, 10, 11, 12, 14, 16, 18, 20, 24, 26, 28, 36, 48, 72];
        if (typeof (value) === 'string' && value === 'increment') {
            if (format.fontSize < 8) {
                return format.fontSize + 1;
            }
            else if (format.fontSize >= 72 && format.fontSize < 80) {
                return 80;
            }
            else if (format.fontSize >= 80) {
                return format.fontSize + 10;
            }
            else {
                for (let i = 0; i < fontsizeCollection.length; i++) {
                    if (format.fontSize < fontsizeCollection[i]) {
                        return fontsizeCollection[i];
                    }
                }
            }
        }
        else if (typeof (value) === 'string' && value === 'decrement' && format.fontSize > 1) {
            if (format.fontSize <= 8) {
                return format.fontSize - 1;
            }
            else if (format.fontSize > 72 && format.fontSize <= 80) {
                return 72;
            }
            else if (format.fontSize > 80) {
                return format.fontSize - 10;
            }
            else {
                for (let i = 0; i < fontsizeCollection.length; i++) {
                    if (format.fontSize <= fontsizeCollection[i]) {
                        return fontsizeCollection[i - 1];
                    }
                }
            }
        }
        return format.fontSize;
    }
    // Inline
    // tslint:disable-next-line:max-line-length
    applyCharFormatInline(inline, selection, startIndex, endIndex, property, value, update) {
        if (startIndex === 0 && endIndex === inline.length) {
            this.applyCharFormatValue(inline.characterFormat, property, value, update);
            return 0;
        }
        else if (inline instanceof TextElementBox) {
            return this.formatInline(inline, selection, startIndex, endIndex, property, value, update);
        }
        return 0;
    }
    // tslint:disable-next-line:max-line-length
    formatInline(inline, selection, startIndex, endIndex, property, value, update) {
        let x = 0;
        let node = inline;
        let index = inline.line.children.indexOf(node);
        let paragraph = inline.paragraph;
        let lineIndex = paragraph.childWidgets.indexOf(inline.line);
        let textElement;
        if (startIndex > 0) {
            textElement = new TextElementBox();
            textElement.characterFormat.copyFormat(inline.characterFormat);
            textElement.line = inline.line;
            textElement.text = inline.text.substr(startIndex, endIndex - startIndex);
            this.applyCharFormatValue(textElement.characterFormat, property, value, update);
            index++;
            node.line.children.splice(index, 0, textElement);
            x++;
            // this.addToLinkedFields(span);                      
        }
        if (endIndex < node.length) {
            textElement = new TextElementBox();
            textElement.characterFormat.copyFormat(inline.characterFormat);
            textElement.text = node.text.substring(endIndex);
            textElement.line = inline.line;
            index++;
            node.line.children.splice(index, 0, textElement);
            x++;
            // this.addToLinkedFields(span);                       
        }
        if (startIndex === 0) {
            inline.text = inline.text.substr(0, endIndex);
            this.applyCharFormatValue(inline.characterFormat, property, value, update);
        }
        else {
            inline.text = inline.text.substr(0, startIndex);
        }
        return x;
    }
    // Cell
    // tslint:disable-next-line:max-line-length
    applyCharFormatCell(cell, selection, start, end, property, value, update) {
        if (end.paragraph.isInsideTable) {
            let containerCell = selection.getContainerCellOf(cell, end.paragraph.associatedCell);
            if (containerCell.ownerTable.contains(end.paragraph.associatedCell)) {
                let startCell = selection.getSelectedCell(cell, containerCell);
                let endCell = selection.getSelectedCell(end.paragraph.associatedCell, containerCell);
                if (selection.containsCell(containerCell, end.paragraph.associatedCell)) {
                    //Selection end is in container cell.
                    if (selection.isCellSelected(containerCell, start, end)) {
                        value = this.getCharacterFormatValueOfCell(cell, selection, value, property);
                        this.applyCharFormatForSelectedCell(containerCell, selection, property, value, update);
                    }
                    else {
                        if (startCell === containerCell) {
                            this.applyCharFormat(start.paragraph, selection, start, end, property, value, update);
                        }
                        else {
                            this.applyCharFormatRow(startCell.ownerRow, selection, start, end, property, value, update);
                        }
                    }
                }
                else {
                    this.applyCharFormatForTableCell(containerCell.ownerTable, selection, containerCell, endCell, property, value, update);
                }
            }
            else {
                this.applyCharFormatRow(containerCell.ownerRow, selection, start, end, property, value, update);
            }
        }
        else {
            let tableCell = selection.getContainerCell(cell);
            this.applyCharFormatRow(tableCell.ownerRow, selection, start, end, property, value, update);
        }
    }
    // tslint:disable-next-line:max-line-length
    applyCharFormatForSelectedCell(cell, selection, property, value, update) {
        for (let i = 0; i < cell.childWidgets.length; i++) {
            let block = cell.childWidgets[i];
            if (block instanceof ParagraphWidget) {
                this.applyCharFormatForSelectedPara(block, selection, property, value, update);
            }
            else {
                this.applyCharFormatForSelTable(block, selection, property, value, update);
            }
        }
    }
    // Row
    // tslint:disable-next-line:max-line-length
    applyCharFormatRow(row, selection, start, end, property, value, update) {
        value = this.getCharacterFormatValueOfCell(row.childWidgets[0], selection, value, property);
        this.applyCharFormatForTable(row.rowIndex, row.ownerTable, selection, start, end, property, value, update);
    }
    // Table
    // tslint:disable-next-line:max-line-length
    applyCharFormatForTable(index, table, selection, start, end, property, value, update) {
        table = table.combineWidget(this.viewer);
        for (let i = index; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                this.applyCharFormatForSelectedCell(row.childWidgets[j], selection, property, value, update);
            }
            if (end.paragraph.isInsideTable && selection.containsRow(row, end.paragraph.associatedCell)) {
                this.viewer.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
                return;
            }
        }
        this.viewer.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
        this.getNextParagraphForCharacterFormatting(table, start, end, property, value, update);
    }
    // tslint:disable-next-line:max-line-length
    applyCharFormatForSelTable(tableWidget, selection, property, value, update) {
        for (let i = 0; i < tableWidget.childWidgets.length; i++) {
            let row = tableWidget.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                this.applyCharFormatForSelectedCell(row.childWidgets[j], selection, property, value, update);
            }
        }
    }
    // tslint:disable-next-line:max-line-length
    applyCharFormatForTableCell(table, selection, startCell, endCell, property, value, update) {
        let startCellLeft = selection.getCellLeft(startCell.ownerRow, startCell);
        let startCellRight = startCellLeft + startCell.cellFormat.cellWidth;
        let endCellLeft = selection.getCellLeft(endCell.ownerRow, endCell);
        let endCellRight = endCellLeft + endCell.cellFormat.cellWidth;
        let cellInfo = this.updateSelectedCellsInTable(startCellLeft, startCellRight, endCellLeft, endCellRight);
        startCellLeft = cellInfo.start;
        startCellRight = cellInfo.end;
        let count = table.childWidgets.indexOf(endCell.ownerRow);
        let isStarted = false;
        for (let i = table.childWidgets.indexOf(startCell.ownerRow); i <= count; i++) {
            let row = table.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                let left = selection.getCellLeft(row, row.childWidgets[j]);
                if (HelperMethods.round(startCellLeft, 2) <= HelperMethods.round(left, 2) &&
                    HelperMethods.round(left, 2) < HelperMethods.round(startCellRight, 2)) {
                    if (!isStarted) {
                        value = this.getCharacterFormatValueOfCell(row.childWidgets[j], selection, value, property);
                        isStarted = true;
                    }
                    this.applyCharFormatForSelectedCell(row.childWidgets[j], selection, property, value, update);
                }
            }
        }
    }
    updateSelectedCellsInTable(start, end, endCellLeft, endCellRight) {
        let selection = this.viewer.selection;
        if (start > endCellLeft) {
            start = endCellLeft;
        }
        if (end < endCellRight) {
            end = endCellRight;
        }
        if (start > selection.upDownSelectionLength) {
            start = selection.upDownSelectionLength;
        }
        if (end < selection.upDownSelectionLength) {
            end = selection.upDownSelectionLength;
        }
        return { start: start, end: end };
    }
    getCharacterFormatValueOfCell(cell, selection, value, property) {
        if (typeof (value) === 'boolean' || (value === undefined && (property === 'bold' || property === 'italic'))) {
            let firstParagraph = selection.getFirstParagraph(cell);
            let format = firstParagraph.characterFormat;
            if (firstParagraph.childWidgets.length > 0 && firstParagraph.childWidgets[0].children.length > 0) {
                format = firstParagraph.childWidgets[0].children[0].characterFormat;
            }
            value = !format.getPropertyValue(property);
        }
        return value;
    }
    /**
     * Apply Character format for selection
     * @private
     */
    applyCharFormatValueInternal(selection, format, property, value) {
        this.applyCharFormatValue(format, property, value, false);
    }
    copyInlineCharacterFormat(sourceFormat, destFormat) {
        destFormat.uniqueCharacterFormat = sourceFormat.uniqueCharacterFormat;
        destFormat.baseCharStyle = sourceFormat.baseCharStyle;
    }
    applyCharFormatValue(format, property, value, update) {
        if (update && property === 'fontSize') {
            value = this.updateFontSize(format, value);
        }
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedProperties(format, property, value);
        }
        if (value instanceof WCharacterFormat) {
            if (this.editorHistory && (this.editorHistory.isUndoing || this.editorHistory.isRedoing)) {
                this.copyInlineCharacterFormat(value, format);
            }
            else {
                format.copyFormat(value);
            }
            return;
        }
        if (isNullOrUndefined(value)) {
            format.clearFormat();
            return;
        }
        if (property === 'bold') {
            format.bold = value;
        }
        else if (property === 'italic') {
            format.italic = value;
        }
        else if (property === 'fontColor') {
            format.fontColor = value;
        }
        else if (property === 'fontFamily') {
            format.fontFamily = value;
        }
        else if (property === 'fontSize') {
            format.fontSize = value;
        }
        else if (property === 'highlightColor') {
            format.highlightColor = value;
        }
        else if (property === 'baselineAlignment') {
            format.baselineAlignment = value;
        }
        else if (property === 'strikethrough') {
            format.strikethrough = value;
        }
        else if (property === 'underline') {
            format.underline = value;
        }
        else if (property === 'styleName') {
            format.baseCharStyle = value;
        }
    }
    /**
     * @private
     */
    onImageFormat(elementBox, width, height) {
        let modifiedFormat = new ImageFormat(elementBox);
        if (this.editorHistory) {
            this.editorHistory.initializeHistory('ImageResizing');
            this.editorHistory.currentBaseHistoryInfo.modifiedProperties.push(modifiedFormat);
        }
        this.setOffsetValue(this.selection);
        elementBox.width = width;
        elementBox.height = height;
        // tslint:disable-next-line:max-line-length
        this.viewer.layout.reLayoutParagraph(elementBox.line.paragraph, elementBox.line.indexInOwner, 0);
        this.reLayout(this.selection, false);
        if (this.viewer.owner.imageResizerModule) {
            this.viewer.owner.imageResizerModule.positionImageResizer(elementBox);
        }
    }
    /**
     * Toggles the text alignment of selected paragraphs.
     * @param  {TextAlignment} textAlignment
     */
    toggleTextAlignment(textAlignment) {
        if (this.viewer.owner.isReadOnlyMode || !this.viewer.owner.isDocumentLoaded) {
            return;
        }
        // Toggle performed based on current selection format similar to MS word behavior.
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(this.viewer.selection.paragraphFormat.textAlignment) && this.viewer.selection.paragraphFormat.textAlignment === textAlignment) {
            if (textAlignment === 'Left') {
                this.onApplyParagraphFormat('textAlignment', 'Justify', false, true);
            }
            else {
                this.onApplyParagraphFormat('textAlignment', 'Left', false, true);
            }
        }
        else {
            this.onApplyParagraphFormat('textAlignment', textAlignment, false, true);
        }
    }
    /**
     * Applies paragraph format for the selection ranges.
     * @param {string} property
     * @param {Object} value
     * @param {boolean} update
     * @param {boolean} isSelectionChanged
     * @private
     */
    onApplyParagraphFormat(property, value, update, isSelectionChanged) {
        let action = (property[0].toUpperCase() + property.slice(1));
        this.viewer.owner.isShiftingEnabled = true;
        let selection = this.viewer.selection;
        this.initHistory(action);
        if (this.viewer.owner.isReadOnlyMode || !this.viewer.owner.isDocumentLoaded) {
            return;
        }
        if (property === 'leftIndent') {
            if (selection.paragraphFormat.listId !== -1 && update) {
                this.updateListLevel(value > 0);
                return;
            }
        }
        if (selection.isEmpty) {
            this.setOffsetValue(selection);
            if (update && property === 'leftIndent') {
                value = this.getIndentIncrementValue(selection.start.paragraph, value);
            }
            let para = selection.start.paragraph.combineWidget(this.viewer);
            this.applyParaFormatProperty(para, property, value, update);
            this.layoutItemBlock(para, false);
        }
        else {
            //Iterate and update formatting's.      
            this.setOffsetValue(selection);
            this.updateSelectionParagraphFormatting(property, value, update);
        }
        this.reLayout(selection);
    }
    /**
     * Update the list level
     * @param  {boolean} increaseLevel
     * @private
     */
    updateListLevel(increaseLevel) {
        // Increment or Decrement list level for Multilevel lists.
        let viewer = this.viewer;
        let listFormat = this.viewer.selection.start.paragraph.paragraphFormat.listFormat;
        let paragraphFormat = this.viewer.selection.start.paragraph.paragraphFormat;
        let list = viewer.getListById(paragraphFormat.listFormat.listId);
        let listLevel = viewer.layout.getListLevel(list, paragraphFormat.listFormat.listLevelNumber);
        let levelNumber;
        if (increaseLevel) {
            levelNumber = paragraphFormat.listFormat.listLevelNumber + 1;
        }
        else {
            levelNumber = paragraphFormat.listFormat.listLevelNumber - 1;
        }
        let nextListLevel = viewer.layout.getListLevel(list, levelNumber);
        if (!isNullOrUndefined(nextListLevel)) {
            this.onApplyListInternal(list, levelNumber);
            viewer.selection.start.updatePhysicalPosition(true);
            viewer.selection.end.updatePhysicalPosition(true);
            viewer.selection.updateCaretPosition();
        }
    }
    /**
     * Applies list
     * @param  {WList} list
     * @param  {number} listLevelNumber
     * @private
     */
    onApplyListInternal(list, listLevelNumber) {
        let selection = this.viewer.selection;
        let listFormat = new WListFormat();
        if (!isNullOrUndefined(list) && listLevelNumber >= 0 && listLevelNumber < 9) {
            listFormat.listId = list.listId;
            listFormat.listLevelNumber = listLevelNumber;
        }
        this.onApplyParagraphFormat('listFormat', listFormat, false, false);
    }
    /**
     * Apply paragraph format to selection range
     * @private
     */
    updateSelectionParagraphFormatting(property, value, update) {
        let selection = this.viewer.selection;
        if (property === 'leftIndent' && update) {
            if (!isNullOrUndefined(selection.start) && selection.start.isExistBefore(selection.end)) {
                value = this.getIndentIncrementValue(selection.start.paragraph, value);
            }
            else {
                value = this.getIndentIncrementValue(selection.end.paragraph, value);
            }
        }
        this.updateParagraphFormatInternal(property, value, update);
    }
    getIndentIncrementValue(currentParagraph, incrementFactor) {
        let currentParagraphIndent = currentParagraph.paragraphFormat.leftIndent;
        if (currentParagraphIndent < 0) {
            // In MS Word, if the current paragraph left indent is lesser that or equal to 0
            // then performing decrement indent will set left indent to 0. 
            if (incrementFactor < 0 || currentParagraphIndent + incrementFactor >= 0) {
                return -currentParagraphIndent;
            }
            else {
                let incrementValue = -this.getIndentIncrementValueInternal(-currentParagraphIndent, -incrementFactor);
                return incrementValue % incrementFactor === 0 ? incrementValue : incrementValue + incrementFactor;
            }
        }
        else {
            return this.getIndentIncrementValueInternal(currentParagraphIndent, incrementFactor);
        }
    }
    getIndentIncrementValueInternal(position, incrementFactor) {
        let tabValue = Math.abs(incrementFactor);
        if (position === 0 || tabValue === 0) {
            return incrementFactor > 0 ? tabValue : 0;
        }
        else {
            let diff = ((Math.round(position) * 100) % (Math.round(tabValue) * 100)) / 100;
            let cnt = (Math.round(position) - diff) / Math.round(tabValue);
            let fPosition = cnt * tabValue;
            if (incrementFactor > 0) {
                fPosition += tabValue;
            }
            return (fPosition - position) === 0 ? incrementFactor : fPosition - position;
        }
    }
    updateParagraphFormatInternal(property, value, update) {
        if (isNullOrUndefined(property)) {
            property = 'ParagraphFormat';
        }
        switch (property) {
            case 'afterSpacing':
                this.updateParagraphFormat('afterSpacing', value, false);
                break;
            case 'beforeSpacing':
                this.updateParagraphFormat('beforeSpacing', value, false);
                break;
            case 'rightIndent':
                this.updateParagraphFormat('rightIndent', value, false);
                break;
            case 'leftIndent':
                this.updateParagraphFormat('leftIndent', value, update);
                break;
            case 'firstLineIndent':
                this.updateParagraphFormat('firstLineIndent', value, false);
                break;
            case 'lineSpacing':
                this.updateParagraphFormat('lineSpacing', value, false);
                break;
            case 'lineSpacingType':
                this.updateParagraphFormat('lineSpacingType', value, false);
                break;
            case 'textAlignment':
                this.updateParagraphFormat('textAlignment', value, false);
                break;
            case 'listFormat':
                this.updateParagraphFormat('listFormat', value, false);
                break;
            case 'ParagraphFormat':
                this.updateParagraphFormat(undefined, value, false);
                break;
            case 'styleName':
                this.updateParagraphFormat('styleName', value, false);
                break;
            case 'ClearParagraphFormat':
                // this.initializeHistory('ClearParagraphFormat', selectionRange);
                this.updateParagraphFormat(undefined, value, false);
                break;
        }
    }
    /**
     * Update paragraph format on undo
     * @param  {SelectionRange} selectionRange
     * @param  {string} property
     * @param  {Object} value
     * @param  {boolean} update
     * @private
     */
    updateParagraphFormat(property, value, update) {
        let selection = this.viewer.selection;
        let startPosition = selection.start;
        let endPosition = selection.end;
        if (!selection.isForward) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        // this.updateInsertPosition(selection, startPosition);
        this.applyParaFormatSelectedContent(startPosition, endPosition, property, value, update);
        // this.startSelectionReLayouting(startPosition.paragraph, selection, startPosition, endPosition);
    }
    applyParaFormatSelectedContent(start, end, property, value, update) {
        let selection = this.viewer.selection;
        if (start.paragraph.isInsideTable && (!end.paragraph.isInsideTable
            || start.paragraph.associatedCell !== end.paragraph.associatedCell
            || selection.isCellSelected(start.paragraph.associatedCell, start, end))) {
            let cell;
            start.paragraph.associatedCell.ownerTable.combineWidget(this.viewer);
            if (this.checkInsertPosition(selection)) {
                this.updateHistoryPosition(start, true);
            }
            cell = start.paragraph.associatedCell;
            this.applyParaFormatInCell(cell, start, end, property, value, update);
            let table = cell.ownerTable;
            this.viewer.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
        }
        else {
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(value) && !this.selection.isEmpty && property === 'styleName' && this.applyCharacterStyle(start.paragraph, start, end, property, value, update)) {
                return;
            }
            else {
                this.applyParaFormat(start.paragraph, start, end, property, value, update);
            }
        }
    }
    /**
     * Apply Paragraph format
     * @private
     */
    applyParaFormatProperty(paragraph, property, value, update) {
        let format = paragraph.paragraphFormat;
        if (update && property === 'leftIndent') {
            value = format.leftIndent + value;
        }
        if (property === 'listFormat' && value instanceof WListFormat) {
            let listFormat = value;
            if (!listFormat.hasValue('listLevelNumber')) {
                listFormat.listLevelNumber = format.listFormat.listLevelNumber;
            }
        }
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedPropertiesForParagraphFormat(format, property, value);
        }
        if (value instanceof WParagraphFormat) {
            if (isNullOrUndefined(property)) {
                if (this.editorHistory && (this.editorHistory.isUndoing || this.editorHistory.isRedoing)) {
                    this.copyParagraphFormat(value, format);
                }
                else {
                    format.copyFormat(value);
                }
            }
            else if (property === 'listFormat') {
                format.listFormat = value.listFormat;
                // this.handleListFormat(format, value as WParagraphFormat);
            }
        }
        if (isNullOrUndefined(value)) {
            format.clearFormat();
            this.viewer.layout.reLayoutParagraph(format.ownerBase, 0, 0);
            return;
        }
        if (property === 'afterSpacing') {
            format.afterSpacing = value;
        }
        else if (property === 'beforeSpacing') {
            format.beforeSpacing = value;
        }
        else if (property === 'leftIndent') {
            format.leftIndent = value;
        }
        else if (property === 'lineSpacingType') {
            format.lineSpacingType = value;
        }
        else if (property === 'lineSpacing') {
            format.lineSpacing = value;
        }
        else if (property === 'rightIndent') {
            format.rightIndent = value;
        }
        else if (property === 'firstLineIndent') {
            format.firstLineIndent = value;
        }
        else if (property === 'textAlignment') {
            format.textAlignment = value;
            this.viewer.layout.allowLayout = false;
        }
        else if (property === 'styleName') {
            if (typeof (value) === 'string') {
                value = this.viewer.styles.findByName(value);
            }
            format.ApplyStyle(value);
        }
        else if (property === 'listFormat') {
            if (value instanceof WParagraphFormat) {
                this.copyFromListLevelParagraphFormat(format, value);
                value = value.listFormat;
            }
            format.listFormat.copyFormat(value);
            this.viewer.layout.clearListElementBox(format.ownerBase);
            this.onListFormatChange(format.ownerBase, value, format);
            this.layoutItemBlock(format.ownerBase, false);
            return;
        }
    }
    copyParagraphFormat(sourceFormat, destFormat) {
        destFormat.uniqueParagraphFormat = sourceFormat.uniqueParagraphFormat;
        destFormat.listFormat = sourceFormat.listFormat;
        destFormat.baseStyle = sourceFormat.baseStyle;
    }
    onListFormatChange(paragraph, listFormat, paraFormat) {
        if (listFormat instanceof WListFormat) {
            this.updateListParagraphFormat(paragraph, listFormat);
        }
    }
    updateListParagraphFormat(paragraph, listFormat) {
        let list = this.viewer.getListById(listFormat.listId);
        let listlevel = undefined;
        if (!isNullOrUndefined(list)) {
            listlevel = this.viewer.layout.getListLevel(list, listFormat.listLevelNumber);
        }
        let isUpdateIndent = !this.editorHistory || (this.editorHistory && !this.editorHistory.isUndoing);
        if (isUpdateIndent) {
            if (paragraph instanceof ParagraphWidget && !isNullOrUndefined(listlevel)
                && !isNullOrUndefined(listlevel.paragraphFormat) && !isNullOrUndefined(paragraph.containerWidget)) {
                this.copyFromListLevelParagraphFormat(paragraph.paragraphFormat, listlevel.paragraphFormat);
            }
            else if (isNullOrUndefined(list)) {
                paragraph.paragraphFormat.leftIndent = undefined;
                paragraph.paragraphFormat.firstLineIndent = undefined;
            }
        }
    }
    /**
     * Copies list level paragraph format
     * @param  {WParagraphFormat} oldFormat
     * @param  {WParagraphFormat} newFormat
     * @private
     */
    copyFromListLevelParagraphFormat(oldFormat, newFormat) {
        if (!isNullOrUndefined(newFormat.leftIndent)) {
            oldFormat.leftIndent = newFormat.leftIndent;
        }
        if (!isNullOrUndefined(newFormat.firstLineIndent)) {
            oldFormat.firstLineIndent = newFormat.firstLineIndent;
        }
    }
    /**
     * @private
     */
    applyContinueNumbering(selection) {
        this.editorHistory.initializeHistory('ContinueNumbering');
        this.applyContinueNumberingInternal(selection);
    }
    /**
     * @private
     */
    applyContinueNumberingInternal(selection) {
        let paragraph = selection.start.paragraph;
        let numberingInfo = this.getContinueNumberingInfo(paragraph);
        let paraFormat = this.getParagraphFormat(paragraph, numberingInfo.listLevelNumber, numberingInfo.listPattern);
        this.changeListId(numberingInfo.currentList, paragraph, paraFormat, numberingInfo.listLevelNumber, numberingInfo.listPattern);
        this.reLayout(selection, false);
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            this.editorHistory.updateHistory();
        }
        this.viewer.updateFocus();
    }
    /**
     * @private
     */
    getContinueNumberingInfo(paragraph) {
        let currentList = undefined;
        let listLevelNumber = 0;
        let listPattern = 'None';
        if (!isNullOrUndefined(paragraph.paragraphFormat)
            && !isNullOrUndefined(paragraph.paragraphFormat.listFormat)) {
            currentList = this.viewer.getListById(paragraph.paragraphFormat.listFormat.listId);
            listLevelNumber = paragraph.paragraphFormat.listFormat.listLevelNumber;
        }
        let viewer = this.viewer;
        if (listLevelNumber !== 0 && !isNullOrUndefined(currentList) &&
            !isNullOrUndefined(viewer.getAbstractListById(currentList.abstractListId))
            && !isNullOrUndefined(viewer.getAbstractListById(currentList.abstractListId).levels[listLevelNumber])) {
            let listLevel = this.viewer.layout.getListLevel(currentList, listLevelNumber);
            if (!isNullOrUndefined(listLevel)) {
                listPattern = listLevel.listLevelPattern;
            }
        }
        return {
            currentList: currentList,
            listLevelNumber: listLevelNumber,
            listPattern: listPattern
        };
    }
    /**
     * @private
     */
    revertContinueNumbering(selection, format) {
        let paragraph = selection.start.paragraph;
        let numberingInfo = this.getContinueNumberingInfo(paragraph);
        this.changeListId(numberingInfo.currentList, paragraph, format, numberingInfo.listLevelNumber, numberingInfo.listPattern);
        this.reLayout(selection, false);
        if (!isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            this.editorHistory.updateHistory();
        }
    }
    changeListId(list, block, format, levelNum, listType) {
        if (isNullOrUndefined(block)) {
            return;
        }
        if (block instanceof ParagraphWidget) {
            if (list.listId === block.paragraphFormat.listFormat.listId
                && levelNum === block.paragraphFormat.listFormat.listLevelNumber) {
                let baseHistoryInfo = this.editorHistory.currentBaseHistoryInfo;
                if (!isNullOrUndefined(baseHistoryInfo)) {
                    format = baseHistoryInfo.addModifiedPropertiesForContinueNumbering(block.paragraphFormat, format);
                }
                block.paragraphFormat.copyFormat(format);
                this.viewer.layout.reLayoutParagraph(block, 0, 0);
            }
        }
        return this.changeListId(list, block.nextRenderedWidget, format, levelNum, listType);
    }
    getParagraphFormat(paragraph, levelNumber, listType) {
        if (!isNullOrUndefined(paragraph.previousRenderedWidget)) {
            if (paragraph.previousRenderedWidget instanceof ParagraphWidget) {
                if (!isNullOrUndefined(paragraph.previousRenderedWidget.paragraphFormat.listFormat)
                    && paragraph.previousRenderedWidget.paragraphFormat.listFormat.listId !== -1) {
                    let listLevel = this.getListLevel(paragraph.previousRenderedWidget);
                    if (levelNumber === 0) {
                        return paragraph.previousRenderedWidget.paragraphFormat;
                    }
                    else if (listType === listLevel.listLevelPattern
                        || this.checkNumberArabic(listType, listLevel.listLevelPattern)) {
                        return paragraph.previousRenderedWidget.paragraphFormat;
                    }
                    else {
                        return this.getParagraphFormat(paragraph.previousRenderedWidget, levelNumber, listType);
                    }
                }
                else {
                    return this.getParagraphFormat(paragraph.previousRenderedWidget, levelNumber, listType);
                }
            }
        }
        return undefined;
    }
    checkNumberArabic(listType, levelPattern) {
        if ((listType === 'Number' && levelPattern === 'Arabic')
            || (levelPattern === 'Number' && listType === 'Arabic')) {
            return true;
        }
        return false;
    }
    /**
     * @private
     */
    applyRestartNumbering(selection) {
        this.editorHistory.initializeHistory('RestartNumbering');
        this.restartListAt(selection);
    }
    /**
     * @private
     */
    restartListAt(selection) {
        let currentListLevel = this.getListLevel(selection.start.paragraph);
        let list = new WList();
        list.listId = this.viewer.lists[(this.viewer.lists.length - 1)].listId + 1;
        let abstractList = new WAbstractList();
        abstractList.abstractListId = this.viewer.abstractLists[(this.viewer.abstractLists.length - 1)].abstractListId + 1;
        list.abstractListId = abstractList.abstractListId;
        this.viewer.abstractLists.push(abstractList);
        this.createListLevels(abstractList, currentListLevel, list);
        this.viewer.lists.push(list);
        this.restartListAtInternal(selection, list.listId);
    }
    /**
     * @private
     */
    restartListAtInternal(selection, listId) {
        let numberingInfo = this.getContinueNumberingInfo(selection.start.paragraph);
        this.changeRestartNumbering(numberingInfo.currentList, selection.start.paragraph, listId);
        this.reLayout(selection, false);
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            this.editorHistory.updateHistory();
        }
        this.incrementListNumber = -1;
        this.refListNumber = undefined;
        this.viewer.updateFocus();
    }
    changeRestartNumbering(list, block, listId) {
        if (isNullOrUndefined(block)) {
            return;
        }
        if (block instanceof ParagraphWidget) {
            if (list.listId === block.paragraphFormat.listFormat.listId) {
                let baseHistoryInfo = this.editorHistory.currentBaseHistoryInfo;
                if (!isNullOrUndefined(baseHistoryInfo)) {
                    listId = baseHistoryInfo.addModifiedPropertiesForRestartNumbering(block.paragraphFormat.listFormat, listId);
                }
                block.paragraphFormat.listFormat.listId = listId;
                if (this.refListNumber !== block.paragraphFormat.listFormat.listLevelNumber) {
                    this.incrementListNumber += 1;
                    this.refListNumber = block.paragraphFormat.listFormat.listLevelNumber;
                }
                block.paragraphFormat.listFormat.listLevelNumber = this.incrementListNumber;
                this.viewer.layout.reLayoutParagraph(block, 0, 0);
            }
        }
        return this.changeRestartNumbering(list, block.nextRenderedWidget, listId);
    }
    createListLevels(abstractList, currentListLevel, list) {
        let levelPattern = currentListLevel.listLevelPattern;
        let levelPatterns = [];
        let currentAbstractList = currentListLevel.ownerBase;
        for (let i = 0; i < 3; i++) {
            let listLevel = currentAbstractList.levels[i];
            if (!isNullOrUndefined(listLevel)) {
                levelPatterns.push(listLevel.listLevelPattern);
            }
        }
        let indexOfLevelPattern = levelPatterns.indexOf(levelPattern) === -1 ? 0 : levelPatterns.indexOf(levelPattern);
        for (let i = 0; i < currentAbstractList.levels.length; i++) {
            let listLevel = new WListLevel(abstractList);
            if (i === 0) {
                listLevel.listLevelPattern = levelPattern;
            }
            else {
                if (indexOfLevelPattern === 0 || indexOfLevelPattern < levelPatterns.length - 1) {
                    indexOfLevelPattern++;
                }
                else {
                    indexOfLevelPattern = 0;
                }
                listLevel.listLevelPattern = levelPatterns[indexOfLevelPattern];
            }
            listLevel.numberFormat = '%' + (i + 1) + '.';
            listLevel.startAt = 1;
            listLevel.characterFormat.copyFormat(currentListLevel.characterFormat);
            listLevel.paragraphFormat.copyFormat(currentListLevel.paragraphFormat);
            listLevel.restartLevel = i;
            abstractList.levels.push(listLevel);
        }
    }
    // tslint:disable-next-line:max-line-length
    applyParaFormat(paragraph, start, end, property, value, update) {
        this.setOffsetValue(this.selection);
        paragraph = paragraph.combineWidget(this.viewer);
        //Apply Paragraph Format for spitted paragraph
        this.applyParaFormatProperty(paragraph, property, value, update);
        this.layoutItemBlock(paragraph, false);
        this.getOffsetValue(this.selection);
        if (paragraph.equals(end.paragraph)) {
            return;
        }
        this.getNextParagraphForFormatting(paragraph, start, end, property, value, update);
    }
    /* tslint:disable-next-line:max-line-length */
    applyCharacterStyle(paragraph, start, end, property, value, update) {
        let paragraphWidget = paragraph.getSplitWidgets();
        if ((end.paragraph === paragraph || paragraphWidget.indexOf(end.paragraph) !== -1)) {
            if (((value.type === 'Paragraph') && ((value.link) instanceof WCharacterStyle)) || (value.type === 'Character')) {
                let obj = (value.type === 'Character') ? value : value.link;
                this.updateSelectionCharacterFormatting(property, obj, update);
                return true;
            }
        }
        return false;
    }
    // Cell
    // tslint:disable-next-line:max-line-length
    applyParaFormatInCell(cell, start, end, property, value, update) {
        let selection = this.viewer.selection;
        if (end.paragraph.isInsideTable) {
            let cellContainer = selection.getContainerCellOf(cell, end.paragraph.associatedCell);
            if (cellContainer.ownerTable.contains(end.paragraph.associatedCell)) {
                let startCell = selection.getSelectedCell(cell, cellContainer);
                let endCell = selection.getSelectedCell(end.paragraph.associatedCell, cellContainer);
                if (selection.containsCell(cellContainer, end.paragraph.associatedCell)) {
                    //Selection end is in container cell.
                    if (selection.isCellSelected(cellContainer, start, end)) {
                        value = this.getParaFormatValueInCell(cellContainer, property, value);
                        this.applyParaFormatCellInternal(cellContainer, property, value, update);
                    }
                    else {
                        if (startCell === cellContainer) {
                            this.applyParaFormat(start.paragraph, start, end, property, value, update);
                        }
                        else {
                            this.applyParagraphFormatRow(startCell.ownerRow, start, end, property, value, update);
                        }
                    }
                }
                else {
                    //Format other selected cells in current table.
                    this.applyParaFormatTableCell(cellContainer.ownerTable, cellContainer, endCell, property, value, update);
                }
            }
            else {
                this.applyParagraphFormatRow(cellContainer.ownerRow, start, end, property, value, update);
            }
        }
        else {
            let wCell = selection.getContainerCell(cell);
            this.applyParagraphFormatRow(wCell.ownerRow, start, end, property, value, update);
        }
    }
    applyParaFormatCellInternal(cell, property, value, update) {
        for (let i = 0; i < cell.childWidgets.length; i++) {
            let block = cell.childWidgets[i];
            if (block instanceof ParagraphWidget) {
                this.applyParaFormatProperty(block, property, value, update);
            }
            else {
                this.applyParagraphFormatTableInternal(block, property, value, update);
            }
        }
    }
    getParaFormatValueInCell(cell, property, value) {
        if (typeof value === 'boolean') {
            let firstPara = this.viewer.selection.getFirstParagraph(cell);
            value = !firstPara.paragraphFormat.getPropertyValue(property);
        }
        return value;
    }
    // Row
    // tslint:disable-next-line:max-line-length
    applyParagraphFormatRow(wRow, start, end, property, value, update) {
        value = this.getParaFormatValueInCell(wRow.childWidgets[0], property, value);
        for (let i = wRow.rowIndex; i < wRow.ownerTable.childWidgets.length; i++) {
            let row = wRow.ownerTable.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                this.applyParaFormatCellInternal(row.childWidgets[j], property, value, update);
            }
            if (end.paragraph.isInsideTable && this.viewer.selection.containsRow(row, end.paragraph.associatedCell)) {
                return;
            }
        }
        this.getNextParagraphForFormatting(wRow.ownerTable, start, end, property, value, update);
    }
    // Table
    // tslint:disable-next-line:max-line-length
    applyParaFormatTableCell(table, startCell, endCell, property, value, update) {
        let selection = this.viewer.selection;
        let startValue = selection.getCellLeft(startCell.ownerRow, startCell);
        let endValue = startValue + startCell.cellFormat.cellWidth;
        let endCellLeft = selection.getCellLeft(endCell.ownerRow, endCell);
        let endCellRight = endCellLeft + endCell.cellFormat.cellWidth;
        let cellInfo = this.updateSelectedCellsInTable(startValue, endValue, endCellLeft, endCellRight);
        startValue = cellInfo.start;
        endValue = cellInfo.end;
        let count = table.childWidgets.indexOf(endCell.ownerRow);
        let isStarted = false;
        for (let m = table.childWidgets.indexOf(startCell.ownerRow); m <= count; m++) {
            let row = table.childWidgets[m];
            for (let j = 0; j < row.childWidgets.length; j++) {
                let left = selection.getCellLeft(row, row.childWidgets[j]);
                if (Math.round(startValue) <= Math.round(left) && Math.round(left) < Math.round(endValue)) {
                    if (!isStarted) {
                        value = this.getParaFormatValueInCell(row.childWidgets[j], property, value);
                        isStarted = true;
                    }
                    this.applyParaFormatCellInternal(row.childWidgets[j], property, value, update);
                }
            }
        }
    }
    // tslint:disable-next-line:max-line-length
    applyParaFormatTable(table, start, end, property, value, update) {
        table = table.combineWidget(this.viewer);
        let selection = this.viewer.selection;
        for (let m = 0; m < table.childWidgets.length; m++) {
            let tableRow = table.childWidgets[m];
            for (let k = 0; k < tableRow.childWidgets.length; k++) {
                this.applyParaFormatCellInternal(tableRow.childWidgets[k], property, value, update);
            }
            if (end.paragraph.isInsideTable && selection.containsRow(tableRow, end.paragraph.associatedCell)) {
                this.viewer.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
                return;
            }
        }
        this.viewer.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
        this.getNextParagraphForFormatting(table, start, end, property, value, update);
    }
    // tslint:disable-next-line:max-line-length
    getNextParagraphForFormatting(block, start, end, property, value, update) {
        let widgetCollection = block.getSplitWidgets();
        block = widgetCollection[widgetCollection.length - 1];
        block = this.viewer.selection.getNextRenderedBlock(block);
        if (!isNullOrUndefined(block)) {
            if (block instanceof ParagraphWidget) {
                this.applyParaFormat(block, start, end, property, value, update);
            }
            else {
                this.applyParaFormatTable(block, start, end, property, value, update);
            }
        }
    }
    applyParagraphFormatTableInternal(table, property, value, update) {
        for (let x = 0; x < table.childWidgets.length; x++) {
            let row = table.childWidgets[x];
            for (let y = 0; y < row.childWidgets.length; y++) {
                this.applyParaFormatCellInternal(row.childWidgets[y], property, value, update);
            }
        }
    }
    //Paragraph Format apply implementation Ends
    // Apply Selection Section Format Option Implementation Starts
    /**
     * Apply section format selection changes
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    onApplySectionFormat(property, value) {
        if (!isNullOrUndefined(property)) {
            let action = (property[0].toUpperCase() + property.slice(1));
            this.initHistory(action);
        }
        else {
            this.initHistory('SectionFormat');
        }
        this.updateSectionFormat(property, value);
    }
    /**
     * Update section format
     * @param  {string} property
     * @param  {Object} value
     * @returns TextPosition
     * @private
     */
    updateSectionFormat(property, value) {
        let selection = this.viewer.selection;
        selection.owner.isShiftingEnabled = true;
        let startPosition = selection.start;
        let endPosition = selection.end;
        if (!selection.isForward) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        let startPageIndex;
        let endPageIndex;
        this.viewer.clearContent();
        let startSectionIndex = startPosition.paragraph.containerWidget.index;
        let endSectionIndex = endPosition.paragraph.containerWidget.index;
        for (let i = 0; i < this.viewer.pages.length; i++) {
            if (this.viewer.pages[i].bodyWidgets[0].index === startSectionIndex) {
                startPageIndex = i;
                break;
            }
        }
        for (let i = startPageIndex; i < this.viewer.pages.length; i++) {
            let bodyWidget = this.viewer.pages[i].bodyWidgets[0];
            endPageIndex = i;
            if ((bodyWidget.index === startSectionIndex)) {
                continue;
            }
            else if ((bodyWidget.index >= startSectionIndex) && bodyWidget.index <= endSectionIndex) {
                continue;
            }
            else {
                endPageIndex = i - 1;
                break;
            }
        }
        // let startPageIndex: number = this.viewer.pages.indexOf((selection.start.paragraph.containerWidget as BodyWidget).page);
        // let endPageIndex: number = this.viewer.pages.indexOf((selection.end.paragraph.containerWidget as BodyWidget).page);
        let update = true;
        let index = 0;
        for (let i = startPageIndex; i <= endPageIndex; i++) {
            if (index !== this.viewer.pages[i].bodyWidgets[0].index && !update) {
                update = true;
            }
            this.applyPropertyValueForSection(this.viewer.pages[i].bodyWidgets[0].sectionFormat, property, value, update);
            index = this.viewer.pages[i].bodyWidgets[0].index;
            update = false;
        }
        this.layoutWholeDocument();
        this.fireContentChange();
    }
    //Apply Selection Table Format option implementation starts
    /**
     * Apply table format property changes
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    onApplyTableFormat(property, value) {
        let action = this.getTableFormatAction(property);
        this.viewer.owner.isShiftingEnabled = true;
        let selection = this.viewer.selection;
        let table = selection.start.paragraph.associatedCell.ownerTable;
        table = table.combineWidget(this.viewer);
        if (selection.isEmpty) {
            this.initHistory(action);
            this.applyTablePropertyValue(selection, property, value, table);
        }
        else {
            this.updateSelectionTableFormat(this.selection, action, value);
        }
        table.calculateGrid();
        this.selection.owner.isLayoutEnabled = true;
        this.viewer.layout.reLayoutTable(table);
        this.reLayout(selection, false);
    }
    getTableFormatAction(property) {
        switch (property) {
            case 'tableAlignment':
                return 'TableAlignment';
            case 'leftIndent':
                return 'TableLeftIndent';
            case 'leftMargin':
                return 'DefaultCellLeftMargin';
            case 'rightMargin':
                return 'DefaultCellRightMargin';
            case 'bottomMargin':
                return 'DefaultCellBottomMargin';
            case 'topMargin':
                return 'DefaultCellTopMargin';
            case 'preferredWidth':
                return 'TablePreferredWidth';
            case 'preferredWidthType':
                return 'TablePreferredWidthType';
            case 'shading':
                return 'Shading';
            default:
                return 'DefaultCellSpacing';
        }
    }
    // Apply Selection Row Format Option Implementation Starts
    /**
     * Apply table row format property changes
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    onApplyTableRowFormat(property, value) {
        let action = this.getRowAction(property);
        this.viewer.owner.isShiftingEnabled = true;
        let selection = this.viewer.selection;
        if (selection.isEmpty) {
            this.initHistory(action);
            let table = selection.start.paragraph.associatedCell.ownerRow.ownerTable;
            this.applyRowPropertyValue(selection, property, value, selection.start.paragraph.associatedCell.ownerRow);
        }
        else {
            this.updateSelectionTableFormat(this.selection, action, value);
        }
        this.reLayout(selection, false);
    }
    getRowAction(property) {
        switch (property) {
            case 'height':
                return 'RowHeight';
            case 'heightType':
                return 'RowHeightType';
            case 'isHeader':
                return 'RowHeader';
            default:
                return 'AllowBreakAcrossPages';
        }
    }
    /**
     * Apply table cell property changes
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    onApplyTableCellFormat(property, value) {
        let action = this.getTableCellAction(property);
        this.viewer.owner.isShiftingEnabled = true;
        let selection = this.viewer.selection;
        let table = selection.start.paragraph.associatedCell.ownerTable;
        table = table.combineWidget(this.viewer);
        if (selection.isEmpty) {
            this.initHistory(action);
            this.applyCellPropertyValue(selection, property, value, selection.start.paragraph.associatedCell.cellFormat);
            table.calculateGrid();
            this.selection.owner.isLayoutEnabled = true;
            this.viewer.layout.reLayoutTable(table);
        }
        else {
            this.updateSelectionTableFormat(this.selection, action, value);
        }
        this.reLayout(selection, false);
    }
    getTableCellAction(property) {
        switch (property) {
            case 'verticalAlignment':
                return 'CellContentVerticalAlignment';
            case 'leftMargin':
                return 'CellLeftMargin';
            case 'rightMargin':
                return 'CellRightMargin';
            case 'bottomMargin':
                return 'CellBottomMargin';
            case 'topMargin':
                return 'CellTopMargin';
            case 'preferredWidth':
                return 'CellPreferredWidth';
            case 'shading':
                return 'Shading';
            default:
                return 'CellPreferredWidthType';
        }
    }
    applyPropertyValueForSection(sectionFormat, property, value, update) {
        let selection = this.viewer.selection;
        if (update && this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedPropertiesForSection(sectionFormat, property, value);
        }
        if (isNullOrUndefined(value)) {
            return;
        }
        if (value instanceof WSectionFormat) {
            if (isNullOrUndefined(property)) {
                sectionFormat.copyFormat(value, this.editorHistory);
            }
            return;
        }
        if (property === 'pageHeight') {
            sectionFormat.pageHeight = value;
        }
        else if (property === 'pageWidth') {
            sectionFormat.pageWidth = value;
        }
        else if (property === 'leftMargin') {
            sectionFormat.leftMargin = value;
        }
        else if (property === 'rightMargin') {
            sectionFormat.rightMargin = value;
        }
        else if (property === 'topMargin') {
            sectionFormat.topMargin = value;
        }
        else if (property === 'bottomMargin') {
            sectionFormat.bottomMargin = value;
        }
        else if (property === 'differentFirstPage') {
            sectionFormat.differentFirstPage = value;
        }
        else if (property === 'differentOddAndEvenPages') {
            sectionFormat.differentOddAndEvenPages = value;
        }
        else if (property === 'headerDistance') {
            sectionFormat.headerDistance = value;
        }
        else if (property === 'footerDistance') {
            sectionFormat.footerDistance = value;
        }
    }
    /**
     * @private
     */
    layoutWholeDocument() {
        let startPosition = this.viewer.selection.start;
        let endPosition = this.viewer.selection.end;
        if (startPosition.isExistAfter(endPosition)) {
            startPosition = this.viewer.selection.end;
            endPosition = this.viewer.selection.start;
        }
        let startInfo = this.getParagraphInfo(startPosition);
        let endInfo = this.getParagraphInfo(startPosition);
        let startIndex = this.getHierarchicalIndex(startInfo.paragraph, startInfo.offset.toString());
        let endIndex = this.getHierarchicalIndex(endInfo.paragraph, endInfo.offset.toString());
        this.viewer.renderedLists.clear();
        // this.viewer.owner.isLayoutEnabled = true;
        let sections = this.combineSection();
        this.viewer.clearContent();
        this.viewer.layout.layoutItems(sections);
        this.viewer.owner.isShiftingEnabled = false;
        this.setPositionForCurrentIndex(startPosition, startIndex);
        this.setPositionForCurrentIndex(endPosition, endIndex);
        this.viewer.selection.selectPosition(startPosition, endPosition);
        this.reLayout(this.viewer.selection);
    }
    combineSection() {
        let sections = [];
        let nextSection = this.viewer.pages[0].bodyWidgets[0];
        do {
            nextSection = this.combineSectionChild(nextSection, sections);
        } while (nextSection);
        return sections;
    }
    combineSectionChild(bodyWidget, sections) {
        let previousBodyWidget = bodyWidget;
        let temp = new BodyWidget();
        temp.sectionFormat = bodyWidget.sectionFormat;
        temp.index = previousBodyWidget.index;
        do {
            previousBodyWidget = bodyWidget;
            if (bodyWidget.lastChild) {
                bodyWidget.lastChild.combineWidget(this.viewer);
            }
            bodyWidget = bodyWidget.nextRenderedWidget;
            for (let j = 0; j < previousBodyWidget.childWidgets.length; j++) {
                let block = previousBodyWidget.childWidgets[j];
                if (block instanceof TableWidget) {
                    this.viewer.layout.clearTableWidget(block, true, true);
                }
                else {
                    block.x = 0;
                    block.y = 0;
                    block.width = 0;
                    block.height = 0;
                }
                temp.childWidgets.push(block);
                previousBodyWidget.childWidgets.splice(j, 1);
                j--;
                block.containerWidget = temp;
            }
            previousBodyWidget.page.destroy();
            // this.viewer.pages.splice(previousBodyWidget.page.index, 1);
        } while (bodyWidget && previousBodyWidget.equals(bodyWidget));
        sections.push(temp);
        return bodyWidget;
    }
    updateSelectionTableFormat(selection, action, value) {
        switch (action) {
            case 'TableAlignment':
                this.editorHistory.initializeHistory('TableAlignment');
                this.updateTableFormat(selection, 'tableAlignment', value);
                break;
            case 'TableLeftIndent':
                this.editorHistory.initializeHistory('TableLeftIndent');
                this.updateTableFormat(selection, 'leftIndent', value);
                break;
            case 'DefaultCellSpacing':
                this.editorHistory.initializeHistory('DefaultCellSpacing');
                this.updateTableFormat(selection, 'cellSpacing', value);
                break;
            case 'DefaultCellLeftMargin':
                this.editorHistory.initializeHistory('DefaultCellLeftMargin');
                this.updateTableFormat(selection, 'leftMargin', value);
                break;
            case 'DefaultCellRightMargin':
                this.editorHistory.initializeHistory('DefaultCellRightMargin');
                this.updateTableFormat(selection, 'rightMargin', value);
                break;
            case 'DefaultCellTopMargin':
                this.editorHistory.initializeHistory('DefaultCellTopMargin');
                this.updateTableFormat(selection, 'topMargin', value);
                break;
            case 'TablePreferredWidth':
                this.editorHistory.initializeHistory('TablePreferredWidth');
                this.updateTableFormat(selection, 'preferredWidth', value);
                break;
            case 'TablePreferredWidthType':
                this.editorHistory.initializeHistory('TablePreferredWidthType');
                this.updateTableFormat(selection, 'preferredWidthType', value);
                break;
            case 'DefaultCellBottomMargin':
                this.editorHistory.initializeHistory('DefaultCellBottomMargin');
                this.updateTableFormat(selection, 'bottomMargin', value);
                break;
            case 'CellContentVerticalAlignment':
                this.editorHistory.initializeHistory('CellContentVerticalAlignment');
                this.updateCellFormat(selection, 'verticalAlignment', value);
                break;
            case 'CellLeftMargin':
                this.editorHistory.initializeHistory('CellLeftMargin');
                this.updateCellFormat(selection, 'leftMargin', value);
                break;
            case 'CellRightMargin':
                this.editorHistory.initializeHistory('CellRightMargin');
                this.updateCellFormat(selection, 'rightMargin', value);
                break;
            case 'CellTopMargin':
                this.editorHistory.initializeHistory('CellTopMargin');
                this.updateCellFormat(selection, 'topMargin', value);
                break;
            case 'CellBottomMargin':
                this.editorHistory.initializeHistory('CellBottomMargin');
                this.updateCellFormat(selection, 'bottomMargin', value);
                break;
            case 'CellPreferredWidth':
                this.editorHistory.initializeHistory('CellPreferredWidth');
                this.updateCellFormat(selection, 'preferredWidth', value);
                break;
            case 'CellPreferredWidthType':
                this.editorHistory.initializeHistory('CellPreferredWidthType');
                this.updateCellFormat(selection, 'preferredWidthType', value);
                break;
            case 'Shading':
                this.editorHistory.initializeHistory('Shading');
                this.updateCellFormat(selection, 'shading', value);
                break;
            case 'RowHeight':
                this.editorHistory.initializeHistory('RowHeight');
                this.updateRowFormat(selection, 'height', value);
                break;
            case 'RowHeightType':
                this.editorHistory.initializeHistory('RowHeightType');
                this.updateRowFormat(selection, 'heightType', value);
                break;
            case 'RowHeader':
                this.editorHistory.initializeHistory('RowHeader');
                this.updateRowFormat(selection, 'isHeader', value);
                break;
            case 'AllowBreakAcrossPages':
                this.editorHistory.initializeHistory('AllowBreakAcrossPages');
                this.updateRowFormat(selection, 'allowBreakAcrossPages', value);
                break;
        }
    }
    // Update Table Properties
    /**
     * Update Table Format on undo
     * @param  {Selection} selection
     * @param  {SelectionRange} selectionRange
     * @param  {string} property
     * @param  {object} value
     * @private
     */
    updateTableFormat(selection, property, value) {
        let tableStartPosition = selection.start;
        let tableEndPosition = selection.end;
        if (!selection.isForward) {
            tableStartPosition = selection.end;
            tableEndPosition = selection.start;
        }
        this.initHistoryPosition(selection, tableStartPosition);
        // tslint:disable-next-line:max-line-length
        this.applyTablePropertyValue(selection, property, value, tableStartPosition.paragraph.associatedCell.ownerTable);
    }
    /**
     * update cell format on undo
     * @param  {Selection} selection
     * @param  {SelectionRange} selectionRange
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    updateCellFormat(selection, property, value) {
        selection.owner.isShiftingEnabled = true;
        let newStartPosition = selection.start;
        let newEndPosition = selection.end;
        if (!selection.isForward) {
            newStartPosition = selection.end;
            newEndPosition = selection.start;
        }
        this.initHistoryPosition(selection, newStartPosition);
        this.updateFormatForCell(selection, property, value);
    }
    /**
     * update row format on undo
     * @param  {Selection} selection
     * @param  {SelectionRange} selectionRange
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    updateRowFormat(selection, property, value) {
        let rowStartPosition = selection.start;
        let rowEndPosition = selection.end;
        if (!selection.isForward) {
            rowStartPosition = selection.end;
            rowEndPosition = selection.start;
        }
        this.initHistoryPosition(selection, rowStartPosition);
        // tslint:disable-next-line:max-line-length
        this.applyRowFormat(rowStartPosition.paragraph.associatedCell.ownerRow, rowStartPosition, rowEndPosition, property, value);
    }
    initHistoryPosition(selection, position) {
        if (this.viewer.owner.editorHistoryModule && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            if (!isNullOrUndefined(position)) {
                if (isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo.insertPosition)) {
                    this.editorHistory.currentBaseHistoryInfo.insertPosition = position.getHierarchicalIndexInternal();
                }
            }
            else if (isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo.insertPosition)) {
                this.editorHistory.currentBaseHistoryInfo.insertPosition = selection.start.getHierarchicalIndexInternal();
            }
        }
    }
    startSelectionReLayouting(paragraph, selection, start, end) {
        selection.owner.isLayoutEnabled = true;
        if (start.paragraph.isInsideTable) {
            let table = start.paragraph.associatedCell.ownerTable;
            while (table.isInsideTable) {
                table = table.associatedCell.ownerTable;
            }
            this.reLayoutSelectionOfTable(table, selection, start, end);
        }
        else {
            this.reLayoutSelection(paragraph, selection, start, end);
        }
    }
    reLayoutSelectionOfTable(table, selection, start, end) {
        let isEnded = false;
        this.viewer.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
        // If the selection ends in the current table, need to stop relayouting.
        if (!isNullOrUndefined(end.paragraph.associatedCell) && table.contains(end.paragraph.associatedCell)) {
            return true;
        }
        let block = selection.getNextRenderedBlock(table);
        // Relayout the next block.
        if (!isNullOrUndefined(block)) {
            isEnded = this.reLayoutSelectionOfBlock(block, selection, start, end);
        }
        return isEnded;
    }
    reLayoutSelection(paragraph, selection, start, end) {
        if (start.paragraph === paragraph) {
            let startOffset = start.offset;
            let length = selection.getParagraphLength(paragraph);
            let indexInInline = 0;
            let index = 0;
            let inlineObj = paragraph.getInline(start.offset, indexInInline);
            let inline = inlineObj.element;
            indexInInline = inlineObj.index;
            if (!isNullOrUndefined(inline)) {
                if (indexInInline === inline.length && !isNullOrUndefined(inline.nextNode)) {
                    inline = inline.nextNode;
                }
                index = inline.line.children.indexOf(inline);
            }
            let lineIndex = 0;
            if (start.currentWidget.paragraph === paragraph) {
                lineIndex = paragraph.childWidgets.indexOf(start.currentWidget);
                index = start.currentWidget.children.indexOf(inline);
            }
            // If selection start inline is at new inline, need to relayout from the previous inline.
            if (inline instanceof TextElementBox && !inline.line && index > 0) {
                this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, index - 1);
            }
            else {
                this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, index);
            }
        }
        else {
            this.viewer.layout.reLayoutParagraph(paragraph, 0, 0);
        }
        // If the selection ends at the current paragraph, need to stop relayouting.
        if (end.paragraph === paragraph) {
            return true;
        }
        // _Relayout the next block.
        let block = selection.getNextRenderedBlock(paragraph);
        if (!isNullOrUndefined(block)) {
            return this.reLayoutSelectionOfBlock(block, selection, start, end);
        }
        return false;
    }
    //Relayouting Start    
    reLayoutSelectionOfBlock(block, selection, start, end) {
        if (block instanceof ParagraphWidget) {
            return this.reLayoutSelection(block, selection, start, end);
        }
        else {
            return undefined;
            // return this.reLayoutSelectionOfTable(block as TableWidget, selection, start, end);
        }
    }
    /**
     * @private
     */
    layoutItemBlock(block, shiftNextWidget) {
        let section = undefined;
        if (block.containerWidget instanceof BlockContainer) {
            section = block.containerWidget;
            let index = section.childWidgets.indexOf(block);
            if (!isNullOrUndefined(this.viewer.owner)
                && this.viewer.owner.isLayoutEnabled) {
                // tslint:disable-next-line:max-line-length
                this.viewer.layout.layoutBodyWidgetCollection(block.index, section, block, false);
            }
        }
        else if (block.containerWidget instanceof TableCellWidget) {
            let cell = block.containerWidget;
            cell = this.viewer.selection.getContainerCell(cell);
            if (!isNullOrUndefined(this.viewer.owner)
                && this.viewer.owner.isLayoutEnabled) {
                this.viewer.layout.reLayoutTable(block);
            }
        }
    }
    /**
     * @private
     */
    removeSelectedContents(selection) {
        return this.removeSelectedContentInternal(selection, selection.start, selection.end);
    }
    removeSelectedContentInternal(selection, startPosition, endPosition) {
        let startPos = startPosition;
        let endPos = endPosition;
        if (!startPosition.isExistBefore(endPosition)) {
            startPos = endPosition;
            endPos = startPosition;
        }
        // tslint:disable-next-line:max-line-length
        if (startPos.paragraph === endPos.paragraph && startPos.paragraph.childWidgets.indexOf(startPos.currentWidget) === startPos.paragraph.childWidgets.length - 1 &&
            startPos.offset === selection.getParagraphLength(startPos.paragraph) && startPos.offset + 1 === endPos.offset) {
            selection.owner.isShiftingEnabled = true;
            selection.selectContent(startPos, true);
            return true;
        }
        let paragraphInfo = this.getParagraphInfo(startPos);
        selection.editPosition = this.getHierarchicalIndex(paragraphInfo.paragraph, paragraphInfo.offset.toString());
        let isRemoved = this.removeSelectedContent(endPos.paragraph, selection, startPos, endPos);
        let textPosition = new TextPosition(selection.owner);
        this.setPositionForCurrentIndex(textPosition, selection.editPosition);
        selection.selectContent(textPosition, true);
        return isRemoved;
    }
    removeSelectedContent(paragraph, selection, start, end) {
        //If end is not table end and start is outside the table, then skip removing the contents and move caret to start position.
        if (end.paragraph.isInsideTable
            && end.paragraph !== selection.getLastParagraphInLastCell(end.paragraph.associatedCell.ownerTable)
            && (!start.paragraph.isInsideTable || start.paragraph.associatedCell.ownerTable !== end.paragraph.associatedCell.ownerTable)) {
            return false;
        }
        selection.owner.isShiftingEnabled = true;
        this.deleteSelectedContent(paragraph, selection, start, end, 2);
        return true;
    }
    // tslint:disable-next-line:max-line-length
    deleteSelectedContent(paragraph, selection, start, end, editAction) {
        let indexInInline = 0;
        let inlineObj = start.currentWidget.getInline(start.offset, indexInInline);
        let inline = inlineObj.element;
        indexInInline = inlineObj.index;
        // if (!isNullOrUndefined(inline)) {
        //     inline = selection.getNextRenderedInline(inline, indexInInline);
        // }
        // if (inline instanceof WFieldBegin && !isNullOrUndefined((inline as WFieldBegin).fieldEnd)) {
        // tslint:disable-next-line:max-line-length
        //     let fieldEndOffset: number = ((inline as WFieldBegin).fieldEnd.owner as WParagraph).getOffset((inline as WFieldBegin).fieldEnd, 1);
        //     let fieldEndIndex: string = WordDocument.getHierarchicalIndexOf((inline as WFieldBegin).fieldEnd.owner as WParagraph, fieldEndOffset.toString());
        //     let selectionEndIndex: string = end.getHierarchicalIndexInternal();
        //     if (!TextPosition.isForwardSelection(fieldEndIndex, selectionEndIndex)) {
        //         //If selection end is after field begin, moves selection start to field separator.
        //         start.moveToInline((inline as WFieldBegin).fieldSeparator, 1);
        //         selection.editPosition = start.getHierarchicalIndexInternal();
        //         if (!isNullOrUndefined(selection.currentBaseHistoryInfo)) {
        //             selection.currentBaseHistoryInfo.insertPosition = selection.editPosition;
        //         }
        //     }
        // }
        indexInInline = 0;
        inlineObj = end.currentWidget.getInline(end.offset, indexInInline);
        inline = inlineObj.element;
        indexInInline = inlineObj.index;
        // if (!isNullOrUndefined(inline)) {
        //     inline = selection.getNextRenderedInline(inline, indexInInline);
        // }
        // if (inline instanceof WFieldEnd && !isNullOrUndefined((inline as WFieldEnd).fieldBegin)) {
        // tslint:disable-next-line:max-line-length
        //     let fieldBeginOffset: number = ((inline as WFieldEnd).fieldBegin.owner as WParagraph).getOffset((inline as WFieldEnd).fieldBegin, 0);
        //     let fieldBeginIndex: string = WordDocument.getHierarchicalIndexOf((inline as WFieldEnd).fieldBegin.owner as WParagraph, fieldBeginOffset.toString());
        //     let selectionStartIndex: string = start.getHierarchicalIndexInternal();
        //     if (!TextPosition.isForwardSelection(selectionStartIndex, fieldBeginIndex)) {
        //         //If field begin is before selection start, move selection end to inline item before field end.
        //         let prevInline: WInline = selection.getPreviousTextInline(inline);
        //         if (isNullOrUndefined(prevInline)) {
        //             end.moveBackward();
        //         } else {
        //             end.moveToInline(prevInline, prevInline.length);
        //         }
        //     }
        // }
        if (end.paragraph !== paragraph) {
            this.deleteSelectedContent(end.paragraph, selection, start, end, editAction);
            return;
        }
        //  Selection start in cell.
        if (end.paragraph.isInsideTable && (!start.paragraph.isInsideTable
            || start.paragraph.associatedCell !== end.paragraph.associatedCell
            || selection.isCellSelected(end.paragraph.associatedCell, start, end))) {
            end.paragraph.associatedCell.ownerTable.combineWidget(this.viewer);
            this.deleteTableCell(end.paragraph.associatedCell, selection, start, end, editAction);
        }
        else {
            this.deletePara(paragraph, start, end, editAction);
        }
    }
    /**
     * Merge the selected cells.
     */
    mergeCells() {
        if (this.owner.isReadOnlyMode || !this.owner.isDocumentLoaded) {
            return;
        }
        if (!isNullOrUndefined(this.viewer) && !this.selection.isEmpty) {
            this.mergeSelectedCellsInTable();
        }
    }
    /**
     * Deletes the entire table at selection.
     */
    deleteTable() {
        if (this.owner.isReadOnlyMode) {
            return;
        }
        let startPos = this.selection.isForward ? this.selection.start : this.selection.end;
        if (startPos.paragraph.isInsideTable) {
            let table = this.getOwnerTable(this.selection.isForward).combineWidget(this.viewer);
            this.selection.owner.isShiftingEnabled = true;
            if (this.checkIsNotRedoing()) {
                this.initHistory('DeleteTable');
                //Sets the insert position in history info as current table.    
                this.updateHistoryPosition(startPos, true);
            }
            let paragraph = this.getParagraphForSelection(table);
            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                this.editorHistory.currentBaseHistoryInfo.removedNodes.push(table.clone());
            }
            this.removeBlock(table);
            this.selection.selectParagraph(paragraph, true);
            if (this.checkIsNotRedoing() || isNullOrUndefined(this.editorHistory)) {
                this.reLayout(this.selection);
            }
        }
    }
    /**
     * Deletes the selected column(s).
     */
    deleteColumn() {
        if (this.owner.isReadOnlyMode) {
            return;
        }
        let startPos = this.selection.isForward ? this.selection.start : this.selection.end;
        let endPos = this.selection.isForward ? this.selection.end : this.selection.start;
        if (startPos.paragraph.isInsideTable) {
            this.selection.owner.isShiftingEnabled = true;
            if (this.checkIsNotRedoing()) {
                this.initHistory('DeleteColumn');
            }
            let startCell = this.getOwnerCell(this.selection.isForward);
            let endCell = this.getOwnerCell(!this.selection.isForward);
            let table = startCell.ownerTable.combineWidget(this.viewer);
            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                this.cloneTableToHistoryInfo(table);
            }
            let paragraph = undefined;
            if (endCell.nextWidget) {
                let nextCell = endCell.nextWidget;
                paragraph = this.selection.getFirstParagraph(nextCell);
            }
            else if (startCell.previousWidget) {
                let previousCell = startCell.previousWidget;
                paragraph = this.selection.getFirstParagraph(previousCell);
            }
            if (isNullOrUndefined(paragraph)) {
                paragraph = this.getParagraphForSelection(table);
            }
            //retrieve the cell collection based on start and end cell to remove. 
            let deleteCells = table.getColumnCellsForSelection(startCell, endCell);
            for (let i = 0; i < table.childWidgets.length; i++) {
                let row = table.childWidgets[i];
                if (row.childWidgets.length === 1) {
                    if (deleteCells.indexOf(row.childWidgets[0]) >= 0) {
                        table.childWidgets.splice(table.childWidgets.indexOf(row), 1);
                        row.destroy();
                        i--;
                    }
                }
                else {
                    for (let j = 0; j < row.childWidgets.length; j++) {
                        let tableCell = row.childWidgets[j];
                        if (deleteCells.indexOf(tableCell) >= 0) {
                            row.childWidgets.splice(j, 1);
                            tableCell.destroy();
                            j--;
                        }
                    }
                    if (row.childWidgets.length === 0) {
                        table.childWidgets.splice(table.childWidgets.indexOf(row), 1);
                        row.destroy();
                        i--;
                    }
                }
            }
            if (table.childWidgets.length === 0) {
                // Before disposing table reset the paragrph.
                paragraph = this.getParagraphForSelection(table);
                this.removeBlock(table);
                if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                    this.editorHistory.currentBaseHistoryInfo.action = 'DeleteTable';
                }
                table.destroy();
            }
            else {
                table.isGridUpdated = false;
                table.buildTableColumns();
                table.isGridUpdated = true;
                this.viewer.layout.reLayoutTable(table);
            }
            this.selection.selectParagraph(paragraph, true);
            if (isNullOrUndefined(this.editorHistory) || this.checkIsNotRedoing()) {
                this.reLayout(this.selection, true);
            }
        }
    }
    /**
     * Deletes the selected row(s).
     */
    deleteRow() {
        if (this.owner.isReadOnlyMode) {
            return;
        }
        let startPos = !this.selection.isForward ? this.selection.end : this.selection.start;
        let endPos = !this.selection.isForward ? this.selection.start : this.selection.end;
        if (startPos.paragraph.isInsideTable) {
            let startCell = this.getOwnerCell(this.selection.isForward);
            let endCell = this.getOwnerCell(!this.selection.isForward);
            if (this.checkIsNotRedoing()) {
                this.initHistory('DeleteRow');
            }
            this.selection.owner.isShiftingEnabled = true;
            let table = startCell.ownerTable.combineWidget(this.viewer);
            let row = this.getOwnerRow(true);
            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                this.cloneTableToHistoryInfo(table);
            }
            let paragraph = undefined;
            if (row.nextWidget) {
                let nextCell = row.nextWidget.childWidgets[0];
                paragraph = this.selection.getFirstParagraph(nextCell);
            }
            if (isNullOrUndefined(paragraph)) {
                paragraph = this.getParagraphForSelection(table);
            }
            if (!this.selection.isEmpty) {
                //tslint:disable-next-line:max-line-length
                let containerCell = this.selection.getContainerCellOf(startCell, endCell);
                if (containerCell.ownerTable.contains(endCell)) {
                    startCell = this.selection.getSelectedCell(startCell, containerCell);
                    endCell = this.selection.getSelectedCell(endCell, containerCell);
                    if (this.selection.containsCell(containerCell, endCell)) {
                        row = startCell.ownerRow;
                        this.removeRow(row);
                    }
                    else {
                        row = startCell.ownerRow;
                        let endRow = endCell.ownerRow;
                        //Update the selection paragraph.
                        paragraph = undefined;
                        if (endRow.nextWidget) {
                            let nextCell = endRow.nextWidget.childWidgets[0];
                            paragraph = this.selection.getFirstParagraph(nextCell);
                        }
                        if (isNullOrUndefined(paragraph)) {
                            paragraph = this.getParagraphForSelection(table);
                        }
                        for (let i = 0; i < table.childWidgets.length; i++) {
                            let tableRow = table.childWidgets[i];
                            if (tableRow.rowIndex >= row.rowIndex && tableRow.rowIndex <= endRow.rowIndex) {
                                table.childWidgets.splice(i, 1);
                                tableRow.destroy();
                                i--;
                            }
                        }
                        if (table.childWidgets.length === 0) {
                            this.removeBlock(table);
                            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                                this.editorHistory.currentBaseHistoryInfo.action = 'DeleteTable';
                            }
                            table.destroy();
                        }
                        else {
                            this.updateTable(table);
                        }
                    }
                }
            }
            else {
                this.removeRow(row);
            }
            this.selection.selectParagraph(paragraph, true);
            if (isNullOrUndefined(this.editorHistory) || this.checkIsNotRedoing()) {
                this.reLayout(this.selection, true);
            }
        }
    }
    removeRow(row) {
        let table = row.ownerTable;
        if (table.childWidgets.length === 1) {
            this.removeBlock(table);
            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                this.editorHistory.currentBaseHistoryInfo.action = 'Delete';
            }
            table.destroy();
        }
        else {
            table.childWidgets.splice(table.childWidgets.indexOf(row), 1);
            row.destroy();
            this.updateTable(table);
        }
    }
    updateTable(table) {
        table.updateRowIndex(0);
        table.isGridUpdated = false;
        table.buildTableColumns();
        table.isGridUpdated = true;
        this.viewer.layout.reLayoutTable(table);
    }
    getParagraphForSelection(table) {
        let paragraph = undefined;
        let nextWidget = table.nextWidget ? table.nextWidget : table.nextRenderedWidget;
        let previousWidget = table.previousWidget ? table.previousWidget : table.previousRenderedWidget;
        if (nextWidget) {
            paragraph = nextWidget instanceof ParagraphWidget ? nextWidget
                : this.selection.getFirstParagraphInFirstCell(nextWidget);
        }
        else if (previousWidget) {
            paragraph = previousWidget instanceof ParagraphWidget ? previousWidget
                : this.selection.getLastParagraphInLastCell(previousWidget);
        }
        return paragraph;
    }
    deletePara(paragraph, start, end, editAction) {
        paragraph = paragraph.combineWidget(this.viewer);
        let selection = this.viewer.selection;
        let paragraphStart = selection.getStartOffset(paragraph);
        let endParagraphStartOffset = selection.getStartOffset(end.paragraph);
        let startOffset = paragraphStart;
        let endOffset = 0;
        let isCombineNextParagraph = false;
        let lastLinelength = this.selection.getLineLength(paragraph.lastChild);
        let currentParagraph = paragraph;
        let section = paragraph.bodyWidget instanceof BodyWidget ? paragraph.bodyWidget : undefined;
        let startLine = undefined;
        let endLineWidget = undefined;
        if (paragraph === start.paragraph) {
            startOffset = start.offset;
            startLine = start.currentWidget;
            if (end.paragraph.isInsideTable) {
                isCombineNextParagraph = this.isEndInAdjacentTable(paragraph, end.paragraph);
            }
        }
        else {
            startLine = paragraph.firstChild;
        }
        if (paragraph !== start.paragraph && selection.isSkipLayouting) {
            selection.isSkipLayouting = false;
        }
        if (paragraph === end.paragraph) {
            endLineWidget = end.currentWidget;
            endOffset = end.offset;
        }
        else {
            endLineWidget = paragraph.lastChild;
            endOffset = this.viewer.selection.getLineLength(paragraph.lastChild);
        }
        let block = paragraph.previousRenderedWidget;
        if (startOffset > paragraphStart && start.currentWidget === paragraph.lastChild &&
            startOffset === lastLinelength && (paragraph === end.paragraph && end.offset === startOffset + 1 ||
            paragraph.nextRenderedWidget === end.paragraph && end.offset === endParagraphStartOffset) ||
            (this.editorHistory && this.editorHistory.isUndoing && this.editorHistory.currentHistoryInfo &&
                this.editorHistory.currentHistoryInfo.action === 'PageBreak' && block && block.isPageBreak())) {
            isCombineNextParagraph = true;
        }
        if (end.paragraph === paragraph && end.currentWidget !== paragraph.lastChild ||
            (end.currentWidget === paragraph.lastChild && end.offset <= selection.getLineLength(paragraph.lastChild))) {
            let isStartParagraph = start.paragraph === paragraph;
            if (end.currentWidget.isFirstLine() && end.offset > paragraphStart || !end.currentWidget.isFirstLine()) {
                //If selection end with this paragraph and selection doesnot include paragraph mark.               
                this.removeInlines(paragraph, startLine, startOffset, endLineWidget, endOffset, editAction);
                //Removes the splitted paragraph.
            }
            if (!isNullOrUndefined(block) && !isStartParagraph) {
                let nextSection = block.bodyWidget instanceof BodyWidget ? block.bodyWidget : undefined;
                if (nextSection && !section.equals(nextSection) && section.index !== nextSection.index) {
                    this.deleteSection(selection, nextSection, section, editAction);
                }
                this.deleteBlock(block, selection, start, end, editAction);
            }
        }
        else if (start.paragraph === paragraph && (start.currentWidget !== paragraph.firstChild ||
            (start.currentWidget === paragraph.firstChild && startOffset > paragraphStart))) {
            // If selection start is after paragraph start
            //And selection does not end with this paragraph Or selection include paragraph mark.
            if (editAction === 4) {
                return;
            }
            else {
                currentParagraph = this.splitParagraph(paragraph, paragraph.firstChild, 0, startLine, startOffset, true);
                this.insertParagraphPaste(paragraph, currentParagraph, start, end, isCombineNextParagraph, editAction);
                this.addRemovedNodes(paragraph);
                return;
            }
        }
        else {
            let newParagraph = undefined;
            let previousBlock = paragraph.previousWidget;
            let prevParagraph = (previousBlock instanceof ParagraphWidget) ? previousBlock : undefined;
            let nextWidget = paragraph.nextRenderedWidget;
            if (editAction < 4) {
                //Checks whether this is last paragraph of owner text body and previousBlock is not paragraph.
                newParagraph = this.checkAndInsertBlock(paragraph, start, end, editAction, prevParagraph);
                this.removeBlock(paragraph);
                if (this.viewer.blockToShift === paragraph) {
                    this.viewer.blockToShift = undefined;
                }
                this.addRemovedNodes(paragraph);
                if (!isNullOrUndefined(newParagraph)) {
                    selection.editPosition = this.getHierarchicalIndex(newParagraph, '0');
                    let offset = selection.getParagraphLength(newParagraph) + 1;
                    if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                        //tslint:disable-next-line:max-line-length
                        this.editorHistory.currentBaseHistoryInfo.endPosition = this.getHierarchicalIndex(newParagraph, offset.toString());
                    }
                }
                else if (paragraph === start.paragraph && isNullOrUndefined(nextWidget) && !isNullOrUndefined(prevParagraph)) {
                    let offset = this.selection.getParagraphLength(prevParagraph);
                    // if (isNullOrUndefined(block)) {
                    selection.editPosition = this.getHierarchicalIndex(prevParagraph, offset.toString());
                    if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                        this.updateHistoryPosition(selection.editPosition, true);
                        this.editorHistory.currentBaseHistoryInfo.endPosition = selection.editPosition;
                    }
                    // } else {
                    //     let offset: number = selection.getParagraphLength(paragraph) + 1;
                    //     if (block instanceof ParagraphWidget) {
                    //         prevParagraph = block as ParagraphWidget;
                    //     }
                    //     // if (block instanceof WTable) {
                    //     //     prevParagraph = (block as WTable).getFirstParagraphInFirstCell();
                    //     // }
                    //     selection.editPosition = prevLineWidget.getHierarchicalIndex('0');
                    // }
                }
            }
            if (start.paragraph !== paragraph && !isNullOrUndefined(block)) {
                let nextSection = block.bodyWidget instanceof BodyWidget ? block.bodyWidget : undefined;
                // if (section !== nextSection) {
                //     this.deleteSection(selection, section, nextSection, editAction);
                // }
                this.deleteBlock(block, selection, start, end, editAction);
            }
        }
        this.insertParagraphPaste(paragraph, currentParagraph, start, end, isCombineNextParagraph, editAction);
    }
    deleteSection(selection, section, nextSection, editAction) {
        if (editAction < 4) {
            this.combineSectionInternal(selection, section, nextSection);
        }
        //Copies the section properties, if this is last paragraph of section.
        if (editAction > 2) {
            section.sectionFormat.copyFormat(nextSection.sectionFormat);
        }
    }
    combineSectionInternal(selection, section, nextSection) {
        // if (section.sectionFormat.isEqualFormat(nextSection.sectionFormat)) {
        // } else {
        let bodyWidget = section.getSplitWidgets()[0];
        let currentSection = [];
        this.combineSectionChild(bodyWidget, currentSection);
        bodyWidget = currentSection[0];
        let lastBlockIndex = bodyWidget.lastChild.index;
        this.updateBlockIndex(lastBlockIndex + 1, nextSection.firstChild);
        let insertIndex = 0;
        let containerWidget = nextSection;
        for (let i = 0; i < bodyWidget.childWidgets.length; i++) {
            let block = bodyWidget.childWidgets.splice(i, 1)[0];
            containerWidget.childWidgets.splice(insertIndex, 0, block);
            block.containerWidget = containerWidget;
            this.viewer.layout.layoutBodyWidgetCollection(block.index, block.bodyWidget, block, false);
            block = block.getSplitWidgets().pop();
            containerWidget = block.containerWidget;
            insertIndex = block.indexInOwner + 1;
            i--;
        }
        this.updateSectionIndex(undefined, nextSection, false);
        this.addRemovedNodes(bodyWidget);
        // this.insert
        // }
    }
    //tslint:disable:max-line-length
    /**
     * @private
     */
    checkAndInsertBlock(block, start, end, editAction, previousParagraph) {
        if (block instanceof ParagraphWidget && block === start.paragraph || block instanceof TableWidget) {
            let newParagraph; //Adds an empty paragraph, to ensure minimal content.
            if (isNullOrUndefined(block.nextWidget) && (isNullOrUndefined(previousParagraph) || previousParagraph.nextRenderedWidget instanceof TableWidget)) {
                newParagraph = new ParagraphWidget();
                if (editAction === 1 && block instanceof ParagraphWidget) {
                    newParagraph.characterFormat.copyFormat(block.characterFormat);
                    newParagraph.paragraphFormat.copyFormat(block.paragraphFormat);
                }
                newParagraph.index = block.index + 1;
                newParagraph.containerWidget = block.containerWidget;
                this.viewer.layout.layoutBodyWidgetCollection(newParagraph.index, newParagraph.bodyWidget, newParagraph, false);
                if (block.containerWidget instanceof Widget) {
                    block.containerWidget.childWidgets.push(newParagraph);
                }
            }
            return newParagraph;
        }
        return undefined;
    }
    // tslint:disable-next-line:max-line-length
    splitParagraph(paragraphAdv, startLine, startOffset, endLine, endOffset, removeBlock) {
        let paragraph = new ParagraphWidget();
        paragraph.paragraphFormat = new WParagraphFormat(paragraph);
        paragraph.characterFormat = new WCharacterFormat(paragraph);
        paragraph.paragraphFormat.copyFormat(paragraphAdv.paragraphFormat);
        paragraph.characterFormat.copyFormat(paragraphAdv.characterFormat);
        let lineWidget = new LineWidget(paragraph);
        paragraph.childWidgets.push(lineWidget);
        let blockIndex = paragraphAdv.index;
        let insertIndex = paragraphAdv.indexInOwner;
        this.moveInlines(paragraphAdv, paragraph, 0, startOffset, startLine, endOffset, endLine);
        //Inserts new paragraph in the current text position.
        paragraphAdv.containerWidget.childWidgets.splice(insertIndex, 0, paragraph);
        paragraph.index = blockIndex;
        paragraph.containerWidget = paragraphAdv.containerWidget;
        this.updateNextBlocksIndex(paragraph, true);
        if (removeBlock) {
            this.removeBlock(paragraphAdv);
        }
        // tslint:disable-next-line:max-line-length
        this.viewer.layout.layoutBodyWidgetCollection(blockIndex, paragraph.containerWidget, paragraph, false);
        return paragraph;
    }
    /**
     * @private
     */
    removeBlock(block) {
        let index;
        let blockCollection;
        let containerWidget;
        this.removeFieldInBlock(block);
        if (block.isInsideTable) {
            containerWidget = block.associatedCell;
            index = block.associatedCell.childWidgets.indexOf(block);
            blockCollection = block.associatedCell.childWidgets;
            this.updateNextBlocksIndex(block, false);
            block.associatedCell.childWidgets.splice(index, 1);
            block.containerWidget = undefined;
            this.viewer.layout.layoutBodyWidgetCollection(block.index, containerWidget, block, false);
        }
        else {
            containerWidget = block.containerWidget;
            index = containerWidget.childWidgets.indexOf(block);
            blockCollection = containerWidget.childWidgets;
            this.updateNextBlocksIndex(block, false);
            containerWidget.childWidgets.splice(index, 1);
            block.containerWidget = undefined;
            containerWidget.height -= block.height;
            this.viewer.layout.layoutBodyWidgetCollection(block.index, containerWidget, block, false);
        }
    }
    removeField(block) {
        for (let i = 0; i < this.viewer.fields.length; i++) {
            let field = this.viewer.fields[i];
            if (field.line.paragraph === block) {
                this.viewer.fields.splice(i, 1);
                i--;
            }
        }
    }
    addRemovedNodes(node) {
        if (node instanceof FieldElementBox && node.fieldType === 0) {
            if (this.viewer.fields.indexOf(node) !== -1) {
                this.viewer.fields.splice(this.viewer.fields.indexOf(node), 1);
            }
        }
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            this.editorHistory.currentBaseHistoryInfo.removedNodes.push(node);
        }
        else if (this.editHyperlinkInternal) {
            this.nodes.push(node);
        }
    }
    deleteBlock(block, selection, start, end, editAction) {
        if (block instanceof ParagraphWidget) {
            this.deletePara(block, start, end, editAction);
        }
        else {
            this.deleteTableBlock(block, selection, start, end, editAction);
        }
    }
    // tslint:disable-next-line:max-line-length
    deleteTableCell(cellAdv, selection, start, end, editAction) {
        let deletePreviousBlock = !(start.paragraph.isInsideTable && cellAdv.ownerTable.contains(start.paragraph.associatedCell));
        let previousBlock = cellAdv.ownerTable.previousRenderedWidget;
        if (start.paragraph.isInsideTable) {
            let containerCell = selection.getContainerCellOf(cellAdv, start.paragraph.associatedCell);
            if (containerCell.ownerTable.contains(start.paragraph.associatedCell)) {
                let startCell = selection.getSelectedCell(cellAdv, containerCell);
                let endCell = selection.getSelectedCell(start.paragraph.associatedCell, containerCell);
                if (selection.containsCell(containerCell, start.paragraph.associatedCell)) {
                    //Selection end is in container cell.
                    if (selection.isCellSelected(containerCell, start, end)) {
                        //Container cell is completely selected.
                        this.updateEditPosition(containerCell, selection);
                        if (editAction === 1) {
                            //Specifically handled for backspace. Delete selected cell in current table.
                            this.deleteCellsInTable(cellAdv.ownerRow.ownerTable, selection, start, end, editAction);
                        }
                        else {
                            //Delete contents within table cell or Copy contents within table cell to clipboard.
                            let isCellCleared = this.deleteCell(containerCell, selection, editAction, true);
                            if (!isCellCleared && editAction !== 2 && this.editorHistory) {
                                this.editorHistory.currentBaseHistoryInfo = undefined;
                            }
                        }
                    }
                    else {
                        if (startCell === containerCell) {
                            this.deletePara(end.paragraph, start, end, editAction);
                        }
                        else {
                            this.deleteContainer(startCell, selection, start, end, editAction);
                        }
                    }
                }
                else {
                    if (editAction === 2) {
                        //Delete contents within table cell.
                        this.deleteCell(cellAdv, selection, 2, false);
                    }
                    else {
                        //Delete other selected cells in current table.
                        this.deleteCellsInTable(containerCell.ownerTable, selection, start, end, editAction);
                    }
                }
            }
            else {
                //Selection end is different table.
                this.deleteContainer(containerCell, selection, start, end, editAction);
            }
        }
        else {
            //Selection end is outside table.
            let cell = selection.getContainerCell(cellAdv);
            this.deleteContainer(cell, selection, start, end, editAction);
        }
        if (deletePreviousBlock) {
            let sectionAdv = previousBlock.bodyWidget instanceof BodyWidget ? previousBlock.bodyWidget : undefined;
            // this.deleteContent(cellAdv.ownerTable, selection, editAction);
            if (!isNullOrUndefined(previousBlock)) {
                // let nextSection: WSection = blockAdv.section instanceof WSection ? blockAdv.section as WSection : undefined;
                // if (sectionAdv !== nextSection) {
                //     this.deleteSection(selection, sectionAdv, nextSection, editAction);
                // }
                //Goto the next block.
                this.deleteBlock(previousBlock, selection, start, end, editAction);
            }
        }
    }
    // tslint:disable-next-line:max-line-length
    deleteCellsInTable(table, selection, start, end, editAction) {
        let clonedTable = undefined;
        let isDeleteCells = false;
        let action = 'Delete';
        let startCell = start.paragraph.associatedCell;
        let endCell = end.paragraph.associatedCell;
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            action = this.editorHistory.currentBaseHistoryInfo.action;
            //tslint:disable-next-line:max-line-length
            isDeleteCells = this.editorHistory.currentBaseHistoryInfo.action === 'BackSpace' || this.editorHistory.currentBaseHistoryInfo.action === 'DeleteCells'
                || this.editorHistory.currentBaseHistoryInfo.action === 'InsertTable' || (isNullOrUndefined(startCell.ownerRow.previousWidget)
                && isNullOrUndefined(endCell.ownerRow.nextWidget) && this.editorHistory.currentBaseHistoryInfo.action === 'Cut');
            this.editorHistory.currentBaseHistoryInfo.action = isDeleteCells ? 'DeleteCells' : 'ClearCells';
            clonedTable = this.cloneTableToHistoryInfo(table);
            selection.owner.isLayoutEnabled = false;
        }
        let startColumnIndex = startCell.columnIndex;
        let endColumnIndex = endCell.columnIndex + endCell.cellFormat.columnSpan - 1;
        let startRowIndex = startCell.rowIndex;
        let endRowIndex = endCell.rowIndex;
        let isStarted = false;
        let isCellCleared = false;
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            if (row.index >= startRowIndex && row.index <= endRowIndex) {
                for (let j = 0; j < row.childWidgets.length; j++) {
                    let cell = row.childWidgets[j];
                    if (cell.columnIndex >= startColumnIndex && cell.columnIndex <= endColumnIndex) {
                        if (!isStarted) {
                            this.updateEditPosition(cell, selection);
                            isStarted = true;
                        }
                        if (isDeleteCells) {
                            //Specific for Backspace and Cut if selection includes all rows.
                            let cell = row.childWidgets[j];
                            this.updateNextBlocksIndex(cell, false);
                            row.childWidgets.splice(j, 1);
                            j--;
                        }
                        else if (editAction < 4) {
                            isCellCleared = this.deleteCell(cell, selection, editAction, false);
                        }
                    }
                }
                if (row.childWidgets.length === 0) {
                    this.updateNextBlocksIndex(table.childWidgets[i], false);
                    table.childWidgets.splice(i, 1);
                    i--;
                    endRowIndex--;
                }
            }
        }
        //Layouts the table after delete cells.
        selection.owner.isLayoutEnabled = true;
        if (table.childWidgets.length === 0) {
            selection.editPosition = this.getHierarchicalIndex(table, '0');
            this.setActionInternal(selection, action);
            this.removeBlock(table);
        }
        else {
            // Before lay outing need to update table grid.
            table.isGridUpdated = false;
            table.buildTableColumns();
            table.isGridUpdated = true;
            this.viewer.layout.reLayoutTable(table);
        }
    }
    deleteCell(cell, selection, editAction, copyChildToClipboard) {
        //Checks whether this is last paragraph of owner textbody.
        let block = cell.childWidgets[0];
        if (cell.childWidgets.length === 1 && block instanceof ParagraphWidget && block.isEmpty()) {
            return false;
        }
        for (let i = 0; i < cell.childWidgets.length; i++) {
            block = cell.childWidgets[i];
            if (editAction < 4) {
                //Checks whether this is last paragraph of owner textbody.
                if (block instanceof ParagraphWidget && cell.childWidgets.length === 1) {
                    //Preserves empty paragraph, to ensure minimal content.
                    let paragraph = block;
                    //Removes all the inlines in the paragraph.
                    for (let j = 0; j < paragraph.childWidgets.length; j++) {
                        let inline = paragraph.childWidgets[j];
                        for (let k = 0; k < inline.children.length; k++) {
                            let element = inline.children[k];
                            this.unLinkFieldCharacter(element);
                            inline.children.splice(k, 1);
                            // this.layoutInlineCollection(true, paragraph.inlines.indexOf(inline), paragraph.inlines, inline);
                            k--;
                            if (this.checkClearCells(selection)) {
                                this.addRemovedNodes(element);
                            }
                        }
                        if (paragraph.childWidgets.length > 1) {
                            paragraph.childWidgets.splice(j, 1);
                            j--;
                        }
                    }
                    if (this.checkClearCells(selection)) {
                        //Add Index for line Widget
                        selection.editPosition = this.getHierarchicalIndex(paragraph, '0');
                        this.updateHistoryPosition(selection.editPosition, true);
                    }
                    break;
                }
                this.removeBlock(block);
                i--;
                if (this.checkClearCells(selection)) {
                    this.addRemovedNodes(block);
                }
            }
        }
        return true;
    }
    deleteContainer(cell, selection, start, end, editAction) {
        let ownerTable = cell.ownerTable;
        if (selection.containsRow(ownerTable.lastChild, end.paragraph.associatedCell)) {
            this.deleteContent(ownerTable, selection, editAction);
        }
        else {
            for (let i = 0; i < ownerTable.childWidgets.length; i++) {
                let row = ownerTable.childWidgets[i];
                if (editAction < 4) {
                    this.updateNextBlocksIndex(row, false);
                    ownerTable.childWidgets.splice(i, 1);
                    this.addRemovedNodes(row);
                    i--;
                }
                if (end.paragraph.isInsideTable && selection.containsRow(row, end.paragraph.associatedCell)) {
                    this.viewer.layout.reLayoutTable(ownerTable);
                    return;
                }
            }
        }
    }
    deleteTableBlock(table, selection, start, end, editAction) {
        table = table.combineWidget(this.viewer);
        if (start.paragraph.isInsideTable && table.contains(start.paragraph.associatedCell)) {
            let block = table.previousRenderedWidget;
            // tslint:disable-next-line:max-line-length
            let previousBlock = this.checkAndInsertBlock(table, start, end, editAction, block instanceof ParagraphWidget ? block : undefined);
            if (selection.containsRow(table.firstChild, start.paragraph.associatedCell)) {
                this.deleteContent(table, selection, editAction);
            }
            else {
                let newTable = this.splitTable(table, start.paragraph.associatedCell.ownerRow);
                this.deleteContent(table, selection, editAction);
                this.viewer.layout.layoutBodyWidgetCollection(newTable.index, newTable.containerWidget, newTable, false);
            }
            if (!isNullOrUndefined(previousBlock)) {
                selection.editPosition = this.getHierarchicalIndex(previousBlock, '0');
                if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                    this.editorHistory.currentBaseHistoryInfo.endPosition = selection.editPosition;
                }
            }
        }
        else {
            let blockAdv = table.previousRenderedWidget;
            let sectionAdv = table.bodyWidget instanceof BodyWidget ? table.bodyWidget : undefined;
            this.deleteContent(table, selection, editAction);
            if (!isNullOrUndefined(blockAdv)) {
                // let nextSection: WSection = blockAdv.section instanceof WSection ? blockAdv.section as WSection : undefined;
                // if (sectionAdv !== nextSection) {
                //     this.deleteSection(selection, sectionAdv, nextSection, editAction);
                // }
                //Goto the next block.
                this.deleteBlock(blockAdv, selection, start, end, editAction);
            }
        }
    }
    splitTable(table, splitEndRow) {
        let newTable = new TableWidget();
        newTable.tableFormat.copyFormat(table.tableFormat);
        newTable.index = table.index;
        //Moves the rows to new table.
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            if (row === splitEndRow) {
                break;
            }
            newTable.childWidgets.push(row);
            row.containerWidget = newTable;
            table.childWidgets.splice(i, 1);
            i--;
        }
        //Inserts new table in the current text position.
        let insertIndex = table.getIndex();
        table.containerWidget.childWidgets.splice(insertIndex, 0, newTable);
        newTable.containerWidget = table.containerWidget;
        this.updateNextBlocksIndex(newTable, true);
        return newTable;
    }
    updateEditPosition(cell, selection) {
        let firstParagraph = selection.getFirstParagraphInCell(cell);
        selection.editPosition = this.getHierarchicalIndex(firstParagraph, '0');
    }
    /**
     * @private
     */
    deleteContent(table, selection, editAction) {
        if (editAction < 4) {
            this.removeBlock(table);
            this.addRemovedNodes(table);
        }
    }
    setActionInternal(selection, action) {
        if (this.viewer.owner.enableHistoryMode && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            this.editorHistory.currentBaseHistoryInfo.action = action;
        }
    }
    checkClearCells(selection) {
        // tslint:disable-next-line:max-line-length
        return this.editorHistory && this.editorHistory.currentBaseHistoryInfo && this.editorHistory.currentBaseHistoryInfo.action !== 'ClearCells';
    }
    isEndInAdjacentTable(paragraph, endParagraph) {
        let start = this.getHierarchicalIndex(paragraph, '');
        let end = this.getHierarchicalIndex(endParagraph, '');
        let selectionStart = start.split(';');
        let selectionEnd = end.split(';');
        return selectionStart.length < selectionEnd.length;
    }
    cloneTableToHistoryInfo(table) {
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            //Clones the entire table to preserve in history.
            let clonedTable = table.clone();
            //Preserves the cloned table in history info, for future undo operation.
            this.editorHistory.currentBaseHistoryInfo.removedNodes.push(clonedTable);
            //Sets the insert position in history info as current table.
            if (this.viewer.selection.start.paragraph.isInsideTable &&
                this.viewer.selection.start.paragraph.associatedCell.ownerTable === table) {
                this.updateHistoryPosition(this.getHierarchicalIndex(table, '0'), true);
            }
            return clonedTable;
        }
        return undefined;
    }
    // tslint:disable-next-line:max-line-length
    insertParagraphPaste(paragraph, currentParagraph, start, end, isCombineNextParagraph, editAction) {
        if (this.editorHistory && (this.editorHistory.isUndoing || this.editorHistory.isRedoing) && this.editorHistory.currentBaseHistoryInfo.action === 'Paste') {
            let nextParagraph = this.selection.getNextParagraphBlock(currentParagraph);
            if (nextParagraph) {
                if (start.offset > 0 && nextParagraph === end.paragraph && paragraph === start.paragraph
                    && this.editorHistory.currentBaseHistoryInfo.action === 'Paste') {
                    //Combines the current paragraph with end paragraph specific for undo/redo paste action.
                    let insertIndex = 0;
                    this.removeBlock(currentParagraph);
                    this.viewer.layout.clearListElementBox(nextParagraph);
                    this.viewer.layout.clearListElementBox(currentParagraph);
                    for (let i = 0; i < currentParagraph.childWidgets.length; i++) {
                        let line = currentParagraph.childWidgets[i];
                        nextParagraph.childWidgets.splice(insertIndex, 0, line);
                        currentParagraph.childWidgets.splice(i, 1);
                        i--;
                        insertIndex++;
                        line.paragraph = nextParagraph;
                    }
                    this.viewer.layout.reLayoutParagraph(nextParagraph, 0, 0);
                    isCombineNextParagraph = false;
                    let offset = this.selection.editPosition.substring(this.selection.editPosition.lastIndexOf(';') + 1);
                    this.selection.editPosition = this.getHierarchicalIndex(nextParagraph, offset);
                }
            }
        }
        if (isCombineNextParagraph) {
            this.deleteParagraphMark(currentParagraph, this.selection, editAction);
        }
    }
    // tslint:disable-next-line:max-line-length
    removeInlines(paragraph, startLine, startOffset, endLine, endOffset, editAction) {
        let isRemoved = false;
        this.viewer.layout.clearListElementBox(paragraph);
        let startIndex = paragraph.childWidgets.indexOf(startLine);
        for (let i = paragraph.childWidgets.length - 1; i >= 0; i--) {
            let lineWidget = paragraph.childWidgets[i];
            if (startLine === lineWidget && endLine === lineWidget) {
                this.removeContent(lineWidget, startOffset, endOffset);
                isRemoved = true;
                break;
            }
            if (endLine === lineWidget) {
                isRemoved = true;
                this.removeContent(lineWidget, 0, endOffset);
            }
            else if (startLine === lineWidget) {
                this.removeContent(lineWidget, startOffset, this.viewer.selection.getLineLength(lineWidget));
                break;
            }
            else if (isRemoved) {
                this.removeContent(lineWidget, 0, this.viewer.selection.getLineLength(lineWidget));
            }
        }
        if (isRemoved) {
            this.removeEmptyLine(paragraph);
            this.viewer.layout.reLayoutParagraph(paragraph, 0, 0);
        }
    }
    /**
     * @private
     */
    removeContent(lineWidget, startOffset, endOffset) {
        let count = this.selection.getLineLength(lineWidget);
        for (let i = lineWidget.children.length - 1; i >= 0; i--) {
            let inline = lineWidget.children[i];
            if (endOffset <= count - inline.length) {
                count -= inline.length;
                continue;
            }
            let endIndex = inline.length;
            if (count > endOffset && (count - endIndex < endOffset)) {
                endIndex = endOffset - (count - inline.length);
            }
            let startIndex = 0;
            if (count - inline.length < startOffset) {
                startIndex = startOffset - (count - inline.length);
            }
            if (count > endOffset) {
                count -= (inline.length - endIndex);
            }
            if (startIndex === 0 && endIndex === inline.length) {
                if (!(this.editorHistory && (this.editorHistory.isUndoing || this.editorHistory.isRedoing))) {
                    if (inline instanceof BookmarkElementBox) {
                        this.removedBookmarkElements.push(inline);
                    }
                }
                // if (editAction < 4) {
                this.unLinkFieldCharacter(inline);
                this.addRemovedNodes(lineWidget.children[i]);
                lineWidget.children.splice(i, 1);
                // }
            }
            else if (inline instanceof TextElementBox) {
                // if (editAction < 4) {
                let span = new TextElementBox();
                span.characterFormat.copyFormat(inline.characterFormat);
                span.text = inline.text.substr(startIndex, endIndex - startIndex);
                this.addRemovedNodes(span);
                inline.text = inline.text.slice(0, startIndex) + inline.text.slice(endIndex);
            }
            if (startOffset >= count - (endIndex - startIndex)) {
                break;
            }
            count -= (endIndex - startIndex);
        }
    }
    /**
     * @private
     */
    removeEmptyLine(paragraph) {
        if (paragraph.childWidgets.length > 1) {
            for (let i = 0; i < paragraph.childWidgets.length; i++) {
                let lineWidget = paragraph.childWidgets[i];
                if (lineWidget.children.length === 0 && paragraph.childWidgets.length > 1) {
                    paragraph.childWidgets.splice(i, 1);
                    i--;
                }
            }
        }
    }
    //#endregion
    /**
     * clone the list level
     * @param  {WListLevel} source
     * @private
     */
    cloneListLevel(source) {
        let listLevel = new WListLevel(undefined);
        this.copyListLevel(listLevel, source);
        return listLevel;
    }
    /**
     * Copies the list level
     * @param  {WListLevel} destination
     * @param  {WListLevel} listLevel
     * @private
     */
    copyListLevel(destination, listLevel) {
        if (!isNullOrUndefined(listLevel.paragraphFormat)) {
            destination.paragraphFormat = new WParagraphFormat(destination);
            destination.paragraphFormat.copyFormat(listLevel.paragraphFormat);
        }
        if (!isNullOrUndefined(listLevel.characterFormat)) {
            destination.characterFormat = new WCharacterFormat(destination);
            destination.characterFormat.copyFormat(listLevel.characterFormat);
        }
        if (!isNullOrUndefined(listLevel.followCharacter)) {
            destination.followCharacter = listLevel.followCharacter;
        }
        if (!isNullOrUndefined(listLevel.listLevelPattern)) {
            destination.listLevelPattern = listLevel.listLevelPattern;
        }
        if (!isNullOrUndefined(listLevel.numberFormat)) {
            destination.numberFormat = listLevel.numberFormat;
        }
        if (!isNullOrUndefined(listLevel.restartLevel)) {
            destination.restartLevel = listLevel.restartLevel;
        }
        if (!isNullOrUndefined(listLevel.startAt)) {
            destination.startAt = listLevel.startAt;
        }
    }
    /**
     * Clone level override
     * @param  {WLevelOverride} source
     * @private
     */
    cloneLevelOverride(source) {
        let levelOverride = new WLevelOverride();
        if (!isNullOrUndefined(source.startAt)) {
            levelOverride.startAt = source.startAt;
        }
        if (!isNullOrUndefined(source.overrideListLevel)) {
            levelOverride.overrideListLevel = source.overrideListLevel;
        }
        if (!isNullOrUndefined(source.levelNumber)) {
            levelOverride.levelNumber = source.levelNumber;
        }
        return levelOverride;
    }
    /**
     * Update List Paragraph
     * @private
     */
    updateListParagraphs() {
        this.viewer.listParagraphs = [];
        for (let j = 0; j < this.viewer.pages.length; j++) {
            let bodyWidget = this.viewer.pages[j].bodyWidgets[0];
            for (let i = 0; i < bodyWidget.childWidgets.length; i++) {
                this.updateListParagraphsInBlock(bodyWidget.childWidgets[i]);
            }
        }
    }
    /**
     * @private
     */
    updateListParagraphsInBlock(block) {
        if (block instanceof ParagraphWidget) {
            if (!isNullOrUndefined(block.paragraphFormat)
                && !isNullOrUndefined(block.paragraphFormat.listFormat)
                && !isNullOrUndefined(block.paragraphFormat.listFormat.listId)) {
                if (isNullOrUndefined(this.viewer.listParagraphs)) {
                    this.viewer.listParagraphs = [];
                }
                this.viewer.listParagraphs.push(block);
            }
        }
        else if (block instanceof TableWidget) {
            for (let i = 0; i < block.childWidgets.length; i++) {
                for (let j = 0; j < block.childWidgets[i].childWidgets.length; j++) {
                    let cell = block.childWidgets[i].childWidgets[j];
                    for (let k = 0; k < cell.childWidgets.length; k++) {
                        this.updateListParagraphsInBlock(cell.childWidgets[k]);
                    }
                }
            }
        }
    }
    /**
     * Applies list format
     * @param  {WList} list
     * @private
     */
    onApplyList(list) {
        let selection = this.viewer.selection;
        this.setOffsetValue(this.viewer.selection);
        this.initHistory('ListFormat');
        let format = new WListFormat();
        if (!isNullOrUndefined(list)) {
            format.listId = list.listId;
        }
        this.viewer.owner.isShiftingEnabled = true;
        if (selection.isEmpty) {
            this.applyParaFormatProperty(selection.start.paragraph, 'listFormat', format, false);
            this.layoutItemBlock(selection.start.paragraph, false);
        }
        else {
            this.updateSelectionParagraphFormatting('listFormat', format, false);
        }
        this.reLayout(selection);
    }
    /**
     * Applies bullets or numbering list
     * @param  {string} format
     * @param  {ListLevelPattern} listLevelPattern
     * @param  {string} fontFamily
     * @private
     */
    applyBulletOrNumbering(format, listLevelPattern, fontFamily) {
        let selection = this.viewer.selection;
        let list = selection.paragraphFormat.getList();
        let isUpdate = false;
        let start = selection.start;
        if (!selection.isForward) {
            start = selection.end;
        }
        let currentParagraph = start.paragraph;
        if (isNullOrUndefined(list)) {
            while (!isNullOrUndefined(currentParagraph.previousWidget) && currentParagraph.previousWidget instanceof ParagraphWidget
                && currentParagraph.previousWidget.isEmpty() && currentParagraph.previousWidget.paragraphFormat.listFormat.listId === -1) {
                currentParagraph = currentParagraph.previousWidget;
            }
            if (currentParagraph.previousWidget && currentParagraph.previousWidget instanceof ParagraphWidget
                && currentParagraph.previousWidget.paragraphFormat.listFormat.listId !== -1) {
                currentParagraph = currentParagraph.previousWidget;
                list = this.viewer.getListById(currentParagraph.paragraphFormat.listFormat.listId);
                isUpdate = true;
            }
        }
        let startListLevel = undefined;
        if (!isNullOrUndefined(list)) {
            let tempList = this.viewer.getListById(currentParagraph.paragraphFormat.listFormat.listId);
            startListLevel = this.viewer.layout.getListLevel(tempList, currentParagraph.paragraphFormat.listFormat.listLevelNumber);
        }
        if (isNullOrUndefined(list) || (!isNullOrUndefined(list) && ((startListLevel.listLevelPattern !== listLevelPattern) ||
            startListLevel.numberFormat !== format || (startListLevel.characterFormat.fontFamily !== fontFamily
            && startListLevel.listLevelPattern === 'Bullet')))) {
            isUpdate = false;
            list = new WList();
            if (this.viewer.lists.length > 0) {
                list.listId = this.viewer.lists[this.viewer.lists.length - 1].listId + 1;
            }
            else {
                list.listId = 0;
            }
            let abstractList = new WAbstractList();
            if (this.viewer.abstractLists.length > 0) {
                abstractList.abstractListId = this.viewer.abstractLists[this.viewer.abstractLists.length - 1].abstractListId + 1;
            }
            else {
                abstractList.abstractListId = 0;
            }
            list.abstractListId = abstractList.abstractListId;
            list.abstractList = abstractList;
            this.viewer.abstractLists.push(abstractList);
            if (format === 'bullet' || format === 'multiLevel' || format === 'numbering') {
                this.addListLevels(abstractList, format, selection);
            }
            else {
                let listLevel = new WListLevel(abstractList);
                listLevel.listLevelPattern = listLevelPattern;
                listLevel.numberFormat = format;
                if (listLevelPattern !== 'Bullet') {
                    listLevel.startAt = 1;
                }
                else {
                    listLevel.characterFormat.fontFamily = fontFamily;
                }
                listLevel.paragraphFormat.leftIndent = 36;
                listLevel.paragraphFormat.firstLineIndent = -18;
                abstractList.levels.push(listLevel);
                selection.paragraphFormat.listLevelNumber = 0;
            }
            selection.paragraphFormat.setList(list);
        }
        else if (!isNullOrUndefined(list) && isUpdate) {
            selection.paragraphFormat.setList(list);
        }
        else {
            selection.paragraphFormat.setList(undefined);
        }
    }
    addListLevels(abstractListAdv, listName, selection) {
        let bulletCharacters = ['\uf076', '\uf0d8', '\uf0a7', '\uf0b7', '\uf0a8'];
        for (let i = abstractListAdv.levels.length; i < 9; i++) {
            let listLevel = new WListLevel(abstractListAdv);
            if (listName.match('bullet')) {
                listLevel.listLevelPattern = 'Bullet';
                listLevel.numberFormat = bulletCharacters[i < 5 ? i % 5 : i % 5 + 1];
                listLevel.characterFormat.fontFamily = i < 3 || i === 5 ? 'Wingdings' : 'Symbol';
            }
            else {
                if (listName.match('multiLevel')) {
                    for (let j = 0; j < i + 1; j++) {
                        listLevel.numberFormat += '%' + (j + 1).toString() + '.';
                    }
                    listLevel.listLevelPattern = 'Number';
                }
                else {
                    listLevel.numberFormat = '%' + (i + 1).toString() + ')';
                    listLevel.listLevelPattern = i % 3 === 0 ? 'Number'
                        : i % 3 === 1 ? 'LowLetter' : 'LowRoman';
                }
                listLevel.startAt = 1;
                listLevel.restartLevel = i;
            }
            if (i === 0) {
                listLevel.paragraphFormat.leftIndent = 36;
            }
            else {
                listLevel.paragraphFormat.leftIndent = 36 * i;
            }
            listLevel.paragraphFormat.firstLineIndent = -18;
            abstractListAdv.levels.push(listLevel);
            selection.paragraphFormat.listLevelNumber = i;
        }
    }
    /**
     * Insert page break at cursor position
     */
    insertPageBreak() {
        if (!this.owner.isReadOnlyMode) {
            if (this.viewer.selection.start.paragraph.isInsideTable ||
                this.viewer.selection.start.paragraph.isInHeaderFooter) {
                return;
            }
            this.initComplexHistory('PageBreak');
            this.onEnter(true);
            if (this.editorHistory && this.editorHistory.currentHistoryInfo != null) {
                this.editorHistory.updateComplexHistory();
            }
            this.selection.checkForCursorVisibility();
        }
    }
    /**
     * @private
     */
    onEnter(isInsertPageBreak) {
        let selection = this.viewer.selection;
        if (selection.isEmpty) {
            //ToDo: Need to handle the CTRL + Enter (Page Break) and SHIFT + Enter (Line Break) behavior.
            let hyperlinkField = selection.getHyperlinkField();
            let isSelectionOnHyperlink = !isNullOrUndefined(hyperlinkField);
            if (isSelectionOnHyperlink) {
                selection.fireRequestNavigate(hyperlinkField);
                return;
            }
            let paragraph = selection.start.paragraph;
            if (paragraph.isEmpty() && paragraph.paragraphFormat.listFormat.listId !== -1) {
                // tslint:disable-next-line:max-line-length
                this.onApplyListInternal(this.viewer.getListById(paragraph.paragraphFormat.listFormat.listId), paragraph.paragraphFormat.listFormat.listLevelNumber - 1);
                return;
            }
        }
        this.initHistory('Enter');
        let isRemoved = true;
        if (!selection.isEmpty) {
            // this.initHistoryWithSelection(selection, 'Enter');
            isRemoved = this.removeSelectedContents(selection);
        }
        if (isRemoved) {
            selection.owner.isShiftingEnabled = true;
            this.updateInsertPosition();
            let blockInfo = this.getParagraphInfo(selection.start);
            let initialStart = this.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
            this.splitParagraphInternal(selection, selection.start.paragraph, selection.start.currentWidget, selection.start.offset);
            this.setPositionForCurrentIndex(selection.start, initialStart);
            if (isInsertPageBreak) {
                let currentParagraph = selection.start.paragraph;
                let breakParagraph = new ParagraphWidget();
                breakParagraph.characterFormat.copyFormat(currentParagraph.characterFormat);
                breakParagraph.paragraphFormat.copyFormat(currentParagraph.paragraphFormat);
                let pageBreak = new TextElementBox();
                pageBreak.text = '\f';
                let line = new LineWidget(breakParagraph);
                line.children.push(pageBreak);
                pageBreak.line = line;
                breakParagraph.childWidgets.push(line);
                this.insertParagraph(breakParagraph, true);
                selection.selectParagraph(breakParagraph, true);
            }
            let nextNode = selection.start.paragraph.nextWidget;
            if (isNullOrUndefined(nextNode)) {
                nextNode = selection.getNextRenderedBlock(selection.start.paragraph);
            }
            selection.selectParagraph(nextNode, true);
            this.updateEndPosition();
            if (isInsertPageBreak && this.editorHistory) {
                this.owner.editorHistory.updateHistory();
            }
            // if (!isNullOrUndefined(selection.currentHistoryInfo)) {
            //     this.updateComplexHistory();
            // } else {
            this.reLayout(selection);
            // }
            let paragraph = selection.start.paragraph.previousWidget;
            if (!isNullOrUndefined(paragraph) && !paragraph.isEmpty() &&
                // tslint:disable-next-line:max-line-length
                paragraph.lastChild.children[paragraph.lastChild.children.length - 1] instanceof TextElementBox) {
                this.checkAndConvertToHyperlink(selection, true, paragraph);
            }
        }
    }
    splitParagraphInternal(selection, paragraphAdv, currentLine, offset) {
        let insertIndex = 0;
        let blockIndex = paragraphAdv.index;
        let paragraph = new ParagraphWidget();
        let lineWidget = new LineWidget(paragraph);
        paragraph.childWidgets.push(lineWidget);
        //Copies the format to new paragraph.
        paragraph.paragraphFormat.ownerBase = paragraph;
        if (currentLine === paragraphAdv.lastChild && offset === selection.getLineLength(currentLine)) {
            // tslint:disable-next-line:max-line-length
            if (paragraphAdv.paragraphFormat.baseStyle
                && paragraphAdv.paragraphFormat.baseStyle.name !== 'Normal' && paragraphAdv.paragraphFormat.baseStyle.next instanceof WParagraphStyle) {
                if (paragraphAdv.paragraphFormat.baseStyle.name === paragraphAdv.paragraphFormat.baseStyle.next.name) {
                    paragraph.paragraphFormat.copyFormat(paragraphAdv.paragraphFormat);
                    paragraph.characterFormat.copyFormat(paragraphAdv.characterFormat);
                }
                else {
                    paragraph.paragraphFormat.baseStyle = paragraphAdv.paragraphFormat.baseStyle.next;
                }
                this.selection.skipFormatRetrieval = false;
            }
            else {
                paragraph.paragraphFormat.copyFormat(paragraphAdv.paragraphFormat);
                paragraph.characterFormat.copyFormat(paragraphAdv.characterFormat);
            }
            //ToDo in future: Need to skip copying formattings to new paragraph, if the style for following paragraph is same style.
            insertIndex++;
            blockIndex++;
        }
        else {
            paragraph.paragraphFormat.copyFormat(paragraphAdv.paragraphFormat);
            paragraph.characterFormat.copyFormat(paragraphAdv.characterFormat);
            if (offset > 0 || !currentLine.isFirstLine()) {
                paragraphAdv = paragraphAdv.combineWidget(this.viewer);
                this.moveInlines(paragraphAdv, paragraph, 0, 0, paragraphAdv.firstChild, offset, currentLine);
            }
            paragraphAdv = paragraphAdv.getSplitWidgets()[0];
        }
        insertIndex += paragraphAdv.getIndex();
        let container = paragraphAdv.containerWidget;
        let childNodes = container.childWidgets;
        childNodes.splice(insertIndex, 0, paragraph);
        paragraph.containerWidget = container;
        paragraph.index = blockIndex;
        this.updateNextBlocksIndex(paragraph, true);
        // tslint:disable-next-line:max-line-length
        this.viewer.layout.layoutBodyWidgetCollection(blockIndex, container, paragraph, false);
    }
    /**
     * @private
     */
    updateNextBlocksIndex(block, increaseIndex) {
        let nextIndex = block.containerWidget.childWidgets.indexOf(block) + 1;
        if (block.containerWidget instanceof BodyWidget) {
            let currentSectionIndex = block.containerWidget.index;
            for (let j = this.viewer.pages.indexOf(block.containerWidget.page); j < this.viewer.pages.length; j++) {
                let page = this.viewer.pages[j];
                if (page.bodyWidgets[0].index === currentSectionIndex) {
                    for (let k = nextIndex; k < page.bodyWidgets[0].childWidgets.length; k++) {
                        let childWidget = page.bodyWidgets[0].childWidgets[k];
                        this.updateIndex(childWidget, increaseIndex);
                    }
                    nextIndex = 0;
                }
                else {
                    return;
                }
            }
        }
        else if (block.containerWidget instanceof TableCellWidget) {
            let cells = block.containerWidget.getSplitWidgets();
            let currentCellIndex = cells.indexOf(block.containerWidget);
            for (let x = currentCellIndex; x < cells.length; x++) {
                let blocks = cells[x].childWidgets;
                for (let y = nextIndex; y < blocks.length; y++) {
                    this.updateIndex(blocks[y], increaseIndex);
                }
                currentCellIndex = 0;
                nextIndex = 0;
            }
        }
        else if (block.containerWidget instanceof TableRowWidget) {
            for (let i = nextIndex; i < block.containerWidget.childWidgets.length; i++) {
                let cell = block.containerWidget.childWidgets[i];
                if (cell.rowIndex === block.containerWidget.index) {
                    this.updateIndex(cell, increaseIndex);
                }
            }
        }
        else if (block.containerWidget instanceof TableWidget) {
            for (let i = nextIndex; i < block.containerWidget.childWidgets.length; i++) {
                let row = block.containerWidget.childWidgets[i];
                this.updateIndex(row, increaseIndex);
                for (let j = 0; j < row.childWidgets.length; j++) {
                    row.childWidgets[j].rowIndex = row.index;
                }
            }
            //update Row index of all the cell
        }
        else if (block.containerWidget instanceof HeaderFooterWidget) {
            for (let i = nextIndex; i < block.containerWidget.childWidgets.length; i++) {
                let nextBlock = block.containerWidget.childWidgets[i];
                this.updateIndex(nextBlock, increaseIndex);
            }
        }
    }
    updateIndex(widget, increment) {
        if (increment) {
            widget.index++;
        }
        else {
            widget.index--;
        }
    }
    updateEndPosition() {
        let selection = this.viewer.selection;
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            this.updateHistoryPosition(selection.start, false);
        }
    }
    /**
     * @private
     */
    onBackSpace() {
        let selection = this.viewer.selection;
        if (selection.isEmpty) {
            this.singleBackspace(selection, false);
        }
        else {
            this.initHistory('BackSpace');
            let skipBackSpace = this.deleteSelectedContents(selection, true);
            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                if (skipBackSpace) {
                    this.editorHistory.currentBaseHistoryInfo = undefined;
                }
                else {
                    if (this.checkEndPosition(selection)) {
                        this.updateHistoryPosition(selection.end, false);
                    }
                    this.reLayout(selection);
                }
            }
        }
    }
    /**
     * @private
     */
    insertRemoveBookMarkElements() {
        let isHandledComplexHistory = false;
        for (let i = 0; i < this.removedBookmarkElements.length; i++) {
            let bookMark = this.removedBookmarkElements[i];
            if (bookMark.bookmarkType === 0) {
                let bookMarkStart = bookMark;
                if (bookMarkStart && bookMarkStart.reference && this.removedBookmarkElements.indexOf(bookMarkStart.reference) !== -1) {
                    let endIndex = this.removedBookmarkElements.indexOf(bookMarkStart.reference);
                    let startIndex = this.removedBookmarkElements.indexOf(bookMarkStart);
                    this.removedBookmarkElements.splice(endIndex, 1);
                    this.removedBookmarkElements.splice(startIndex, 1);
                }
                else {
                    this.initComplexHistory(this.editorHistory.currentBaseHistoryInfo.action);
                    this.editorHistory.updateHistory();
                    this.initInsertInline(bookMarkStart.clone());
                    this.editorHistory.updateComplexHistory();
                    isHandledComplexHistory = true;
                }
            }
            else {
                let bookMarkEnd = bookMark;
                if (bookMarkEnd && bookMarkEnd.reference && this.removedBookmarkElements.indexOf(bookMarkEnd.reference) !== -1) {
                    let endIndex = this.removedBookmarkElements.indexOf(bookMarkEnd.reference);
                    let startIndex = this.removedBookmarkElements.indexOf(bookMarkEnd);
                    this.removedBookmarkElements.splice(endIndex, 1);
                    this.removedBookmarkElements.splice(startIndex, 1);
                }
                else {
                    this.initComplexHistory(this.editorHistory.currentBaseHistoryInfo.action);
                    this.editorHistory.updateHistory();
                    this.initInsertInline(bookMarkEnd.clone());
                    this.editorHistory.updateComplexHistory();
                    isHandledComplexHistory = true;
                }
            }
        }
        this.removedBookmarkElements = [];
        return isHandledComplexHistory;
    }
    /**
     * @private
     */
    deleteSelectedContents(selection, isBackSpace) {
        let skipBackSpace = this.deleteSelectedContentInternal(selection, isBackSpace, selection.start, selection.end);
        let textPosition = new TextPosition(selection.owner);
        let blockInfo = this.getParagraph({ index: selection.editPosition });
        let lineInfo = this.getLineInfo(blockInfo.paragraph, blockInfo.offset);
        textPosition.setPositionForLineWidget(lineInfo.line, lineInfo.offset);
        selection.selectContent(textPosition, true);
        return skipBackSpace;
    }
    /**
     * @private
     */
    singleBackspace(selection, isRedoing) {
        let history = this.editorHistory;
        // If backspace is pressed after auto format to hyperlink is done, need to undo auto format.
        if (history && !isRedoing && !history.canRedo() && history.canUndo()) {
            let historyInfo = history.undoStack[history.undoStack.length - 1];
            let startBlockInfo = this.getParagraphInfo(selection.start);
            let endBlockInfo = this.getParagraphInfo(selection.end);
            // tslint:disable-next-line:max-line-length
            if (historyInfo.action === 'AutoFormatHyperlink' && historyInfo.insertPosition === this.getHierarchicalIndex(startBlockInfo.paragraph, startBlockInfo.offset.toString()) &&
                historyInfo.endPosition === this.getHierarchicalIndex(endBlockInfo.paragraph, endBlockInfo.offset.toString())) {
                history.undo();
                return;
            }
        }
        let paragraph = selection.start.paragraph;
        let currentLineWidget = selection.start.currentWidget;
        let offset = selection.start.offset;
        let indexInInline = 0;
        let inlineObj = currentLineWidget.getInline(offset, indexInInline);
        let inline = inlineObj.element;
        indexInInline = inlineObj.index;
        if (inline instanceof FieldElementBox && inline.fieldType === 2) {
            if (HelperMethods.isLinkedFieldCharacter(inline)) {
                let begin = inline.fieldBegin;
                let end = inline.fieldEnd;
                selection.start.setPositionParagraph(begin.line, begin.line.getOffset(begin, 0));
                selection.end.setPositionParagraph(end.line, end.line.getOffset(end, 0) + 1);
                selection.fireSelectionChanged(true);
                return;
            }
        }
        if (inline instanceof FieldElementBox && inline.fieldType === 1) {
            let prevInline = selection.getPreviousValidElement(inline);
            if (prevInline instanceof FieldElementBox) {
                inline = prevInline.fieldBegin;
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, 0);
                selection.end.setPositionParagraph(inline.line, offset); //Selects the entire field.
                selection.fireSelectionChanged(true);
                return;
            }
            else if (prevInline !== inline) {
                inline = prevInline; //Updates the offset to delete next content.
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, inline.length);
            }
        }
        if (inline && (inline instanceof BookmarkElementBox && inline.bookmarkType === 1
            || inline.previousNode instanceof BookmarkElementBox)) {
            if (inline instanceof BookmarkElementBox) {
                inline = inline.previousNode;
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, inline.length);
            }
            if (inline.length === 1 && inline.nextNode instanceof BookmarkElementBox && inline.previousNode instanceof BookmarkElementBox) {
                let begin = inline.previousNode;
                let end = inline.nextNode;
                selection.start.setPositionParagraph(begin.line, begin.line.getOffset(begin, 0));
                selection.end.setPositionParagraph(end.line, end.line.getOffset(end, 0) + 1);
                this.initHistory('BackSpace');
                this.deleteSelectedContents(selection, true);
                if (this.checkEndPosition(selection)) {
                    this.updateHistoryPosition(selection.end, false);
                }
                this.reLayout(selection);
                return;
            }
        }
        if (!isRedoing) {
            this.initHistory('BackSpace');
        }
        if (offset === selection.getStartOffset(paragraph) && selection.start.currentWidget.isFirstLine()) {
            if (paragraph.paragraphFormat.listFormat && paragraph.paragraphFormat.listFormat.listId !== -1) {
                this.onApplyList(undefined);
                return;
            }
            if (paragraph.paragraphFormat.firstLineIndent !== 0) {
                this.onApplyParagraphFormat('firstLineIndent', 0, false, false);
                return;
            }
            if (paragraph.paragraphFormat.leftIndent !== 0) {
                this.onApplyParagraphFormat('leftIndent', 0, false, false);
                return;
            }
            if (paragraph.paragraphFormat.textAlignment !== 'Left') {
                this.onApplyParagraphFormat('textAlignment', 'Left', false, true);
                return;
            }
            if (paragraph.previousRenderedWidget instanceof ParagraphWidget) {
                selection.owner.isShiftingEnabled = true;
                let previousParagraph = paragraph.previousRenderedWidget;
                // if (isNullOrUndefined(previousParagraph)) {
                //     previousParagraph = this.viewer.selection.getPreviousBlock(paragraph) as ParagraphWidget;
                // }
                if (previousParagraph.isEmpty()) {
                    this.removeBlock(previousParagraph);
                    this.addRemovedNodes(previousParagraph);
                }
                else {
                    this.removeBlock(paragraph);
                    let endOffset = this.viewer.selection.getLineLength(previousParagraph.lastChild);
                    let previousIndex = previousParagraph.childWidgets.length - 1;
                    let lineWidget;
                    if (!paragraph.isEmpty()) {
                        for (let i = 0; i < paragraph.childWidgets.length; i++) {
                            lineWidget = paragraph.childWidgets[i];
                            previousParagraph.childWidgets.push(lineWidget);
                            paragraph.childWidgets.splice(i, 1);
                            i--;
                            lineWidget.paragraph = previousParagraph;
                        }
                    }
                    this.viewer.layout.reLayoutParagraph(previousParagraph, previousIndex, 0);
                    selection.selects(previousParagraph.childWidgets[previousIndex], endOffset, true);
                    this.addRemovedNodes(paragraph);
                }
                this.setPositionForHistory();
                // if (!isRedoing) {
                this.reLayout(selection);
                // }
            }
            else {
                if (this.editorHistory) {
                    this.editorHistory.currentBaseHistoryInfo = undefined;
                }
            }
        }
        else {
            if (!isRedoing) {
                selection.owner.isShiftingEnabled = true;
            }
            let paragraphInfo = this.getParagraphInfo(selection.start);
            let lineWidget = selection.start.currentWidget;
            let removeOffset = offset - 1;
            if (removeOffset < 0) {
                lineWidget = lineWidget.previousLine;
                removeOffset = this.viewer.selection.getLineLength(lineWidget) + removeOffset;
            }
            this.removeAtOffset(lineWidget, selection, removeOffset);
            this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset - 1, false);
            this.setPositionForHistory();
            if (!isRedoing) {
                this.reLayout(selection);
            }
            else {
                this.fireContentChange();
            }
        }
    }
    setPositionForHistory(editPosition) {
        let selection = this.viewer.selection;
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            if (isNullOrUndefined(editPosition)) {
                this.updateHistoryPosition(selection.start, true);
                this.editorHistory.currentBaseHistoryInfo.endPosition = this.editorHistory.currentBaseHistoryInfo.insertPosition;
            }
            else {
                this.editorHistory.currentBaseHistoryInfo.insertPosition = editPosition;
                this.editorHistory.currentBaseHistoryInfo.endPosition = editPosition;
            }
        }
    }
    removeAtOffset(lineWidget, selection, offset) {
        let count = 0;
        let lineIndex = lineWidget.paragraph.childWidgets.indexOf(lineWidget);
        for (let i = 0; i < lineWidget.children.length; i++) {
            let inline = lineWidget.children[i];
            if (inline instanceof ListTextElementBox) {
                continue;
            }
            if (offset < count + inline.length) {
                let indexInInline = offset - count;
                if (offset === count && inline.length === 1) {
                    this.unLinkFieldCharacter(inline);
                    lineWidget.children.splice(i, 1);
                    this.viewer.layout.reLayoutParagraph(lineWidget.paragraph, lineIndex, i);
                    this.addRemovedNodes(inline);
                }
                else {
                    let span = new TextElementBox();
                    span.characterFormat.copyFormat(inline.characterFormat);
                    span.text = inline.text.substr(indexInInline, 1);
                    inline.text = HelperMethods.remove(inline.text, indexInInline, 1);
                    this.viewer.layout.reLayoutParagraph(lineWidget.paragraph, lineIndex, i);
                    this.addRemovedNodes(span);
                }
                break;
            }
            count += inline.length;
        }
    }
    /**
     * @private
     */
    onDelete() {
        let selection = this.viewer.selection;
        if (selection.isEmpty) {
            this.singleDelete(selection, false);
        }
        else {
            // this.initComplexHistory('MultiSelection');
            // for (let i: number = 0; i < selection.selectionRanges.length; i++) {
            // let selectionRange: SelectionRange = selection.selectionRanges.getRange(i);
            this.initHistory('Delete');
            this.deleteSelectedContentInternal(selection, false, selection.start, selection.end);
            let textPosition = new TextPosition(selection.owner);
            this.setPositionForCurrentIndex(textPosition, selection.editPosition);
            selection.selectContent(textPosition, true);
            // if (this.viewer.owner.enableEditorHistory) {
            this.reLayout(selection);
            // }
            // this.updateSelectionRangeOffSet(selection.start, selection.end);
            // }
            // let textPosition: TextPosition = new TextPosition(selection.owner, this.viewer);
            // this.setPositionForCurrentIndex(textPosition,selection.editPosition);
            // selection.selectContent(textPosition, true);
            // if (!isNullOrUndefined(selection.currentHistoryInfo)) {
            //     this.updateComplexHistory();
            // } else {
            //     this.updateComplexWithoutHistory();
            // }
        }
    }
    /**
     * Remove single character on right of cursor position
     * @param  {Selection} selection
     * @param  {boolean} isRedoing
     * @private
     */
    singleDelete(selection, isRedoing) {
        // tslint:disable-next-line:max-line-length
        let paragraph = selection.start.paragraph;
        let offset = selection.start.offset;
        let indexInInline = 0;
        let inlineObj = paragraph.getInline(selection.start.offset, indexInInline);
        let inline = inlineObj.element;
        indexInInline = inlineObj.index;
        if (paragraph.paragraphFormat.listFormat && paragraph.paragraphFormat.listFormat.listId !== -1 &&
            this.viewer.isListTextSelected && selection.contextType === 'List') {
            this.onApplyList(undefined);
            return;
        }
        if (!isNullOrUndefined(inline) && indexInInline === inline.length && !isNullOrUndefined(inline.nextNode)) {
            inline = inline.nextNode;
            indexInInline = 0;
        }
        if (!isNullOrUndefined(inline)) {
            let nextRenderedInline = undefined;
            let nextInline = selection.getNextValidElement(inline);
            if (nextInline instanceof ElementBox) {
                nextRenderedInline = nextInline;
            }
            if (!isNullOrUndefined(nextRenderedInline) && nextRenderedInline instanceof FieldElementBox
                && nextRenderedInline.fieldType === 0) {
                inline = nextRenderedInline.fieldEnd;
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, 1);
                selection.end.setPositionParagraph(inline.line, offset);
                selection.fireSelectionChanged(true);
                return;
            }
            else if (inline !== nextRenderedInline) {
                inline = nextRenderedInline;
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, 0);
                if (inline instanceof FieldElementBox && inline.fieldType === 1) {
                    offset++;
                }
            }
        }
        if (inline && (inline instanceof BookmarkElementBox && inline.bookmarkType === 0
            || inline.nextNode instanceof BookmarkElementBox)) {
            if (inline instanceof BookmarkElementBox) {
                inline = inline.nextNode;
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, 0);
            }
            if (inline.length === 1 && inline.nextNode instanceof BookmarkElementBox
                && inline.previousNode instanceof BookmarkElementBox) {
                let bookMarkBegin = inline.previousNode;
                let bookMarkEnd = inline.nextNode;
                selection.start.setPositionParagraph(bookMarkBegin.line, bookMarkBegin.line.getOffset(bookMarkBegin, 0));
                selection.end.setPositionParagraph(bookMarkEnd.line, bookMarkEnd.line.getOffset(bookMarkEnd, 0) + 1);
                this.initHistory('Delete');
                this.deleteSelectedContentInternal(selection, false, selection.start, selection.end);
                let textPosition = new TextPosition(selection.owner);
                this.setPositionForCurrentIndex(textPosition, selection.editPosition);
                selection.selectContent(textPosition, true);
                this.reLayout(selection);
                return;
            }
        }
        if (selection.start.currentWidget.isLastLine() && offset === this.viewer.selection.getLineLength(selection.start.currentWidget)) {
            if (paragraph.isInsideTable && isNullOrUndefined(paragraph.nextWidget)) {
                return;
            }
            let previousParagraph = undefined;
            let newParagraph = undefined;
            let nextParagraph = selection.getNextParagraphBlock(paragraph);
            if (isNullOrUndefined(nextParagraph)) {
                if (offset > 0) {
                    return;
                }
                else {
                    if (paragraph.previousWidget instanceof ParagraphWidget) {
                        previousParagraph = paragraph.previousWidget;
                    }
                    if (paragraph.previousWidget instanceof TableWidget) {
                        return;
                    }
                    if (isNullOrUndefined(previousParagraph)) {
                        return;
                        //Adds an empty paragraph, to ensure minimal content.
                    }
                }
            }
            if (!isRedoing) {
                this.initHistory('Delete');
            }
            let blockInfo = this.getParagraphInfo(selection.start);
            selection.editPosition = this.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
            if (this.checkInsertPosition(selection)) {
                this.setPositionForHistory(selection.editPosition);
            }
            selection.owner.isShiftingEnabled = true;
            if (paragraph.isEmpty()) {
                this.removeBlock(paragraph);
                this.addRemovedNodes(paragraph);
                if (isNullOrUndefined(nextParagraph)) {
                    if (isNullOrUndefined(previousParagraph)) {
                        // selection.selectParagraph(newParagraph, true, true);
                        let paraEndOffset = selection.getParagraphLength(newParagraph) + 1;
                        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                            this.updateHistoryPosition(selection.start, true);
                            //tslint:disable-next-line:max-line-length
                            this.editorHistory.currentBaseHistoryInfo.endPosition = this.getHierarchicalIndex(newParagraph, paraEndOffset.toString());
                        }
                    }
                    else {
                        selection.selectParagraph(previousParagraph, false);
                        this.setPositionForHistory();
                    }
                }
                else {
                    selection.selectParagraph(nextParagraph, true);
                }
            }
            else {
                paragraph = paragraph.combineWidget(this.viewer);
                // tslint:disable-next-line:max-line-length
                let currentParagraph = this.splitParagraph(paragraph, paragraph.firstChild, 0, selection.start.currentWidget, selection.start.offset, true);
                this.deleteParagraphMark(currentParagraph, selection, 0);
                this.addRemovedNodes(paragraph);
                this.setPositionForCurrentIndex(selection.start, selection.editPosition);
                selection.selectContent(selection.start, true);
            }
            // if (!isRedoing) {
            this.reLayout(selection);
            // }
        }
        else {
            this.singleDeleteInternal(selection, isRedoing, paragraph);
        }
    }
    singleDeleteInternal(selection, isRedoing, paragraph) {
        if (!isRedoing) {
            selection.owner.isShiftingEnabled = true;
            this.initHistory('Delete');
        }
        if (this.checkInsertPosition(selection)) {
            this.updateHistoryPosition(selection.start, true);
            this.editorHistory.currentBaseHistoryInfo.endPosition = this.editorHistory.currentBaseHistoryInfo.insertPosition;
        }
        let paragraphInfo = this.getParagraphInfo(selection.start);
        let lineWidget = selection.start.currentWidget;
        let removeOffset = selection.start.offset;
        let lineLength = selection.getLineLength(selection.start.currentWidget);
        if (removeOffset >= lineLength) {
            lineWidget = lineWidget.nextLine;
            removeOffset = removeOffset - lineLength;
        }
        this.removeAtOffset(lineWidget, selection, removeOffset);
        this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset, false);
        if (!isRedoing) {
            this.reLayout(selection);
        }
        else {
            this.fireContentChange();
        }
    }
    deleteParagraphMark(paragraph, selection, editAction) {
        if (isNullOrUndefined(paragraph.containerWidget)) {
            return;
        }
        paragraph = paragraph.combineWidget(this.viewer);
        let nextParagraph = selection.getNextParagraphBlock(paragraph);
        if (paragraph.isInsideTable && isNullOrUndefined(paragraph.nextWidget) || isNullOrUndefined(nextParagraph)) {
            return;
        }
        //BodyWidget
        let section = paragraph.containerWidget instanceof BodyWidget ? paragraph.containerWidget : undefined;
        let table = undefined;
        if (selection.getNextRenderedBlock(paragraph) instanceof TableWidget) {
            table = selection.getNextRenderedBlock(paragraph);
        }
        else {
            table = undefined;
        }
        if (nextParagraph.isInsideTable && !isNullOrUndefined(table) && table.contains(nextParagraph.associatedCell)) {
            if (editAction < 4) {
                // let nextSection: BodyWidget = table.containerWidget instanceof BodyWidget ? table.containerWidget : undefined;
                // if (section !== nextSection) {
                //     this.combineSection(section, selection, nextSection);
                // }
                let offset = 0;
                this.removeBlock(paragraph);
                this.viewer.layout.clearListElementBox(nextParagraph);
                this.viewer.layout.clearListElementBox(paragraph);
                for (let i = paragraph.childWidgets.length - 1; i >= 0; i--) {
                    let line = paragraph.childWidgets[i];
                    for (let j = line.children.length - 1; j >= 0; j--) {
                        let element = line.children[j];
                        offset += element.length;
                        nextParagraph.firstChild.children.unshift(element);
                        element.line = nextParagraph.firstChild;
                        // this.layoutInlineCollection(false, 0, nextParagraph.inlines, inline);
                    }
                }
                this.viewer.layout.reLayoutParagraph(nextParagraph, 0, 0);
                if (offset > 0) {
                    selection.editPosition = this.getHierarchicalIndex(nextParagraph, offset.toString());
                }
            }
        }
        else {
            if (editAction < 4) {
                // let nextSection: WSection = nextParagraph.section instanceof WSection ? nextParagraph.section as WSection : undefined;
                // if (section !== nextSection) {
                //     this.combineSection(section, selection, nextSection);
                // }
                let prevLength = paragraph.childWidgets.length - 1;
                let nextPara = nextParagraph.getSplitWidgets();
                nextParagraph = nextParagraph.combineWidget(this.viewer);
                this.viewer.layout.clearListElementBox(nextParagraph);
                this.viewer.layout.clearListElementBox(paragraph);
                this.updateEditPositionOnMerge(paragraph, nextParagraph);
                for (let i = 0; i < nextParagraph.childWidgets.length; i++) {
                    let inline = nextParagraph.childWidgets[i];
                    nextParagraph.childWidgets.splice(i, 1);
                    paragraph.childWidgets.push(inline);
                    inline.paragraph = paragraph;
                    i--;
                }
                if (nextParagraph.childWidgets.length === 0) {
                    nextParagraph.childWidgets.push(new LineWidget(nextParagraph));
                }
                this.removeBlock(nextParagraph);
                this.viewer.layout.reLayoutParagraph(paragraph, 0, 0);
                this.addRemovedNodes(nextParagraph);
            }
        }
    }
    updateEditPositionOnMerge(currentParagraph, nextParagraph) {
        if (this.viewer.selection.editPosition === this.getHierarchicalIndex(nextParagraph, '0') &&
            nextParagraph.nextRenderedWidget === undefined) {
            // tslint:disable-next-line:max-line-length
            this.viewer.selection.editPosition = this.getHierarchicalIndex(currentParagraph, this.viewer.selection.getLineLength(currentParagraph.lastChild).toString());
        }
    }
    checkEndPosition(selection) {
        return (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)
            && isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo.endPosition));
    }
    checkInsertPosition(selection) {
        return (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)
            && isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo.insertPosition));
    }
    checkIsNotRedoing() {
        return this.viewer.owner.enableHistoryMode && !this.editorHistory.isRedoing;
    }
    // tslint:disable-next-line:max-line-length
    deleteSelectedContentInternal(selection, isBackSpace, startPosition, endPosition) {
        let startPos = startPosition;
        let endPos = endPosition;
        if (!startPosition.isExistBefore(endPosition)) {
            startPos = endPosition;
            endPos = startPosition;
        }
        let blockInfo = this.getParagraphInfo(startPos);
        selection.editPosition = this.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        let skipBackSpace = false;
        if (isBackSpace && startPos.isInSameParagraph(endPos)) {
            //Handled specifically to skip removal of contents, if selection is only paragraph mark and next rendered block is table.
            if (startPos.offset < endPos.offset && startPos.offset === selection.getParagraphLength(endPos.paragraph)) {
                let nextBlock = selection.getNextRenderedBlock(startPos.paragraph);
                skipBackSpace = nextBlock instanceof TableWidget;
            }
            //Handled specifically to remove paragraph completely (Delete behavior), if the selected paragraph is empty.
            if (endPos.offset === 1 && endPos.offset > selection.getParagraphLength(endPos.paragraph)
                && !(endPos.paragraph.isInsideTable && isNullOrUndefined(endPos.paragraph.nextWidget))) {
                isBackSpace = false;
            }
        }
        if (!skipBackSpace) {
            selection.owner.isShiftingEnabled = true;
            if (this.checkInsertPosition(selection)) {
                this.editorHistory.currentBaseHistoryInfo.insertPosition = selection.editPosition;
            }
            let editAction = (isBackSpace ? 1 : 0);
            this.deleteSelectedContent(endPos.paragraph, selection, startPos, endPos, editAction);
        }
        return skipBackSpace;
    }
    /**
     * Init EditorHistory
     * @private
     */
    initHistory(action) {
        if (this.viewer.owner.enableHistoryMode) {
            this.editorHistory.initializeHistory(action);
        }
    }
    /**
     * Init Complex EditorHistory
     * @private
     */
    initComplexHistory(action) {
        if (this.viewer.owner.enableHistoryMode) {
            this.editorHistory.initComplexHistory(this.viewer.selection, action);
        }
    }
    //Insert Picture implementation starts
    /**
     * Insert image
     * @param  {string} base64String
     * @param  {number} width
     * @param  {number} height
     * @private
     */
    insertPicture(base64String, width, height) {
        let imageElementBox = new ImageElementBox(true);
        imageElementBox.imageString = base64String;
        imageElementBox.width = width;
        imageElementBox.height = height;
        this.insertPictureInternal(imageElementBox);
    }
    insertPictureInternal(imageElementBox) {
        let selection = this.viewer.selection;
        this.initHistory('InsertInline');
        this.fitImageToPage(selection, imageElementBox);
        this.insertInlineInSelection(selection, imageElementBox);
        this.reLayout(selection);
    }
    fitImageToPage(selection, imageElementBox) {
        let section = selection.start.paragraph.bodyWidget;
        let pageWidth = section.sectionFormat.pageWidth - section.sectionFormat.leftMargin - section.sectionFormat.rightMargin;
        let pageHeight = section.sectionFormat.pageHeight - section.sectionFormat.topMargin - section.sectionFormat.topMargin;
        //Resizes image to page size.
        if (imageElementBox.width > pageWidth) {
            imageElementBox.height = imageElementBox.height * pageWidth / imageElementBox.width;
            imageElementBox.width = pageWidth;
        }
        if (imageElementBox.height > pageHeight) {
            imageElementBox.width = imageElementBox.width * pageHeight / imageElementBox.height;
            imageElementBox.height = pageHeight;
        }
    }
    //Insert Picture implementation ends
    /**
     * @private
     */
    insertInlineInSelection(selection, elementBox) {
        if (this.checkIsNotRedoing()) {
            selection.owner.isShiftingEnabled = true;
        }
        if (!selection.isEmpty) {
            this.removeSelectedContents(selection);
        }
        this.updateInsertPosition();
        this.insertInlineInternal(elementBox);
        if (this.checkEndPosition(selection)) {
            this.updateHistoryPosition(selection.start, false);
        }
        this.fireContentChange();
    }
    /**
     * @private
     */
    onPortrait() {
        let sectionFormat = new WSectionFormat();
        let width = this.viewer.selection.sectionFormat.pageWidth;
        let height = this.viewer.selection.sectionFormat.pageHeight;
        if (width > height) {
            sectionFormat.pageWidth = height;
            sectionFormat.pageHeight = width;
        }
        this.onApplySectionFormat(undefined, sectionFormat);
    }
    /**
     * @private
     */
    onLandscape() {
        let sectionFormat = new WSectionFormat();
        let width = this.viewer.selection.sectionFormat.pageWidth;
        let height = this.viewer.selection.sectionFormat.pageHeight;
        if (width < height) {
            sectionFormat.pageWidth = height;
            sectionFormat.pageHeight = width;
        }
        this.onApplySectionFormat(undefined, sectionFormat);
    }
    copyValues() {
        let format = new WSectionFormat();
        format.bottomMargin = this.viewer.selection.sectionFormat.bottomMargin;
        format.topMargin = this.viewer.selection.sectionFormat.topMargin;
        format.leftMargin = this.viewer.selection.sectionFormat.leftMargin;
        format.rightMargin = this.viewer.selection.sectionFormat.rightMargin;
        format.pageHeight = this.viewer.selection.sectionFormat.pageHeight;
        format.pageWidth = this.viewer.selection.sectionFormat.pageWidth;
        format.footerDistance = this.viewer.selection.sectionFormat.footerDistance;
        format.headerDistance = this.viewer.selection.sectionFormat.headerDistance;
        return format;
    }
    /**
     * @private
     */
    changeMarginValue(property) {
        let sectionFormat = this.copyValues();
        if (property === 'lastCustomSetting' || property === 'normal') {
            sectionFormat.topMargin = 72;
            sectionFormat.bottomMargin = 72;
            sectionFormat.leftMargin = 72;
            sectionFormat.rightMargin = 72;
        }
        else if (property === 'narrow') {
            sectionFormat.topMargin = 36;
            sectionFormat.bottomMargin = 36;
            sectionFormat.leftMargin = 36;
            sectionFormat.rightMargin = 36;
        }
        else if (property === 'moderate') {
            sectionFormat.topMargin = 72;
            sectionFormat.bottomMargin = 72;
            sectionFormat.leftMargin = 54;
            sectionFormat.rightMargin = 54;
        }
        else if (property === 'wide') {
            sectionFormat.topMargin = 72;
            sectionFormat.bottomMargin = 72;
            sectionFormat.leftMargin = 144;
            sectionFormat.rightMargin = 144;
        }
        else if (property === 'mirrored') {
            sectionFormat.topMargin = 72;
            sectionFormat.bottomMargin = 72;
            sectionFormat.leftMargin = 90;
            sectionFormat.rightMargin = 72;
        }
        else if (property === 'office2003Default') {
            sectionFormat.topMargin = 72;
            sectionFormat.bottomMargin = 72;
            sectionFormat.leftMargin = 90;
            sectionFormat.rightMargin = 90;
        }
        this.onApplySectionFormat(undefined, sectionFormat);
    }
    /**
     * @private
     */
    onPaperSize(property) {
        let sectionFormat = this.copyValues();
        let width = this.viewer.selection.sectionFormat.pageWidth;
        let height = this.viewer.selection.sectionFormat.pageHeight;
        if (property === 'letter') {
            if (width < height) {
                sectionFormat.pageWidth = 611.9;
                sectionFormat.pageHeight = 791.9;
            }
            else {
                sectionFormat.pageWidth = 791.9;
                sectionFormat.pageHeight = 611.9;
            }
        }
        else if (property === 'tabloid') {
            if (width < height) {
                sectionFormat.pageWidth = 791.9;
                sectionFormat.pageHeight = 1223.9;
            }
            else {
                sectionFormat.pageWidth = 1223.9;
                sectionFormat.pageHeight = 791.9;
            }
        }
        else if (property === 'legal') {
            if (width < height) {
                sectionFormat.pageWidth = 611.9;
                sectionFormat.pageHeight = 1007.9;
            }
            else {
                sectionFormat.pageWidth = 1007.9;
                sectionFormat.pageHeight = 611.9;
            }
        }
        else if (property === 'statement') {
            if (width < height) {
                sectionFormat.pageWidth = 396;
                sectionFormat.pageHeight = 611.9;
            }
            else {
                sectionFormat.pageWidth = 611.9;
                sectionFormat.pageHeight = 396;
            }
        }
        else if (property === 'executive') {
            if (width < height) {
                sectionFormat.pageWidth = 521.9;
                sectionFormat.pageHeight = 755.9;
            }
            else {
                sectionFormat.pageWidth = 755.9;
                sectionFormat.pageHeight = 521.9;
            }
        }
        else if (property === 'a3') {
            if (width < height) {
                sectionFormat.pageWidth = 841.8;
                sectionFormat.pageHeight = 1190.4;
            }
            else {
                sectionFormat.pageWidth = 1190.4;
                sectionFormat.pageHeight = 841.8;
            }
        }
        else if (property === 'a4') {
            if (width < height) {
                sectionFormat.pageWidth = 595.2;
                sectionFormat.pageHeight = 841.8;
            }
            else {
                sectionFormat.pageWidth = 841.8;
                sectionFormat.pageHeight = 595.2;
            }
        }
        else if (property === 'a5') {
            if (width < height) {
                sectionFormat.pageWidth = 419.5;
                sectionFormat.pageHeight = 595.2;
            }
            else {
                sectionFormat.pageWidth = 595.2;
                sectionFormat.pageHeight = 419.5;
            }
        }
        else if (property === 'b4') {
            if (width < height) {
                sectionFormat.pageWidth = 728.4;
                sectionFormat.pageHeight = 1031.7;
            }
            else {
                sectionFormat.pageWidth = 1031.7;
                sectionFormat.pageHeight = 728.4;
            }
        }
        else if (property === 'b5') {
            if (width < height) {
                sectionFormat.pageWidth = 515.8;
                sectionFormat.pageHeight = 728.4;
            }
            else {
                sectionFormat.pageWidth = 728.4;
                sectionFormat.pageHeight = 515.8;
            }
        }
        this.onApplySectionFormat(undefined, sectionFormat);
    }
    //Update List Items
    /**
     * @private
     */
    updateListItemsTillEnd(blockAdv, updateNextBlockList) {
        let block = updateNextBlockList ? this.viewer.selection.getNextRenderedBlock(blockAdv) : blockAdv;
        while (!isNullOrUndefined(block)) {
            //Updates the list value of the rendered paragraph. 
            this.updateRenderedListItems(block);
            block = block.getSplitWidgets().pop().nextRenderedWidget;
        }
    }
    /**
     * @private
     */
    updateWholeListItems(block) {
        this.viewer.renderedLists.clear();
        let sectionIndex = block.bodyWidget.index;
        let currentBlock;
        for (let j = 0; j < this.viewer.pages.length; j++) {
            let page = this.viewer.pages[j];
            if (page.bodyWidgets[0].index === sectionIndex) {
                currentBlock = page.bodyWidgets[0].firstChild;
                break;
            }
        }
        let isListUpdated = false;
        do {
            isListUpdated = this.updateListItems(currentBlock, block);
            if (isListUpdated) {
                break;
            }
            currentBlock = currentBlock.getSplitWidgets().pop().nextRenderedWidget;
        } while (currentBlock);
    }
    updateListItems(blockAdv, block) {
        let isListUpdated = false;
        if (blockAdv instanceof ParagraphWidget) {
            isListUpdated = this.updateListItemsForPara(blockAdv, block);
        }
        else {
            isListUpdated = this.updateListItemsForTable(blockAdv, block);
        }
        return isListUpdated;
    }
    updateListItemsForTable(table, block) {
        if (block instanceof TableWidget && table.equals(block)) {
            return true;
        }
        let row = table.firstChild;
        do {
            let isListUpdated = this.updateListItemsForRow(row, block);
            if (isListUpdated) {
                return true;
            }
            row = row.getSplitWidgets().pop().nextRenderedWidget;
        } while (row);
        return false;
    }
    updateListItemsForRow(row, block) {
        if (block.isInsideTable && row.childWidgets.indexOf(this.viewer.selection.getContainerCell(block.associatedCell)) !== -1) {
            //Returns as list updated, inorder to start list numbering from first list paragraph of this row.
            return true;
        }
        let cell = row.firstChild;
        do {
            this.updateListItemsForCell(cell, block);
            cell = cell.nextRenderedWidget;
        } while (cell);
        return false;
    }
    updateListItemsForCell(cell, block) {
        if (cell.childWidgets.length === 0) {
            return;
        }
        let currentBlock = cell.firstChild;
        do {
            this.updateListItems(currentBlock, block);
            currentBlock = currentBlock.getSplitWidgets().pop().nextRenderedWidget;
        } while (currentBlock);
    }
    // public abstract updateListParagraphs(): void;
    /**
     * @private
     */
    updateRenderedListItems(block) {
        if (block instanceof ParagraphWidget) {
            this.updateRenderedListItemsForPara(block);
        }
        else {
            this.updateRenderedListItemsForTable(block);
        }
    }
    updateRenderedListItemsForTable(table) {
        let row = table.firstChild;
        do {
            this.updateRenderedListItemsForRow(row);
            row = row.getSplitWidgets().pop().nextRenderedWidget;
        } while (row);
    }
    updateRenderedListItemsForRow(row) {
        let cell = row.firstChild;
        do {
            this.updateRenderedListItemsForCell(cell);
            cell = cell.nextRenderedWidget;
        } while (cell);
    }
    updateRenderedListItemsForCell(cell) {
        if (cell.childWidgets.length === 0) {
            return;
        }
        let currentBlock = cell.firstChild;
        do {
            this.updateRenderedListItems(currentBlock);
            currentBlock = currentBlock.getSplitWidgets().pop().nextRenderedWidget;
        } while (currentBlock);
    }
    updateListItemsForPara(paragraph, block) {
        if (paragraph.equals(block)) {
            return true;
        }
        else {
            let currentList = undefined;
            let listLevelNumber = 0;
            if (!isNullOrUndefined(paragraph.paragraphFormat) && !isNullOrUndefined(paragraph.paragraphFormat.listFormat)) {
                currentList = this.viewer.getListById(paragraph.paragraphFormat.listFormat.listId);
                listLevelNumber = paragraph.paragraphFormat.listFormat.listLevelNumber;
            }
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(currentList) && !isNullOrUndefined(this.viewer.getAbstractListById(currentList.abstractListId))
                // tslint:disable-next-line:max-line-length
                && !isNullOrUndefined(this.viewer.getAbstractListById(currentList.abstractListId).levels[listLevelNumber])) {
                let currentListLevel = this.viewer.layout.getListLevel(currentList, listLevelNumber);
                //Updates the list numbering from document start for reLayouting.
                if (currentListLevel.listLevelPattern !== 'Bullet') {
                    this.viewer.layout.getListNumber(paragraph.paragraphFormat.listFormat);
                }
            }
        }
        return false;
    }
    updateRenderedListItemsForPara(paragraph) {
        if (!isNullOrUndefined(this.viewer.getListById(paragraph.paragraphFormat.listFormat.listId))) {
            let currentList = this.viewer.getListById(paragraph.paragraphFormat.listFormat.listId);
            let listLevelNumber = paragraph.paragraphFormat.listFormat.listLevelNumber;
            if (!isNullOrUndefined(currentList) && !isNullOrUndefined(this.viewer.getAbstractListById(currentList.abstractListId))
                // tslint:disable-next-line:max-line-length
                && !isNullOrUndefined(this.viewer.getAbstractListById(currentList.abstractListId).levels[paragraph.paragraphFormat.listFormat.listLevelNumber])) {
                let currentListLevel = this.viewer.layout.getListLevel(currentList, listLevelNumber);
                //Updates the list numbering from document start for reLayouting.
                if (currentListLevel.listLevelPattern !== 'Bullet') {
                    let element = undefined;
                    if (paragraph.childWidgets.length > 0) {
                        let lineWidget = paragraph.childWidgets[0];
                        if (lineWidget.children.length > 0) {
                            element = lineWidget.children[0];
                        }
                    }
                    if (!isNullOrUndefined(element)) {
                        element.text = this.viewer.layout.getListNumber(paragraph.paragraphFormat.listFormat);
                    }
                }
            }
        }
    }
    /**
     * Get logical offset of paragraph.
     * @private
     */
    getParagraphInfo(position) {
        return this.getParagraphInfoInternal(position.currentWidget, position.offset);
    }
    /**
     * @private
     */
    getParagraphInfoInternal(line, lineOffset) {
        let paragraph = line.paragraph;
        let offset = this.selection.getParagraphLength(paragraph, line) + lineOffset;
        let previous = paragraph.previousSplitWidget;
        while (previous instanceof ParagraphWidget) {
            paragraph = previous;
            offset += this.viewer.selection.getParagraphLength(paragraph);
            previous = paragraph.previousSplitWidget;
        }
        return { 'paragraph': paragraph, 'offset': offset };
    }
    /**
     * Get offset value to update in selection
     * @private
     */
    getOffsetValue(selection) {
        if (this.startParagraph) {
            let lineInfo = this.getLineInfo(this.startParagraph, this.startOffset);
            selection.start.setPositionFromLine(lineInfo.line, lineInfo.offset);
        }
        selection.start.updatePhysicalPosition(true);
        if (selection.isEmpty) {
            selection.end.setPositionInternal(selection.start);
        }
        else {
            if (this.endParagraph) {
                let lineInfo = this.getLineInfo(this.endParagraph, this.endOffset);
                selection.end.setPositionFromLine(lineInfo.line, lineInfo.offset);
            }
            selection.end.updatePhysicalPosition(true);
        }
    }
    /**
     * Get offset value to update in selection
     * @private
     */
    getLineInfo(paragraph, offset) {
        let length = this.selection.getParagraphLength(paragraph);
        let next = paragraph.nextSplitWidget;
        if (offset > length + 1 && isNullOrUndefined(next)) {
            offset = length;
        }
        while (offset > length && next instanceof ParagraphWidget) {
            offset -= length;
            paragraph = next;
            length = this.selection.getParagraphLength(paragraph);
            next = paragraph.nextSplitWidget;
        }
        return this.selection.getLineInfo(paragraph, offset);
    }
    /**
     * @private
     */
    setPositionParagraph(paragraph, offset, skipSelectionChange) {
        let selection = this.viewer.selection;
        let lineInfo = this.getLineInfo(paragraph, offset);
        selection.start.setPositionFromLine(lineInfo.line, lineInfo.offset);
        selection.end.setPositionInternal(selection.start);
        if (!skipSelectionChange) {
            selection.fireSelectionChanged(true);
        }
    }
    /**
     * @private
     */
    setPositionForCurrentIndex(textPosition, editPosition) {
        let blockInfo = this.getParagraph({ index: editPosition });
        let lineInfo = this.getLineInfo(blockInfo.paragraph, blockInfo.offset);
        textPosition.setPositionForLineWidget(lineInfo.line, lineInfo.offset);
    }
    /**
     * @private
     */
    insertPageNumber(numberFormat) {
        if (isNullOrUndefined(numberFormat)) {
            numberFormat = '';
        }
        else {
            numberFormat = ' \\*' + numberFormat;
        }
        let fieldCode = 'PAGE ' + numberFormat + ' \\* MERGEFORMAT';
        this.createFields(fieldCode);
    }
    /**
     * @private
     */
    insertPageCount(numberFormat) {
        if (isNullOrUndefined(numberFormat)) {
            numberFormat = '';
        }
        else {
            numberFormat = ' \*' + numberFormat;
        }
        let fieldCode = 'NUMPAGES ' + numberFormat + ' \* MERGEFORMAT';
        this.createFields(fieldCode);
    }
    createFields(fieldCode) {
        let paragraph = new ParagraphWidget();
        let line = new LineWidget(paragraph);
        let fieldBegin = new FieldElementBox(0);
        line.children.push(fieldBegin);
        let fieldtext = new FieldTextElementBox();
        fieldtext.fieldBegin = fieldBegin;
        fieldtext.text = '1';
        let text = new TextElementBox();
        text.text = fieldCode;
        line.children.push(text);
        let fieldSeparator = new FieldElementBox(2);
        fieldSeparator.fieldBegin = fieldBegin;
        fieldBegin.fieldSeparator = fieldSeparator;
        line.children.push(fieldSeparator);
        line.children.push(fieldtext);
        let fieldEnd = new FieldElementBox(1);
        fieldEnd.fieldBegin = fieldBegin;
        fieldEnd.fieldSeparator = fieldSeparator;
        fieldSeparator.fieldEnd = fieldEnd;
        fieldBegin.fieldEnd = fieldEnd;
        line.children.push(fieldEnd);
        fieldBegin.line = line;
        paragraph.childWidgets.push(line);
        let widgets = [];
        widgets.push(paragraph);
        this.viewer.fields.push(fieldBegin);
        this.pasteContentsInternal(widgets);
    }
    /**
     * @private
     */
    insertBookmark(name) {
        let bookmark = new BookmarkElementBox(0);
        bookmark.name = name;
        let bookmarkEnd = new BookmarkElementBox(1);
        bookmarkEnd.name = name;
        bookmark.reference = bookmarkEnd;
        bookmarkEnd.reference = bookmark;
        this.viewer.bookmarks.add(name, bookmark);
        this.initComplexHistory('InsertBookmark');
        this.insertElements([bookmarkEnd], [bookmark]);
        if (this.editorHistory) {
            this.editorHistory.updateComplexHistoryInternal();
        }
        this.selection.start.setPositionForSelection(bookmark.line, bookmark, 1, this.selection.start.location);
        this.selection.end.setPositionForSelection(bookmarkEnd.line, bookmarkEnd, 0, this.selection.end.location);
        this.selection.fireSelectionChanged(true);
        this.fireContentChange();
    }
    /**
     * @private
     */
    deleteBookmark(bookmarkName) {
        let bookmarks = this.viewer.bookmarks;
        let bookmark = bookmarks.get(bookmarkName);
        if (bookmark instanceof BookmarkElementBox) {
            let bookmarkEnd = bookmark.reference;
            this.initHistory('DeleteBookmark');
            if (this.editorHistory) {
                this.editorHistory.currentBaseHistoryInfo.setBookmarkInfo(bookmark);
                this.editorHistory.updateHistory();
            }
            this.deleteBookmarkInternal(bookmark);
        }
        this.fireContentChange();
    }
    /**
     * @private
     */
    deleteBookmarkInternal(bookmark) {
        this.viewer.bookmarks.remove(bookmark.name);
        bookmark.line.children.splice(bookmark.indexInOwner, 1);
        bookmark.reference.line.children.splice(bookmark.reference.indexInOwner, 1);
    }
    /**
     * @private
     */
    getSelectionInfo() {
        let start = this.selection.start;
        let end = this.selection.end;
        let isEmpty = this.selection.isEmpty;
        if (!this.selection.isForward) {
            start = this.selection.end;
            end = this.selection.start;
        }
        let startElementInfo = start.currentWidget.getInline(start.offset, 0);
        let endElementInfo = end.currentWidget.getInline(end.offset, 0);
        // tslint:disable-next-line:max-line-length
        return { 'start': start.clone(), 'end': end.clone(), 'startElementInfo': startElementInfo, 'endElementInfo': endElementInfo, 'isEmpty': isEmpty };
    }
    /**
     * @private
     */
    insertElements(endElements, startElements) {
        let info = this.getSelectionInfo();
        if (!isNullOrUndefined(startElements)) {
            this.insertElementsInternal(info.start, startElements);
        }
        if (!isNullOrUndefined(endElements)) {
            this.insertElementsInternal(info.end, endElements);
        }
    }
    /**
     * @private
     */
    insertElementsInternal(position, elements) {
        this.selection.selectPosition(position, position);
        this.initHistory('InsertElements');
        this.updateInsertPosition();
        let indexInInline = 0;
        let paragraphInfo = this.getParagraphInfo(this.selection.start);
        if (this.selection.start.paragraph.isEmpty()) {
            let paragraph = this.selection.start.paragraph;
            paragraph.childWidgets[0].children.push(elements[0]);
            elements[0].line = paragraph.childWidgets[0];
            elements[0].linkFieldCharacter(this.viewer);
            this.viewer.layout.reLayoutParagraph(paragraph, 0, 0);
            this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset + length, true);
            position.setPositionForSelection(elements[0].line, elements[0], elements[0].length, this.selection.start.location);
            this.selection.selectPosition(position, position);
        }
        else {
            let inlineObj = this.selection.start.currentWidget.getInline(this.viewer.selection.start.offset, indexInInline);
            let curInline = inlineObj.element;
            indexInInline = inlineObj.index;
            let firstElement = elements[0];
            this.insertElementInternal(curInline, firstElement, indexInInline, true);
            let index = firstElement.indexInOwner;
            let lastElement = firstElement;
            for (let i = 1; i < elements.length; i++) {
                lastElement = elements[i];
                firstElement.line.children.splice(index + i, 0, lastElement);
            }
            position.setPositionForSelection(lastElement.line, lastElement, lastElement.length, this.selection.start.location);
            this.selection.selectPosition(position, position);
        }
        if (this.editorHistory) {
            if (this.checkEndPosition()) {
                this.updateHistoryPosition(this.selection.start, false);
            }
            this.editorHistory.updateHistory();
        }
    }
    /**
     * @private
     */
    getHierarchicalIndex(block, offset) {
        let index;
        if (block) {
            if (block instanceof HeaderFooterWidget) {
                let hfString = block.headerFooterType.indexOf('Header') !== -1 ? 'H' : 'F';
                let pageIndex = block.page.index.toString();
                let headerFooterIndex = this.viewer.getHeaderFooter(block.headerFooterType).toString();
                let sectionIndex = block.page.sectionIndex;
                index = sectionIndex + ';' + hfString + ';' + pageIndex + ';' + offset;
            }
            else {
                index = block.index + ';' + offset;
            }
            if (block.containerWidget) {
                if (block instanceof TableCellWidget && block.rowIndex !== block.containerWidget.index) {
                    index = block.rowIndex + ';' + index;
                    block = block.containerWidget;
                }
                return this.getHierarchicalIndex(block.containerWidget, index);
            }
        }
        return index;
    }
    /**
     * @private
     */
    getBlock(position) {
        let bodyWidget = this.getBodyWidget(position);
        return this.getBlockInternal(bodyWidget, position);
    }
    /**
     * Return Block relative to position
     * @private
     */
    getBlockInternal(widget, position) {
        if (position.index === '' || isNullOrUndefined(position)) {
            return undefined;
        }
        let index = position.index.indexOf(';');
        let value = position.index.substring(0, index);
        position.index = position.index.substring(index).replace(';', '');
        let node = widget;
        // if (node instanceof WSection && value === 'HF') {
        //     //Gets the block in Header footers.
        //     let blockObj: BlockInfo = this.getBlock((node as WSection).headerFooters, position);
        // tslint:disable-next-line:max-line-length
        //     return { 'node': (!isNullOrUndefined(blockObj)) ? blockObj.node : undefined, 'position': (!isNullOrUndefined(blockObj)) ? blockObj.position : undefined };
        // }
        index = parseInt(value, 10);
        let childWidget = this.getBlockByIndex(widget, index);
        if (childWidget) {
            let child = childWidget;
            if (position.index.indexOf(';') >= 0) {
                if (child instanceof ParagraphWidget) {
                    if (position.index.indexOf(';') >= 0) {
                        position.index = '0';
                    }
                    return { 'node': child, 'position': position };
                }
                if (child instanceof Widget) {
                    let blockObj = this.getBlockInternal(child, position);
                    // tslint:disable-next-line:max-line-length
                    return { 'node': (!isNullOrUndefined(blockObj)) ? blockObj.node : undefined, 'position': (!isNullOrUndefined(blockObj)) ? blockObj.position : undefined };
                }
            }
            else {
                return { 'node': child, 'position': position };
            }
        }
        else {
            return { 'node': node, 'position': position };
        }
        return { 'node': node, 'position': position };
    }
    /**
     * @private
     */
    getParagraph(position) {
        let paragraph = this.getParagraphInternal(this.getBodyWidget(position), position);
        return { paragraph: paragraph, offset: parseInt(position.index, 10) };
    }
    /**
     * Get paragraph relative to position
     * @private
     */
    getParagraphInternal(container, position) {
        if (isNullOrUndefined(position.index)) {
            return undefined;
        }
        // let ins: Widget = container;
        let index = position.index.indexOf(';');
        let value = '0';
        if (index >= 0) {
            value = position.index.substring(0, index);
            position.index = position.index.substring(index).replace(';', '');
        }
        // if (container instanceof BodyWidget && value === 'HF') {
        //     return this.getParagraph(container.headerFooters, position);
        // }
        index = parseInt(value, 10);
        if (container instanceof TableRowWidget && index >= container.childWidgets.length) {
            position.index = '0;0';
            index = container.childWidgets.length - 1;
        }
        let childWidget = this.getBlockByIndex(container, index);
        if (childWidget) {
            let child = childWidget;
            if (child instanceof ParagraphWidget) {
                if (position.index.indexOf(';') > 0) {
                    position.index = '0';
                }
                return child;
            }
            if (child instanceof Widget) {
                if (position.index.indexOf(';') > 0) {
                    return this.getParagraphInternal(child, position);
                }
                else {
                    //If table is shifted to previous text position then return the first paragraph within table.
                    if (child instanceof TableWidget) {
                        return this.viewer.selection.getFirstParagraphInFirstCell(child);
                    }
                    return undefined;
                }
            }
        }
        else if (container) {
            let nextWidget = container.getSplitWidgets().pop().nextRenderedWidget;
            if (nextWidget instanceof Widget) {
                position.index = '0';
                if (nextWidget instanceof TableWidget) {
                    return this.viewer.selection.getFirstParagraphInFirstCell(nextWidget);
                }
                return nextWidget;
            }
        }
        return undefined;
    }
    getBodyWidget(position) {
        let index = position.index.indexOf(';');
        let value = position.index.substring(0, index);
        position.index = position.index.substring(index).replace(';', '');
        let sectionIndex = parseInt(value, 10);
        index = parseInt(value, 10);
        index = position.index.indexOf(';');
        value = position.index.substring(0, index);
        // position = position.substring(index).replace(';', '');
        if (value === 'H' || value === 'F') {
            return this.getHeaderFooterWidget(position);
        }
        index = parseInt(value, 10);
        return this.getBodyWidgetInternal(sectionIndex, index);
    }
    getHeaderFooterWidget(position) {
        //HEADER OR FOOTER WIDGET
        let index = position.index.indexOf(';');
        let value = position.index.substring(0, index);
        position.index = position.index.substring(index).replace(';', '');
        let isHeader = value === 'H';
        index = position.index.indexOf(';');
        value = position.index.substring(0, index);
        position.index = position.index.substring(index).replace(';', '');
        index = parseInt(value, 10);
        let page = this.viewer.pages[index];
        if (isHeader) {
            return page.headerWidget;
        }
        else {
            return page.footerWidget;
        }
    }
    getBodyWidgetInternal(sectionIndex, blockIndex) {
        for (let i = 0; i < this.viewer.pages.length; i++) {
            let bodyWidget = this.viewer.pages[i].bodyWidgets[0];
            if (bodyWidget.index === sectionIndex) {
                if (bodyWidget.firstChild.index <= blockIndex && bodyWidget.lastChild.index >= blockIndex) {
                    return bodyWidget;
                }
            }
            if (bodyWidget.index > sectionIndex) {
                break;
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    getBlockByIndex(container, blockIndex) {
        let childWidget;
        if (container) {
            for (let j = 0; j < container.childWidgets.length; j++) {
                if (container.childWidgets[j].index === blockIndex) {
                    childWidget = container.childWidgets[j];
                    break;
                }
            }
            if (!childWidget && !(container instanceof HeaderFooterWidget)) {
                return this.getBlockByIndex(container.nextSplitWidget, blockIndex);
            }
        }
        return childWidget;
    }
    /**
     * @private
     */
    updateHistoryPosition(position, isInsertPosition) {
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            let hierarchicalIndex;
            if (position instanceof TextPosition) {
                let blockInfo = this.getParagraphInfo(position);
                hierarchicalIndex = this.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
            }
            else {
                hierarchicalIndex = position;
            }
            if (isInsertPosition) {
                this.editorHistory.currentBaseHistoryInfo.insertPosition = hierarchicalIndex;
            }
            else {
                this.editorHistory.currentBaseHistoryInfo.endPosition = hierarchicalIndex;
            }
        }
    }
    /**
     * Applies the borders based on given settings.
     * @param {BorderSettings} settings
     */
    applyBorders(settings) {
        this.initHistory('Borders');
        let startPos = this.selection.isForward ? this.selection.start : this.selection.end;
        let endPos = this.selection.isForward ? this.selection.end : this.selection.start;
        let table = startPos.paragraph.associatedCell.ownerTable;
        table = table.combineWidget(this.viewer);
        if (this.editorHistory) {
            let clonedTable = this.cloneTableToHistoryInfo(table);
        }
        let startCell = startPos.paragraph.associatedCell;
        let endCell = endPos.paragraph.associatedCell;
        let cells;
        let border = this.getBorder(settings.borderColor, settings.lineWidth, settings.borderStyle);
        if (this.selection.isEmpty) {
            //Apply borders for current selected cell initially.                    
            if (settings.type === 'OutsideBorders' || settings.type === 'AllBorders' ||
                settings.type === 'LeftBorder') {
                endCell.cellFormat.borders.left.copyFormat(border);
            }
            if (settings.type === 'OutsideBorders' || settings.type === 'AllBorders' ||
                settings.type === 'TopBorder') {
                endCell.cellFormat.borders.top.copyFormat(border);
            }
            if (settings.type === 'OutsideBorders' || settings.type === 'AllBorders' ||
                settings.type === 'RightBorder') {
                endCell.cellFormat.borders.right.copyFormat(border);
            }
            if (settings.type === 'OutsideBorders' || settings.type === 'AllBorders' ||
                settings.type === 'BottomBorder') {
                endCell.cellFormat.borders.bottom.copyFormat(border);
            }
            if (settings.type === 'AllBorders' || settings.type === 'InsideBorders'
                || settings.type === 'InsideVerticalBorder') {
                endCell.cellFormat.borders.vertical.copyFormat(border);
            }
            if (settings.type === 'AllBorders' || settings.type === 'InsideBorders'
                || settings.type === 'InsideHorizontalBorder') {
                endCell.cellFormat.borders.horizontal.copyFormat(border);
            }
            if (settings.type === 'NoBorder') {
                this.clearAllBorderValues(endCell.cellFormat.borders);
            }
        }
        else {
            if (settings.type === 'OutsideBorders' || settings.type === 'TopBorder') {
                let selectedCell = this.getTopBorderCellsOnSelection();
                for (let i = 0; i < selectedCell.length; i++) {
                    selectedCell[i].cellFormat.borders.top.copyFormat(border);
                }
            }
            if (settings.type === 'OutsideBorders' || settings.type === 'LeftBorder') {
                let selectedCell = this.getLeftBorderCellsOnSelection();
                for (let i = 0; i < selectedCell.length; i++) {
                    selectedCell[i].cellFormat.borders.left.copyFormat(border);
                }
            }
            if (settings.type === 'OutsideBorders' || settings.type === 'RightBorder') {
                let selectedCell = this.getRightBorderCellsOnSelection();
                for (let i = 0; i < selectedCell.length; i++) {
                    selectedCell[i].cellFormat.borders.right.copyFormat(border);
                }
            }
            if (settings.type === 'OutsideBorders' || settings.type === 'BottomBorder') {
                let selectedCell = this.getBottomBorderCellsOnSelection();
                for (let i = 0; i < selectedCell.length; i++) {
                    selectedCell[i].cellFormat.borders.bottom.copyFormat(border);
                }
            }
        }
        //Apply Only borders property to selected cells      
        if (settings.type === 'BottomBorder' || settings.type === 'AllBorders' || settings.type === 'OutsideBorders'
            || settings.type === 'NoBorder') {
            cells = this.getAdjacentCellToApplyBottomBorder();
            for (let i = 0; i < cells.length; i++) {
                let cell = cells[i];
                if (settings.type === 'NoBorder') {
                    cell.cellFormat.borders.top.copyFormat(this.clearBorder());
                }
                else {
                    cell.cellFormat.borders.top.copyFormat(border);
                }
            }
        }
        if (settings.type === 'AllBorders' || settings.type === 'OutsideBorders' || settings.type === 'RightBorder'
            || settings.type === 'NoBorder') {
            cells = this.getAdjacentCellToApplyRightBorder();
            for (let i = 0; i < cells.length; i++) {
                let cell = cells[i];
                if (settings.type === 'NoBorder') {
                    cell.cellFormat.borders.left.copyFormat(this.clearBorder());
                }
                else {
                    cell.cellFormat.borders.left.copyFormat(border);
                }
            }
        }
        if (settings.type === 'AllBorders' || settings.type === 'NoBorder') {
            this.applyAllBorders(border, settings.type);
        }
        if (settings.type === 'InsideBorders' || settings.type === 'InsideVerticalBorder'
            || settings.type === 'InsideHorizontalBorder' || settings.type === 'NoBorder') {
            this.applyInsideBorders(border, settings.type, table);
        }
        this.updateGridForTableDialog(table, false);
        this.reLayout(this.selection, false);
        this.editorHistory.updateHistory();
    }
    applyAllBorders(border, borderType) {
        let cells = this.selection.getSelectedCells();
        for (let i = 0; i < cells.length; i++) {
            if (borderType === 'NoBorder') {
                cells[i].cellFormat.borders.left.copyFormat(this.clearBorder());
                cells[i].cellFormat.borders.right.copyFormat(this.clearBorder());
                cells[i].cellFormat.borders.top.copyFormat(this.clearBorder());
                cells[i].cellFormat.borders.bottom.copyFormat(this.clearBorder());
            }
            else {
                cells[i].cellFormat.borders.left.copyFormat(border);
                cells[i].cellFormat.borders.right.copyFormat(border);
                cells[i].cellFormat.borders.top.copyFormat(border);
                cells[i].cellFormat.borders.bottom.copyFormat(border);
            }
        }
    }
    applyInsideBorders(border, borderType, table) {
        let cells = this.selection.getSelectedCells();
        for (let i = 0; i < cells.length; i++) {
            let cell = cells[i];
            let isLastSelectedRow = cell.ownerRow === cells[cells.length - 1].ownerRow;
            let isLastRightCell = (cell.columnIndex + cell.cellFormat.columnSpan - 1) === cells[cells.length - 1].columnIndex;
            if (borderType === 'NoBorder') {
                cell.cellFormat.borders.right.copyFormat(this.clearBorder());
                cell.cellFormat.borders.bottom.copyFormat(this.clearBorder());
            }
            else {
                if (!isLastRightCell && borderType !== 'InsideHorizontalBorder') {
                    cell.cellFormat.borders.right.copyFormat(border);
                }
                if (!isLastSelectedRow && borderType !== 'InsideVerticalBorder') {
                    cell.cellFormat.borders.bottom.copyFormat(border);
                }
            }
            if (!isLastSelectedRow && borderType !== 'InsideVerticalBorder') {
                // Apply adjacent bottom borders.
                let nextRowIndex = cell.ownerRow.rowIndex + cell.cellFormat.rowSpan;
                let nextRow = table.childWidgets[nextRowIndex];
                if (nextRow) {
                    let selectedCells = this.getAdjacentBottomBorderOnEmptyCells(nextRow, cell, true);
                    for (let j = 0; j < selectedCells.length; j++) {
                        if (borderType === 'NoBorder') {
                            selectedCells[j].cellFormat.borders.top.copyFormat(this.clearBorder());
                        }
                        else {
                            selectedCells[j].cellFormat.borders.top.copyFormat(border);
                        }
                    }
                }
            }
            if (!isLastRightCell && borderType !== 'InsideHorizontalBorder') {
                // Apply adjacent right borders.
                let rightBorderCells = this.getSelectedCellsNextWidgets(cell, table);
                for (let k = 0; k < rightBorderCells.length; k++) {
                    if (borderType === 'NoBorder') {
                        rightBorderCells[k].cellFormat.borders.left.copyFormat(this.clearBorder());
                    }
                    else {
                        rightBorderCells[k].cellFormat.borders.left.copyFormat(border);
                    }
                }
            }
        }
    }
    /**
     * @private
     */
    getTopBorderCellsOnSelection() {
        let startPos = this.selection.isForward ? this.selection.start : this.selection.end;
        let startCell = startPos.paragraph.associatedCell;
        let topBorderCells = [];
        let cells = this.selection.getSelectedCells();
        for (let i = 0; i < cells.length; i++) {
            if (cells[i].ownerRow === startCell.ownerRow) {
                topBorderCells.push(cells[i]);
            }
        }
        return topBorderCells;
    }
    /**
     * @private
     */
    getLeftBorderCellsOnSelection() {
        let startPos = this.selection.isForward ? this.selection.start : this.selection.end;
        let startCell = startPos.paragraph.associatedCell;
        let cells = this.selection.getSelectedCells();
        let leftBorderCells = [];
        for (let i = 0; i < cells.length; i++) {
            if (cells[i].columnIndex === startCell.columnIndex) {
                leftBorderCells.push(cells[i]);
            }
        }
        return leftBorderCells;
    }
    /**
     * @private
     */
    getRightBorderCellsOnSelection() {
        let cells = this.selection.getSelectedCells();
        let rightBorderCells = [];
        for (let i = 0; i < cells.length; i++) {
            if ((cells[i].columnIndex + cells[i].cellFormat.columnSpan - 1) === cells[cells.length - 1].columnIndex) {
                rightBorderCells.push(cells[i]);
            }
        }
        return rightBorderCells;
    }
    /**
     * @private
     */
    getBottomBorderCellsOnSelection() {
        let endPos = this.selection.isForward ? this.selection.end : this.selection.start;
        let endCell = endPos.paragraph.associatedCell;
        let cells = this.selection.getSelectedCells();
        let bottomBorderCells = [];
        for (let i = 0; i < cells.length; i++) {
            if (cells[i].ownerRow === endCell.ownerRow) {
                bottomBorderCells.push(cells[i]);
            }
        }
        return bottomBorderCells;
    }
    /**
     * @private
     */
    clearAllBorderValues(borders) {
        let border = this.clearBorder();
        borders.bottom.copyFormat(border);
        borders.left.copyFormat(border);
        borders.right.copyFormat(border);
        borders.top.copyFormat(border);
        borders.vertical.copyFormat(border);
        borders.horizontal.copyFormat(border);
    }
    clearBorder() {
        let border = new WBorder();
        border.lineStyle = 'Cleared';
        return border;
    }
    /**
     * @private
     */
    getAdjacentCellToApplyBottomBorder() {
        let cells = [];
        let startPos = this.selection.start;
        let endPos = this.selection.end;
        if (!this.selection.isForward) {
            startPos = this.selection.end;
            endPos = this.selection.start;
        }
        let table = startPos.paragraph.associatedCell.ownerTable;
        table = table.combineWidget(this.viewer);
        let startCell = startPos.paragraph.associatedCell;
        let endCell = endPos.paragraph.associatedCell;
        let nextRowIndex = endCell.ownerRow.rowIndex + endCell.cellFormat.rowSpan;
        let nextRow = table.childWidgets[nextRowIndex];
        if (nextRow) {
            if (endCell.cellFormat.columnSpan > 1) {
                for (let i = endCell.columnIndex; i < endCell.columnIndex + endCell.cellFormat.columnSpan; i++) {
                    cells.push(nextRow.childWidgets[i]);
                }
            }
            else {
                cells = this.getAdjacentBottomBorderOnEmptyCells(nextRow, endCell);
                if (!this.selection.isEmpty) {
                    for (let i = 0; i < nextRow.childWidgets.length; i++) {
                        let nextCellColIndex = nextRow.childWidgets[i].columnIndex;
                        if (nextCellColIndex >= startCell.columnIndex && nextCellColIndex <= endCell.columnIndex) {
                            cells.push(nextRow.childWidgets[i]);
                        }
                    }
                }
            }
        }
        return cells;
    }
    getAdjacentBottomBorderOnEmptyCells(nextRow, cell, isSingleCell) {
        let cells = [];
        if (cell.cellFormat.columnSpan > 1) {
            for (let i = cell.columnIndex; i < cell.columnIndex + cell.cellFormat.columnSpan; i++) {
                cells.push(nextRow.childWidgets[i]);
            }
        }
        else {
            if (this.selection.isEmpty || isSingleCell) {
                for (let i = 0; i < nextRow.childWidgets.length; i++) {
                    if (nextRow.childWidgets[i].columnIndex === cell.columnIndex) {
                        cells.push(nextRow.childWidgets[i]);
                    }
                }
            }
        }
        return cells;
    }
    /**
     * @private
     */
    getAdjacentCellToApplyRightBorder() {
        let cells = [];
        let startPosIn = this.selection.start;
        let endPosIn = this.selection.end;
        if (!this.selection.isForward) {
            startPosIn = this.selection.end;
            endPosIn = this.selection.start;
        }
        let table = startPosIn.paragraph.associatedCell.ownerTable;
        table = table.combineWidget(this.viewer);
        let startCell = startPosIn.paragraph.associatedCell;
        let endCell = endPosIn.paragraph.associatedCell;
        if (this.selection.isEmpty) {
            let selectedCell = startPosIn.paragraph.associatedCell;
            cells = this.getSelectedCellsNextWidgets(selectedCell, table);
        }
        else {
            // tslint:disable-next-line:max-line-length
            let selectedCells = this.getRightBorderCellsOnSelection();
            for (let i = 0; i < selectedCells.length; i++) {
                let cell = selectedCells[i];
                cells = cells.concat(this.getSelectedCellsNextWidgets(cell, table));
            }
        }
        return cells;
    }
    getSelectedCellsNextWidgets(selectedCell, table) {
        let cells = [];
        if (selectedCell.nextWidget) {
            cells.push(selectedCell.nextWidget);
        }
        if (selectedCell.cellFormat.rowSpan > 1) {
            let nextRowIndex = selectedCell.ownerRow.rowIndex + selectedCell.cellFormat.rowSpan;
            for (let i = selectedCell.ownerRow.rowIndex + 1; i < nextRowIndex; i++) {
                let nextRow = table.childWidgets[i];
                if (nextRow) {
                    for (let j = 0; j < nextRow.childWidgets.length; j++) {
                        if (nextRow.childWidgets[j].columnIndex ===
                            selectedCell.nextWidget.columnIndex) {
                            cells.push(nextRow.childWidgets[j]);
                        }
                    }
                }
            }
        }
        return cells;
    }
    /**
     * @private
     */
    getBorder(borderColor, lineWidth, borderStyle) {
        let border = new WBorder();
        border.color = borderColor || '#000000';
        border.lineWidth = lineWidth || 1;
        border.lineStyle = borderStyle || 'Single';
        return border;
    }
    /**
     * Applies borders
     * @param  {WBorders} sourceBorders
     * @param  {WBorders} applyBorders
     * @private
     */
    applyBordersInternal(sourceBorders, applyBorders) {
        if (!isNullOrUndefined(sourceBorders) && !isNullOrUndefined(sourceBorders)) {
            if (!isNullOrUndefined(sourceBorders.top)) {
                this.applyBorder(sourceBorders.top, applyBorders.top);
            }
            if (!isNullOrUndefined(sourceBorders.bottom)) {
                this.applyBorder(sourceBorders.bottom, applyBorders.bottom);
            }
            if (!isNullOrUndefined(sourceBorders.left)) {
                this.applyBorder(sourceBorders.left, applyBorders.left);
            }
            if (!isNullOrUndefined(sourceBorders.right)) {
                this.applyBorder(sourceBorders.right, applyBorders.right);
            }
            if (!isNullOrUndefined(sourceBorders.horizontal)) {
                this.applyBorder(sourceBorders.horizontal, applyBorders.horizontal);
            }
            if (!isNullOrUndefined(sourceBorders.vertical)) {
                this.applyBorder(sourceBorders.vertical, applyBorders.vertical);
            }
            if (!isNullOrUndefined(sourceBorders.diagonalUp)) {
                this.applyBorder(sourceBorders.diagonalUp, applyBorders.diagonalUp);
            }
            if (!isNullOrUndefined(sourceBorders.diagonalDown)) {
                this.applyBorder(sourceBorders.diagonalDown, applyBorders.diagonalDown);
            }
        }
    }
    /**
     * Apply shading to table
     * @param  {WShading} sourceShading
     * @param  {WShading} applyShading
     * @private
     */
    applyShading(sourceShading, applyShading) {
        if (!isNullOrUndefined(applyShading) && !isNullOrUndefined(sourceShading)) {
            if (!isNullOrUndefined(applyShading.backgroundColor)
                && sourceShading.backgroundColor !== applyShading.backgroundColor) {
                sourceShading.backgroundColor = applyShading.backgroundColor;
            }
            if (!isNullOrUndefined(applyShading.foregroundColor)
                && sourceShading.foregroundColor !== applyShading.foregroundColor) {
                sourceShading.foregroundColor = applyShading.foregroundColor;
            }
            if (!isNullOrUndefined(applyShading.textureStyle)
                && sourceShading.textureStyle !== applyShading.textureStyle) {
                sourceShading.textureStyle = applyShading.textureStyle;
            }
        }
    }
    applyBorder(sourceBorder, applyBorder) {
        if (!isNullOrUndefined(sourceBorder) && !isNullOrUndefined(applyBorder)) {
            if (!isNullOrUndefined(applyBorder.color)
                && sourceBorder.color !== applyBorder.color) {
                sourceBorder.color = applyBorder.color;
            }
            if (!isNullOrUndefined(applyBorder.lineStyle)
                && sourceBorder.lineStyle !== applyBorder.lineStyle) {
                sourceBorder.lineStyle = applyBorder.lineStyle;
            }
            if (!isNullOrUndefined(applyBorder.lineWidth)
                && sourceBorder.lineWidth !== applyBorder.lineWidth) {
                sourceBorder.lineWidth = applyBorder.lineWidth;
            }
            if (!isNullOrUndefined(applyBorder.shadow)
                && sourceBorder.shadow !== applyBorder.shadow) {
                sourceBorder.shadow = applyBorder.shadow;
            }
            if (!isNullOrUndefined(applyBorder.space)
                && sourceBorder.space !== applyBorder.space) {
                sourceBorder.space = applyBorder.space;
            }
        }
    }
    /**
     * Apply Table Format changes
     * @param  {Selection} selection
     * @param  {WTableFormat} format
     * @private
     */
    onTableFormat(format) {
        if (!isNullOrUndefined(this.selection.tableFormat)) {
            this.viewer.owner.isShiftingEnabled = true;
            this.editorHistory.initializeHistory('TableFormat');
            let table = this.selection.start.paragraph.associatedCell.ownerTable.combineWidget(this.viewer);
            this.applyTableFormat(table, undefined, format);
            this.reLayout(this.selection, false);
        }
    }
    /**
     * @private
     */
    applyTableFormat(table, property, value) {
        this.applyTablePropertyValue(this.viewer.selection, undefined, value, table);
    }
    // tslint:disable-next-line:max-line-length
    applyTablePropertyValue(selection, property, value, table) {
        let sourceFormat = table.tableFormat;
        if (!isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedTableProperties(sourceFormat, property, value);
        }
        if (value instanceof WTableFormat) {
            if (isNullOrUndefined(property)) {
                this.handleTableFormat(sourceFormat, value);
            }
            return;
        }
        if (property === 'preferredWidth') {
            sourceFormat.preferredWidth = value;
        }
        else if (property === 'leftIndent') {
            sourceFormat.leftIndent = value;
        }
        else if (property === 'tableAlignment') {
            sourceFormat.tableAlignment = value;
        }
        else if (property === 'cellSpacing') {
            sourceFormat.cellSpacing = value;
        }
        else if (property === 'leftMargin') {
            sourceFormat.leftMargin = value;
        }
        else if (property === 'rightMargin') {
            sourceFormat.rightMargin = value;
        }
        else if (property === 'topMargin') {
            sourceFormat.topMargin = value;
        }
        else if (property === 'bottomMargin') {
            sourceFormat.bottomMargin = value;
        }
        else if (property === 'preferredWidthType') {
            sourceFormat.preferredWidthType = value;
        }
        if (property === 'shading') {
            sourceFormat.shading = value;
        }
        else if (property === 'borders') {
            sourceFormat.borders = value;
        }
        // if (!isNullOrUndefined(table)) {
        //     this.layoutItemBlock(table, true);
        // }
    }
    handleTableFormat(tableFormat, applyFormat) {
        if (this.isBordersAndShadingDialog || this.editorHistory.isUndoing
            || this.editorHistory.isRedoing) {
            if (!isNullOrUndefined(tableFormat.borders)) {
                this.applyBordersInternal(tableFormat.borders, applyFormat.borders);
            }
            if (!isNullOrUndefined(tableFormat.shading)) {
                this.applyShading(tableFormat.shading, applyFormat.shading);
            }
        }
        if (!this.isBordersAndShadingDialog) {
            if (applyFormat.hasValue('preferredWidth') && applyFormat.preferredWidth !== tableFormat.preferredWidth) {
                tableFormat.preferredWidth = applyFormat.preferredWidth;
            }
            if (applyFormat.hasValue('preferredWidthType') && applyFormat.preferredWidthType !== tableFormat.preferredWidthType) {
                tableFormat.preferredWidthType = applyFormat.preferredWidthType;
            }
            if (applyFormat.hasValue('tableAlignment') && applyFormat.tableAlignment !== tableFormat.tableAlignment) {
                tableFormat.tableAlignment = applyFormat.tableAlignment;
            }
            if (applyFormat.hasValue('leftIndent') && applyFormat.leftIndent !== tableFormat.leftIndent) {
                tableFormat.leftIndent = applyFormat.leftIndent;
            }
        }
        this.updateGridForTableDialog(tableFormat.ownerBase, false);
    }
    updateGridForTableDialog(table, shiftNextItem) {
        if (table.tableHolder) {
            table.updateRowIndex(0);
            table.calculateGrid();
            table.isGridUpdated = false;
        }
        this.viewer.layout.reLayoutTable(table);
    }
    /**
     * Applies Row Format Changes
     * @param  {Selection} selection
     * @param  {WRowFormat} format
     * @param  {WRow} row
     * @private
     */
    onRowFormat(format) {
        if (isNullOrUndefined(this.selection) || isNullOrUndefined(format)) {
            return;
        }
        this.editorHistory.initializeHistory('RowFormat');
        this.viewer.owner.isShiftingEnabled = true;
        let rowStartPos = this.selection.isForward ? this.selection.start : this.selection.end;
        let rowEndPos = this.selection.isForward ? this.selection.end : this.selection.start;
        let table = rowStartPos.paragraph.associatedCell.ownerTable.combineWidget(this.viewer);
        this.applyRowFormat(rowStartPos.paragraph.associatedCell.ownerRow, rowStartPos, rowEndPos, undefined, format);
        this.reLayout(this.selection, false);
    }
    applyRowFormat(row, start, end, property, value) {
        this.applyRowPropertyValue(this.viewer.selection, property, value, row);
        if (end.paragraph.associatedCell.ownerRow === row) {
            return;
        }
        let newRow = row.nextWidget;
        if (!isNullOrUndefined(newRow)) {
            this.applyRowFormat(newRow, start, end, property, value);
        }
    }
    applyRowPropertyValue(selection, property, value, row) {
        let applyFormat = row.rowFormat;
        if (!isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedRowProperties(applyFormat, property, value);
        }
        if (value instanceof WRowFormat) {
            if (isNullOrUndefined(property)) {
                this.handleRowFormat(value, applyFormat);
            }
            return;
        }
        if (property === 'heightType') {
            applyFormat.heightType = value;
        }
        else if (property === 'height') {
            applyFormat.height = value;
        }
        else if (property === 'isHeader') {
            applyFormat.isHeader = value;
        }
        else if (property === 'allowBreakAcrossPages') {
            applyFormat.allowBreakAcrossPages = value;
        }
        if (!isNullOrUndefined(row.ownerTable)) {
            this.layoutItemBlock(row.ownerTable, true);
        }
    }
    handleRowFormat(format, applyFormat) {
        if (format.hasValue('allowBreakAcrossPages') && format.allowBreakAcrossPages !== applyFormat.allowBreakAcrossPages) {
            applyFormat.allowBreakAcrossPages = format.allowBreakAcrossPages;
        }
        if (format.hasValue('isHeader') && format.isHeader !== applyFormat.isHeader) {
            applyFormat.isHeader = format.isHeader;
        }
        if (format.hasValue('heightType') && format.heightType !== applyFormat.heightType) {
            applyFormat.heightType = format.heightType;
        }
        if (format.hasValue('height') && format.height !== applyFormat.height) {
            applyFormat.height = format.height;
        }
        this.updateGridForTableDialog(applyFormat.ownerBase.ownerTable, true);
    }
    /**
     * Applies Cell Format changes
     * @param  {Selection} selection
     * @param  {WCellFormat} format
     * @param  {WCell} cell
     * @private
     */
    onCellFormat(format) {
        if (isNullOrUndefined(this.selection) || isNullOrUndefined(format)) {
            return;
        }
        this.editorHistory.initializeHistory('CellFormat');
        this.updateFormatForCell(this.selection, undefined, format);
        this.reLayout(this.selection, false);
    }
    /**
     * @private
     */
    updateCellMargins(selection, value) {
        let cellStartPosition = selection.start;
        let cellEndPosition = selection.end;
        if (!selection.isForward) {
            cellStartPosition = selection.end;
            cellEndPosition = selection.start;
        }
        this.initHistoryPosition(selection, cellStartPosition);
        // tslint:disable-next-line:max-line-length
        this.viewer.owner.cellOptionsDialogModule.applyCellmarginsValue(cellStartPosition.paragraph.associatedCell.ownerRow, cellStartPosition, cellEndPosition, value);
    }
    /**
     * @private
     */
    updateFormatForCell(selection, property, value) {
        let start = selection.start;
        let end = selection.end;
        if (!selection.isForward) {
            start = selection.end;
            end = selection.start;
        }
        let startCell = start.paragraph.associatedCell;
        let endCell = end.paragraph.associatedCell;
        let cells;
        let table = startCell.ownerTable.combineWidget(this.viewer);
        let appliedFormat;
        for (let k = startCell.columnIndex; k <= endCell.columnIndex; k++) {
            cells = this.getSelectedCellInColumn(startCell.ownerTable, startCell.ownerRow.rowIndex, k, endCell.ownerRow.rowIndex);
            for (let i = 0; i < cells.length; i++) {
                appliedFormat = this.applyCellPropertyValue(this.viewer.selection, property, value, cells[i].cellFormat);
            }
        }
        this.updateGridForTableDialog(table, false);
    }
    /**
     * @private
     */
    getSelectedCellInColumn(table, rowStartIndex, columnIndex, rowEndIndex) {
        let cells = [];
        for (let i = rowStartIndex; i <= rowEndIndex; i++) {
            let row = table.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                if (row.childWidgets[j].columnIndex === columnIndex) {
                    cells.push(row.childWidgets[j]);
                }
            }
        }
        return cells;
    }
    getColumnCells(table, columnIndex, isLeftSideCollection) {
        let cells = [];
        for (let k = 0; k < table.childWidgets.length; k++) {
            let row = table.childWidgets[k];
            for (let i = 0; i < row.childWidgets.length; i++) {
                let cell = row.childWidgets[i];
                if (isLeftSideCollection) {
                    if (cell.columnIndex + cell.cellFormat.columnSpan === columnIndex) {
                        cells.push(cell);
                    }
                }
                else {
                    if (cell.columnIndex === columnIndex) {
                        cells.push(cell);
                    }
                }
            }
        }
        return cells;
    }
    /**
     * @private
     */
    getTableWidth(table) {
        if (table.tableFormat.preferredWidth !== 0 || table.tableFormat.preferredWidthType === 'Percent') {
            if (table.tableFormat.preferredWidthType === 'Auto' || table.tableFormat.preferredWidthType === 'Point') {
                return table.tableFormat.preferredWidth;
            }
            else {
                if (table.tableFormat.preferredWidth === 0) {
                    return 0;
                }
                else {
                    return HelperMethods.convertPixelToPoint(this.viewer.clientArea.width) / 100 * table.tableFormat.preferredWidth;
                }
            }
        }
        return HelperMethods.convertPixelToPoint(this.viewer.layout.getTableWidth(table));
    }
    applyCellPropertyValue(selection, property, value, applyFormat) {
        if (!isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedCellProperties(applyFormat, property, value);
        }
        if (value instanceof WCellFormat) {
            if (isNullOrUndefined(property)) {
                this.handleCellFormat(value, applyFormat);
            }
            return value;
        }
        if (property === 'leftMargin') {
            applyFormat.leftMargin = value;
        }
        else if (property === 'topMargin') {
            applyFormat.topMargin = value;
        }
        else if (property === 'rightMargin') {
            applyFormat.rightMargin = value;
        }
        else if (property === 'bottomMargin') {
            applyFormat.bottomMargin = value;
        }
        else if (property === 'preferredWidth') {
            applyFormat.preferredWidth = value;
            applyFormat.cellWidth = value;
        }
        else if (property === 'cellWidth') {
            applyFormat.cellWidth = value;
        }
        else if (property === 'columnSpan') {
            applyFormat.columnSpan = value;
        }
        else if (property === 'rowSpan') {
            applyFormat.rowSpan = value;
        }
        else if (property === 'preferredWidthType') {
            applyFormat.preferredWidthType = value;
        }
        else if (property === 'verticalAlignment') {
            applyFormat.verticalAlignment = value;
        }
        if (property === 'shading') {
            applyFormat.shading = value;
        }
        else if (property === 'borders') {
            applyFormat.borders = value;
        }
        return undefined;
    }
    handleCellFormat(cellFormat, applyFormat) {
        if (!isNullOrUndefined(cellFormat) && !isNullOrUndefined(applyFormat)) {
            if (this.isBordersAndShadingDialog) {
                if (!isNullOrUndefined(cellFormat.borders)) {
                    this.applyBordersInternal(applyFormat.borders, cellFormat.borders);
                }
                if (!isNullOrUndefined(cellFormat.shading)) {
                    this.applyShading(applyFormat.shading, cellFormat.shading);
                }
                // this.layoutRow((applyFormat.ownerBase as TableCellWidget).ownerRow, this.viewer, false);
            }
            else {
                if (cellFormat.hasValue('preferredWidth') && applyFormat.preferredWidth !== cellFormat.preferredWidth) {
                    applyFormat.preferredWidth = cellFormat.preferredWidth;
                }
                if (cellFormat.hasValue('preferredWidthType') && applyFormat.preferredWidthType !== cellFormat.preferredWidthType) {
                    applyFormat.preferredWidthType = cellFormat.preferredWidthType;
                }
                if (cellFormat.hasValue('verticalAlignment') && applyFormat.verticalAlignment !== cellFormat.verticalAlignment) {
                    applyFormat.verticalAlignment = cellFormat.verticalAlignment;
                }
            }
        }
    }
    /**
     * @private
     */
    destroy() {
        this.viewer = undefined;
        this.nodes = [];
    }
    isTocField(element) {
        if (element instanceof FieldElementBox) {
            let nextElement = element.nextNode;
            if (element instanceof FieldElementBox && element.fieldType === 0 && nextElement instanceof TextElementBox
                && nextElement.text.trim().toLowerCase().indexOf('toc') === 0) {
                return true;
            }
        }
        return false;
    }
    /**
     * Updates the table of contents.
     * @private
     */
    updateToc(tocField) {
        if (isNullOrUndefined(tocField)) {
            tocField = this.selection.getTocFieldInternal();
        }
        if (!this.isTocField(tocField)) {
            return;
        }
        // Decode field code to get parameters
        let code = this.selection.getFieldCode(tocField);
        if (code.toLocaleLowerCase().indexOf('toc') !== -1) {
            this.insertTableOfContents(this.validateTocSettings(this.getTocSettings(code, tocField)));
        }
    }
    getTocSettings(code, tocField) {
        let tocSettings = {};
        tocSettings.includePageNumber = true;
        tocSettings.rightAlign = true;
        // Decode field code to get parameters
        if (code.toLowerCase() === 'toc \\mergeformat') {
            tocSettings.startLevel = 1;
            tocSettings.endLevel = 3;
        }
        else {
            let swtiches = code.split('\\');
            for (let i = 0; i < swtiches.length; i++) {
                let swtch = swtiches[i];
                if (swtch.length === 0) {
                    continue;
                }
                switch (swtch[0]) {
                    case 'o':
                        if (!isNullOrUndefined(swtch.match(/\d+/g))) {
                            let levels = swtch.match(/\d+/g).map(Number);
                            tocSettings.startLevel = levels[0];
                            tocSettings.endLevel = levels[1];
                        }
                        else {
                            tocSettings.startLevel = 1;
                            tocSettings.endLevel = 9;
                        }
                        break;
                    case 'h':
                        tocSettings.includeHyperlink = true;
                        break;
                    case 'n':
                        tocSettings.includePageNumber = false;
                        break;
                    case 'p':
                        tocSettings.rightAlign = false;
                        break;
                    case 'u':
                        tocSettings.includeOutlineLevels = true;
                        break;
                    case 't':
                        this.decodeTSwitch(tocSettings, swtch);
                        break;
                }
            }
        }
        //assigns tab leader.
        let tabs = tocField.paragraph.paragraphFormat.getUpdatedTabs();
        if (tabs.length > 0) {
            tocSettings.tabLeader = tabs[tabs.length - 1].tabLeader;
        }
        if (tocSettings.rightAlign && isNullOrUndefined(tocSettings.tabLeader)) {
            tocSettings.tabLeader = 'Dot';
        }
        return tocSettings;
    }
    decodeTSwitch(tocSettings, tSwitch) {
        tocSettings.levelSettings = {};
        tSwitch = tSwitch.replace('t', '');
        tSwitch = tSwitch.replace('"', '');
        tSwitch = tSwitch.replace('"', '');
        tSwitch = tSwitch.trim();
        let levels = tSwitch.split(',');
        for (let index = 0; index < levels.length; index++) {
            tocSettings.levelSettings[levels[index]] = parseInt(levels[index + 1], 10);
            index++;
        }
    }
    /**
     * Inserts, modifies or updates the table of contents based on given settings.
     * @param {TableOfContentsSettings} tableOfContentsSettings
     */
    insertTableOfContents(tableOfContentsSettings) {
        this.isInsertingTOC = true;
        this.initComplexHistory('TOC');
        if (isNullOrUndefined(tableOfContentsSettings)) {
            //Initializes with default value.
            tableOfContentsSettings = {};
            tableOfContentsSettings.startLevel = 1;
            tableOfContentsSettings.endLevel = 3;
            tableOfContentsSettings.includeHyperlink = true;
            tableOfContentsSettings.includeOutlineLevels = true;
            tableOfContentsSettings.includePageNumber = true;
            tableOfContentsSettings.rightAlign = true;
            tableOfContentsSettings.tabLeader = 'Dot';
        }
        let tocField = undefined;
        let code = undefined;
        if (this.selection.contextType === 'TableOfContents') {
            tocField = this.selection.getTocFieldInternal();
        }
        if (tocField instanceof FieldElementBox) {
            this.selection.start.setPositionForSelection(tocField.line, tocField, 0, this.selection.start.location);
            this.selection.end.setPositionForSelection(tocField.fieldEnd.line, tocField.fieldEnd, 2, this.selection.end.location);
            this.onDelete();
        }
        // Build TOC field code based on parameter
        code = this.constructTocFieldCode(tableOfContentsSettings);
        let isStartParagraph = this.selection.start.isAtParagraphStart;
        let blockInfo = this.getParagraphInfo(this.selection.start);
        let initialStart = this.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        // Build TOC fields
        // tslint:disable-next-line:max-line-length
        let widgets = this.buildToc(this.validateTocSettings(tableOfContentsSettings), code, true, isStartParagraph);
        if (widgets.length > 0) {
            let tocLastPara = new ParagraphWidget();
            let tocLastLine = new LineWidget(tocLastPara);
            tocLastPara.childWidgets.push(tocLastLine);
            let index = 0;
            if (!isStartParagraph) {
                index = 1;
            }
            let line = widgets[index].childWidgets[0];
            let fieldBegin = line.children[0];
            this.appendEndField(fieldBegin, tocLastLine);
            widgets.push(tocLastPara);
            this.appendEmptyPara(widgets);
        }
        this.setPositionForCurrentIndex(this.selection.start, initialStart);
        this.selection.end.setPositionInternal(this.selection.start);
        this.pasteContentsInternal(widgets);
        this.isInsertingTOC = false;
        this.updatePageRef();
        if (this.editorHistory) {
            this.editorHistory.updateComplexHistoryInternal();
        }
    }
    appendEmptyPara(widgets) {
        let emptyPara = new ParagraphWidget();
        let emptyLine = new LineWidget(emptyPara);
        emptyPara.childWidgets.push(emptyLine);
        widgets.push(emptyPara);
    }
    constructTocFieldCode(tocSettings) {
        let tocFieldCode = 'TOC';
        //appends styles level
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(tocSettings.startLevel) && tocSettings.startLevel !== 0 && !isNullOrUndefined(tocSettings.endLevel) && tocSettings.endLevel !== 0) {
            tocFieldCode = tocFieldCode + ' \\o "' + tocSettings.startLevel + '-' + tocSettings.endLevel + '"';
        }
        if (tocSettings.includePageNumber && !tocSettings.rightAlign) {
            tocFieldCode = tocFieldCode + ' \\p " "';
        }
        if (!tocSettings.includePageNumber) {
            tocFieldCode = tocFieldCode + ' \\n';
        }
        if (tocSettings.includeHyperlink) {
            tocFieldCode = tocFieldCode + ' \\h \\z';
        }
        if (tocSettings.includeOutlineLevels) {
            tocFieldCode = tocFieldCode + ' \\u';
        }
        let tSwitch = this.constructTSwitch(tocSettings);
        if (tSwitch.length > 6) {
            tocFieldCode = tocFieldCode + tSwitch;
        }
        return tocFieldCode;
    }
    constructTSwitch(tocSettings) {
        let tSwitch = '';
        let prefix = ' \\t ';
        if (!isNullOrUndefined(tocSettings.levelSettings)) {
            for (let key of Object.keys(tocSettings.levelSettings)) {
                tSwitch = tSwitch + key + ',' + tocSettings.levelSettings[key].toString() + ',';
            }
        }
        tSwitch = tSwitch.slice(0, -1);
        tSwitch = prefix + '"' + tSwitch + '"';
        return tSwitch;
    }
    /**
     * Appends the end filed to the given line.
     */
    appendEndField(fieldBegin, lineWidget) {
        let fieldEnd = new FieldElementBox(1);
        fieldEnd.fieldSeparator = fieldBegin.fieldSeparator;
        fieldBegin.fieldSeparator.fieldEnd = fieldEnd;
        fieldEnd.fieldBegin = fieldBegin;
        fieldEnd.fieldBegin.fieldEnd = fieldEnd;
        fieldEnd.line = lineWidget;
        lineWidget.children.push(fieldEnd);
    }
    validateTocSettings(tocSettings) {
        if (isNullOrUndefined(tocSettings.startLevel) || tocSettings.startLevel < 1) {
            tocSettings.startLevel = 1;
        }
        if (isNullOrUndefined(tocSettings.endLevel) || tocSettings.endLevel < tocSettings.endLevel) {
            tocSettings.endLevel = tocSettings.startLevel > 3 ? tocSettings.startLevel : 3;
        }
        if (isNullOrUndefined(tocSettings.includeHyperlink)) {
            tocSettings.includeHyperlink = false;
        }
        if (isNullOrUndefined(tocSettings.includePageNumber)) {
            tocSettings.includePageNumber = false;
        }
        if (isNullOrUndefined(tocSettings.rightAlign)) {
            tocSettings.rightAlign = false;
        }
        if (isNullOrUndefined(tocSettings.levelSettings)) {
            tocSettings.levelSettings = {};
        }
        return tocSettings;
    }
    /**
     * Builds the TOC
     * @private
     */
    // tslint:disable-next-line:max-line-length
    buildToc(tocSettings, fieldCode, isFirstPara, isStartParagraph) {
        let tocDomBody = this.viewer.pages[0].bodyWidgets[0];
        let widgets = [];
        this.createHeadingLevels(tocSettings);
        if (tocSettings.includeOutlineLevels) {
            this.createOutlineLevels(tocSettings);
        }
        let widget = tocDomBody.childWidgets[0];
        while (widget !== undefined) {
            // tslint:disable-next-line:max-line-length
            if (widget instanceof ParagraphWidget && (this.isHeadingStyle(widget) || (tocSettings.includeOutlineLevels && this.isOutlineLevelStyle(widget)))) {
                let bookmarkName = this.insertTocBookmark(widget);
                // tslint:disable-next-line:max-line-length
                this.createTOCWidgets(widget, widgets, fieldCode, bookmarkName, tocSettings, isFirstPara, isStartParagraph);
                isFirstPara = false;
            }
            widget = this.selection.getNextParagraphBlock(widget);
        }
        this.tocStyles = {};
        return widgets;
    }
    createOutlineLevels(settings) {
        for (let i = settings.startLevel; i <= settings.endLevel; i++) {
            let levelStyle = 'Level' + i.toString();
            if (isNullOrUndefined(this.tocStyles[levelStyle])) {
                this.tocStyles[levelStyle] = i;
            }
        }
    }
    /**
     * Creates TOC heading styles
     * @param start - lower heading level
     * @param end - higher heading level
     */
    createHeadingLevels(settings) {
        for (let i = settings.startLevel; i <= settings.endLevel; i++) {
            let headingStyle = 'Heading ' + i.toString();
            if (isNullOrUndefined(this.tocStyles[headingStyle])) {
                this.tocStyles[headingStyle] = i;
            }
        }
        if (!isNullOrUndefined(settings.levelSettings)) {
            for (let key of Object.keys(settings.levelSettings)) {
                this.tocStyles[key] = settings.levelSettings[key];
            }
        }
    }
    /**
     * Checks the current style is heading style.
     */
    isHeadingStyle(para) {
        let style = para.paragraphFormat.baseStyle;
        if (style !== undefined) {
            return isNullOrUndefined(this.tocStyles[style.name]) ? false : true;
        }
        return false;
    }
    isOutlineLevelStyle(para) {
        let styleName = para.paragraphFormat.outlineLevel;
        return isNullOrUndefined(this.tocStyles[styleName]) ? false : true;
    }
    /**
     * Creates TOC field element.
     */
    createTocFieldElement(lineWidget, fieldCode) {
        //begin
        let fieldBegin = new FieldElementBox(0);
        fieldBegin.hasFieldEnd = true;
        fieldBegin.line = lineWidget;
        lineWidget.children.push(fieldBegin);
        //format toc
        let textElement = new TextElementBox();
        textElement.text = fieldCode;
        textElement.line = lineWidget;
        lineWidget.children.push(textElement);
        //field separator
        let fieldSeparator = new FieldElementBox(2);
        fieldSeparator.fieldBegin = fieldBegin;
        fieldSeparator.fieldBegin.fieldSeparator = fieldSeparator;
        fieldSeparator.line = lineWidget;
        lineWidget.children.push(fieldSeparator);
        return fieldBegin;
    }
    /**
     * Updates TOC para
     */
    // tslint:disable-next-line:max-line-length
    createTOCWidgets(widget, widgets, fieldCode, bookmarkName, tocSettings, isFirstPara, isStartParagraph) {
        let fieldBegin = undefined;
        let tocPara = undefined;
        let tocLine = undefined;
        // tslint:disable-next-line:max-line-length
        if (widgets.length === 1 && widgets[0].childWidgets[0].children.length === 3 && !isNullOrUndefined(isFirstPara) && !isFirstPara) {
            tocLine = widgets[0].childWidgets[0];
        }
        else {
            tocPara = new ParagraphWidget();
            let styleName = undefined;
            //Adds toc syles into paragraph
            let headingStyleName = widget.paragraphFormat.baseStyle.name;
            if (tocSettings.includeOutlineLevels && isNullOrUndefined(this.tocStyles[headingStyleName])) {
                styleName = widget.paragraphFormat.outlineLevel;
            }
            else {
                styleName = headingStyleName;
            }
            let tocStyleName = 'Toc' + this.tocStyles[styleName];
            let paraStyle = this.viewer.styles.findByName(tocStyleName, 'Paragraph');
            if (isNullOrUndefined(paraStyle)) {
                // tslint:disable-next-line:max-line-length
                this.viewer.owner.parser.parseStyle(JSON.parse(this.getCompleteStyles()), JSON.parse(this.viewer.preDefinedStyles.get(tocStyleName)), this.viewer.styles);
                paraStyle = this.viewer.styles.findByName(tocStyleName, 'Paragraph');
            }
            tocPara.paragraphFormat.ApplyStyle(paraStyle);
            //Creates right tab for page number.
            if (tocSettings.rightAlign && tocSettings.includePageNumber) {
                let tabStop = new WTabStop();
                tabStop.position = HelperMethods.convertPixelToPoint(this.viewer.clientArea.width);
                tabStop.tabLeader = tocSettings.tabLeader;
                tabStop.deletePosition = 0;
                tabStop.tabJustification = 'Right';
                tocPara.paragraphFormat.tabs.push(tabStop);
            }
            tocLine = new LineWidget(tocPara);
            tocPara.childWidgets.push(tocLine);
        }
        //creates toc field element if it is insert
        if ((isFirstPara !== undefined) && isFirstPara) {
            if (!isNullOrUndefined(isStartParagraph) && !isStartParagraph) {
                this.appendEmptyPara(widgets);
            }
            this.createTocFieldElement(tocLine, fieldCode);
        }
        let text = '';
        for (let lineIndex = 0; lineIndex < widget.childWidgets.length; lineIndex++) {
            let lineWidget = widget.childWidgets[lineIndex];
            for (let elementIndex = 0; elementIndex < lineWidget.children.length; elementIndex++) {
                let element = lineWidget.children[elementIndex];
                if (element instanceof TextElementBox || element instanceof ListTextElementBox) {
                    let temp = element.text;
                    let tabChar = '\t';
                    if (temp.indexOf(tabChar) !== -1) {
                        temp = temp.replace(new RegExp(tabChar, 'g'), ' ');
                    }
                    text = text + temp;
                }
            }
        }
        if (text !== '') {
            // inserts hyperlink
            if (tocSettings.includeHyperlink && (bookmarkName !== undefined)) {
                fieldBegin = this.insertTocHyperlink(tocLine, bookmarkName, text);
            }
            else {
                let span = new TextElementBox();
                span.text = text;
                span.line = tocLine;
                tocLine.children.push(span);
            }
            //inserts page number
            if (tocSettings.includePageNumber && (bookmarkName !== undefined)) {
                if (tocSettings.rightAlign) {
                    let tabText = new TabElementBox();
                    tabText.text = '\t';
                    tabText.line = tocLine;
                    tocLine.children.push(tabText);
                }
                let pageField = this.insertTocPageNumber(bookmarkName, tocLine, tocSettings.rightAlign, widget);
                this.appendEndField(pageField, tocLine);
            }
            if (tocSettings.includeHyperlink && fieldBegin !== undefined) {
                this.appendEndField(fieldBegin, tocLine);
            }
        }
        if (!isNullOrUndefined(tocPara) && (text !== '' || isFirstPara)) {
            widgets.push(tocPara);
        }
    }
    /**
     * Inserts toc hyperlink.
     */
    insertTocHyperlink(lineWidget, bookmarkName, text) {
        let fieldCode = ' HYPERLINK \\l \"' + bookmarkName + '\" ';
        let fieldBegin = this.createTocFieldElement(lineWidget, fieldCode);
        //text element.
        let span = new TextElementBox();
        span.text = text;
        span.line = lineWidget;
        lineWidget.children.push(span);
        return fieldBegin;
    }
    /**
     * Inserts toc page number.
     */
    // tslint:disable-next-line:max-line-length
    insertTocPageNumber(bookMarkname, lineWidget, isRightAlign, widget) {
        let fieldCode = ' PAGEREF' + bookMarkname + ' \\h ';
        let fieldBegin = this.createTocFieldElement(lineWidget, fieldCode);
        let text = (this.viewer.pages.indexOf(widget.bodyWidget.page) + 1).toString();
        //text element.
        let span = new FieldTextElementBox();
        span.fieldBegin = fieldBegin;
        if (!isRightAlign) {
            text = ' ' + text;
        }
        span.text = text;
        span.line = lineWidget;
        lineWidget.children.push(span);
        this.pageRefFields[bookMarkname] = span;
        return fieldBegin;
    }
    updatePageRef() {
        for (let key of Object.keys(this.pageRefFields)) {
            let bookmark = this.viewer.bookmarks.get(key);
            let pageRef = (bookmark.paragraph.bodyWidget.page.index + 1).toString();
            let span = this.pageRefFields[key];
            if (pageRef !== span.text) {
                span.text = pageRef;
                let paragraph = span.paragraph;
                let lineIndex = paragraph.childWidgets.indexOf(span.line);
                let elementIndex = span.line.children.indexOf(span);
                this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, elementIndex);
            }
        }
    }
    /**
     * Inserts toc bookmark.
     */
    insertTocBookmark(widget) {
        let bookmarkName = undefined;
        let lineLength = widget.childWidgets.length;
        if (lineLength > 0) {
            let startLine = widget.childWidgets[0];
            let endLine = widget.childWidgets[lineLength - 1];
            if ((startLine !== undefined) && (endLine !== undefined)) {
                let startElement = startLine.children[0];
                //Returns the bookmark if already present for paragraph.
                // tslint:disable-next-line:max-line-length
                if (!isNullOrUndefined(startElement) && startElement instanceof BookmarkElementBox && startElement.bookmarkType === 0 && (startElement.name.toLowerCase().match('^_toc'))) {
                    return startElement.name;
                }
                let endElement = endLine.children[endLine.children.length - 1];
                if ((startElement !== undefined) && (endElement !== undefined)) {
                    this.selection.start.setPositionForSelection(startLine, startElement, 0, this.selection.start.location);
                    this.selection.end.setPositionForSelection(endLine, endElement, endElement.length, this.selection.end.location);
                    bookmarkName = this.generateBookmarkName();
                    this.insertBookmark(bookmarkName);
                }
            }
        }
        return bookmarkName;
    }
    /**
     * Generates bookmark id.
     */
    generateBookmarkName() {
        this.tocBookmarkId++;
        let count = 10 - this.tocBookmarkId.toString().length;
        let formatString = '';
        while (count - 1 > 0) {
            formatString = '0' + formatString;
            count--;
        }
        let bookmarkName = '_Toc' + formatString + this.tocBookmarkId;
        return bookmarkName;
    }
    /**
     * Change cell content alignment
     * @private
     */
    onCellContentAlignment(verticalAlignment, textAlignment) {
        this.owner.isShiftingEnabled = true;
        let selection = this.owner.selection;
        if (selection.isEmpty && selection.start.paragraph.isInsideTable) {
            if (this.owner.editorHistory) {
                this.owner.editorHistory.initComplexHistory(selection, 'MultiSelection');
            }
            //Selecting the table cell to update the all the paragraph format.
            selection.selectTableCell();
            this.initHistory('CellContentVerticalAlignment');
            let cellFormat = selection.start.paragraph.associatedCell.cellFormat;
            this.applyCellPropertyValue(selection, 'verticalAlignment', verticalAlignment, cellFormat);
            this.reLayout(selection, false);
            this.initHistory('TextAlignment');
            this.updateParagraphFormat('textAlignment', textAlignment, false);
            this.reLayout(this.owner.selection, false);
            if (this.owner.editorHistory) {
                this.owner.editorHistory.updateComplexHistory();
            }
        }
        else {
            if (this.owner.editorHistory) {
                this.owner.editorHistory.initComplexHistory(selection, 'MultiSelection');
            }
            if (!isNullOrUndefined(selection.getTable(selection.start, selection.end))) {
                //Table cell vertical alignment.
                this.updateSelectionTableFormat(selection, 'CellContentVerticalAlignment', verticalAlignment);
                this.reLayout(this.owner.selection, false);
                this.initHistory('TextAlignment');
                //Paragraph text alignment.
                this.updateSelectionParagraphFormatting('textAlignment', textAlignment, false);
                this.reLayout(selection, false);
            }
            if (this.owner.editorHistory) {
                this.owner.editorHistory.updateComplexHistory();
            }
        }
    }
}

/**
 * @private
 */
class ModifiedLevel {
    constructor(owner, modified) {
        this.ownerListLevelIn = undefined;
        this.modifiedListLevelIn = undefined;
        this.ownerListLevel = owner;
        this.modifiedListLevel = modified;
    }
    /**
     * @private
     */
    get ownerListLevel() {
        return this.ownerListLevelIn;
    }
    /**
     * @private
     */
    set ownerListLevel(value) {
        this.ownerListLevelIn = value;
    }
    /**
     * @private
     */
    get modifiedListLevel() {
        return this.modifiedListLevelIn;
    }
    /**
     * @private
     */
    set modifiedListLevel(value) {
        this.modifiedListLevelIn = value;
    }
    /**
     * @private
     */
    destroy() {
        this.ownerListLevel = undefined;
        this.modifiedListLevel = undefined;
    }
}
/**
 * @private
 */
class ModifiedParagraphFormat {
    constructor(ownerFormat, modifiedFormat) {
        this.ownerFormatIn = undefined;
        this.modifiedFormatIn = undefined;
        this.ownerFormat = ownerFormat;
        this.modifiedFormat = modifiedFormat;
    }
    /**
     * @private
     */
    get ownerFormat() {
        return this.ownerFormatIn;
    }
    /**
     * @private
     */
    set ownerFormat(value) {
        this.ownerFormatIn = value;
    }
    /**
     * hidden
     */
    get modifiedFormat() {
        return this.modifiedFormatIn;
    }
    /**
     * @private
     */
    set modifiedFormat(value) {
        this.modifiedFormatIn = value;
    }
    /**
     * @private
     */
    destroy() {
        this.ownerFormat = undefined;
        this.modifiedFormat.destroy();
        this.modifiedFormat = undefined;
    }
}
/**
 * @private
 */
class RowHistoryFormat {
    constructor(startingPoint, rowFormat) {
        this.startingPoint = startingPoint;
        this.rowFormat = rowFormat;
        this.rowHeightType = rowFormat.heightType;
    }
    revertChanges(isRedo, owner) {
        //backup current format values.
        let currentRowHeightType = this.rowFormat.heightType;
        //Restore old values.
        owner.editorModule.tableResize.updateRowHeight(this.rowFormat.ownerBase, isRedo ? this.displacement : (-this.displacement));
        owner.viewer.layout.reLayoutTable(this.rowFormat.ownerBase.ownerTable);
        if (this.rowFormat.heightType !== this.rowHeightType) {
            this.rowFormat.heightType = this.rowHeightType;
        }
        //backup the current format values for redo.
        this.rowHeightType = currentRowHeightType;
    }
}
/**
 * @private
 */
class TableHistoryInfo {
    constructor(table, owner) {
        this.tableHolder = new WTableHolder();
        this.tableFormat = new TableFormatHistoryInfo();
        this.rows = [];
        this.owner = owner;
        this.copyProperties(table);
    }
    copyProperties(table) {
        if (table.tableHolder) {
            this.tableHolder = table.tableHolder.clone();
        }
        if (table.tableFormat) {
            this.tableFormat.leftIndent = table.tableFormat.leftIndent;
            this.tableFormat.preferredWidth = table.tableFormat.preferredWidth;
            this.tableFormat.preferredWidthType = table.tableFormat.preferredWidthType;
        }
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            let rowFormat = new RowFormatHistoryInfo();
            rowFormat.gridBefore = row.rowFormat.gridBefore;
            rowFormat.gridBeforeWidth = row.rowFormat.gridBeforeWidth;
            rowFormat.gridBeforeWidthType = row.rowFormat.gridBeforeWidthType;
            rowFormat.gridAfter = row.rowFormat.gridAfter;
            rowFormat.gridAfterWidth = row.rowFormat.gridAfterWidth;
            rowFormat.gridAfterWidthType = row.rowFormat.gridAfterWidthType;
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                let cellFormat = new CellFormatHistoryInfo();
                cellFormat.columnIndex = cell.columnIndex;
                cellFormat.columnSpan = cell.cellFormat.columnSpan;
                cellFormat.preferredWidth = cell.cellFormat.preferredWidth;
                cellFormat.preferredWidthType = cell.cellFormat.preferredWidthType;
                rowFormat.cells.push(cellFormat);
            }
            this.rows.push(rowFormat);
        }
        this.tableHierarchicalIndex = this.owner.editorModule.getHierarchicalIndex(table, '0');
    }
    destroy() {
        this.tableHierarchicalIndex = undefined;
        if (this.tableHolder) {
            this.tableHolder.destroy();
            this.tableHolder = undefined;
        }
        if (this.tableFormat) {
            this.tableFormat = null;
        }
        if (this.rows) {
            this.rows = [];
            this.rows = undefined;
        }
    }
}
/**
 * @private
 */
class TableFormatHistoryInfo {
    constructor() {
        /* tslint:disable:no-empty */
    }
}
/**
 * @private
 */
class RowFormatHistoryInfo {
    constructor() {
        this.cells = [];
    }
}
/**
 * @private
 */
class CellFormatHistoryInfo {
    constructor() {
        /* tslint:disable:no-empty */
    }
}
/**
 * @private
 */
class CellHistoryFormat {
    constructor(point) {
        this.startingPoint = point; // starting point preserved to calculate the displacement on after cell resizing finished.
    }
}

/**
 * @private
 */
class BaseHistoryInfo {
    //Properties
    //gets owner control
    /**
     * gets the owner control
     * @private
     */
    get owner() { return this.ownerIn; }
    /**
     * gets or sets action
     * @private
     */
    get editorHistory() {
        return this.owner.editorHistory;
    }
    /**
     * gets or sets action
     * @private
     */
    get action() { return this.actionIn; }
    set action(value) { this.actionIn = value; }
    /**
     * gets modified properties
     * @returns Object
     * @private
     */
    get modifiedProperties() { return this.modifiedPropertiesIn; }
    /**
     * @private
     */
    get removedNodes() {
        return this.removedNodesIn;
    }
    /**
     * Gets or Sets the selection start
     * @private
     */
    //gets or sets selection start
    get selectionStart() { return this.selectionStartIn; }
    set selectionStart(value) { this.selectionStartIn = value; }
    /**
     * Gets or Sets the selection end
     * @private
     */
    get selectionEnd() { return this.selectionEndIn; }
    set selectionEnd(value) { this.selectionEndIn = value; }
    /**
     * Gets or sets the insert position
     * @private
     */
    get insertPosition() { return this.insertPositionIn; }
    set insertPosition(value) { this.insertPositionIn = value; }
    /**
     * Gets or sets end position
     * @private
     */
    get endPosition() { return this.endPositionIn; }
    set endPosition(value) { this.endPositionIn = value; }
    constructor(node) {
        this.ownerIn = node;
        this.viewer = node.viewer;
        this.modifiedPropertiesIn = [];
        this.modifiedNodeLength = [];
        this.removedNodesIn = [];
    }
    /**
     * Update the selection
     * @param selection
     * @private
     */
    updateSelection() {
        let blockInfo = this.owner.editorModule.getParagraphInfo(this.owner.selection.start);
        this.selectionStart = this.owner.editorModule.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        blockInfo = this.owner.editorModule.getParagraphInfo(this.owner.selection.end);
        this.selectionEnd = this.owner.editorModule.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
    }
    setBookmarkInfo(bookmark) {
        this.removedNodes.push({ 'bookmark': bookmark, 'startIndex': bookmark.indexInOwner, 'endIndex': bookmark.reference.indexInOwner });
    }
    revertBookmark() {
        let bookmarkInfo = this.removedNodes[0];
        let bookmark = bookmarkInfo.bookmark;
        if (this.editorHistory.isUndoing) {
            this.viewer.bookmarks.add(bookmark.name, bookmark);
            bookmark.line.children.splice(bookmarkInfo.startIndex, 0, bookmark);
            bookmark.reference.line.children.splice(bookmarkInfo.endIndex, 0, bookmark.reference);
            this.editorHistory.recordChanges(this);
        }
        else {
            this.owner.editorModule.deleteBookmarkInternal(bookmark);
            this.editorHistory.undoStack.push(this);
        }
    }
    /**
     * Reverts this instance
     * @private
     */
    // tslint:disable: max-func-body-length
    revert() {
        if (this.action === 'DeleteBookmark') {
            this.revertBookmark();
            return;
        }
        this.owner.isShiftingEnabled = true;
        let selectionStartTextPosition = undefined;
        let selectionEndTextPosition = undefined;
        let start = this.selectionStart;
        let end = this.selectionEnd;
        let isForwardSelection = TextPosition.isForwardSelection(start, end);
        if (this.modifiedProperties.length > 0 || this.action === 'Selection' || this.action === 'ClearCharacterFormat'
            || this.action === 'ClearParagraphFormat') {
            selectionStartTextPosition = this.getTextPosition(start);
            selectionEndTextPosition = this.getTextPosition(end);
            this.revertModifiedProperties(selectionStartTextPosition, selectionEndTextPosition);
        }
        else {
            let deletedNodes = this.removedNodes;
            this.removedNodesIn = [];
            let isForward = TextPosition.isForwardSelection(this.insertPosition, this.endPosition);
            let insertTextPosition = this.getTextPosition(isForward ? this.insertPosition : this.endPosition);
            let endTextPosition = this.getTextPosition(isForward ? this.endPosition : this.insertPosition);
            if (insertTextPosition.isAtSamePosition(endTextPosition)) {
                this.owner.selection.selectContent(insertTextPosition, true);
            }
            else {
                this.owner.selection.selectPosition(insertTextPosition, endTextPosition);
            }
            if (this.action === 'InsertHyperlink' && this.editorHistory.isRedoing) {
                let fieldBegin = this.owner.selection.getHyperlinkField();
                if (!isNullOrUndefined(fieldBegin)) {
                    let offset = (fieldBegin.line).getOffset(fieldBegin, 0);
                    insertTextPosition.setPositionParagraph(fieldBegin.line, offset);
                    this.owner.selection.start.setPositionInternal(insertTextPosition);
                    offset = fieldBegin.fieldEnd.line.getOffset(fieldBegin.fieldEnd, 1);
                    endTextPosition.setPositionParagraph(fieldBegin.fieldEnd.line, offset);
                }
            }
            this.editorHistory.currentBaseHistoryInfo = this;
            this.selectionStart = this.insertPosition;
            this.insertPosition = undefined;
            this.selectionEnd = this.endPosition;
            this.endPosition = undefined;
            let isRemoveContent = false;
            if (!insertTextPosition.isAtSamePosition(endTextPosition)) {
                isRemoveContent = this.action === 'BackSpace' || this.action === 'Delete' || this.action === 'ClearCells'
                    || this.action === 'DeleteCells';
                if (!(isRemoveContent) && this.action !== 'MergeCells' && this.action !== 'InsertRowAbove'
                    && this.action !== 'InsertRowBelow' && this.action !== 'InsertColumnLeft'
                    && this.action !== 'InsertColumnRight' && this.action !== 'Borders'
                    && this.action !== 'DeleteTable' && this.action !== 'DeleteColumn' && this.action !== 'DeleteRow') {
                    this.owner.selection.end.setPositionInternal(endTextPosition);
                    if (!this.owner.selection.isEmpty) {
                        if (this.editorHistory.isRedoing) {
                            this.owner.editorModule.removeSelectedContents(this.owner.selection);
                        }
                        else {
                            this.owner.editorModule.deleteSelectedContents(this.owner.selection, true);
                        }
                    }
                }
            }
            let isRedoAction = this.editorHistory.isRedoing && !isRemoveContent;
            this.revertModifiedNodes(deletedNodes, isRedoAction, isForwardSelection ? start : end, start === end);
            if (isRemoveContent) {
                this.removeContent(insertTextPosition, endTextPosition);
            }
            //this.owner.editorModule.reLayout(this.viewer.selection);
        }
        let isSelectionChanged = false;
        if ((this.editorHistory.isUndoing && isNullOrUndefined(this.editorHistory.currentHistoryInfo)) ||
            ((this.action === 'InsertRowAbove' || this.action === 'Borders' || this.action === 'InsertRowBelow'
                || this.action === 'InsertColumnLeft'
                || this.action === 'InsertColumnRight') && (this.editorHistory.isRedoing
                || this.editorHistory.currentHistoryInfo.action === 'Paste'))) {
            selectionStartTextPosition = this.getTextPosition(start);
            selectionEndTextPosition = this.getTextPosition(end);
            this.owner.selection.selectRange(selectionStartTextPosition, selectionEndTextPosition);
            isSelectionChanged = true;
        }
        // Updates insert position of history info instance.
        this.insertPosition = start;
        this.endPosition = end;
        this.owner.editorModule.reLayout(this.owner.selection, this.owner.selection.isEmpty);
        if (isSelectionChanged) {
            this.viewer.scrollToPosition(this.owner.selection.start, this.owner.selection.end);
        }
        this.highlightListText();
    }
    highlightListText() {
        if (!isNullOrUndefined(this.editorHistory.currentHistoryInfo)) {
            // tslint:disable-next-line:max-line-length
            if (this.action === 'ListCharacterFormat' || (this.editorHistory.currentHistoryInfo.action === 'ListSelect' && this.action === 'ListFormat')) {
                let selectionStartTextPosition = this.getTextPosition(this.selectionStart);
                let widget = selectionStartTextPosition.currentWidget;
                this.viewer.selection.highlightListText(widget);
            }
        }
    }
    removeContent(insertTextPosition, endTextPosition) {
        //If the base parent of the insert text position and end text position is null 
        //then the paragraphs already removed.
        //Example scenario: In table editing that is delete cells operation 
        // we will backed up the entire table ad it will be replaced on undo operation.
        //At that time if the positions are in table 
        //which is already replaced in undo (revert modified nodes method) then the base parent of the paragraph will be null.
        //So again, selecting the content and deleting is unnecessary
        // and it will cause improper position updates and null reference exceptions. 
        if ((!isNullOrUndefined(insertTextPosition.paragraph.containerWidget) &&
            insertTextPosition.paragraph.containerWidget instanceof BodyWidget &&
            (!isNullOrUndefined(endTextPosition.paragraph.containerWidget)
                && endTextPosition.paragraph.containerWidget instanceof BodyWidget))
            || (!isNullOrUndefined(insertTextPosition.paragraph.containerWidget)
                && !isNullOrUndefined(endTextPosition.paragraph.containerWidget)
                && insertTextPosition.paragraph.containerWidget instanceof TableCellWidget
                && endTextPosition.paragraph.containerWidget instanceof TableCellWidget
                && !isNullOrUndefined(insertTextPosition.paragraph.bodyWidget))) {
            //Removes if any empty paragraph is added while delete.
            this.owner.selection.selectRange(insertTextPosition, endTextPosition);
            let isDelete = (this.action === 'BackSpace') ? true : false;
            this.owner.editorModule.deleteSelectedContents(this.owner.selection, isDelete);
        }
    }
    revertModifiedProperties(start, end) {
        if (this.action === 'CellFormat' || this.action === 'CellOptions' || this.action === 'TableOptions') {
            this.owner.isShiftingEnabled = false;
        }
        this.owner.selection.selectRange(start, end);
        if (this.action === 'RowResizing' || this.action === 'CellResizing') {
            this.revertResizing();
        }
        else if (this.action === 'CellOptions' || this.action === 'TableOptions') {
            this.revertTableDialogProperties(this.action);
        }
        else if (this.action !== 'Selection') {
            this.revertProperties();
        }
    }
    // Redoes the Action
    redoAction() {
        let editor = this.owner.editorModule;
        switch (this.action) {
            case 'BackSpace':
                editor.singleBackspace(this.owner.selection, true);
                break;
            case 'Delete':
                editor.singleDelete(this.owner.selection, true);
                break;
            case 'DeleteTable':
                editor.deleteTable();
                break;
            case 'DeleteColumn':
                editor.deleteColumn();
                break;
            case 'DeleteRow':
                editor.deleteRow();
                break;
            case 'MergeCells':
                editor.mergeSelectedCellsInTable();
                break;
            case 'InsertRowAbove':
                editor.insertRow(true);
                break;
            case 'InsertRowBelow':
                editor.insertRow(false);
                break;
            case 'InsertColumnLeft':
                editor.insertColumn(true);
                break;
            case 'InsertColumnRight':
                editor.insertColumn(true);
                break;
            case 'SectionBreak':
                editor.insertSection(this.owner.selection, true);
                break;
        }
    }
    /**
     * Revert the modified nodes
     * @param  {WNode[]} deletedNodes
     * @param  {boolean} isRedoAction
     * @param  {string} start
     * @param  {boolean} isEmptySelection
     */
    revertModifiedNodes(deletedNodes, isRedoAction, start, isEmptySelection) {
        if (isRedoAction && (this.action === 'BackSpace' || this.action === 'Delete' || this.action === 'DeleteTable'
            || this.action === 'DeleteColumn' || this.action === 'DeleteRow' || this.action === 'InsertRowAbove' ||
            this.action === 'InsertRowBelow' || this.action === 'InsertColumnLeft' || this.action === 'InsertColumnRight'
            || this.action === 'MergeCells' || this.action === 'SectionBreak')) {
            this.redoAction();
            if (this.action === 'SectionBreak') {
                return;
            }
        }
        if (deletedNodes.length > 0) {
            if ((this.editorHistory.isUndoing && (this.action === 'DeleteCells' || this.action === 'DeleteColumn'
                || this.action === 'DeleteRow' || this.action === 'MergeCells'))
                || (this.action === 'InsertRowAbove' || this.action === 'InsertRowBelow' || this.action === 'InsertColumnLeft'
                    || this.action === 'ClearCells' || this.action === 'InsertColumnRight' || this.action === 'Borders')) {
                let insertIndex = this.selectionStart;
                let block = this.owner.editorModule.getBlock({ index: insertIndex }).node;
                let lastNode = deletedNodes[deletedNodes.length - 1];
                if ((block instanceof TableWidget || block.previousRenderedWidget instanceof TableWidget || block.isInsideTable)
                    && lastNode instanceof TableWidget) {
                    if (block instanceof ParagraphWidget && !block.isInsideTable) {
                        block = block.previousRenderedWidget;
                    }
                    block = block.combineWidget(this.viewer);
                    this.owner.editorModule.insertTableInternal(block, lastNode, false);
                    deletedNodes.splice(deletedNodes.indexOf(lastNode), 1);
                }
                else if (lastNode instanceof TableWidget) {
                    this.owner.editorModule.insertBlock(lastNode);
                }
            }
            else {
                let initialStart = start;
                let block = this.owner.editorModule.getBlock({ index: initialStart }).node;
                // initialStart = blockObj.position;
                if (deletedNodes.length > 0 && (this.action === 'BackSpace' && isEmptySelection
                    || (!(block instanceof TableWidget) && !(block instanceof HeaderFooterWidget)))) {
                    let lastNode = deletedNodes[0];
                    if (this.action === 'SectionBreak' && lastNode instanceof BodyWidget ||
                        !isNullOrUndefined(this.editorHistory.currentHistoryInfo) &&
                            this.editorHistory.currentHistoryInfo.action === 'PageBreak') {
                        lastNode = deletedNodes[1];
                    }
                    if (lastNode instanceof ParagraphWidget && this.owner.selection.start.offset > 0) {
                        this.owner.editorModule.insertNewParagraphWidget(lastNode, true);
                        deletedNodes.splice(deletedNodes.indexOf(lastNode), 1);
                        if (isNullOrUndefined(block)) {
                            // tslint:disable-next-line:max-line-length
                            let nextBlock = this.viewer.selection.getNextParagraphBlock(lastNode.getSplitWidgets().pop());
                            this.owner.selection.getNextRenderedBlock(lastNode);
                            if (isNullOrUndefined(nextBlock)) {
                                //Sets the selection as starting of last paragraph.
                                this.owner.selection.selectParagraph(lastNode, true);
                            }
                        }
                    }
                    if (lastNode instanceof TableWidget && this.owner.selection.start.offset > 0) {
                        let firstBlock = deletedNodes[deletedNodes.length - 1];
                        if (firstBlock instanceof ParagraphWidget) {
                            this.owner.editorModule.insertNewParagraphWidget(firstBlock, true);
                            deletedNodes.splice(deletedNodes.indexOf(firstBlock), 1);
                            if (isNullOrUndefined(block)) {
                                // tslint:disable-next-line:max-line-length
                                let nextBlock = this.viewer.selection.getNextParagraphBlock(firstBlock.getSplitWidgets().pop());
                                if (isNullOrUndefined(nextBlock)) {
                                    //Sets the selection as starting of last paragraph.
                                    this.owner.selection.selectParagraph(firstBlock, true);
                                }
                            }
                        }
                    }
                }
                if (deletedNodes.length > 0) {
                    let firstNode = deletedNodes[deletedNodes.length - 1];
                    if (block instanceof TableWidget) {
                        block = block.combineWidget(this.viewer);
                        if (firstNode instanceof TableWidget) {
                            this.owner.editorModule.insertTableInternal(block, firstNode, true);
                            deletedNodes.splice(deletedNodes.indexOf(firstNode), 1);
                            this.insertPosition = start;
                            let nextWidget = firstNode.getSplitWidgets().pop();
                            if (nextWidget.nextRenderedWidget instanceof TableWidget) {
                                block = nextWidget.nextRenderedWidget;
                            }
                            else {
                                initialStart = start;
                                block = this.owner.editorModule.getBlock({ index: initialStart }).node;
                            }
                        }
                    }
                    //Checks if first node is paragraph and current insert position is paragraph end.
                    // tslint:disable-next-line:max-line-length
                    if (firstNode instanceof ParagraphWidget && this.owner.selection.start.offset > 0
                        && this.owner.selection.start.offset === this.owner.selection.getLineLength(this.owner.selection.start.paragraph.lastChild)) {
                        let editor = this.owner.editorModule;
                        editor.insertNewParagraphWidget(firstNode, false);
                        deletedNodes.splice(deletedNodes.indexOf(firstNode), 1);
                        //Removes the intermediate empty paragraph instance.
                        if (this.action !== 'Paste') {
                            editor.removeBlock(this.owner.selection.start.paragraph);
                        }
                        // tslint:disable-next-line:max-line-length
                        let paragraph = this.viewer.selection.getNextParagraphBlock(firstNode.getSplitWidgets().pop());
                        if (!isNullOrUndefined(paragraph)) {
                            this.owner.selection.selectParagraph(paragraph, true);
                        }
                    }
                    else if (deletedNodes[0] instanceof TableWidget && deletedNodes.length !== 1) {
                        let nextNode = deletedNodes[1];
                        if (nextNode instanceof ParagraphWidget && nextNode.isEmpty()) {
                            deletedNodes.splice(deletedNodes.indexOf(nextNode), 1);
                        }
                    }
                }
                if (deletedNodes.length > 0) {
                    if (block instanceof TableWidget) {
                        block = block.combineWidget(this.viewer);
                    }
                    this.insertRemovedNodes(deletedNodes, block);
                }
            }
        }
    }
    insertRemovedNodes(deletedNodes, block) {
        for (let i = deletedNodes.length - 1, index = 0; i > -1; i--) {
            let node = deletedNodes[i];
            if (node instanceof ElementBox) {
                this.owner.editorModule.insertInlineInSelection(this.owner.selection, node);
            }
            else if (node instanceof BlockWidget) {
                if (node instanceof TableRowWidget) {
                    if (block instanceof TableWidget) {
                        block.childWidgets.splice(index, 0, node);
                        this.owner.editorModule.updateNextBlocksIndex(node, true);
                        if (i === 0 || !(deletedNodes[i - 1] instanceof TableRowWidget)) {
                            // tslint:disable-next-line:max-line-length
                            this.viewer.layout.layoutBodyWidgetCollection(block.index, block.containerWidget, block, false);
                        }
                    }
                }
                else if (block instanceof TableWidget) {
                    this.owner.editorModule.insertBlockTable(this.owner.selection, node, block);
                }
                else {
                    this.owner.editorModule.insertBlock(node);
                }
            }
            else if (node instanceof BodyWidget) {
                this.owner.editorModule.insertSection(this.owner.selection, false);
            }
        }
        deletedNodes = [];
    }
    revertResizing() {
        this.editorHistory.currentBaseHistoryInfo = this;
        if (this.action === 'RowResizing') {
            if (this.modifiedProperties[0] instanceof RowHistoryFormat) {
                // tslint:disable-next-line:max-line-length
                this.modifiedProperties[0].revertChanges(this.editorHistory.isRedoing, this.owner);
            }
        }
        else {
            if (this.modifiedProperties[0] instanceof TableHistoryInfo) {
                //selected cell resizing the condition checks done based on the selected widgets only. so need to highlight the selection.
                if (this.owner.selection.selectedWidgets.length === 0) {
                    this.owner.selection.highlightSelection(true);
                }
                let prevTableHistoryInfo = this.modifiedProperties[0];
                let position = prevTableHistoryInfo.tableHierarchicalIndex;
                let block = this.owner.editorModule.getBlock({ index: position }).node;
                if (block instanceof TableWidget) {
                    let tableResize = this.owner.editorModule.tableResize;
                    this.owner.editor.setOffsetValue(this.owner.selection);
                    block = block.combineWidget(this.owner.viewer);
                    tableResize.currentResizingTable = block;
                    this.modifiedProperties.splice(0, 1);
                    if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
                        let tableHistoryInfoCurrent = new TableHistoryInfo(block, this.owner);
                        this.modifiedProperties.splice(0, 0, tableHistoryInfoCurrent);
                        this.owner.isLayoutEnabled = false;
                        tableResize.applyProperties(tableResize.currentResizingTable, prevTableHistoryInfo);
                        tableResize.currentResizingTable.isGridUpdated = true;
                        this.owner.isLayoutEnabled = true;
                        tableResize.updateGridValue(tableResize.currentResizingTable, false);
                        prevTableHistoryInfo.destroy();
                        prevTableHistoryInfo = undefined;
                    }
                }
            }
        }
    }
    revertTableDialogProperties(action) {
        this.owner.isShiftingEnabled = false;
        this.editorHistory.currentBaseHistoryInfo = this;
        this.currentPropertyIndex = 0;
        if (action === 'CellOptions') {
            let selection = this.owner.selection;
            let cellFormat = this.modifiedProperties[0];
            this.owner.editorModule.updateCellMargins(selection, cellFormat);
        }
        else if (action === 'TableOptions') {
            this.owner.tableOptionsDialogModule.applyTableOptionsHelper(this.modifiedProperties[0]);
        }
        this.currentPropertyIndex = 0;
        this.owner.isShiftingEnabled = true;
    }
    getTextPosition(hierarchicalIndex) {
        let textPosition = new TextPosition(this.owner);
        let blockInfo = this.owner.editorModule.getParagraph({ index: hierarchicalIndex });
        let lineInfo = this.owner.editorModule.getLineInfo(blockInfo.paragraph, blockInfo.offset);
        textPosition.setPositionForLineWidget(lineInfo.line, lineInfo.offset);
        return textPosition;
    }
    /**
     * Add modified properties for section format
     * @param  {WSectionFormat} format
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    addModifiedPropertiesForSection(format, property, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            let modifiedProperties = this.modifiedProperties;
            let previousFormat = (this.currentPropertyIndex < modifiedProperties.length ?
                modifiedProperties[this.currentPropertyIndex] : modifiedProperties[modifiedProperties.length - 1]);
            if (isNullOrUndefined(property)) {
                value = previousFormat;
                if (this.currentPropertyIndex < this.modifiedProperties.length) {
                    this.modifiedProperties[this.currentPropertyIndex] = format.cloneFormat();
                }
                else {
                    this.modifiedProperties[this.modifiedProperties.length - 1] = format.cloneFormat();
                }
            }
            else {
                value = previousFormat.getPropertyValue(property);
                previousFormat.copyFormat(format);
            }
            this.currentPropertyIndex++;
        }
        else {
            if (isNullOrUndefined(property)) {
                this.modifiedProperties.push(format.cloneFormat());
            }
            else {
                let currentFormat = new WSectionFormat();
                currentFormat.copyFormat(format);
                this.modifiedProperties.push(currentFormat);
            }
        }
        return value;
    }
    /**
     * Add the modified properties for character format
     * @param  {WCharacterFormat} format
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    addModifiedProperties(format, property, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length           
            let previousFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            let skipRemove = false;
            if (format.ownerBase instanceof ElementBox) {
                let prevLength = this.modifiedNodeLength[this.currentPropertyIndex];
                if (format.ownerBase.length < prevLength) {
                    skipRemove = true;
                    this.modifiedNodeLength[this.currentPropertyIndex] = format.ownerBase.length;
                    this.modifiedNodeLength.splice(this.currentPropertyIndex + 1, 0, prevLength - format.ownerBase.length);
                    //Adds a copy of character format at next position for splitted inline.
                    let nextFormat = new WCharacterFormat(undefined);
                    nextFormat.copyFormat(previousFormat);
                    this.modifiedProperties.splice(this.currentPropertyIndex + 1, 0, nextFormat);
                }
            }
            if (this.action === 'ClearCharacterFormat') {
                if (this.editorHistory.isUndoing) {
                    value = previousFormat;
                    if (!skipRemove) {
                        this.modifiedProperties.splice(this.currentPropertyIndex, 1);
                        this.currentPropertyIndex--;
                    }
                }
                else {
                    this.modifiedProperties.push(format.cloneFormat());
                }
            }
            else {
                value = previousFormat;
                if (this.currentPropertyIndex < this.modifiedProperties.length) {
                    this.modifiedProperties[this.currentPropertyIndex] = format.cloneFormat();
                }
                else {
                    this.modifiedProperties[this.modifiedProperties.length - 1] = format.cloneFormat();
                }
            }
            this.currentPropertyIndex++;
        }
        else {
            if (isNullOrUndefined(property)) {
                this.modifiedProperties.push(format.cloneFormat());
            }
            else {
                let currentFormat = new WCharacterFormat(undefined);
                currentFormat.copyFormat(format);
                this.modifiedProperties.push(currentFormat);
            }
            if (format.ownerBase instanceof ElementBox) {
                this.modifiedNodeLength.push(format.ownerBase.length);
            }
            else {
                this.modifiedNodeLength.push(0);
            }
        }
        return value;
    }
    /**
     * Add the modified properties for paragraph format
     * @param  {WParagraphFormat} format
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    addModifiedPropertiesForParagraphFormat(format, property, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            let previousFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            if (this.action === 'ClearParagraphFormat') {
                if (this.editorHistory.isUndoing) {
                    value = previousFormat;
                    this.modifiedProperties.splice(this.currentPropertyIndex, 1);
                    this.currentPropertyIndex--;
                }
                else {
                    this.modifiedProperties.push(format.cloneFormat());
                }
                this.currentPropertyIndex++;
                return value;
            }
            if (isNullOrUndefined(property)) {
                value = previousFormat;
                if (this.currentPropertyIndex < this.modifiedProperties.length) {
                    this.modifiedProperties[this.currentPropertyIndex] = format.cloneFormat();
                }
                else {
                    this.modifiedProperties[this.modifiedProperties.length - 1] = format.cloneFormat();
                }
                this.currentPropertyIndex++;
                return value;
            }
            if (property === 'listFormat') {
                value = new WParagraphFormat(undefined);
                value.copyFormat(previousFormat);
                previousFormat.listFormat = new WListFormat();
                previousFormat.listFormat.copyFormat(format.listFormat);
                this.currentPropertyIndex++;
                return value;
            }
            if (property === 'styleName') {
                if (!isNullOrUndefined(previousFormat.baseStyle)) {
                    value = new WParagraphStyle();
                    value.copyStyle(previousFormat.baseStyle);
                    this.currentPropertyIndex++;
                    return value;
                }
                else {
                    return undefined;
                }
            }
            value = previousFormat.getPropertyValue(property);
            previousFormat.copyFormat(format);
            this.currentPropertyIndex++;
        }
        else {
            if (isNullOrUndefined(property)) {
                this.modifiedProperties.push(format.cloneFormat());
            }
            else {
                let currentFormat = new WParagraphFormat(undefined);
                currentFormat.copyFormat(format);
                this.modifiedProperties.push(currentFormat);
            }
        }
        return value;
    }
    /**
     * @private
     */
    addModifiedPropertiesForContinueNumbering(paragraphFormat, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            let previousFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            value = previousFormat;
            if (this.currentPropertyIndex < this.modifiedProperties.length) {
                this.modifiedProperties[this.currentPropertyIndex] = paragraphFormat.cloneFormat();
            }
            else {
                this.modifiedProperties[this.modifiedProperties.length - 1] = paragraphFormat.cloneFormat();
            }
            this.currentPropertyIndex++;
            return value;
        }
        else {
            let currentFormat = new WParagraphFormat();
            currentFormat.copyFormat(paragraphFormat);
            this.modifiedProperties.push(currentFormat);
        }
        return value;
    }
    /**
     * @param listFormat
     * @param value
     * @private
     */
    addModifiedPropertiesForRestartNumbering(listFormat, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            let listId = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            value = listId;
            if (this.currentPropertyIndex < this.modifiedProperties.length) {
                this.modifiedProperties[this.currentPropertyIndex] = listFormat.listId;
            }
            else {
                this.modifiedProperties[this.modifiedProperties.length - 1] = listFormat.listId;
            }
            this.currentPropertyIndex++;
            return value;
        }
        else {
            this.modifiedProperties.push(listFormat.listId);
        }
        return value;
    }
    /**
     * Add modified properties for list format
     * @param  {WListLevel} listLevel
     * @private
     */
    addModifiedPropertiesForList(listLevel) {
        let value;
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            let previousLevel = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            value = previousLevel;
            previousLevel = new ModifiedLevel(listLevel, this.owner.editorModule.cloneListLevel(listLevel));
            if (this.currentPropertyIndex < this.modifiedProperties.length) {
                this.modifiedProperties[this.currentPropertyIndex] = previousLevel;
            }
            else {
                this.modifiedProperties[this.modifiedProperties.length - 1] = previousLevel;
            }
            this.currentPropertyIndex++;
        }
        else {
            this.modifiedProperties.push(new ModifiedLevel(listLevel, this.owner.editorModule.cloneListLevel(listLevel)));
            value = listLevel;
        }
        return value;
    }
    /**
     * Revert the properties
     * @param  {SelectionRange} selectionRange
     */
    revertProperties() {
        this.editorHistory.currentBaseHistoryInfo = this;
        this.currentPropertyIndex = 0;
        let property = this.getProperty();
        this.viewer.owner.editorModule.setOffsetValue(this.viewer.selection);
        if (this.action === 'ClearCharacterFormat' || this.modifiedProperties[0] instanceof WCharacterFormat) {
            if (this.action === 'ListCharacterFormat') {
                this.owner.editorModule.updateListCharacterFormat(this.viewer.selection, property, undefined);
                return;
            }
            this.owner.editorModule.updateSelectionCharacterFormatting(property, undefined, false);
        }
        else if (this.action === 'ClearParagraphFormat' || this.modifiedProperties[0] instanceof WParagraphFormat) {
            if (this.action === 'ContinueNumbering') {
                // tslint:disable-next-line:max-line-length
                this.owner.editorModule.revertContinueNumbering(this.owner.selection, this.modifiedProperties[0]);
                return;
            }
            if (this.action === 'StyleName' && this.modifiedProperties[0] instanceof WParagraphFormat) {
                // tslint:disable-next-line:max-line-length
                this.owner.editorModule.updateSelectionParagraphFormatting(property, this.modifiedProperties[0].baseStyle, false);
                return;
            }
            this.owner.editorModule.updateSelectionParagraphFormatting(property, undefined, false);
        }
        else if (this.modifiedProperties[0] instanceof WSectionFormat) {
            this.owner.editorModule.updateSectionFormat(property, undefined);
        }
        else if (this.action === 'RestartNumbering') {
            this.owner.editorModule.restartListAtInternal(this.owner.selection, this.modifiedProperties[0]);
            return;
        }
        else if (this.modifiedProperties[0] instanceof ImageFormat) {
            this.owner.selection.updateImageSize(this.modifiedProperties[0]);
        }
        else if (this.modifiedProperties[0] instanceof ModifiedLevel) {
            let modified = new Dictionary();
            for (let i = 0; i < this.modifiedProperties.length; i++) {
                let modifiedLevel = this.modifiedProperties[i];
                // modified.modifiedLevels.add(modifiedLevel.ownerListLevel.levelNumber, modifiedLevel);
                modified.add(i, modifiedLevel);
            }
            this.editorHistory.updateListChanges(modified);
            modified.destroy();
            modified = undefined;
        }
        else if (this.modifiedProperties[0] instanceof WTableFormat) {
            this.owner.editorModule.updateTableFormat(this.owner.selection, property, undefined);
        }
        else if (this.modifiedProperties[0] instanceof WCellFormat) {
            this.owner.isShiftingEnabled = true;
            this.owner.editorModule.updateCellFormat(this.owner.selection, property, undefined);
        }
        else if (this.modifiedProperties[0] instanceof WRowFormat) {
            this.owner.editorModule.updateRowFormat(this.owner.selection, property, undefined);
        }
        this.currentPropertyIndex = 0;
        if (this.action === 'ClearCharacterFormat' || this.action === 'ClearParagraphFormat') {
            this.owner.editorModule.getOffsetValue(this.viewer.selection);
        }
    }
    /**
     * Add modified properties for cell options dialog
     * @param  {WCellFormat} format
     * @param  {WTable} table
     * @private
     */
    addModifiedCellOptions(applyFormat, format, table) {
        let currentFormat;
        if (isNullOrUndefined(applyFormat.bottomMargin) && isNullOrUndefined(applyFormat.topMargin)
            && isNullOrUndefined(applyFormat.rightMargin) && isNullOrUndefined(applyFormat.leftMargin)) {
            currentFormat = this.copyCellOptions(table.tableFormat);
        }
        else {
            currentFormat = this.copyCellOptions(applyFormat);
        }
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            let previousFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            format = previousFormat;
            if (this.currentPropertyIndex < this.modifiedProperties.length) {
                this.modifiedProperties[this.currentPropertyIndex] = this.copyCellOptions(applyFormat);
            }
            else {
                this.modifiedProperties[this.modifiedProperties.length - 1] = this.copyCellOptions(applyFormat);
            }
            this.currentPropertyIndex++;
            return format;
        }
        else {
            this.modifiedProperties.push(currentFormat);
        }
        return format;
    }
    copyCellOptions(format) {
        let cellFormat = new WCellFormat();
        cellFormat.topMargin = format.topMargin;
        cellFormat.rightMargin = format.rightMargin;
        cellFormat.bottomMargin = format.bottomMargin;
        cellFormat.leftMargin = format.leftMargin;
        return cellFormat;
    }
    /**
     * Add modified properties for cell options dialog
     * @param  {WTableFormat} format
     * @private
     */
    addModifiedTableOptions(format) {
        let currentFormat = this.copyTableOptions(format);
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length           
            let previousFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            if (this.currentPropertyIndex < this.modifiedProperties.length) {
                this.modifiedProperties.splice(this.currentPropertyIndex, 1, currentFormat);
            }
            else {
                this.modifiedProperties.splice(this.modifiedProperties.length - 1, 1, currentFormat);
            }
            this.currentPropertyIndex++;
        }
        else {
            this.modifiedProperties.push(currentFormat);
        }
    }
    copyTableOptions(format) {
        let tableFormat = new WTableFormat();
        tableFormat.topMargin = format.topMargin;
        tableFormat.rightMargin = format.rightMargin;
        tableFormat.bottomMargin = format.bottomMargin;
        tableFormat.leftMargin = format.leftMargin;
        tableFormat.cellSpacing = format.cellSpacing;
        return tableFormat;
    }
    getProperty() {
        switch (this.action) {
            case 'Bold':
                return 'bold';
            case 'Italic':
                return 'italic';
            case 'FontColor':
                return 'fontColor';
            case 'FontFamily':
                return 'fontFamily';
            case 'FontSize':
                return 'fontSize';
            case 'HighlightColor':
                return 'highlightColor';
            case 'BaselineAlignment':
                return 'baselineAlignment';
            case 'Strikethrough':
                return 'strikethrough';
            case 'Underline':
                return 'underline';
            case 'AfterSpacing':
                return 'afterSpacing';
            case 'BeforeSpacing':
                return 'beforeSpacing';
            case 'LeftIndent':
                return 'leftIndent';
            case 'RightIndent':
                return 'rightIndent';
            case 'FirstLineIndent':
                return 'firstLineIndent';
            case 'LineSpacingType':
                return 'lineSpacingType';
            case 'LineSpacing':
                return 'lineSpacing';
            case 'TextAlignment':
                return 'textAlignment';
            case 'ListFormat':
                return 'listFormat';
            case 'PageHeight':
                return 'pageHeight';
            case 'PageWidth':
                return 'pageWidth';
            case 'TableAlignment':
                return 'tableAlignment';
            case 'TableLeftIndent':
                return 'leftIndent';
            case 'DefaultCellSpacing':
                return 'cellSpacing';
            case 'LeftMargin':
            case 'CellLeftMargin':
            case 'DefaultCellLeftMargin':
                return 'leftMargin';
            case 'RightMargin':
            case 'CellRightMargin':
            case 'DefaultCellRightMargin':
                return 'rightMargin';
            case 'TopMargin':
            case 'CellTopMargin':
            case 'DefaultCellTopMargin':
                return 'topMargin';
            case 'BottomMargin':
            case 'CellBottomMargin':
            case 'DefaultCellBottomMargin':
                return 'bottomMargin';
            case 'CellContentVerticalAlignment':
                return 'verticalAlignment';
            case 'RowHeight':
                return 'height';
            case 'RowHeightType':
                return 'heightType';
            case 'RowHeader':
                return 'isHeader';
            case 'AllowBreakAcrossPages':
                return 'allowBreakAcrossPages';
            case 'TablePreferredWidth':
            case 'CellPreferredWidth':
                return 'preferredWidth';
            case 'TablePreferredWidthType':
            case 'CellPreferredWidthType':
                return 'preferredWidthType';
            case 'Shading':
                return 'shading';
            case 'StyleName':
                return 'styleName';
        }
        return undefined;
    }
    getCharacterPropertyValue(property, modifiedProperty) {
        let value;
        if (property === 'bold') {
            value = modifiedProperty.bold;
        }
        else if (property === 'italic') {
            value = modifiedProperty.italic;
        }
        else if (property === 'fontColor') {
            value = modifiedProperty.fontColor;
        }
        else if (property === 'fontFamily') {
            value = modifiedProperty.fontFamily;
        }
        else if (property === 'fontSize') {
            value = modifiedProperty.fontSize;
        }
        else if (property === 'highlightColor') {
            value = modifiedProperty.highlightColor;
        }
        else if (property === 'baselineAlignment') {
            value = modifiedProperty.baselineAlignment;
        }
        else if (property === 'strikethrough') {
            value = modifiedProperty.strikethrough;
        }
        else if (property === 'underline') {
            value = modifiedProperty.underline;
        }
        return value;
    }
    /**
     * Add modified properties for table format
     * @param  {WTableFormat} format
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    addModifiedTableProperties(format, property, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            let previousTableFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            if (isNullOrUndefined(property)) {
                value = previousTableFormat;
                if (this.currentPropertyIndex < this.modifiedProperties.length) {
                    this.modifiedProperties[this.currentPropertyIndex] = format.cloneFormat();
                }
                else {
                    this.modifiedProperties[this.modifiedProperties.length - 1] = format.cloneFormat();
                }
                this.currentPropertyIndex++;
                return value;
            }
            if (property === 'shading') {
                value = previousTableFormat.shading;
            }
            else {
                value = previousTableFormat.getPropertyValue(property);
            }
            previousTableFormat.copyFormat(format);
            this.currentPropertyIndex++;
        }
        else {
            let currentFormat = new WTableFormat();
            currentFormat.copyFormat(format);
            this.modifiedProperties.push(currentFormat);
        }
        return value;
    }
    /**
     * Add modified properties for row format
     * @param  {WRowFormat} rowFormat
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    addModifiedRowProperties(rowFormat, property, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            let previousFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            if (isNullOrUndefined(property)) {
                value = previousFormat;
                if (this.currentPropertyIndex < this.modifiedProperties.length) {
                    this.modifiedProperties[this.currentPropertyIndex] = rowFormat.cloneFormat();
                }
                else {
                    this.modifiedProperties[this.modifiedProperties.length - 1] = rowFormat.cloneFormat();
                }
                this.currentPropertyIndex++;
                return value;
            }
            value = previousFormat.getPropertyValue(property);
            previousFormat.copyFormat(rowFormat);
            this.currentPropertyIndex++;
        }
        else {
            let currentFormat = new WRowFormat();
            currentFormat.copyFormat(rowFormat);
            this.modifiedProperties.push(currentFormat);
        }
        return value;
    }
    /**
     * Add modified properties for cell format
     * @param  {WCellFormat} cellFormat
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    addModifiedCellProperties(cellFormat, property, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            let previousFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            if (isNullOrUndefined(property)) {
                value = previousFormat;
                if (this.currentPropertyIndex < this.modifiedProperties.length) {
                    this.modifiedProperties[this.currentPropertyIndex] = cellFormat.cloneFormat();
                }
                else {
                    this.modifiedProperties[this.modifiedProperties.length - 1] = cellFormat.cloneFormat();
                }
                this.currentPropertyIndex++;
                return value;
            }
            if (property === 'shading') {
                value = previousFormat.shading;
            }
            else {
                value = previousFormat.getPropertyValue(property);
            }
            previousFormat.copyFormat(cellFormat);
            this.currentPropertyIndex++;
        }
        else {
            let currentFormat = new WCellFormat();
            currentFormat.copyFormat(cellFormat);
            this.modifiedProperties.push(currentFormat);
        }
        return value;
    }
    /**
     * @private
     */
    destroy() {
        this.selectionStart = undefined;
        this.selectionEnd = undefined;
        this.insertPosition = undefined;
        this.endPosition = undefined;
        if (!isNullOrUndefined(this.modifiedNodeLength)) {
            this.modifiedNodeLength = [];
            this.modifiedNodeLength = undefined;
        }
        if (!isNullOrUndefined(this.modifiedProperties)) {
            for (let i = 0; i < this.modifiedProperties.length; i++) {
                let property = this.modifiedProperties[i];
                if (property instanceof WCharacterFormat) {
                    property.destroy();
                }
                else if (property instanceof WParagraphFormat) {
                    property.destroy();
                }
                else if (property instanceof WSectionFormat) {
                    property.destroy();
                }
                else if (property instanceof ModifiedLevel) {
                    property.destroy();
                }
                this.modifiedProperties.splice(this.modifiedProperties.indexOf(property), 1);
                i--;
            }
            this.modifiedPropertiesIn = undefined;
        }
        if (!isNullOrUndefined(this.removedNodes)) {
            for (let i = 0; i < this.removedNodes.length; i++) {
                let node = this.removedNodes[i];
                if (node instanceof ParagraphWidget) {
                    node.destroyInternal(this.viewer);
                }
                else if (node instanceof ElementBox) {
                    node.destroy();
                }
                this.removedNodes.splice(this.removedNodes.indexOf(node), 1);
                i--;
            }
            this.removedNodesIn = undefined;
        }
        this.ownerIn = undefined;
    }
}

/**
 * Image resizer implementation.
 */
class ImageResizer {
    /**
     * Constructor for image resizer module.
     * @param {DocumentEditor} node
     * @param {LayoutViewer} viewer
     * @private
     */
    constructor(node, viewer) {
        /**
         * @private
         */
        this.resizeContainerDiv = undefined;
        /**
         * @private
         */
        this.topLeftRect = undefined;
        /**
         * @private
         */
        this.topMiddleRect = undefined;
        /**
         * @private
         */
        this.topRightRect = undefined;
        /**
         * @private
         */
        this.bottomLeftRect = undefined;
        /**
         * @private
         */
        this.bottomMiddleRect = undefined;
        /**
         * @private
         */
        this.bottomRightRect = undefined;
        /**
         * @private
         */
        this.leftMiddleRect = undefined;
        /**
         * @private
         */
        this.rightMiddleRect = undefined;
        /**
         * @private
         */
        this.topLeftRectParent = undefined;
        /**
         * @private
         */
        this.topMiddleRectParent = undefined;
        /**
         * @private
         */
        this.topRightRectParent = undefined;
        /**
         * @private
         */
        this.bottomLeftRectParent = undefined;
        /**
         * @private
         */
        this.bottomMiddleRectParent = undefined;
        /**
         * @private
         */
        this.bottomRightRectParent = undefined;
        /**
         * @private
         */
        this.leftMiddleRectParent = undefined;
        /**
         * @private
         */
        this.rightMiddleRectParent = undefined;
        /**
         * @private
         */
        this.resizeMarkSizeIn = 7;
        /**
         * @private
         */
        this.selectedImageWidget = undefined;
        /**
         * @private
         */
        this.baseHistoryInfo = undefined;
        /**
         * @private
         */
        this.isImageResizing = false;
        /**
         * @private
         */
        this.isImageResizerVisible = false;
        /**
         * @private
         */
        this.isImageMoveToNextPage = false;
        /**
         * @private
         */
        this.selectedResizeElement = undefined;
        /**
         * @private
         */
        this.topValue = undefined;
        /**
         * @private
         */
        this.leftValue = undefined;
        this.owner = node;
        this.selectedImageWidget = new Dictionary();
        this.viewer = viewer;
        this.imageResizerPoints = new ImageResizingPoints();
        if (isNullOrUndefined(this.imageResizerDiv) && this.viewer && this.viewer.pageContainer) {
            this.initializeImageResizer();
        }
    }
    /**
     * Gets or Sets the current image element box.
     * @private
     */
    get currentImageElementBox() {
        return this.currentImageElementBoxIn;
    }
    /**
     * @private
     */
    set currentImageElementBox(value) {
        this.currentImageElementBoxIn = value;
    }
    /**
     * Gets or Sets the resize mark size.
     * @private
     */
    get resizeMarkSize() {
        return this.resizeMarkSizeIn;
    }
    /**
     * @private
     */
    set resizeMarkSize(value) {
        this.resizeMarkSizeIn = value;
    }
    /**
     * Gets module name.
     */
    getModuleName() {
        return 'ImageResizer';
    }
    //Image Resizing Methods
    /**
     * Sets image resizer position.
     * @param {number} x - Specifies for image resizer left value.
     * @param {number} y - Specifies for image resizer top value.
     * @param {number} width - Specifies for image resizer width value.
     * @param {number} height - Specifies for image resizer height value.
     * @private
     */
    setImageResizerPositions(x, y, width, height) {
        this.imageResizerDivElement.style.top = y.toString() + 'px';
        this.imageResizerDivElement.style.left = x.toString() + 'px';
        this.imageResizerDivElement.style.borderWidth = '0px';
        this.imageResizerDivElement.style.height = height + 'px';
        this.imageResizerDivElement.style.width = width + 'px';
        this.imageResizerDivElement.style.backgroundColor = 'transparent';
        this.imageResizerDivElement.style.overflow = 'hidden';
        this.imageResizerDivElement.style.position = 'absolute';
    }
    /**
     * Creates image resizer DOM element.
     * @private
     */
    initializeImageResizer() {
        this.imageResizerDivElement = document.createElement('div');
        this.imageResizerDivElement.style.zIndex = '1';
        this.imageResizerDivElement.style.display = 'none';
        this.viewer.pageContainer.appendChild(this.imageResizerDivElement);
    }
    /**
     * Position an image resizer
     * @param {ImageElementBox} elementBox - Specifies the image position.
     * @private
     */
    positionImageResizer(elementBox) {
        this.selectedImageWidget.clear();
        // Initializes the image resizer on demand, i.e at the time of selecting an image for the first time.
        let resizeDiv;
        if (!isNullOrUndefined(this.viewer.currentPage)) {
            resizeDiv = this.imageResizerDivElement;
        }
        if (!isNullOrUndefined(resizeDiv) && !resizeDiv.contains(this.imageResizerDiv)) {
            this.imageResizerDiv = this.initResizeMarks(resizeDiv, this);
        }
        this.imageResizerDiv.style.width = (elementBox.width) + 'px';
        this.imageResizerDiv.style.height = (elementBox.height) + 'px';
        this.currentImageElementBox = elementBox;
        let lineWidget = elementBox.line;
        let top = this.viewer.selection.getTop(lineWidget) + elementBox.margin.top;
        let left = this.viewer.selection.getLeftInternal(lineWidget, elementBox, 0);
        let page = this.viewer.selection.getPage(lineWidget.paragraph);
        this.currentPage = page;
        let x = 0;
        let y = 0;
        if (!isNullOrUndefined(resizeDiv)) {
            this.imageResizerDivElement.style.display = 'block';
            resizeDiv.style.width = page.boundingRectangle.width + 'px';
            resizeDiv.style.height = page.boundingRectangle.height + 'px';
            resizeDiv.style.left = page.boundingRectangle.x + 'px';
            resizeDiv.style.top = page.boundingRectangle.y + 'px';
            resizeDiv.style.borderWidth = '0px';
            resizeDiv.style.backgroundColor = 'transparent';
            resizeDiv.style.overflow = 'hidden';
            resizeDiv.style.position = 'absolute';
        }
        let horizontalWidth = 0;
        let pageWidth = this.viewer.getPageWidth(page);
        let pagelayout = this.viewer;
        // tslint:disable-next-line:max-line-length
        horizontalWidth = parseFloat(this.imageResizerDivElement.style.width);
        x = (this.viewer.visibleBounds.width - horizontalWidth * this.viewer.zoomFactor) / 2;
        if (x < 30) {
            x = 30;
        }
        if (pageWidth < horizontalWidth) {
            x += (horizontalWidth - pageWidth) * this.viewer.zoomFactor / 2;
        }
        // tslint:disable-next-line:max-line-length           
        y = page.boundingRectangle.y * this.viewer.zoomFactor + (this.viewer.pages.indexOf(page) + 1) * 20 * (1 - this.viewer.zoomFactor);
        let currentPageDiv = this.imageResizerDivElement;
        let currentPageDivWidth = parseFloat(currentPageDiv.style.width);
        let currentPageDivHeight = parseFloat(currentPageDiv.style.height);
        let imageResizerDivWidth = parseFloat(this.imageResizerDiv.style.width);
        let imageResizerDivHeight = parseFloat(this.imageResizerDiv.style.height);
        let margin = (this.resizeMarkSize - 1) / 2;
        let width = imageResizerDivWidth + 2 * margin;
        let height = imageResizerDivHeight + 2 * margin;
        if (width > (currentPageDivWidth - left) * this.viewer.zoomFactor + margin) {
            width = (currentPageDivWidth - left) * this.viewer.zoomFactor;
        }
        if (height > (currentPageDivHeight - top) * this.viewer.zoomFactor + margin) {
            height = (currentPageDivHeight - top) * this.viewer.zoomFactor;
        }
        // if (width < imageResizerDivHeight + margin || height < imageResizerDivHeight + margin) {
        // }
        // tslint:disable-next-line:max-line-length
        this.imageResizerDivElement.style.width = parseInt(this.imageResizerDivElement.style.width.replace('px', ''), 10) * this.viewer.zoomFactor + 'px';
        this.imageResizerDivElement.style.height = parseInt(this.imageResizerDivElement.style.height.replace('px', ''), 10) * this.viewer.zoomFactor + 'px';
        height = this.viewer.render.getScaledValue(elementBox.height);
        width = this.viewer.render.getScaledValue(elementBox.width);
        left = this.viewer.render.getScaledValue(left);
        top = this.viewer.render.getScaledValue(top);
        this.setImageResizerPosition(left, top, width, height, this);
        if (!this.selectedImageWidget.containsKey(lineWidget)) {
            let selectedImageInfo = new SelectedImageInfo(elementBox.height, elementBox.width);
            this.selectedImageWidget.add(lineWidget, selectedImageInfo);
        }
    }
    /**
     * Shows the image resizer.
     * @private
     */
    showImageResizer() {
        if (!isNullOrUndefined(this.imageResizerDivElement)) {
            this.imageResizerDivElement.style.display = '';
        }
        if (!isNullOrUndefined(this.resizeContainerDiv)) {
            this.resizeContainerDiv.style.display = '';
        }
        if (!isNullOrUndefined(this.bottomLeftRect)) {
            this.bottomLeftRect.style.display = '';
            this.bottomLeftRectParent.style.display = '';
        }
        if (!isNullOrUndefined(this.bottomRightRect)) {
            this.bottomRightRect.style.display = '';
            this.bottomRightRectParent.style.display = '';
        }
        if (!isNullOrUndefined(this.bottomMiddleRect)) {
            this.bottomMiddleRect.style.display = '';
            this.bottomMiddleRectParent.style.display = '';
        }
        if (!isNullOrUndefined(this.rightMiddleRect)) {
            this.rightMiddleRect.style.display = '';
            this.rightMiddleRectParent.style.display = '';
        }
        if (!isNullOrUndefined(this.topRightRect)) {
            this.topRightRect.style.display = '';
            this.topRightRectParent.style.display = '';
        }
        if (!isNullOrUndefined(this.topLeftRect)) {
            this.topLeftRect.style.display = '';
            this.topLeftRectParent.style.display = '';
        }
        if (!isNullOrUndefined(this.leftMiddleRect)) {
            this.leftMiddleRect.style.display = '';
            this.leftMiddleRectParent.style.display = '';
        }
        if (!isNullOrUndefined(this.topMiddleRect)) {
            this.topMiddleRect.style.display = '';
            this.topMiddleRectParent.style.display = '';
        }
        this.isImageResizerVisible = true;
    }
    /**
     * Hides the image resizer.
     * @private
     */
    hideImageResizer() {
        if (!isNullOrUndefined(this.imageResizerDivElement)) {
            this.imageResizerDivElement.style.display = 'none';
        }
        if (!isNullOrUndefined(this.resizeContainerDiv)) {
            this.resizeContainerDiv.style.display = 'none';
        }
        if (!isNullOrUndefined(this.bottomLeftRect)) {
            this.bottomLeftRect.style.display = 'none';
            this.bottomLeftRectParent.style.display = 'none';
        }
        if (!isNullOrUndefined(this.bottomRightRect)) {
            this.bottomRightRect.style.display = 'none';
            this.bottomRightRectParent.style.display = 'none';
        }
        if (!isNullOrUndefined(this.bottomMiddleRect)) {
            this.bottomMiddleRect.style.display = 'none';
            this.bottomMiddleRectParent.style.display = 'none';
        }
        if (!isNullOrUndefined(this.rightMiddleRect)) {
            this.rightMiddleRect.style.display = 'none';
            this.rightMiddleRectParent.style.display = 'none';
        }
        if (!isNullOrUndefined(this.topRightRect)) {
            this.topRightRect.style.display = 'none';
            this.topRightRectParent.style.display = 'none';
        }
        if (!isNullOrUndefined(this.topLeftRect)) {
            this.topLeftRect.style.display = 'none';
            this.topLeftRectParent.style.display = 'none';
        }
        if (!isNullOrUndefined(this.leftMiddleRect)) {
            this.leftMiddleRect.style.display = 'none';
            this.leftMiddleRectParent.style.display = 'none';
        }
        if (!isNullOrUndefined(this.topMiddleRect)) {
            this.topMiddleRect.style.display = 'none';
            this.topMiddleRectParent.style.display = 'none';
        }
        this.isImageResizerVisible = false;
        this.currentPage = undefined;
    }
    /**
     * Initialize the resize marks.
     * @param {HTMLElement} resizeDiv - Specifies to appending resizer container div element.
     * @param {ImageResizer} imageResizer - Specifies to creating div element of each position.
     * @private
     */
    // tslint:disable:max-func-body-length
    initResizeMarks(resizeDiv, imageResizer) {
        this.initResizeContainerDiv(imageResizer);
        resizeDiv.appendChild(imageResizer.resizeContainerDiv);
        imageResizer.topRightRectParent = document.createElement('div');
        imageResizer.topRightRectParent.style.cursor = 'ne-resize';
        imageResizer.topRightRectParent.id = this.viewer.owner.containerId + '_TopRightRectParent';
        this.applyProperties(imageResizer.topRightRectParent);
        imageResizer.topRightRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.topRightRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.topRightRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.topRightRectParent);
        imageResizer.topRightRect = document.createElement('div');
        imageResizer.topRightRect.id = this.viewer.owner.containerId + '_TopRightRect';
        imageResizer.topRightRect.style.cursor = 'ne-resize';
        this.applyProperties(imageResizer.topRightRect);
        resizeDiv.appendChild(imageResizer.topRightRect);
        imageResizer.topLeftRectParent = document.createElement('div');
        imageResizer.topLeftRectParent.style.cursor = 'nw-resize';
        imageResizer.topLeftRectParent.id = this.viewer.owner.containerId + '_TopLeftRectParent';
        this.applyProperties(imageResizer.topLeftRectParent);
        imageResizer.topLeftRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.topLeftRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.topLeftRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.topLeftRectParent);
        imageResizer.topLeftRect = document.createElement('div');
        imageResizer.topLeftRect.id = this.viewer.owner.containerId + '_TopLeftRect';
        imageResizer.topLeftRect.style.cursor = 'nw-resize';
        this.applyProperties(imageResizer.topLeftRect);
        resizeDiv.appendChild(imageResizer.topLeftRect);
        imageResizer.topMiddleRectParent = document.createElement('div');
        imageResizer.topMiddleRectParent.style.cursor = 'n-resize';
        imageResizer.topMiddleRectParent.id = this.viewer.owner.containerId + '_TopMiddleRectParent';
        this.applyProperties(imageResizer.topMiddleRectParent);
        imageResizer.topMiddleRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.topMiddleRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.topMiddleRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.topMiddleRectParent);
        imageResizer.topMiddleRect = document.createElement('div');
        imageResizer.topMiddleRect.id = this.viewer.owner.containerId + '_TopMiddleRect';
        imageResizer.topMiddleRect.style.cursor = 'n-resize';
        this.applyProperties(imageResizer.topMiddleRect);
        resizeDiv.appendChild(imageResizer.topMiddleRect);
        imageResizer.bottomRightRectParent = document.createElement('div');
        imageResizer.bottomRightRectParent.style.cursor = 'se-resize';
        imageResizer.bottomRightRectParent.id = this.viewer.owner.containerId + '_BottomRightRectParent';
        this.applyProperties(imageResizer.bottomRightRectParent);
        imageResizer.bottomRightRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.bottomRightRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.bottomRightRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.bottomRightRectParent);
        imageResizer.bottomRightRect = document.createElement('div');
        imageResizer.bottomRightRect.id = this.viewer.owner.containerId + '_BottomRightRect';
        imageResizer.bottomRightRect.style.cursor = 'se-resize';
        this.applyProperties(imageResizer.bottomRightRect);
        resizeDiv.appendChild(imageResizer.bottomRightRect);
        imageResizer.bottomLeftRectParent = document.createElement('div');
        imageResizer.bottomLeftRectParent.style.cursor = 'sw-resize';
        imageResizer.bottomLeftRectParent.id = this.viewer.owner.containerId + '_BottomLeftRectParent';
        this.applyProperties(imageResizer.bottomLeftRectParent);
        imageResizer.bottomLeftRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.bottomLeftRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.bottomLeftRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.bottomLeftRectParent);
        imageResizer.bottomLeftRect = document.createElement('div');
        imageResizer.bottomLeftRect.id = this.viewer.owner.containerId + '_BottomLeftRect';
        imageResizer.bottomLeftRect.style.cursor = 'sw-resize';
        this.applyProperties(imageResizer.bottomLeftRect);
        resizeDiv.appendChild(imageResizer.bottomLeftRect);
        imageResizer.bottomMiddleRectParent = document.createElement('div');
        imageResizer.bottomMiddleRectParent.style.cursor = 's-resize';
        imageResizer.bottomMiddleRectParent.id = this.viewer.owner.containerId + '_BottomMiddleRectParent';
        this.applyProperties(imageResizer.bottomMiddleRectParent);
        imageResizer.bottomMiddleRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.bottomMiddleRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.bottomMiddleRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.bottomMiddleRectParent);
        imageResizer.bottomMiddleRect = document.createElement('div');
        imageResizer.bottomMiddleRect.id = this.viewer.owner.containerId + '_BottomMiddleRect';
        imageResizer.bottomMiddleRect.style.cursor = 's-resize';
        this.applyProperties(imageResizer.bottomMiddleRect);
        resizeDiv.appendChild(imageResizer.bottomMiddleRect);
        imageResizer.rightMiddleRectParent = document.createElement('div');
        imageResizer.rightMiddleRectParent.style.cursor = 'e-resize';
        imageResizer.rightMiddleRectParent.id = this.viewer.owner.containerId + '_RightMiddleRectParent';
        this.applyProperties(imageResizer.rightMiddleRectParent);
        imageResizer.rightMiddleRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.rightMiddleRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.rightMiddleRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.rightMiddleRectParent);
        imageResizer.rightMiddleRect = document.createElement('div');
        imageResizer.rightMiddleRect.id = this.viewer.owner.containerId + '_RightMiddleRect';
        imageResizer.rightMiddleRect.style.cursor = 'e-resize';
        this.applyProperties(imageResizer.rightMiddleRect);
        resizeDiv.appendChild(imageResizer.rightMiddleRect);
        imageResizer.leftMiddleRectParent = document.createElement('div');
        imageResizer.leftMiddleRectParent.style.cursor = 'w-resize';
        imageResizer.leftMiddleRectParent.id = this.viewer.owner.containerId + '_LeftMiddleRectParent';
        this.applyProperties(imageResizer.leftMiddleRectParent);
        imageResizer.leftMiddleRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.leftMiddleRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.leftMiddleRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.leftMiddleRectParent);
        imageResizer.leftMiddleRect = document.createElement('div');
        imageResizer.leftMiddleRect.id = this.viewer.owner.containerId + '_LeftMiddleRect';
        imageResizer.leftMiddleRect.style.cursor = 'w-resize';
        this.applyProperties(imageResizer.leftMiddleRect);
        resizeDiv.appendChild(imageResizer.leftMiddleRect);
        return imageResizer.resizeContainerDiv;
    }
    /**
     * Sets the image resizer position.
     * @param {number} left - Specifies for image resizer left value.
     * @param {number} top - Specifies for image resizer top value.
     * @param {number} width - Specifies for image resizer width value.
     * @param {number} height - Specifies for image resizer height value.
     * @param {ImageResizer} imageResizer - Specifies for image resizer.
     * @private
     */
    setImageResizerPosition(left, top, width, height, imageResizer) {
        //Positions Updating For Image Resize Div
        imageResizer.resizeContainerDiv.style.width = width + 'px';
        imageResizer.resizeContainerDiv.style.height = height + 'px';
        imageResizer.resizeContainerDiv.style.left = left - 1 + 'px';
        imageResizer.resizeContainerDiv.style.top = top + 'px';
        //Positions Updating For Image Resizing Points
        imageResizer.topRightRect.style.left = ((left + width) - 5) + 'px';
        imageResizer.topRightRect.style.top = (top - 4) + 'px';
        imageResizer.topLeftRect.style.left = (left - 5) + 'px';
        imageResizer.topLeftRect.style.top = (top - 4) + 'px';
        imageResizer.topMiddleRect.style.left = ((parseFloat(imageResizer.topLeftRect.style.left) + (width / 2)) - 4) + 'px';
        imageResizer.topMiddleRect.style.top = (top - 4) + 'px';
        imageResizer.bottomRightRect.style.left = imageResizer.topRightRect.style.left;
        imageResizer.bottomRightRect.style.top = (parseFloat(imageResizer.topRightRect.style.top) + height) + 'px';
        imageResizer.bottomLeftRect.style.left = imageResizer.topLeftRect.style.left;
        imageResizer.bottomLeftRect.style.top = (parseFloat(imageResizer.topLeftRect.style.top) + height) + 'px';
        imageResizer.bottomMiddleRect.style.left = imageResizer.topMiddleRect.style.left;
        imageResizer.bottomMiddleRect.style.top = (parseFloat(imageResizer.topMiddleRect.style.top) + height) + 'px';
        imageResizer.rightMiddleRect.style.left = ((left + width) - 4) + 'px';
        imageResizer.rightMiddleRect.style.top = (parseFloat(imageResizer.topRightRect.style.top) + (height / 2)) + 'px';
        imageResizer.leftMiddleRect.style.left = imageResizer.topLeftRect.style.left;
        imageResizer.leftMiddleRect.style.top = (parseFloat(imageResizer.topLeftRect.style.top) + (height / 2)) + 'px';
        imageResizer.topRightRectParent.style.left = !this.viewer.isTouchInput ? ((left + width) - 8) + 'px' : ((left + width) - 15) + 'px';
        imageResizer.topRightRectParent.style.top = !this.viewer.isTouchInput ? (top - 7) + 'px' : (top - 15) + 'px';
        imageResizer.topLeftRectParent.style.left = !this.viewer.isTouchInput ? (left - 8) + 'px' : (left - 15) + 'px';
        imageResizer.topLeftRectParent.style.top = !this.viewer.isTouchInput ? (top - 7) + 'px' : (top - 15) + 'px';
        imageResizer.topMiddleRectParent.style.left = ((parseFloat(imageResizer.topLeftRectParent.style.left) + (width / 2)) - 4) + 'px';
        imageResizer.topMiddleRectParent.style.top = !this.viewer.isTouchInput ? (top - 7) + 'px' : (top - 15) + 'px';
        imageResizer.bottomRightRectParent.style.left = imageResizer.topRightRectParent.style.left;
        imageResizer.bottomRightRectParent.style.top = (parseFloat(imageResizer.topRightRectParent.style.top) + height) + 'px';
        imageResizer.bottomLeftRectParent.style.left = imageResizer.topLeftRectParent.style.left;
        imageResizer.bottomLeftRectParent.style.top = (parseFloat(imageResizer.topLeftRectParent.style.top) + height) + 'px';
        imageResizer.bottomMiddleRectParent.style.left = imageResizer.topMiddleRectParent.style.left;
        imageResizer.bottomMiddleRectParent.style.top = (parseFloat(imageResizer.topMiddleRectParent.style.top) + height) + 'px';
        // tslint:disable-next-line:max-line-length 
        imageResizer.rightMiddleRectParent.style.left = !this.viewer.isTouchInput ? ((left + width) - 7) + 'px' : ((left + width) - 15) + 'px';
        imageResizer.rightMiddleRectParent.style.top = (parseFloat(imageResizer.topRightRectParent.style.top) + (height / 2)) + 'px';
        imageResizer.leftMiddleRectParent.style.left = imageResizer.topLeftRectParent.style.left;
        imageResizer.leftMiddleRectParent.style.top = (parseFloat(imageResizer.topLeftRectParent.style.top) + (height / 2)) + 'px';
        this.setImageResizingPoints(imageResizer);
        if (this.viewer.isTouchInput) {
            this.applyPropertiesForTouch();
        }
        else {
            this.applyPropertiesForMouse();
        }
    }
    /**
     * Sets the image resizing points.
     * @param {ImageResizer} imageResizer - Specifies for position of each resizing elements.
     * @private
     */
    setImageResizingPoints(imageResizer) {
        this.imageResizerPoints.resizeContainerDiv.x = parseFloat(imageResizer.resizeContainerDiv.style.left);
        this.imageResizerPoints.resizeContainerDiv.y = parseFloat(imageResizer.resizeContainerDiv.style.top);
        this.imageResizerPoints.bottomLeftRectParent.x = parseFloat(imageResizer.bottomLeftRectParent.style.left);
        this.imageResizerPoints.bottomLeftRectParent.y = parseFloat(imageResizer.bottomLeftRectParent.style.top);
        this.imageResizerPoints.bottomRightRectParent.x = parseFloat(imageResizer.bottomRightRectParent.style.left);
        this.imageResizerPoints.bottomRightRectParent.y = parseFloat(imageResizer.bottomRightRectParent.style.top);
        this.imageResizerPoints.bottomMiddleRectParent.x = parseFloat(imageResizer.bottomMiddleRectParent.style.left);
        this.imageResizerPoints.bottomMiddleRectParent.y = parseFloat(imageResizer.bottomMiddleRectParent.style.top);
        this.imageResizerPoints.topLeftRectParent.x = parseFloat(imageResizer.topLeftRectParent.style.left);
        this.imageResizerPoints.topLeftRectParent.y = parseFloat(imageResizer.topLeftRectParent.style.top);
        this.imageResizerPoints.topRightRectParent.x = parseFloat(imageResizer.topRightRectParent.style.left);
        this.imageResizerPoints.topRightRectParent.y = parseFloat(imageResizer.topRightRectParent.style.top);
        this.imageResizerPoints.topMiddleRectParent.x = parseFloat(imageResizer.topMiddleRectParent.style.left);
        this.imageResizerPoints.topMiddleRectParent.y = parseFloat(imageResizer.topMiddleRectParent.style.top);
        this.imageResizerPoints.leftMiddleRectParent.x = parseFloat(imageResizer.leftMiddleRectParent.style.left);
        this.imageResizerPoints.leftMiddleRectParent.y = parseFloat(imageResizer.leftMiddleRectParent.style.top);
        this.imageResizerPoints.rightMiddleRectParent.x = parseFloat(imageResizer.rightMiddleRectParent.style.left);
        this.imageResizerPoints.rightMiddleRectParent.y = parseFloat(imageResizer.rightMiddleRectParent.style.top);
    }
    /**
     * Initialize the resize container div element.
     * @param {ImageResizer} imageResizer - Specifies for creating resize container div element.
     * @private
     */
    initResizeContainerDiv(imageResizer) {
        imageResizer.resizeContainerDiv = document.createElement('div');
        imageResizer.resizeContainerDiv.id = this.viewer.owner.containerId + '_ResizeDivElement';
        imageResizer.resizeContainerDiv.style.position = 'absolute';
        imageResizer.resizeContainerDiv.style.border = '1px solid #bfbfbf';
        imageResizer.resizeContainerDiv.style.zIndex = '30';
        imageResizer.resizeContainerDiv.style.backgroundColor = 'transparent';
        imageResizer.resizeContainerDiv.style.display = 'block';
    }
    /**
     * Apply the properties of each resize rectangle element.
     * @param {HTMLDivElement} resizeRectElement - Specifies for applying properties to resize rectangle element.
     * @private
     */
    applyProperties(resizeRectElement) {
        resizeRectElement.style.position = 'absolute';
        resizeRectElement.style.width = '8px';
        resizeRectElement.style.height = '8px';
        resizeRectElement.style.fontSize = '0px';
        resizeRectElement.style.zIndex = ' 551';
        resizeRectElement.style.backgroundColor = '#ffffff';
        resizeRectElement.style.border = '1px solid #bfbfbf';
        resizeRectElement.style.boxShadow = '0 1px 2px 0 #bfbfbf 0.35';
        resizeRectElement.style.color = '#000000';
    }
    /**
     * Handles an image resizing.
     * @param {number} x  - Specifies for left value while resizing.
     * @param {number} y - Specifies for top value while resizing.
     */
    handleImageResizing(touchPoint, prevX, prevY) {
        prevX = prevX / this.viewer.zoomFactor;
        prevY = prevY / this.viewer.zoomFactor;
        this.leftValue = isNullOrUndefined(this.leftValue) ? prevX : this.leftValue;
        this.topValue = isNullOrUndefined(this.topValue) ? prevY : this.topValue;
        let points;
        switch (this.selectedResizeElement.id.split('_')[1]) {
            case 'TopRightRectParent':
                points = this.topRightResizing(touchPoint);
                prevX = points.left;
                prevY = points.top;
                break;
            case 'TopLeftRectParent':
                points = this.topLeftResizing(touchPoint);
                prevX = -points.left;
                prevY = -points.top;
                break;
            case 'TopMiddleRectParent':
                prevX = 0;
                prevY = this.topMiddleResizing(touchPoint);
                break;
            case 'BottomRightRectParent':
                points = this.bottomRightResizing(touchPoint);
                prevX = points.left;
                prevY = points.top;
                break;
            case 'BottomLeftRectParent':
                points = this.bottomLeftResizing(touchPoint);
                prevX = -points.left;
                prevY = -points.top;
                break;
            case 'BottomMiddleRectParent':
                prevY = touchPoint.y - prevY;
                prevX = 0;
                break;
            case 'RightMiddleRectParent':
                prevX = touchPoint.x - prevX;
                prevY = 0;
                break;
            case 'LeftMiddleRectParent':
                prevX = this.leftMiddleResizing(touchPoint);
                prevY = 0;
                break;
            default:
                break;
        }
        if (prevX !== 0 || prevY !== 0) {
            let widget = this.currentImageElementBox.line.paragraph;
            let image = this.currentImageElementBox;
            if (!isNullOrUndefined(widget) && widget.isInsideTable) {
                let cellWidget = widget.containerWidget;
                if (!isNullOrUndefined(cellWidget)) {
                    let rowWidget = cellWidget.containerWidget;
                    let imageHeight = HelperMethods.convertPointToPixel(image.height);
                    let widgetHeight = rowWidget.height - imageHeight;
                    if (prevY > 0 && rowWidget.y + widgetHeight + imageHeight + prevY > this.viewer.clientArea.bottom) {
                        this.isImageMoveToNextPage = true;
                    }
                }
            }
            // tslint:disable-next-line:max-line-length 
            if (this.owner.enableHistoryMode) {
                this.initHistoryForImageResizer(this.currentImageElementBox);
            }
            if (!isNullOrUndefined(this.currentImageElementBox)) {
                // tslint:disable-next-line:max-line-length   
                let width = this.currentImageElementBox.width + prevX > 10 ? this.currentImageElementBox.width + prevX : 10;
                // tslint:disable-next-line:max-line-length 
                let height = this.currentImageElementBox.height + prevY > 10 ? this.currentImageElementBox.height + prevY : 10;
                if (this.selectedResizeElement.id.split('_')[1] === 'BottomRightRectParent'
                    || this.selectedResizeElement.id.split('_')[1] === 'TopRightRectParent'
                    || this.selectedResizeElement.id.split('_')[1] === 'BottomLeftRectParent'
                    || this.selectedResizeElement.id.split('_')[1] === 'TopLeftRectParent') {
                    height = this.currentImageElementBox.height / this.currentImageElementBox.width * width;
                    width = this.currentImageElementBox.width / this.currentImageElementBox.height * height;
                }
                this.currentImageElementBox.width = width;
                this.currentImageElementBox.height = height;
                let owner = this.currentImageElementBox.line.paragraph;
                this.positionImageResizer(this.currentImageElementBox);
            }
            this.isImageResizing = true;
        }
    }
    /**
     * Handles image resizing on mouse.
     * @param {MouseEvent} event - Specifies for image resizing using mouse event.
     * @private
     */
    handleImageResizingOnMouse(event) {
        if (!isNullOrUndefined(this.selectedResizeElement)) {
            let prevX = parseFloat(this.selectedResizeElement.style.left);
            let prevY = parseFloat(this.selectedResizeElement.style.top);
            let cursorPoint = new Point(event.offsetX, event.offsetY);
            let touchPoint = this.viewer.findFocusedPage(cursorPoint, true);
            this.handleImageResizing(touchPoint, prevX, prevY);
        }
    }
    topMiddleResizing(touchPoint) {
        let prevY;
        if (this.topValue >= touchPoint.y) {
            prevY = this.topValue / touchPoint.y;
            this.topValue = touchPoint.y;
            if (this.viewer instanceof PageLayoutViewer) {
                if (this.topValue <= this.viewer.pageGap) {
                    prevY = 1;
                }
            }
        }
        else {
            prevY = -(touchPoint.y / this.topValue);
            this.topValue = touchPoint.y;
            if (this.topValue === 0) {
                prevY = -1;
            }
        }
        return prevY;
    }
    leftMiddleResizing(touchPoint) {
        let prevX;
        if (this.leftValue >= touchPoint.x) {
            prevX = this.leftValue / touchPoint.x;
            this.leftValue = touchPoint.x;
            if (this.leftValue === 0) {
                prevX = 1;
                this.leftValue = parseFloat(this.selectedResizeElement.style.left);
            }
        }
        else {
            prevX = -(touchPoint.x / this.leftValue);
            this.leftValue = touchPoint.x;
        }
        return prevX;
    }
    topRightResizing(touchPoint) {
        let points;
        if (this.leftValue <= touchPoint.x && this.topValue >= touchPoint.y) {
            points = this.getOuterResizingPoint(touchPoint);
        }
        else {
            points = this.getInnerResizingPoint(touchPoint);
        }
        return points;
    }
    topLeftResizing(touchPoint) {
        let points;
        if (this.leftValue >= touchPoint.x && this.topValue >= touchPoint.y) {
            points = this.getOuterResizingPoint(touchPoint);
        }
        else {
            points = this.getInnerResizingPoint(touchPoint);
        }
        return points;
    }
    bottomRightResizing(touchPoint) {
        let points;
        if (this.leftValue <= touchPoint.x && this.topValue <= touchPoint.y) {
            points = this.getOuterResizingPoint(touchPoint);
        }
        else {
            points = this.getInnerResizingPoint(touchPoint);
        }
        return points;
    }
    bottomLeftResizing(touchPoint) {
        let points;
        if (this.leftValue >= touchPoint.x && this.topValue <= touchPoint.y) {
            points = this.getOuterResizingPoint(touchPoint);
        }
        else {
            points = this.getInnerResizingPoint(touchPoint);
        }
        return points;
    }
    getOuterResizingPoint(touchPoint) {
        let prevX;
        let prevY;
        prevX = touchPoint.x - this.leftValue;
        this.leftValue = touchPoint.x;
        prevY = touchPoint.y - this.topValue;
        this.topValue = touchPoint.y;
        return { left: prevX, top: prevY };
    }
    getInnerResizingPoint(touchPoint) {
        let prevX;
        let prevY;
        prevX = -(this.leftValue - touchPoint.x);
        this.leftValue = touchPoint.x;
        prevY = -(this.topValue - touchPoint.y);
        this.topValue = touchPoint.y;
        return { left: prevX, top: prevY };
    }
    /**
     * Handles image resizing on touch.
     * @param {TouchEvent} touchEvent - Specifies for image resizing using touch event.
     * @private
     */
    handleImageResizingOnTouch(touchEvent) {
        if (!isNullOrUndefined(this.selectedResizeElement)) {
            let prevX = parseFloat(this.selectedResizeElement.style.left) + 24;
            let prevY = parseFloat(this.selectedResizeElement.style.top) + 24;
            let touch = touchEvent.touches;
            let cursorPoint = new Point(touch[0].clientX, touch[0].clientY);
            let touchPoint = this.viewer.findFocusedPage(cursorPoint, true);
            if (isNullOrUndefined(this.currentImageElementBox) || isNullOrUndefined(this.currentImageElementBox)) {
                return;
            }
            this.handleImageResizing(touchPoint, prevX, prevY);
        }
    }
    /**
     * Gets the image point of mouse.
     * @param {Point} touchPoint - Specifies for resizer cursor position.
     * @private
     */
    getImagePoint(touchPoint) {
        let x = this.viewer.render.getScaledValue(touchPoint.x, 1);
        let y = this.viewer.render.getScaledValue(touchPoint.y, 2);
        touchPoint = new Point(x, y);
        let imageResizingPoints = this.imageResizerPoints;
        let resizePosition = '';
        let selectedElement = undefined;
        let bottomMiddle = imageResizingPoints.bottomMiddleRectParent;
        let bottomRight = imageResizingPoints.bottomRightRectParent;
        let bottomLeft = imageResizingPoints.bottomLeftRectParent;
        let topMiddle = imageResizingPoints.topMiddleRectParent;
        let topRight = imageResizingPoints.topRightRectParent;
        let topLeft = imageResizingPoints.topLeftRectParent;
        let rightMiddle = imageResizingPoints.rightMiddleRectParent;
        let leftMiddle = imageResizingPoints.leftMiddleRectParent;
        if (!isNullOrUndefined(this.bottomMiddleRectParent) && this.bottomMiddleRectParent.style.display !== 'none') {
            // tslint:disable-next-line:max-line-length   
            if ((touchPoint.x > bottomMiddle.x && touchPoint.x <= bottomMiddle.x + 15) && (touchPoint.y > bottomMiddle.y && touchPoint.y <= bottomMiddle.y + 15)) {
                selectedElement = this.bottomMiddleRectParent;
                resizePosition = 's-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoint.x > bottomRight.x && touchPoint.x <= bottomRight.x + 15) && (touchPoint.y > bottomRight.y && touchPoint.y <= bottomRight.y + 15)) {
                selectedElement = this.bottomRightRectParent;
                resizePosition = 'se-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoint.x > bottomLeft.x && touchPoint.x <= bottomLeft.x + 15) && (touchPoint.y > bottomLeft.y && touchPoint.y <= bottomLeft.y + 15)) {
                selectedElement = this.bottomLeftRectParent;
                resizePosition = 'sw-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoint.x > topMiddle.x && touchPoint.x <= topMiddle.x + 15) && (touchPoint.y > topMiddle.y && touchPoint.y <= topMiddle.y + 15)) {
                selectedElement = this.topMiddleRectParent;
                resizePosition = 'n-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoint.x > topRight.x && touchPoint.x <= topRight.x + 15) && (touchPoint.y > topRight.y && touchPoint.y <= topRight.y + 15)) {
                selectedElement = this.topRightRectParent;
                resizePosition = 'ne-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoint.x > topLeft.x && touchPoint.x <= topLeft.x + 15) && (touchPoint.y > topLeft.y && touchPoint.y <= topLeft.y + 15)) {
                selectedElement = this.topLeftRectParent;
                resizePosition = 'nw-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoint.x > leftMiddle.x && touchPoint.x <= leftMiddle.x + 15) && (touchPoint.y > leftMiddle.y && touchPoint.y <= leftMiddle.y + 15)) {
                selectedElement = this.leftMiddleRectParent;
                resizePosition = 'w-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoint.x > rightMiddle.x && touchPoint.x <= rightMiddle.x + 15) && (touchPoint.y > rightMiddle.y && touchPoint.y <= rightMiddle.y + 15)) {
                selectedElement = this.rightMiddleRectParent;
                resizePosition = 'e-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if (!isNullOrUndefined(this.resizeContainerDiv) && (touchPoint.x > parseFloat(this.resizeContainerDiv.style.left)
                && touchPoint.x <= (parseFloat(this.resizeContainerDiv.style.left) + parseFloat(this.resizeContainerDiv.style.width)))
                && (touchPoint.y > parseFloat(this.resizeContainerDiv.style.top)
                    // tslint:disable-next-line:max-line-length 
                    && touchPoint.y <= (parseFloat(this.resizeContainerDiv.style.top) + parseFloat(this.resizeContainerDiv.style.height)))) {
                resizePosition = 'move';
            }
        }
        return { 'selectedElement': selectedElement, 'resizePosition': resizePosition };
    }
    applyPropertiesForMouse() {
        if (!isNullOrUndefined(this.bottomLeftRectParent)) {
            this.bottomMiddleRectParent.style.width = '14px';
            this.bottomMiddleRectParent.style.height = '14px';
            this.bottomRightRectParent.style.width = '14px';
            this.bottomRightRectParent.style.height = '14px';
            this.bottomLeftRectParent.style.width = '14px';
            this.bottomLeftRectParent.style.height = '14px';
            this.topMiddleRectParent.style.width = '14px';
            this.topMiddleRectParent.style.height = '14px';
            this.topRightRectParent.style.width = '14px';
            this.topRightRectParent.style.height = '14px';
            this.topLeftRectParent.style.width = '14px';
            this.topLeftRectParent.style.height = '14px';
            this.leftMiddleRectParent.style.width = '14px';
            this.leftMiddleRectParent.style.height = '14px';
            this.rightMiddleRectParent.style.width = '14px';
            this.rightMiddleRectParent.style.height = '14px';
        }
    }
    /**
     * Gets the image point of touch.
     * @param {Point} touchPoints - Specifies for resizer cursor position.
     * @private
     */
    getImagePointOnTouch(touchPoints) {
        let x = this.viewer.render.getScaledValue(touchPoints.x, 1);
        let y = this.viewer.render.getScaledValue(touchPoints.y, 2);
        touchPoints = new Point(x, y);
        let imageResizingPointsOnTouch = this.imageResizerPoints;
        let resizePosition = '';
        let selectedElements = undefined;
        let bottomMiddle = imageResizingPointsOnTouch.bottomMiddleRectParent;
        let bottomRight = imageResizingPointsOnTouch.bottomRightRectParent;
        let bottomLeft = imageResizingPointsOnTouch.bottomLeftRectParent;
        let topMiddle = imageResizingPointsOnTouch.topMiddleRectParent;
        let topRight = imageResizingPointsOnTouch.topRightRectParent;
        let topLeft = imageResizingPointsOnTouch.topLeftRectParent;
        let rightMiddle = imageResizingPointsOnTouch.rightMiddleRectParent;
        let leftMiddle = imageResizingPointsOnTouch.leftMiddleRectParent;
        if (!isNullOrUndefined(this.bottomMiddleRectParent) && this.bottomMiddleRectParent.style.display !== 'none') {
            // tslint:disable-next-line:max-line-length   
            if ((touchPoints.x > bottomMiddle.x && touchPoints.x <= bottomMiddle.x + 25) && (touchPoints.y > bottomMiddle.y && touchPoints.y <= bottomMiddle.y + 25)) {
                selectedElements = this.bottomMiddleRectParent;
                resizePosition = 's-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoints.x > bottomRight.x && touchPoints.x <= bottomRight.x + 25) && (touchPoints.y > bottomRight.y && touchPoints.y <= bottomRight.y + 25)) {
                selectedElements = this.bottomRightRectParent;
                resizePosition = 'se-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoints.x > bottomLeft.x && touchPoints.x <= bottomLeft.x + 25) && (touchPoints.y > bottomLeft.y && touchPoints.y <= bottomLeft.y + 25)) {
                selectedElements = this.bottomLeftRectParent;
                resizePosition = 'sw-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoints.x > topMiddle.x && touchPoints.x <= topMiddle.x + 25) && (touchPoints.y > topMiddle.y && touchPoints.y <= topMiddle.y + 25)) {
                selectedElements = this.topMiddleRectParent;
                resizePosition = 'n-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoints.x > topRight.x && touchPoints.x <= topRight.x + 25) && (touchPoints.y > topRight.y && touchPoints.y <= topRight.y + 25)) {
                selectedElements = this.topRightRectParent;
                resizePosition = 'ne-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoints.x > topLeft.x && touchPoints.x <= topLeft.x + 25) && (touchPoints.y > topLeft.y && touchPoints.y <= topLeft.y + 25)) {
                selectedElements = this.topLeftRectParent;
                resizePosition = 'nw-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoints.x > leftMiddle.x && touchPoints.x <= leftMiddle.x + 25) && (touchPoints.y > leftMiddle.y && touchPoints.y <= leftMiddle.y + 25)) {
                selectedElements = this.leftMiddleRectParent;
                resizePosition = 'w-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoints.x > rightMiddle.x && touchPoints.x <= rightMiddle.x + 25) && (touchPoints.y > rightMiddle.y && touchPoints.y <= rightMiddle.y + 25)) {
                selectedElements = this.rightMiddleRectParent;
                resizePosition = 'e-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if (!isNullOrUndefined(this.resizeContainerDiv) && (touchPoints.x > parseFloat(this.resizeContainerDiv.style.left)
                && touchPoints.x <= (parseFloat(this.resizeContainerDiv.style.left) + parseFloat(this.resizeContainerDiv.style.width)))
                && (touchPoints.y > parseFloat(this.resizeContainerDiv.style.top)
                    // tslint:disable-next-line:max-line-length 
                    && touchPoints.y <= (parseFloat(this.resizeContainerDiv.style.top) + parseFloat(this.resizeContainerDiv.style.height)))) {
                resizePosition = 'move';
            }
        }
        return { 'selectedElement': selectedElements, 'resizePosition': resizePosition };
    }
    applyPropertiesForTouch() {
        if (!isNullOrUndefined(this.bottomLeftRectParent)) {
            this.bottomMiddleRectParent.style.width = '30px';
            this.bottomMiddleRectParent.style.height = '30px';
            this.bottomRightRectParent.style.width = '30px';
            this.bottomRightRectParent.style.height = '30px';
            this.bottomLeftRectParent.style.width = '30px';
            this.bottomLeftRectParent.style.height = '30px';
            this.topMiddleRectParent.style.width = '30px';
            this.topMiddleRectParent.style.height = '30px';
            this.topRightRectParent.style.width = '30px';
            this.topRightRectParent.style.height = '30px';
            this.topLeftRectParent.style.width = '30px';
            this.topLeftRectParent.style.height = '30px';
            this.leftMiddleRectParent.style.width = '30px';
            this.leftMiddleRectParent.style.height = '30px';
            this.rightMiddleRectParent.style.width = '30px';
            this.rightMiddleRectParent.style.height = '30px';
        }
    }
    /**
     * @private
     */
    mouseUpInternal() {
        this.currentImageElementBox.width = parseFloat(this.imageResizerDiv.style.width) / this.viewer.zoomFactor;
        this.currentImageElementBox.height = parseFloat(this.imageResizerDiv.style.height) / this.viewer.zoomFactor;
        this.owner.isShiftingEnabled = true;
        this.owner.editorModule.setOffsetValue(this.owner.selection);
        this.viewer.layout.reLayoutParagraph(this.currentImageElementBox.line.paragraph, 0, 0);
        this.owner.editorModule.reLayout(this.owner.selection, true);
        this.viewer.updateScrollBars();
    }
    /**
     * Initialize history for image resizer.
     * @param {ImageResizer} imageResizer - Specifies for image resizer.
     * @param {WImage} imageContainer - Specifies for an image.
     * @private
     */
    initHistoryForImageResizer(imageContainer) {
        if (!isNullOrUndefined(this.owner) && isNullOrUndefined(this.baseHistoryInfo)) {
            this.baseHistoryInfo = new BaseHistoryInfo(this.owner);
            this.baseHistoryInfo.action = 'ImageResizing';
            this.baseHistoryInfo.updateSelection();
            this.baseHistoryInfo.modifiedProperties.push(new ImageFormat(imageContainer));
        }
    }
    /**
     * Updates histroy for image resizer.
     * @private
     */
    updateHistoryForImageResizer() {
        if (!isNullOrUndefined(this.owner) && !isNullOrUndefined(this.baseHistoryInfo)) {
            let imageFormat = this.baseHistoryInfo.modifiedProperties[0];
            if (this.currentImageElementBox.width === imageFormat.width
                && this.currentImageElementBox.height === imageFormat.height) {
                this.baseHistoryInfo.modifiedProperties.pop();
            }
            else {
                //Records the image size modifications
                this.owner.editorHistory.recordChanges(this.baseHistoryInfo);
            }
            //Fires the content changed event for the image size modifications
            this.baseHistoryInfo = undefined;
        }
    }
    /**
     * Updates image resize container when applying zooming
     * @private
     */
    updateImageResizerPosition() {
        if (!isNullOrUndefined(this.currentImageElementBox)) {
            let elementBox = this.currentImageElementBox;
            let lineWidget = elementBox.line;
            let top = this.viewer.selection.getTop(lineWidget) + elementBox.margin.top;
            let left = this.viewer.selection.getLeftInternal(lineWidget, elementBox, 0);
            let topValue = top * this.viewer.zoomFactor;
            let leftValue = left * this.viewer.zoomFactor;
            let height = this.viewer.render.getScaledValue(elementBox.height, 2);
            let width = this.viewer.render.getScaledValue(elementBox.width, 1);
            this.setImageResizerPosition(leftValue, topValue, width, height, this);
        }
    }
    /**
     * Dispose the internal objects which are maintained.
     * @private
     */
    destroy() {
        if (!isNullOrUndefined(this.resizeContainerDiv)) {
            this.resizeContainerDiv.innerHTML = '';
        }
        if (!isNullOrUndefined(this.topLeftRect)) {
            this.topLeftRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.topMiddleRect)) {
            this.topMiddleRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.topRightRect)) {
            this.topRightRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.bottomLeftRect)) {
            this.bottomLeftRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.bottomMiddleRect)) {
            this.bottomMiddleRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.bottomRightRect)) {
            this.bottomRightRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.leftMiddleRect)) {
            this.leftMiddleRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.rightMiddleRect)) {
            this.rightMiddleRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.imageResizerDiv)) {
            this.imageResizerDiv.innerHTML = '';
        }
        if (!isNullOrUndefined(this.selectedImageWidget)) {
            this.selectedImageWidget.destroy();
        }
        if (!isNullOrUndefined(this.imageResizerDivElement)) {
            this.imageResizerDivElement.innerHTML = '';
        }
        this.imageResizerDivElement = undefined;
        this.resizeContainerDiv = undefined;
        this.topLeftRect = undefined;
        this.topMiddleRect = undefined;
        this.topRightRect = undefined;
        this.bottomLeftRect = undefined;
        this.bottomMiddleRect = undefined;
        this.bottomRightRect = undefined;
        this.leftMiddleRect = undefined;
        this.rightMiddleRect = undefined;
        this.imageResizerDiv = undefined;
        this.selectedImageWidget = undefined;
        this.isImageResizing = false;
        this.isImageResizerVisible = false;
        this.currentImageElementBoxIn = undefined;
        //this.baseHistoryInfo = undefined;
        this.resizeMarkSizeIn = undefined;
        this.viewer = undefined;
        this.owner = undefined;
    }
}
/**
 * @private
 */
class ImageResizingPoints {
    /**
     * Constructor for image resizing points class.
     */
    constructor() {
        /**
         * @private
         */ this.resizeContainerDiv = new Point(0, 0);
        /**
         * @private
         */
        this.topLeftRectParent = new Point(0, 0);
        /**
         * @private
         */
        this.topMiddleRectParent = new Point(0, 0);
        /**
         * @private
         */
        this.topRightRectParent = new Point(0, 0);
        /**
         * @private
         */
        this.bottomLeftRectParent = new Point(0, 0);
        /**
         * @private
         */
        this.bottomMiddleRectParent = new Point(0, 0);
        /**
         * @private
         */
        this.bottomRightRectParent = new Point(0, 0);
        /**
         * @private
         */
        this.leftMiddleRectParent = new Point(0, 0);
        /**
         * @private
         */
        this.rightMiddleRectParent = new Point(0, 0);
        
    }
}
/**
 * @private
 */
class SelectedImageInfo {
    /**
     * Constructor for selected image info class.
     * @param {number} height - Specifies for height value.
     * @param {number} width - Specifies for width value.
     */
    constructor(height, width) {
        this.heightIn = 0;
        this.widthIn = 0;
        this.heightIn = height;
        this.widthIn = width;
    }
    /**
     * Gets or Sets the height value.
     * @private
     */
    get height() {
        return this.heightIn;
    }
    /**
     * @private
     */
    set height(value) {
        this.heightIn = value;
    }
    /**
     * Gets or Sets the width value.
     * @private
     */
    get width() {
        return this.widthIn;
    }
    /**
     * @private
     */
    set width(value) {
        this.widthIn = value;
    }
}

/**
 * Editor Export
 */

/**
 * EditorHistory preservation class
 */
/**
 * @private
 */
class HistoryInfo extends BaseHistoryInfo {
    constructor(node, isChild) {
        super(node);
        this.isChildHistoryInfo = false;
        this.isChildHistoryInfo = isChild;
    }
    /**
     * @private
     */
    get hasAction() {
        return !isNullOrUndefined(this.modifiedActions);
    }
    /**
     * Adds the modified actions
     * @param  {BaseHistoryInfo} baseHistoryInfo
     * @private
     */
    addModifiedAction(baseHistoryInfo) {
        // For complex actions such as Replace text, Insert/Remove Hyperlink etc.
        if (!(this.editorHistory.isUndoing || this.editorHistory.isRedoing)) {
            if (isNullOrUndefined(this.modifiedActions)) {
                this.modifiedActions = [];
            }
            this.modifiedActions.push(baseHistoryInfo);
        }
    }
    /**
     * Reverts this instance
     * @private
     */
    revert() {
        this.editorHistory.currentHistoryInfo = this;
        if (this.action === 'BordersAndShading') {
            this.owner.editorModule.isBordersAndShadingDialog = true;
        }
        if (!isNullOrUndefined(this.modifiedActions)) {
            if (this.editorHistory.isUndoing) {
                let i = this.modifiedActions.length;
                while (i > 0) {
                    let baseHistoryInfo = this.modifiedActions[i - 1];
                    baseHistoryInfo.revert();
                    i = i - 1;
                }
            }
            else {
                let i = 0;
                while (i < this.modifiedActions.length) {
                    let baseHistoryInfo = this.modifiedActions[i];
                    baseHistoryInfo.revert();
                    i = i + 1;
                }
            }
        }
        if (!this.isChildHistoryInfo) {
            this.editorHistory.updateComplexHistory();
        }
        else {
            this.editorHistory.updateComplexHistoryInternal();
        }
    }
    /**
     * @private
     */
    destroy() {
        if (!isNullOrUndefined(this.modifiedActions)) {
            while (this.modifiedActions.length > 0) {
                let baseHistoryInfo = this.modifiedActions[this.modifiedActions.length - 1];
                baseHistoryInfo.destroy();
                this.modifiedActions.splice(this.modifiedActions.indexOf(baseHistoryInfo), 1);
            }
            this.modifiedActions = undefined;
        }
        super.destroy();
    }
}

/**
 *  `EditorHistory` Module class is used to handle history preservation
 */
class EditorHistory {
    /**
     * @private
     */
    constructor(node) {
        //Fields
        this.undoStackIn = [];
        this.redoStackIn = [];
        this.historyInfoStack = [];
        /**
         * @private
         */
        this.isUndoing = false;
        /**
         * @private
         */
        this.isRedoing = false;
        this.owner = node;
        this.viewer = node.viewer;
        this.modifiedParaFormats = new Dictionary();
        this.undoLimitIn = 500;
        this.redoLimitIn = 500;
    }
    /**
     * @private
     */
    get currentHistoryInfo() {
        return this.historyInfoStack && this.historyInfoStack.length > 0 ?
            this.historyInfoStack[this.historyInfoStack.length - 1] : undefined;
    }
    set currentHistoryInfo(value) {
        if (value instanceof HistoryInfo) {
            this.historyInfoStack.push(value);
        }
        else {
            this.historyInfoStack.pop();
        }
    }
    //Properties
    /**
     * gets undo stack
     * @private
     */
    get undoStack() { return this.undoStackIn; }
    /**
     * gets redo stack
     * @private
     */
    get redoStack() { return this.redoStackIn; }
    /**
     * Gets or Sets the limit of undo operations can be done.
     */
    get undoLimit() {
        return isNullOrUndefined(this.undoLimitIn) ? 0 : this.undoLimitIn;
    }
    set undoLimit(value) {
        if (value < 0) {
            throw new Error('The limit should be greater than or equal to zero.');
        }
        this.undoLimitIn = value;
    }
    /**
     * Gets or Sets the limit of redo operations can be done.
     */
    get redoLimit() {
        return isNullOrUndefined(this.redoLimitIn) ? 0 : this.redoLimitIn;
    }
    set redoLimit(value) {
        if (value < 0) {
            throw new Error('The limit should be greater than or equal to zero.');
        }
        this.redoLimitIn = value;
    }
    /**
     * @private
     */
    getModuleName() {
        return 'EditorHistory';
    }
    /**
     * Determines whether undo operation can be done.
     * @returns boolean
     */
    canUndo() {
        return !isNullOrUndefined(this.undoStack) && this.undoStack.length > 0;
    }
    /**
     * Determines whether redo operation can be done.
     * @returns boolean
     */
    canRedo() {
        return !isNullOrUndefined(this.redoStack) && this.redoStack.length > 0;
    }
    //EditorHistory Initialization    
    /**
     * initialize EditorHistory
     * @param  {Selection} selection
     * @param  {Action} action
     * @param  {SelectionRange} selectionRange
     * @private
     */
    initializeHistory(action) {
        this.currentBaseHistoryInfo = new BaseHistoryInfo(this.owner);
        this.currentBaseHistoryInfo.action = action;
        this.currentBaseHistoryInfo.updateSelection();
    }
    /**
     * Initialize complex history
     * @param  {Selection} selection
     * @param  {Action} action
     * @private
     */
    initComplexHistory(selection, action) {
        this.currentHistoryInfo = new HistoryInfo(selection.owner, !isNullOrUndefined(this.currentHistoryInfo));
        this.currentHistoryInfo.action = action;
        this.currentHistoryInfo.updateSelection();
    }
    /**
     * @private
     */
    initResizingHistory(startingPoint, tableResize) {
        if (tableResize.resizeNode === 1) {
            this.initializeHistory('RowResizing');
            if (!isNullOrUndefined(this.currentBaseHistoryInfo)) {
                // tslint:disable-next-line:max-line-length
                this.currentBaseHistoryInfo.modifiedProperties.push(new RowHistoryFormat(startingPoint, tableResize.currentResizingTable.childWidgets[tableResize.resizerPosition].rowFormat));
            }
        }
        else {
            this.initializeHistory('CellResizing');
            if (this.currentBaseHistoryInfo) {
                tableResize.currentResizingTable = tableResize.currentResizingTable.combineWidget(this.viewer);
                let tableHistoryInfo = new TableHistoryInfo(tableResize.currentResizingTable, this.owner);
                tableHistoryInfo.startingPoint = startingPoint;
                this.currentBaseHistoryInfo.modifiedProperties.push(tableHistoryInfo);
            }
        }
    }
    /**
     * Update resizing history
     * @param  {Point} point
     * @param  {Selection} selection
     * @private
     */
    updateResizingHistory(point, tableResize) {
        if (tableResize.resizeNode === 1) {
            if (!isNullOrUndefined(this.currentBaseHistoryInfo)) {
                let rowHistoryFormat = this.currentBaseHistoryInfo.modifiedProperties[0];
                if (rowHistoryFormat.startingPoint.y === point.y) {
                    this.currentBaseHistoryInfo.modifiedProperties.length = 0;
                }
                else {
                    rowHistoryFormat.displacement = HelperMethods.convertPixelToPoint(point.y - rowHistoryFormat.startingPoint.y);
                    this.recordChanges(this.currentBaseHistoryInfo);
                    this.currentBaseHistoryInfo = undefined;
                }
            }
        }
        else {
            if (!isNullOrUndefined(this.currentBaseHistoryInfo)) {
                let cellHistoryFormat = this.currentBaseHistoryInfo.modifiedProperties[0];
                if (cellHistoryFormat.startingPoint.x === point.x) {
                    this.currentBaseHistoryInfo.modifiedProperties.length = 0;
                }
                else {
                    cellHistoryFormat.displacement = HelperMethods.convertPixelToPoint(point.x - cellHistoryFormat.startingPoint.x);
                    cellHistoryFormat.endIndex = tableResize.getCellReSizerPosition(point);
                    this.owner.editorHistory.recordChanges(this.currentBaseHistoryInfo);
                    this.currentBaseHistoryInfo = undefined;
                }
            }
        }
    }
    /**
     * Record the changes
     * @param  {BaseHistoryInfo} baseHistoryInfo
     * @private
     */
    recordChanges(baseHistoryInfo) {
        if (!this.owner.enableHistoryMode) {
            return;
        }
        if (this.isUndoing) {
            if (isNullOrUndefined(this.redoStack)) {
                this.redoStackIn = [];
            }
            if (this.redoStack.length === this.redoLimit && this.redoLimit > 0) {
                let count = this.undoLimit > 20 ? 10 : 1;
                this.redoStackIn.splice(0, count);
            }
            if (this.redoStack.length < this.redoLimit) {
                this.redoStack.push(baseHistoryInfo);
            }
        }
        else {
            if (!this.isRedoing) {
                this.clearRedoStack();
            }
            if (isNullOrUndefined(this.undoStack)) {
                this.undoStackIn = [];
            }
            if (this.undoStack.length === this.undoLimit && this.undoLimit > 0) {
                let count = this.undoLimit > 20 ? 10 : 1;
                this.undoStackIn.splice(0, count);
            }
            if (this.undoStack.length < this.undoLimit) {
                this.undoStackIn.push(baseHistoryInfo);
            }
        }
    }
    /**
     * update EditorHistory
     * @private
     */
    updateHistory() {
        if (this.viewer.owner.enableHistoryMode && !isNullOrUndefined(this.currentBaseHistoryInfo)) {
            //Updates the current end position
            if (!isNullOrUndefined(this.currentBaseHistoryInfo)
                && isNullOrUndefined(this.currentBaseHistoryInfo.endPosition)) {
                this.currentBaseHistoryInfo.endPosition = this.currentBaseHistoryInfo.insertPosition;
            }
            if (!isNullOrUndefined(this.currentHistoryInfo)) {
                this.currentHistoryInfo.addModifiedAction(this.currentBaseHistoryInfo);
            }
            else {
                this.recordChanges(this.currentBaseHistoryInfo);
            }
            this.currentBaseHistoryInfo = undefined;
        }
    }
    /**
     * @private
     */
    isHandledComplexHistory() {
        let isHandledComplexHistory = false;
        if (!(this.isUndoing || this.isRedoing)) {
            isHandledComplexHistory = this.owner.editorModule.insertRemoveBookMarkElements();
        }
        if (this.viewer.owner.enableHistoryMode && !isNullOrUndefined(this.currentHistoryInfo)) {
            this.updateHistory();
            isHandledComplexHistory = true;
        }
        else if (this.owner.editorModule.isHandledComplex) {
            isHandledComplexHistory = true;
        }
        return isHandledComplexHistory;
    }
    /**
     * Update complex history
     * @private
     */
    updateComplexHistory() {
        let selection = this.viewer.selection;
        if (this.currentHistoryInfo.hasAction) {
            if (this.currentHistoryInfo.action === 'AutoFormatHyperlink') {
                let startPosition = new TextPosition(selection.owner);
                this.owner.editorModule.setPositionForCurrentIndex(startPosition, this.currentHistoryInfo.insertPosition);
                // this.reLayoutParagraph(startPosition.paragraph, 0);
                if (selection.owner.editorHistory.isUndoing) {
                    this.owner.editorModule.setPositionForCurrentIndex(selection.start, this.currentHistoryInfo.selectionStart);
                    this.owner.editorModule.setPositionForCurrentIndex(selection.end, this.currentHistoryInfo.selectionEnd);
                }
                else {
                    this.owner.editorModule.setPositionForCurrentIndex(selection.start, this.currentHistoryInfo.endPosition);
                    this.owner.editorModule.setPositionForCurrentIndex(selection.end, this.currentHistoryInfo.endPosition);
                }
            }
            if (this.currentHistoryInfo.action === 'InsertHyperlink') {
                let startPosition = new TextPosition(selection.owner);
                this.owner.editorModule.setPositionForCurrentIndex(startPosition, this.currentHistoryInfo.insertPosition);
                let endPosition = new TextPosition(selection.owner);
                this.owner.editorModule.setPositionForCurrentIndex(endPosition, this.currentHistoryInfo.endPosition);
                this.viewer.layout.reLayoutParagraph(startPosition.paragraph, 0, 0);
                if (endPosition.paragraph !== startPosition.paragraph) {
                    this.viewer.layout.reLayoutParagraph(endPosition.paragraph, 0, 0);
                }
            }
            if (this.currentHistoryInfo.action === 'ReplaceAll') {
                this.owner.editorModule.layoutWholeDocument();
            }
            else if (selection.owner.isShiftingEnabled) {
                this.viewer.layout.shiftLayoutedItems();
                if (this.owner.enableHeaderAndFooter) {
                    this.owner.editorModule.updateHeaderFooterWidget();
                }
                this.viewer.removeEmptyPages();
            }
        }
        selection.owner.isShiftingEnabled = false;
        selection.owner.isLayoutEnabled = true;
        // // selection.addMultipleSelectionRanges();
        selection.start.updatePhysicalPosition(true);
        if (selection.isEmpty) {
            selection.end.setPositionInternal(selection.start);
        }
        else {
            selection.end.updatePhysicalPosition(true);
        }
        selection.upDownSelectionLength = selection.end.location.x;
        this.viewer.updateScrollBars();
        selection.fireSelectionChanged(true);
        this.viewer.updateFocus();
        this.updateComplexHistoryInternal();
        this.owner.editorModule.fireContentChange();
    }
    /**
     * @private
     */
    updateComplexHistoryInternal() {
        if (!isNullOrUndefined(this.currentHistoryInfo)) {
            //Updates the current end position
            if (isNullOrUndefined(this.currentHistoryInfo.endPosition)) {
                this.currentHistoryInfo.endPosition = this.currentHistoryInfo.insertPosition;
            }
            if (this.historyInfoStack.length > 1) {
                let historyInfo = this.historyInfoStack[this.historyInfoStack.length - 2];
                historyInfo.addModifiedAction(this.currentHistoryInfo);
            }
            else {
                this.recordChanges(this.currentHistoryInfo);
            }
            this.currentHistoryInfo = undefined;
        }
    }
    //List history preservation undo API
    /**
     * update list changes for history preservation
     * @param  {Selection} selection
     * @param  {WAbstractList} currentAbstractList
     * @param  {WList} list
     * @private
     */
    updateListChangesInHistory(currentAbstractList, list) {
        this.currentBaseHistoryInfo = new BaseHistoryInfo(this.viewer.owner);
        this.currentBaseHistoryInfo.action = 'List';
        this.currentBaseHistoryInfo.updateSelection();
        let collection = new Dictionary();
        for (let i = 0; i < currentAbstractList.levels.length; i++) {
            let levels = this.viewer.getAbstractListById(list.abstractListId).levels[i];
            let value = this.currentBaseHistoryInfo.addModifiedPropertiesForList(levels);
            let modifiedLevel = new ModifiedLevel(levels, currentAbstractList.levels[i]);
            if (!isNullOrUndefined(levels)) {
                this.viewer.owner.editorModule.copyListLevel(levels, currentAbstractList.levels[i]);
            }
            collection.add(i, modifiedLevel);
        }
        return collection;
    }
    /**
     * Apply list changes
     * @param  {Selection} selection
     * @param  {Dictionary<number, ModifiedLevel>} modifiedLevelsInternal
     * @private
     */
    applyListChanges(selection, modifiedLevelsInternal) {
        if (isNullOrUndefined(this.modifiedParaFormats)) {
            this.modifiedParaFormats = new Dictionary();
        }
        let collection = [];
        for (let i = 0; i < this.viewer.listParagraphs.length; i++) {
            let paragraph = this.viewer.listParagraphs[i];
            let paraFormat = paragraph.paragraphFormat;
            let currentList = this.viewer.getListById(paraFormat.listFormat.listId);
            let listLevel = this.viewer.layout.getListLevel(currentList, paraFormat.listFormat.listLevelNumber);
            // tslint:disable-next-line:max-line-length
            if (modifiedLevelsInternal.containsKey(paraFormat.listFormat.listLevelNumber)
                && modifiedLevelsInternal.get(paraFormat.listFormat.listLevelNumber).ownerListLevel === listLevel) {
                let modifiedFormat = new WParagraphFormat(null);
                modifiedFormat.leftIndent = paraFormat.leftIndent;
                modifiedFormat.firstLineIndent = paraFormat.firstLineIndent;
                let modified = new ModifiedParagraphFormat(paraFormat, modifiedFormat);
                collection.push(modified);
                this.owner.editorModule.copyFromListLevelParagraphFormat(paraFormat, listLevel.paragraphFormat);
            }
        }
        this.modifiedParaFormats.add(this.currentBaseHistoryInfo, collection);
    }
    /**
     * Update list changes
     * @param  {Dictionary<number, ModifiedLevel>} modifiedCollection
     * @param  {Selection} selection
     * @private
     */
    updateListChanges(modifiedCollection) {
        this.viewer.owner.isLayoutEnabled = false;
        this.owner.editorModule.updateListParagraphs();
        for (let i = 0; i < modifiedCollection.keys.length; i++) {
            let levelNumber = modifiedCollection.keys[0];
            let modifiedLevel = modifiedCollection.get(levelNumber);
            if (!isNullOrUndefined(this.currentBaseHistoryInfo)) {
                // tslint:disable-next-line:max-line-length
                modifiedLevel = this.currentBaseHistoryInfo.addModifiedPropertiesForList(modifiedLevel.ownerListLevel);
            }
            this.owner.editorModule.copyListLevel(modifiedLevel.ownerListLevel, modifiedLevel.modifiedListLevel);
        }
        this.revertListChanges();
        this.viewer.owner.isLayoutEnabled = true;
        this.viewer.renderedLists.clear();
        this.viewer.pages = [];
        this.viewer.layout.layout();
        let selection = this.viewer.selection;
        selection.start.updatePhysicalPosition(true);
        if (selection.isEmpty) {
            selection.end.setPositionInternal(selection.start);
        }
        else {
            selection.end.updatePhysicalPosition(true);
        }
        selection.upDownSelectionLength = selection.end.location.x;
        selection.fireSelectionChanged(false);
        this.updateHistory();
    }
    /**
     * Revert list changes
     * @param  {Selection} selection
     */
    revertListChanges() {
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(this.currentBaseHistoryInfo)
            && this.viewer.owner.editorHistory.modifiedParaFormats.containsKey(this.currentBaseHistoryInfo)) {
            // tslint:disable-next-line:max-line-length
            let collection = this.modifiedParaFormats.get(this.currentBaseHistoryInfo);
            for (let i = 0; i < collection.length; i++) {
                let modified = new WParagraphFormat(null);
                modified.leftIndent = collection[i].ownerFormat.leftIndent;
                modified.firstLineIndent = collection[i].ownerFormat.firstLineIndent;
                collection[i].ownerFormat.copyFormat(collection[i].modifiedFormat);
                collection[i].modifiedFormat.leftIndent = modified.leftIndent;
                collection[i].modifiedFormat.firstLineIndent = modified.firstLineIndent;
            }
        }
    }
    /**
     * Reverts the last editing action.
     */
    undo() {
        if (this.owner.isReadOnlyMode || !this.canUndo() || !this.owner.enableHistoryMode) {
            return;
        }
        //this.owner.ClearTextSearchResults();
        let historyInfo = this.undoStack.pop();
        this.isUndoing = true;
        historyInfo.revert();
        this.isUndoing = false;
        this.owner.selection.checkForCursorVisibility();
        this.owner.editorModule.isBordersAndShadingDialog = false;
    }
    /**
     * Performs the last reverted action.
     */
    redo() {
        if (this.owner.isReadOnlyMode || !this.canRedo() || !this.owner.enableHistoryMode) {
            return;
        }
        //this.owner.ClearTextSearchResults();
        let historyInfo = this.redoStack.pop();
        if (historyInfo.action === 'BordersAndShading') {
            this.owner.editorModule.isBordersAndShadingDialog = true;
        }
        this.isRedoing = true;
        historyInfo.revert();
        this.isRedoing = false;
        this.owner.selection.checkForCursorVisibility();
        this.owner.editorModule.isBordersAndShadingDialog = false;
    }
    /**
     * @private
     */
    destroy() {
        this.clearHistory();
        this.undoStackIn = undefined;
        this.redoStackIn = undefined;
    }
    clearHistory() {
        this.clearUndoStack();
        this.clearRedoStack();
    }
    clearUndoStack() {
        if (this.canUndo()) {
            while (this.undoStack.length > 0) {
                let historyInfo = this.undoStack.pop();
                historyInfo.destroy();
                historyInfo = undefined;
            }
        }
    }
    clearRedoStack() {
        if (this.canRedo()) {
            while (this.redoStack.length > 0) {
                let historyInfo = this.redoStack.pop();
                historyInfo.destroy();
                historyInfo = undefined;
            }
        }
    }
}

/**
 * EditorHistory implementation
 */

/**
 * Exports the document to Word format.
 */
class WordExport {
    constructor() {
        //Part path
        this.documentPath = 'word/document.xml';
        this.stylePath = 'word/styles.xml';
        this.numberingPath = 'word/numbering.xml';
        this.settingsPath = 'word/settings.xml';
        this.headerPath = 'word/header';
        this.footerPath = 'word/footer';
        //private commentsPath: string = 'word/comments.xml';
        this.imagePath = 'word/media/image';
        // private footnotesPath: string = 'word/footnotes.xml';
        // private endnotesPath: string = 'word/endnotes.xml';
        this.appPath = 'docProps/app.xml';
        this.corePath = 'docProps/core.xml';
        // private CustomPath: string = 'docProps/custom.xml';
        // private FontTablePath: string = 'word/fontTable.xml';
        this.contentTypesPath = '[Content_Types].xml';
        // private ChartsPath: string = 'word/charts/';
        // private DefaultEmbeddingPath: string = 'word/embeddings/';
        // private EmbeddingPath:string = 'word\embeddings\';
        // private DrawingPath:string = 'word\drawings\';
        // private ThemePath: string = 'word/theme/theme1.xml';
        // private FontsPath:string = 'word\fonts\';
        // private DiagramPath:string = "word/diagrams/';
        // private ControlPath:string = "word/activeX/';
        // private VbaProject: string = 'vbaProject.bin';
        // private VbaData: string = 'vbaData.xml';
        // private VbaProjectPath: string = 'word/vbaProject.bin';
        // private VbaDataPath: string = 'word/vbaData.xml';
        // private CustomXMLPath:string = 'customXml\';
        //Relationship path
        this.generalRelationPath = '_rels/.rels';
        this.wordRelationPath = 'word/_rels/document.xml.rels';
        // private FontRelationPath: string = 'word/_rels/fontTable.xml.rels';
        // private CommentsRelationPath: string = 'word/_rels/comments.xml.rels';
        // private FootnotesRelationPath: string = 'word/_rels/footnotes.xml.rels';
        // private EndnotesRelationPath: string = 'word/_rels/endnotes.xml.rels';
        // private NumberingRelationPath: string = 'word/_rels/numbering.xml.rels';
        this.headerRelationPath = 'word/_rels/header';
        this.footerRelationPath = 'word/_rels/footer';
        // private SettingsRelationpath: string = 'word/_rels/settings.xml.rels';
        // private VbaProjectRelsPath: string = 'word/_rels/vbaProject.bin.rels';
        //Content type of the parts
        this.xmlContentType = 'application/xml';
        this.fontContentType = 'application/vnd.openxmlformats-officedocument.obfuscatedFont';
        this.documentContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml';
        // private TemplateContentType: string = 'application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml';
        // private CommentsContentType: string = 'application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml';
        this.settingsContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml';
        // private EndnoteContentType: string = 'application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml';
        // private FontTableContentType: string = 'application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml';
        this.footerContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml';
        // private FootnoteContentType: string = 'application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml';
        // private GlossaryDocumentContentType: string = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml';
        this.headerContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml';
        this.numberingContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml';
        this.stylesContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml';
        this.webSettingsContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.webSettings+xml';
        this.appContentType = 'application/vnd.openxmlformats-officedocument.extended-properties+xml';
        this.coreContentType = 'application/vnd.openxmlformats-package.core-properties+xml';
        this.customContentType = 'application/vnd.openxmlformats-officedocument.custom-properties+xml';
        this.customXmlContentType = 'application/vnd.openxmlformats-officedocument.customXmlProperties+xml';
        this.relationContentType = 'application/vnd.openxmlformats-package.relationships+xml';
        // private DiagramColor: string = 'application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml';
        // private DiagramData: string = 'application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml';
        // private DiagramLayout: string = 'application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml';
        // private DiagramStyle: string = 'application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml';
        // private ChartsContentType: string = 'application/vnd.openxmlformats-officedocument.drawingml.chart+xml';
        // private ThemeContentType: string = 'application/vnd.openxmlformats-officedocument.theme+xml';
        // private ChartDrawingContentType: string = 'application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml';
        // private ActiveXContentType: string = 'application/vnd.ms-office.activeX+xml';
        // private ActiveXBinContentType: string = 'application/vnd.ms-office.activeX';
        this.tableStyleContentType = 'application/vnd.openxmlformats-officedocument.presentationml.tableStyles+xml';
        // private ChartStyleContentType: string = 'application/vnd.ms-office.chartstyle+xml';
        // private ChartColorStyleContentType: string = 'application/vnd.ms-office.chartcolorstyle+xml';
        // private VbaProjectContentType: string = 'application/vnd.ms-office.vbaProject';
        // private VbaDataContentType: string = 'application/vnd.ms-word.vbaData+xml';
        // private MacroDocumentContentType: string = 'application/vnd.ms-word.document.macroEnabled.main+xml';
        // private MacroTemplateContentType: string = 'application/vnd.ms-word.template.macroEnabledTemplate.main+xml';
        // private OleObjectContentType: string = 'application/vnd.openxmlformats-officedocument.oleObject';
        // Relationship types of document parts
        // private AltChunkRelType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/aFChunk';
        // private CommentsRelType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments';
        this.settingsRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings';
        // private EndnoteRelType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/endnotes';
        // private FontTableRelType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable';
        this.footerRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer';
        // private FootnoteRelType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/footnotes';
        this.headerRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/header';
        this.documentRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument';
        this.numberingRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/numbering';
        this.stylesRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles';
        // private OleObjectRelType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject';
        // private ChartRelType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart';
        // private ThemeRelType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme';
        this.fontRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/font';
        this.tableStyleRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/tableStyles';
        this.coreRelType = 'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties';
        this.appRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties';
        this.customRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties';
        this.imageRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image';
        this.hyperlinkRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink';
        this.controlRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/control';
        this.packageRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/package';
        // private VbaProjectRelType: string = 'http://schemas.microsoft.com/office/2006/relationships/vbaProject';
        // private VbaDataRelType: string = 'http://schemas.microsoft.com/office/2006/relationships/wordVbaData';
        this.customXmlRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml';
        this.customUIRelType = 'http://schemas.microsoft.com/office/2006/relationships/ui/extensibility';
        this.attachedTemplateRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/attachedTemplate';
        // private ChartColorStyleRelType: string = 'http://schemas.microsoft.com/office/2011/relationships/chartColorStyle';
        // private ChartStyleRelType: string = 'http://schemas.microsoft.com/office/2011/relationships/chartStyle';
        // private ChartUserShapesRelType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartUserShapes';
        // private ChartContentType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/package';
        // Namespaces
        // private PKG_namespace: string = 'http://schemas.microsoft.com/office/2006/xmlPackage';
        this.wNamespace = 'http://schemas.openxmlformats.org/wordprocessingml/2006/main';
        this.wpNamespace = 'http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing';
        this.pictureNamespace = 'http://schemas.openxmlformats.org/drawingml/2006/picture';
        this.aNamespace = 'http://schemas.openxmlformats.org/drawingml/2006/main';
        this.a14Namespace = 'http://schemas.microsoft.com/office/drawing/2010/main';
        // private SVG_namespace: string = 'http://schemas.microsoft.com/office/drawing/2016/SVG/main';
        this.rNamespace = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships';
        this.rpNamespace = 'http://schemas.openxmlformats.org/package/2006/relationships';
        this.vNamespace = 'urn:schemas-microsoft-com:vml';
        this.oNamespace = 'urn:schemas-microsoft-com:office:office';
        this.xmlNamespace = 'http://www.w3.org/XML/1998/namespace';
        this.w10Namespace = 'urn:schemas-microsoft-com:office:word';
        this.cpNamespace = 'http://schemas.openxmlformats.org/package/2006/metadata/core-properties';
        this.dcNamespace = 'http://purl.org/dc/elements/1.1/';
        // private DCTERMS_namespace: string = 'http://purl.org/dc/terms/';
        // private XSI_namespace: string = 'http://www.w3.org/2001/XMLSchema-instance';
        this.docPropsNamespace = 'http://schemas.openxmlformats.org/officeDocument/2006/extended-properties';
        this.veNamespace = 'http://schemas.openxmlformats.org/markup-compatibility/2006';
        this.mNamespace = 'http://schemas.openxmlformats.org/officeDocument/2006/math';
        this.wneNamespace = 'http://schemas.microsoft.com/office/word/2006/wordml';
        // private DCMI_namespace: string = 'http://purl.org/dc/dcmitype/';
        this.customPropsNamespace = 'http://schemas.openxmlformats.org/officeDocument/2006/custom-properties';
        this.vtNamespace = 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes';
        this.chartNamespace = 'http://schemas.openxmlformats.org/drawingml/2006/chart';
        this.slNamespace = 'http://schemas.openxmlformats.org/schemaLibrary/2006/main';
        //2003WML namespace
        // private amlNamespace: string = 'http://schemas.microsoft.com/aml/2001/core';
        this.dtNamespace = 'uuid:C2F41010-65B3-11d1-A29F-00AA00C14882';
        this.wmlNamespace = 'http://schemas.microsoft.com/office/word/2003/wordml';
        //2010 namespaces
        this.w14Namespace = 'http://schemas.microsoft.com/office/word/2010/wordml';
        this.wpCanvasNamespace = 'http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas';
        this.wpDrawingNamespace = 'http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing';
        this.wpGroupNamespace = 'http://schemas.microsoft.com/office/word/2010/wordprocessingGroup';
        this.wpInkNamespace = 'http://schemas.microsoft.com/office/word/2010/wordprocessingInk';
        this.wpShapeNamespace = 'http://schemas.microsoft.com/office/word/2010/wordprocessingShape';
        //2013 namespaces
        this.w15Namespace = 'http://schemas.microsoft.com/office/word/2012/wordml';
        this.diagramNamespace = 'http://schemas.openxmlformats.org/drawingml/2006/diagram';
        //Encryption namespaces
        this.eNamespace = 'http://schemas.microsoft.com/office/2006/encryption';
        this.pNamespace = 'http://schemas.microsoft.com/office/2006/keyEncryptor/password';
        this.certNamespace = 'http://schemas.microsoft.com/office/2006/keyEncryptor/certificate';
        // Dls xml tags
        this.cRelationshipsTag = 'Relationships';
        this.cRelationshipTag = 'Relationship';
        this.cIdTag = 'Id';
        this.cTypeTag = 'Type';
        this.cTargetTag = 'Target';
        this.cUserShapesTag = 'userShapes';
        this.cExternalData = 'externalData';
        this.twipsInOnePoint = 20;
        this.twentiethOfPoint = 20;
        this.borderMultiplier = 8;
        this.percentageFactor = 50;
        this.emusPerPoint = 12700;
        // private const TOC_SYMBOL:string = (char)0x01;
        // private const FOOTNOTE_SYMBOL:string = (char)0x02;
        // private const PAGENUMBER_SYMBOL:string = (char)0xB;
        // private DEF_FIT_TEXT_TO_SHAPE: string = 'mso-fit-shape-to-text:t';
        // Document tags
        this.cConditionalTableStyleTag = 'tblStylePr';
        this.cTableFormatTag = 'tblPr';
        this.cTowFormatTag = 'trPr';
        this.cCellFormatTag = 'tcPr';
        this.cParagraphFormatTag = 'pPr';
        this.cCharacterFormatTag = 'rPr';
        this.packageType = 'http://schemas.microsoft.com/office/2006/xmlPackage';
        this.relsPartPath = '/_rels/.rels';
        this.documentRelsPartPath = '/word/_rels/document.xml.rels';
        this.webSettingsPath = '/word/webSettings.xml';
        this.wordMLDocumentPath = '/word/document.xml';
        this.wordMLStylePath = '/word/styles.xml';
        this.wordMLNumberingPath = '/word/numbering.xml';
        this.wordMLSettingsPath = '/word/settings.xml';
        this.wordMLHeaderPath = '/word/header';
        this.wordMLFooterPath = '/word/footer';
        this.wordMLCommentsPath = '/word/comments.xml';
        this.wordMLImagePath = '/word/media/image';
        this.wordMLFootnotesPath = '/word/footnotes.xml';
        this.wordMLEndnotesPath = '/word/endnotes.xml';
        this.wordMLAppPath = '/docProps/app.xml';
        this.wordMLCorePath = '/docProps/core.xml';
        this.wordMLCustomPath = '/docProps/custom.xml';
        this.wordMLFontTablePath = '/word/fontTable.xml';
        this.wordMLChartsPath = '/word/charts/';
        this.wordMLDefaultEmbeddingPath = '/word/embeddings/';
        this.wordMLEmbeddingPath = '/word/embeddings/';
        this.wordMLDrawingPath = '/word/drawings/';
        this.wordMLThemePath = '/word/theme/theme1.xml';
        this.wordMLFontsPath = '/word/fonts/';
        this.wordMLDiagramPath = '/word/diagrams/';
        this.wordMLControlPath = '/word/activeX/';
        this.wordMLVbaProject = '/vbaProject.bin';
        this.wordMLVbaData = '/vbaData.xml';
        this.wordMLVbaProjectPath = '/word/vbaProject.bin';
        this.wordMLVbaDataPath = '/word/vbaData.xml';
        // private WordMLCustomXMLPath: string = '/customXml/';
        this.wordMLWebSettingsPath = '/word/webSettings.xml';
        this.wordMLCustomItemProp1Path = '/customXml/itemProps1.xml';
        // private WordMLCustomXMLRelPath: string = '/customXml/_rels/item1.xml.rels';
        this.wordMLFootnoteRelPath = '/word/_rels/footnotes.xml.rels';
        this.wordMLEndnoteRelPath = '/word/_rels/endnotes.xml.rels';
        this.wordMLSettingsRelPath = '/word/_rels/settings.xml.rels';
        this.wordMLNumberingRelPath = '/word/_rels/numbering.xml.rels';
        this.wordMLFontTableRelPath = '/word/_rels/fontTable.xml.rels';
        this.wordMLCustomXmlPropsRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps';
        this.wordMLControlRelType = 'http://schemas.microsoft.com/office/2006/relationships/activeXControlBinary';
        this.wordMLDiagramContentType = 'application/vnd.ms-office.drawingml.diagramDrawing+xml';
        this.lastSection = false;
        this.mRelationShipID = 0;
        this.mDocPrID = 0;
        this.mDifferentFirstPage = false;
        this.mBookmarks = undefined;
        /* tslint:enable:no-any */
    }
    getModuleName() {
        return 'WordExport';
    }
    // Gets the bookmark name
    get bookmarks() {
        if (isNullOrUndefined(this.mBookmarks)) {
            this.mBookmarks = [];
        }
        return this.mBookmarks;
    }
    // Gets the collection of images present in the document body
    get documentImages() {
        if (this.mDocumentImages === undefined) {
            this.mDocumentImages = new Dictionary();
        }
        return this.mDocumentImages;
    }
    // Gets the collection of images present in the document body
    get externalImages() {
        if (this.mExternalLinkImages === undefined) {
            this.mExternalLinkImages = new Dictionary();
        }
        return this.mExternalLinkImages;
    }
    // Gets the collections of images present in the HeaderFooters
    get headerFooterImages() {
        if (this.mHeaderFooterImages === undefined) {
            this.mHeaderFooterImages = new Dictionary();
        }
        return this.mHeaderFooterImages;
    }
    /// Gets the HeaderFooter Collection
    get headersFooters() {
        if (this.mHeaderFooterColl === undefined) {
            this.mHeaderFooterColl = new Dictionary();
        }
        return this.mHeaderFooterColl;
    }
    /**
     * @private
     */
    save(viewer, fileName) {
        this.serialize(viewer);
        this.mArchive.save(fileName + '.docx').then((mArchive) => {
            mArchive.destroy();
        });
        this.close();
    }
    /**
     * @private
     */
    saveAsBlob(viewer) {
        this.serialize(viewer);
        return new Promise((resolve, reject) => {
            this.mArchive.saveAsBlob().then((blob) => {
                this.mArchive.destroy();
                blob = new Blob([blob], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
                resolve(blob);
            });
        });
    }
    /**
     * @private
     */
    destroy() {
        this.clearDocument();
        this.mRelationShipID = undefined;
        this.mDocPrID = undefined;
        this.mDifferentFirstPage = undefined;
        if (this.mArchive) {
            this.mArchive.destroy();
            this.mArchive = undefined;
        }
    }
    // Saves the word document in the stream
    serialize(viewer) {
        /* tslint:disable:no-any */
        let document = viewer.owner.sfdtExportModule.write();
        this.setDocument(document);
        this.mArchive = new ZipArchive();
        this.mArchive.compressionLevel = 'Normal';
        this.mVerticalMerge = new Dictionary();
        this.mGridSpans = new Dictionary();
        let contenttype;
        //document.xml
        this.serializeDocument();
        //Styles.xml
        this.serializeStyles();
        //numbering.xml
        this.serializeNumberings();
        //theme.xml
        // if (m_document.DocHasThemes && !isNullOrUndefined(m_document.Themes))
        //     SerializeThemes();
        // else
        // this.serializeDefaultThemes();
        //settings.xml
        this.serializeSettings();
        //core.xml
        this.serializeCoreProperties();
        //app.xml
        this.serializeAppProperties();
        //fontTable.xml
        this.serializeFontTable(contenttype);
        //custom.xml
        // if (!isNullOrUndefined(this.wordDocument.CustomDocumentProperties) && m_document.CustomDocumentProperties.length > 0) {
        //     SerializeCustomProperties();
        // }
        //Settings Relations
        this.serializeSettingsRelation();
        //Numbering relation if the document has picture bullet
        // if (PictureBullets.length > 0) {
        //     SerializeNumberingsRelation();
        // }
        this.serializeHeaderFooters();
        //document relations
        this.serializeDocumentRelations();
        // // Add controls to archieve.
        // if (ControlsPathNames.length > 0) {
        //     AddControlsToZip(m_document.DocxPackage);
        // }
        // if (!isNullOrUndefined(m_document.CustomUIPartContainer))
        //     AddPartContainerToArchive(m_document.CustomUIPartContainer);
        // if (!isNullOrUndefined(m_document.CustomXMLContainer))
        //     AddPartContainerToArchive(m_document.CustomXMLContainer);
        //general relations
        this.serializeGeneralRelations();
        //[ContentTypes].xml
        this.serializeContentTypes(contenttype);
        // Clears the internal fields maintained for serializing.
        this.clearDocument();
    }
    // Sets the document
    setDocument(document) {
        this.document = document;
        this.mSections = document.sections;
        this.mLists = document.lists;
        this.mAbstractLists = document.abstractLists;
        this.defCharacterFormat = document.characterFormat;
        this.defParagraphFormat = document.paragraphFormat;
        this.defaultTabWidthValue = document.defaultTabWidth;
        this.mStyles = document.styles;
    }
    // Clears the document
    clearDocument() {
        // Owner Nodes
        this.section = undefined;
        this.lastSection = undefined;
        this.blockOwner = undefined;
        this.paragraph = undefined;
        this.table = undefined;
        this.row = undefined;
        this.headerFooter = undefined;
        this.document = undefined;
        this.mSections = undefined;
        this.mLists = undefined;
        this.mAbstractLists = undefined;
        this.defCharacterFormat = undefined;
        this.defParagraphFormat = undefined;
        this.defaultTabWidthValue = undefined;
        this.mRelationShipID = 0;
        this.mDocPrID = 0;
        this.mDifferentFirstPage = false;
        if (this.mHeaderFooterColl) {
            this.mHeaderFooterColl.destroy();
            this.mHeaderFooterColl = undefined;
        }
        if (this.mVerticalMerge) {
            this.mVerticalMerge.destroy();
            this.mVerticalMerge = undefined;
        }
        if (this.mGridSpans) {
            this.mGridSpans.destroy();
            this.mGridSpans = undefined;
        }
        if (this.mDocumentImages) {
            this.mDocumentImages.destroy();
            this.mDocumentImages = undefined;
        }
        if (this.mExternalLinkImages) {
            this.mExternalLinkImages.destroy();
            this.mExternalLinkImages = undefined;
        }
        if (this.mHeaderFooterImages) {
            this.mHeaderFooterImages.destroy();
            this.mHeaderFooterImages = undefined;
        }
    }
    // Serializes the document elements (document.xml)
    serializeDocument() {
        let writer = new XmlWriter();
        writer.writeStartElement('w', 'document', this.wNamespace);
        this.writeCommonAttributeStrings(writer);
        this.serializeDocumentBody(writer);
        writer.writeEndElement(); //end of document tag
        let archiveItem = new ZipArchiveItem(writer.buffer, this.documentPath);
        this.mArchive.addItem(archiveItem);
    }
    writeCommonAttributeStrings(writer) {
        writer.writeAttributeString('xmlns', 'wpc', undefined, this.wpCanvasNamespace);
        this.writeCustom(writer);
        writer.writeAttributeString('xmlns', 'wp14', undefined, this.wpDrawingNamespace);
        writer.writeAttributeString('xmlns', 'wp', undefined, this.wpNamespace);
        writer.writeAttributeString('xmlns', 'w10', undefined, this.w10Namespace);
        writer.writeAttributeString('xmlns', 'w', undefined, this.wNamespace);
        this.writeDup(writer);
        writer.writeAttributeString('xmlns', 'wne', undefined, this.wneNamespace);
        writer.writeAttributeString('xmlns', 'wps', undefined, this.wpShapeNamespace);
        writer.writeAttributeString('mc', 'Ignorable', undefined, 'w14 w15 wp14');
    }
    writeDup(writer) {
        writer.writeAttributeString('xmlns', 'w14', undefined, this.w14Namespace);
        writer.writeAttributeString('xmlns', 'w15', undefined, this.w15Namespace);
        writer.writeAttributeString('xmlns', 'wpg', undefined, this.wpGroupNamespace);
        writer.writeAttributeString('xmlns', 'wpi', undefined, this.wpInkNamespace);
    }
    writeCustom(writer) {
        writer.writeAttributeString('xmlns', 'mc', undefined, this.veNamespace);
        writer.writeAttributeString('xmlns', 'o', undefined, this.oNamespace);
        writer.writeAttributeString('xmlns', 'r', undefined, this.rNamespace);
        writer.writeAttributeString('xmlns', 'm', undefined, this.mNamespace);
        writer.writeAttributeString('xmlns', 'v', undefined, this.vNamespace);
    }
    // Serializes the document body
    serializeDocumentBody(writer) {
        writer.writeStartElement(undefined, 'body', this.wNamespace);
        let count = this.document.sections.length;
        for (let i = 0; i < count; i++) {
            this.section = this.document.sections[i];
            this.lastSection = i === count - 1;
            this.serializeSection(writer, this.section, i === count - 1);
            this.section = undefined;
        }
        writer.writeEndElement();
    }
    // Serializes the Section.
    serializeSection(writer, section, last) {
        this.blockOwner = section;
        this.serializeBodyItems(writer, section.blocks, last);
        if (last) {
            this.serializeSectionProperties(writer, section);
        }
        this.blockOwner = undefined;
    }
    // Serialize the section properties.
    serializeSectionProperties(writer, section) {
        writer.writeStartElement('w', 'sectPr', this.wNamespace);
        if (section.headersFooters) {
            this.serializeHFReference(writer, section.headersFooters);
        }
        // if (IsNeedToSerializeSectionFootNoteProperties(section))
        //     SerializeFootnoteProperties(section);
        // if (IsNeedToSerializeSectionEndNoteProperties(section))
        //     SerializeEndnoteProperties(section);
        this.serializeSectionType(writer, 'nextPage');
        this.serializePageSetup(writer, section.sectionFormat);
        this.serializeColumns(writer, section);
        // this.serializeSectionProtection(section);
        // if (section.PageSetup.VerticalAlignment !== PageAlignment.Top) {
        //     writer.writeStartElement('vAlign', this.wNamespace);
        //     switch (section.PageSetup.VerticalAlignment) {
        //         case PageAlignment.Top:
        //             writer.WriteAttributeString('val', this.wNamespace, 'top');
        //             break;
        //         case PageAlignment.Middle:
        //             writer.WriteAttributeString('val', this.wNamespace, 'center');
        //             break;
        //         case PageAlignment.Justified:
        //             writer.WriteAttributeString('val', this.wNamespace, 'both');
        //             break;
        //         case PageAlignment.Bottom:
        //             writer.WriteAttributeString('val', this.wNamespace, 'bottom');
        //             break;
        //     }
        //     writer.WriteEndElement();
        // }
        if (section.sectionFormat !== undefined && section.sectionFormat.differentFirstPage) {
            writer.writeStartElement(undefined, 'titlePg', this.wNamespace);
            writer.writeEndElement();
        }
        // SerializeTextDirection(section);
        // if (section.PageSetup.Bidi) {
        //     writer.WriteStartElement('bidi', this.wNamespace);
        //     writer.WriteEndElement();
        // }
        //rtlGutter
        // SerializeDocGrid(section);
        //printerSettings
        writer.writeEndElement(); //end of sectPr tag
    }
    // Serialize the column properties of section.
    serializeColumns(writer, section) {
        writer.writeStartElement(undefined, 'cols', this.wNamespace);
        writer.writeAttributeString(undefined, 'equalWidth', this.wNamespace, '1');
        writer.writeAttributeString(undefined, 'space', this.wNamespace, '0');
        writer.writeEndElement();
        // ColumnCollection columns = section.Columns;
        // writer.WriteStartElement('cols', this.wNamespace);
        // if (columns.length > 0)
        // {
        //     writer.WriteAttributeString('num', this.wNamespace, columns.length.ToString());
        // }
        // if (section.PageSetup.DrawLinesBetweenCols)
        //     writer.WriteAttributeString('sep', this.wNamespace, '1');
        // if (columns.OwnerSection.PageSetup.EqualColumnWidth)
        // {
        //     writer.WriteAttributeString('equalWidth', this.wNamespace, '1');
        //     //When the column count is negative, MS word just reset the column's count to zero
        //     //To avoid index out of exception, checked the columns count
        // tslint:disable-next-line:max-line-length
        //     writer.WriteAttributeString('space', this.wNamespace, ToString(columns.length > 0 ? columns[0].Space * this.TwentiethOfPoint : 0));
        // }
        // else if (columns.length > 0)
        // {
        //     writer.WriteAttributeString('equalWidth', this.wNamespace, '0');
        //     foreach (Column column in columns)
        //     {
        //         writer.WriteStartElement('col', this.wNamespace);
        //         writer.WriteAttributeString('w', this.wNamespace, ToString(column.Width * this.TwentiethOfPoint));
        // tslint:disable-next-line:max-line-length
        //         writer.WriteAttributeString('space', this.wNamespace, ToString(column.Space * this.TwentiethOfPoint));
        //         writer.WriteEndElement();
        //     }
        // }
        // writer.WriteEndElement();
    }
    // Serialize the page setup properties.
    serializePageSetup(writer, pageSetup) {
        if (pageSetup !== undefined) {
            this.serializePageSize(writer, pageSetup);
            this.serializePageMargins(writer, pageSetup);
        }
        // // StartElement paperSrc (if any)
        // if (pageSetup.FirstPageTray > 0 || pageSetup.OtherPagesTray > 0) {
        //     writer.WriteStartElement('paperSrc', this.wNamespace);
        //     if (pageSetup.FirstPageTray > 0) {
        //         writer.WriteAttributeString('first', this.wNamespace, pageSetup.FirstPageTray.ToString());
        //     }
        //     if (pageSetup.OtherPagesTray > 0) {
        //         writer.WriteAttributeString('other', this.wNamespace, pageSetup.OtherPagesTray.ToString());
        //     }
        //     writer.WriteEndElement();
        // }
        writer.writeStartElement(undefined, 'pgBorders', this.wNamespace);
        // //zOrder
        // if (pageSetup.PageBordersApplyType === PageBordersApplyType.FirstPage)
        //     writer.WriteAttributeString('display', this.wNamespace, 'firstPage');
        // else if (pageSetup.PageBordersApplyType === PageBordersApplyType.AllExceptFirstPage)
        //     writer.WriteAttributeString('display', this.wNamespace, 'notFirstPage');
        // if (pageSetup.PageBorderOffsetFrom === PageBorderOffsetFrom.PageEdge) {
        //     writer.WriteAttributeString('offsetFrom', this.wNamespace, 'page');
        // }
        // //Serializing zOrder of the front page border
        // if (!pageSetup.IsFrontPageBorder) {
        //     writer.WriteAttributeString('zOrder', this.wNamespace, 'back');
        // }
        // SerializePageBorders(pageSetup.Borders);
        writer.writeEndElement();
        // this.serializeLineNumberType(writer, pageSetup);
        //this.serializePageNumberType(writer, pageSetup);
    }
    // serialize the page size
    serializePageSize(writer, pageSetup) {
        writer.writeStartElement(undefined, 'pgSz', this.wNamespace);
        // tslint:disable-next-line:max-line-length
        writer.writeAttributeString(undefined, 'w', this.wNamespace, this.roundToTwoDecimal(pageSetup.pageWidth * this.twentiethOfPoint).toString());
        // tslint:disable-next-line:max-line-length
        writer.writeAttributeString(undefined, 'h', this.wNamespace, this.roundToTwoDecimal(pageSetup.pageHeight * this.twentiethOfPoint).toString());
        // if (pageSetup.Orientation === PageOrientation.Landscape)
        // {
        //     writer.WriteAttributeString('orient', this.wNamespace, 'landscape');
        // }
        writer.writeEndElement();
    }
    // Serialize the border.
    serializePageMargins(writer, pageSetup) {
        writer.writeStartElement(undefined, 'pgMar', this.wNamespace);
        let marginValue = Math.round(pageSetup.topMargin * this.twentiethOfPoint);
        writer.writeAttributeString(undefined, 'top', this.wNamespace, marginValue.toString());
        marginValue = Math.round(pageSetup.rightMargin * this.twentiethOfPoint);
        writer.writeAttributeString(undefined, 'right', this.wNamespace, marginValue.toString());
        marginValue = Math.round(pageSetup.bottomMargin * this.twentiethOfPoint);
        writer.writeAttributeString(undefined, 'bottom', this.wNamespace, marginValue.toString());
        marginValue = Math.round(pageSetup.leftMargin * this.twentiethOfPoint);
        writer.writeAttributeString(undefined, 'left', this.wNamespace, marginValue.toString());
        // tslint:disable-next-line:max-line-length
        writer.writeAttributeString(undefined, 'header', this.wNamespace, this.roundToTwoDecimal(pageSetup.headerDistance * this.twentiethOfPoint).toString());
        // tslint:disable-next-line:max-line-length
        writer.writeAttributeString(undefined, 'footer', this.wNamespace, this.roundToTwoDecimal(pageSetup.footerDistance * this.twentiethOfPoint).toString());
        writer.writeAttributeString(undefined, 'gutter', this.wNamespace, '0');
        writer.writeEndElement();
    }
    // Serialize the section type.
    serializeSectionType(writer, sectionBreakCode) {
        writer.writeStartElement('w', 'type', this.wNamespace);
        writer.writeAttributeString('w', 'val', this.wNamespace, sectionBreakCode); //GetSectionBreakCode(sectionBreakCode));
        writer.writeEndElement();
    }
    // Serialize the heeader/footer reference.
    serializeHFReference(writer, headersFooters) {
        let hfId = '';
        if (headersFooters !== undefined) {
            this.mDifferentFirstPage = this.section.sectionFormat.differentOddAndEvenPages;
            let hf = headersFooters.firstPageHeader;
            if (hf && hf.blocks && hf.blocks.length > 0) {
                writer.writeStartElement(undefined, 'headerReference', this.wNamespace);
                writer.writeAttributeString(undefined, 'type', this.wNamespace, 'first');
                hfId = this.getNextRelationShipID();
                writer.writeAttributeString(undefined, 'id', this.rNamespace, hfId);
                this.addHeaderFooter(hf, 'FirstPageHeader', hfId);
                writer.writeEndElement();
            }
            hf = headersFooters.firstPageFooter;
            if (hf && hf.blocks && hf.blocks.length > 0) {
                writer.writeStartElement(undefined, 'footerReference', this.wNamespace);
                writer.writeAttributeString(undefined, 'type', this.wNamespace, 'first');
                hfId = this.getNextRelationShipID();
                writer.writeAttributeString(undefined, 'id', this.rNamespace, hfId);
                this.addHeaderFooter(hf, 'FirstPageFooter', hfId);
                writer.writeEndElement();
            }
            hf = headersFooters.evenHeader;
            if (hf && hf.blocks && hf.blocks.length > 0) {
                writer.writeStartElement(undefined, 'headerReference', this.wNamespace);
                writer.writeAttributeString(undefined, 'type', this.wNamespace, 'even');
                hfId = this.getNextRelationShipID();
                writer.writeAttributeString(undefined, 'id', this.rNamespace, hfId);
                this.addHeaderFooter(hf, 'EvenHeader', hfId);
                writer.writeEndElement();
            }
            hf = headersFooters.evenFooter;
            if (hf && hf.blocks && hf.blocks.length > 0) {
                writer.writeStartElement(undefined, 'footerReference', this.wNamespace);
                writer.writeAttributeString(undefined, 'type', this.wNamespace, 'even');
                hfId = this.getNextRelationShipID();
                writer.writeAttributeString(undefined, 'id', this.rNamespace, hfId);
                this.addHeaderFooter(hf, 'EvenFooter', hfId);
                writer.writeEndElement();
            }
            hf = headersFooters.header;
            if (hf && hf.blocks && hf.blocks.length > 0) {
                writer.writeStartElement(undefined, 'headerReference', this.wNamespace);
                writer.writeAttributeString(undefined, 'type', this.wNamespace, 'default');
                hfId = this.getNextRelationShipID();
                writer.writeAttributeString(undefined, 'id', this.rNamespace, hfId);
                this.addHeaderFooter(hf, 'OddHeader', hfId);
                writer.writeEndElement();
            }
            hf = headersFooters.footer;
            if (hf && hf.blocks && hf.blocks.length > 0) {
                writer.writeStartElement(undefined, 'footerReference', this.wNamespace);
                writer.writeAttributeString(undefined, 'type', this.wNamespace, 'default');
                hfId = this.getNextRelationShipID();
                writer.writeAttributeString(undefined, 'id', this.rNamespace, hfId);
                this.addHeaderFooter(hf, 'OddFooter', hfId);
                writer.writeEndElement();
            }
        }
    }
    // Adds the header footer details to the collection.
    addHeaderFooter(hf, hfType, id) {
        let hfColl = new Dictionary();
        this.headersFooters.add(hfType, hfColl);
        this.headersFooters.get(hfType).add(id, hf);
    }
    // Serializes the bodyItems
    serializeBodyItems(writer, blockCollection, isLastSection) {
        for (let i = 0; i < blockCollection.length; i++) {
            this.serializeBodyItem(writer, blockCollection[i], isLastSection);
        }
    }
    // Serialize the TextBody item
    serializeBodyItem(writer, item, isLastSection) {
        if (isNullOrUndefined(item)) {
            throw new Error('BodyItem should not be undefined');
        }
        if (item.hasOwnProperty('inlines')) {
            this.paragraph = item;
            this.serializeParagraph(writer, item, isLastSection);
            this.paragraph = undefined;
        }
        else {
            let table = item;
            for (let i = 0; i < table.rows.length; i++) {
                if (table.rows[i].cells.length > 0) {
                    this.serializeTable(writer, table);
                    break;
                }
            }
        }
    }
    // Serialize the paragraph
    serializeParagraph(writer, paragraph, isLastSection) {
        if (isNullOrUndefined(paragraph)) {
            throw new Error('Paragraph should not be undefined');
        }
        let sec = this.blockOwner;
        //Need to write the Section Properties if the Paragraph is last item in the section
        if (!isLastSection && sec.hasOwnProperty('sectionFormat')
            && sec.blocks.indexOf(paragraph) === sec.blocks.length - 1) {
            writer.writeStartElement('w', 'p', this.wNamespace);
            writer.writeStartElement(undefined, 'pPr', this.wNamespace);
            this.serializeSectionProperties(writer, sec);
            writer.writeEndElement();
            writer.writeEndElement();
        }
        // if (paragraph.ParagraphFormat.PageBreakAfter && !IsPageBreakNeedToBeSkipped(paragraph as Entity))
        //     paragraph.InsertBreak(BreakType.PageBreak);
        // if (paragraph.ParagraphFormat.ColumnBreakAfter && !IsPageBreakNeedToBeSkipped(paragraph as Entity))
        //     paragraph.InsertBreak(BreakType.ColumnBreak);
        //Splits the paragraph based on the newline character
        // paragraph.SplitTextRange();
        writer.writeStartElement('w', 'p', this.wNamespace);
        writer.writeStartElement(undefined, 'pPr', this.wNamespace);
        this.serializeParagraphFormat(writer, paragraph.paragraphFormat, paragraph);
        writer.writeEndElement(); //end of pPr
        // Serialize watermark if paragraph is the first item of Header document.
        // EnsureWatermark(paragraph);
        this.serializeParagraphItems(writer, paragraph.inlines);
        writer.writeEndElement(); //end of paragraph tag.
    }
    // Serialize the paragraph items
    serializeParagraphItems(writer, paraItems) {
        let previousNode = undefined;
        for (let i = 0; i < paraItems.length; i++) {
            let item = paraItems[i];
            if (item.hasOwnProperty('fieldType')) {
                this.serializeFieldCharacter(writer, item);
            }
            else if (item.hasOwnProperty('imageString')) {
                this.serializePicture(writer, item);
            }
            else if (item.hasOwnProperty('bookmarkType')) {
                this.serializeBookMark(writer, item);
            }
            else {
                this.serializeTextRange(writer, item, previousNode);
            }
            previousNode = item;
        }
    }
    // Serialize the book mark
    serializeBookMark(writer, bookmark) {
        let bookmarkId = this.getBookmarkId(bookmark.name);
        let bookmarkName = bookmark.name;
        if (bookmark.bookmarkType === 0) {
            writer.writeStartElement('w', 'bookmarkStart', this.wNamespace);
            writer.writeAttributeString('w', 'name', this.wNamespace, bookmarkName);
        }
        else if (bookmark.bookmarkType === 1) {
            writer.writeStartElement('w', 'bookmarkEnd', this.wNamespace);
        }
        writer.writeAttributeString('w', 'id', this.wNamespace, bookmarkId.toString());
        writer.writeEndElement();
    }
    getBookmarkId(name) {
        let index = this.bookmarks.indexOf(name);
        if (index < 0) {
            index = this.bookmarks.length;
            this.bookmarks.push(name);
        }
        return index;
    }
    // Serialize the picture.
    serializePicture(writer, image) {
        if (image.width >= 0 && image.height >= 0) {
            writer.writeStartElement(undefined, 'r', this.wNamespace);
            this.serializeCharacterFormat(writer, image.characterFormat);
            this.serializeDrawing(writer, image);
            writer.writeEndElement(); //end of run element
        }
    }
    // Serialize the drawing element.
    serializeDrawing(writer, image) {
        writer.writeStartElement(undefined, 'drawing', this.wNamespace);
        this.serializeInlinePicture(writer, image);
        writer.writeEndElement();
    }
    // Serialize the inline picture.
    serializeInlinePicture(writer, image) {
        writer.writeStartElement(undefined, 'inline', this.wpNamespace);
        writer.writeStartElement(undefined, 'extent', this.wpNamespace);
        let cx = Math.round(image.width * this.emusPerPoint);
        writer.writeAttributeString(undefined, 'cx', undefined, cx.toString());
        let cy = Math.round(image.height * this.emusPerPoint);
        writer.writeAttributeString(undefined, 'cy', undefined, cy.toString());
        writer.writeEndElement();
        // double borderWidth = (double)picture.PictureShape.PictureDescriptor.BorderLeft.LineWidth / DLSConstants.BorderLineFactor;
        // if (borderWidth > 0 && picture.DocxProps.length === 0) {
        //     long leftTop = 0, rightBottom = 0;
        //     picture.PictureShape.GetEffectExtent(borderWidth, ref leftTop, ref rightBottom);
        //     m_writer.WriteStartElement('effectExtent', WP_namespace);
        //     m_writer.WriteAttributeString('l', leftTop.ToString(CultureInfo.InvariantCulture));
        //     m_writer.WriteAttributeString('t', leftTop.ToString(CultureInfo.InvariantCulture));
        //     m_writer.WriteAttributeString('r', rightBottom.ToString(CultureInfo.InvariantCulture));
        //     m_writer.WriteAttributeString('b', rightBottom.ToString(CultureInfo.InvariantCulture));
        //     m_writer.WriteEndElement();
        // }
        //this.serializePicProperties(writer, image);
        this.serializeDrawingGraphics(writer, image);
        writer.writeEndElement();
    }
    startsWith(sourceString, startString) {
        return startString.length > 0 && sourceString.substring(0, startString.length) === startString;
    }
    // Serialize the graphics element for pictures.
    serializeDrawingGraphics(writer, picture) {
        let id = '';
        id = this.updateShapeId(picture);
        // picture.ShapeId = this.getNextDocPrID();
        // Processing picture
        writer.writeStartElement('wp', 'docPr', this.wpNamespace);
        writer.writeAttributeString(undefined, 'id', undefined, (this.mDocPrID++).toString());
        // if (!isNullOrUndefined(picture.AlternativeText))
        //     m_writer.WriteAttributeString('descr', picture.AlternativeText);
        writer.writeAttributeString(undefined, 'name', undefined, '1'.toString());
        // if (!string.IsNullOrEmpty(picture.Title))
        //     m_writer.WriteAttributeString('title', picture.Title);
        // else
        writer.writeAttributeString(undefined, 'title', undefined, '');
        // if (!picture.Visible)
        //     m_writer.WriteAttributeString('hidden', '1');
        // SerializePictureHyperlink(picture);
        writer.writeEndElement();
        writer.writeStartElement('a', 'graphic', this.aNamespace);
        writer.writeStartElement('a', 'graphicData', this.aNamespace);
        writer.writeAttributeString(undefined, 'uri', undefined, this.pictureNamespace);
        writer.writeStartElement('pic', 'pic', this.pictureNamespace);
        writer.writeStartElement('pic', 'nvPicPr', this.pictureNamespace);
        writer.writeStartElement('pic', 'cNvPr', this.pictureNamespace);
        writer.writeAttributeString(undefined, 'id', undefined, '0');
        writer.writeAttributeString(undefined, 'name', undefined, '');
        writer.writeAttributeString(undefined, 'descr', undefined, '');
        writer.writeEndElement();
        writer.writeStartElement('pic', 'cNvPicPr', this.pictureNamespace);
        writer.writeStartElement('a', 'picLocks', this.aNamespace);
        writer.writeAttributeString(undefined, 'noChangeAspect', undefined, '1');
        writer.writeAttributeString(undefined, 'noChangeArrowheads', undefined, '1');
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeStartElement('pic', 'blipFill', this.pictureNamespace);
        writer.writeStartElement('a', 'blip', this.aNamespace);
        if (this.startsWith(picture.imageString, 'data:image')) {
            writer.writeAttributeString('r', 'embed', this.rNamespace, id);
        }
        else {
            if (this.documentImages.containsKey(id)) {
                //Remove the image document images collection for this particular key
                //If the picture image data has href means MS Word contains the image in media folder as well as 
                //it is having external relationship id
                // if (!this.startsWith(picture.imageString, 'data:image')) {
                this.documentImages.remove(id);
                this.externalImages.add(id, picture.imageString);
                writer.writeAttributeString(undefined, 'link', this.rNamespace, id);
            }
        }
        //End Element Blip
        writer.writeEndElement();
        writer.writeStartElement('a', 'srcRect', this.aNamespace);
        writer.writeEndElement();
        writer.writeStartElement('a', 'stretch', this.aNamespace);
        writer.writeStartElement('a', 'fillRect', this.aNamespace);
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeStartElement('pic', 'spPr', this.pictureNamespace);
        writer.writeAttributeString(undefined, 'bwMode', undefined, 'auto');
        writer.writeStartElement('a', 'xfrm', this.aNamespace);
        // if (picture.Rotation !== 0)
        //     m_writer.WriteAttributeString('rot', picture.Rotation.ToString());
        writer.writeStartElement('a', 'off', this.aNamespace);
        writer.writeAttributeString(undefined, 'x', undefined, '0');
        writer.writeAttributeString(undefined, 'y', undefined, '0');
        writer.writeEndElement();
        writer.writeStartElement('a', 'ext', this.aNamespace);
        let cx = Math.round((picture.width * this.emusPerPoint));
        writer.writeAttributeString(undefined, 'cx', undefined, cx.toString());
        let cy = Math.round((picture.height * this.emusPerPoint));
        writer.writeAttributeString(undefined, 'cy', undefined, cy.toString());
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeStartElement('a', 'prstGeom', this.aNamespace);
        writer.writeAttributeString(undefined, 'prst', undefined, 'rect');
        writer.writeStartElement('a', 'avLst', this.aNamespace);
        writer.writeEndElement();
        writer.writeEndElement();
        //When the picture border has been added next to effect list
        //if not, Picture border has not been preserved
        // if (picture.HasBorder)
        // {
        //     if (picture.TextWrappingStyle === TextWrappingStyle.Inline && picture.IsShape)
        //         SerializeInlineShapeLine(picture.PictureShape);
        //     else
        //         SerializeShapeLine(picture.PictureShape);
        // }
        // if (picture.DocxProps.length > 0)
        //     SerializeDocxProps(picture.DocxProps, 'effectLst');
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeEndElement();
    }
    /// Update the shape id.
    updateShapeId(picture) {
        let id = '';
        let tOwner = this.paragraph;
        // Adding picture byte data to the corresponding picture collection 
        // depending on its owner subdocument
        if (this.headerFooter) {
            id = this.updateHFImageRels(this.headerFooter, picture);
        }
        else {
            if (id === '') {
                if (tOwner.hasOwnProperty('sectionFormat') || tOwner.hasOwnProperty('inlines')) {
                    id = this.addImageRelation(this.documentImages, picture);
                    // if (owner is WFootnote)
                    // {
                    //     if ((owner as WFootnote).FootnoteType === FootnoteType.Footnote)
                    //         id = AddImageRelation(FootnoteImages, picture.ImageRecord);
                    //     else
                    //         id = AddImageRelation(EndnoteImages, picture.ImageRecord);
                    // }
                    // if (owner is WComment)
                    //     id = AddImageRelation(CommentImages, picture.ImageRecord);
                }
            }
        }
        return id;
    }
    // Adds the image relation.
    addImageRelation(imageCollection, image) {
        let relationId = '';
        // if (imageCollection.ContainsValue(imageRecord)) {
        //     foreach(string key in imageCollection.keys)
        //     {
        //         if (imageRecord === imageCollection[key]) {
        //             relationId = key;
        //             break;
        //         }
        //     }
        // }
        // else {
        relationId = this.getNextRelationShipID();
        imageCollection.add(relationId, image);
        // }
        return relationId;
    }
    // Update the HeaderFooter image relations.
    updateHFImageRels(hf, image) {
        let id = '';
        // UpdateImages(image);
        let headerId = '';
        let types = this.headersFooters.keys;
        for (let i = 0; i < types.length; i++) {
            let hfColl = this.headersFooters.get(types[i]);
            let hfKeys = hfColl.keys;
            for (let j = 0; j < hfKeys.length; j++) {
                if (hfColl.get(hfKeys[j]) === hf) {
                    headerId = hfKeys[j];
                    let headerImages;
                    if (this.headerFooterImages.containsKey(headerId)) {
                        headerImages = this.headerFooterImages.get(headerId);
                        id = this.addImageRelation(headerImages, image);
                    }
                    else {
                        headerImages = new Dictionary();
                        id = this.addImageRelation(headerImages, image);
                        this.headerFooterImages.add(headerId, headerImages);
                    }
                }
            }
        }
        return id;
    }
    // Serialize the table
    serializeTable(writer, table) {
        if (table.rows.length <= 0) {
            return;
        }
        let owner = this.table;
        this.table = table;
        writer.writeStartElement(undefined, 'tbl', this.wNamespace);
        let tableFormat = table.rows[0].rowFormat;
        this.serializeTableFormat(writer, tableFormat, table);
        this.serializeTableGrid(writer, table);
        this.serializeTableRows(writer, table.rows);
        writer.writeEndElement();
        this.table = owner;
    }
    // Serialize the table grid
    serializeTableGrid(writer, table) {
        writer.writeStartElement(undefined, 'tblGrid', this.wNamespace);
        if (table.grid.length !== 0) {
            this.serializeGridColumns(writer, table.grid);
        }
        writer.writeEndElement();
    }
    // Serialize the table rows
    serializeTableRows(writer, rows) {
        if (rows.length > 0) {
            for (let i = 0; i < rows.length; i++) {
                let row = rows[i];
                if (row.cells.length > 0) {
                    this.serializeRow(writer, row);
                }
            }
        }
    }
    // Serialize the table row
    serializeRow(writer, row) {
        let owner = this.row;
        this.row = row;
        writer.writeStartElement(undefined, 'tr', this.wNamespace);
        this.serializeRowFormat(writer, row);
        this.serializeCells(writer, row.cells);
        writer.writeEndElement(); //end od table row 'tr'
        this.row = owner;
    }
    // Serialize the row format
    serializeRowFormat(writer, row) {
        writer.writeStartElement(undefined, 'trPr', this.wNamespace);
        //Serialize Row Height
        if (row.rowFormat.height > 0) {
            writer.writeStartElement(undefined, 'trHeight', this.wNamespace);
            if (row.rowFormat.heightType === 'Exactly') {
                writer.writeAttributeString('w', 'hRule', this.wNamespace, 'exact');
            }
            else if (row.rowFormat.heightType === 'AtLeast') {
                writer.writeAttributeString('w', 'hRule', this.wNamespace, 'atLeast');
            }
            let height = this.roundToTwoDecimal(row.rowFormat.height * this.twentiethOfPoint).toString();
            writer.writeAttributeString('w', 'val', this.wNamespace, height);
            writer.writeEndElement();
        }
        let rowFormat = row.rowFormat;
        // //Serialize 'gridBefore' element
        let gridBefore = rowFormat.gridBefore;
        if (gridBefore > 0) {
            writer.writeStartElement(undefined, 'gridBefore', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, gridBefore.toString());
            writer.writeEndElement();
        }
        // //Serialize 'gridAfter' element
        let gridAfter = rowFormat.gridAfter;
        if (gridAfter > 0) {
            writer.writeStartElement(undefined, 'gridAfter', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, gridAfter.toString());
            writer.writeEndElement();
        }
        // //Serialize 'wBefore' element 
        if (gridBefore > 0) {
            writer.writeStartElement(undefined, 'wBefore', this.wNamespace);
            switch (rowFormat.gridBeforeWidthType) {
                case 'Percent':
                    let width = this.roundToTwoDecimal(rowFormat.gridBeforeWidth * this.percentageFactor).toString();
                    writer.writeAttributeString('w', 'val', this.wNamespace, width);
                    writer.writeAttributeString('w', 'type', this.wNamespace, 'pct');
                    break;
                case 'Point':
                    let pointWidth = this.roundToTwoDecimal(rowFormat.gridBeforeWidth * this.twipsInOnePoint).toString();
                    writer.writeAttributeString('w', 'val', this.wNamespace, pointWidth);
                    writer.writeAttributeString('w', 'type', this.wNamespace, 'dxa');
                    break;
            }
            writer.writeEndElement();
        }
        //Serialize 'wAfter' element
        if (gridAfter > 0) {
            writer.writeStartElement(undefined, 'wAfter', this.wNamespace);
            switch (rowFormat.gridAfterWidthType) {
                case 'Percent':
                    let width = this.roundToTwoDecimal(rowFormat.gridAfterWidth * this.percentageFactor).toString();
                    writer.writeAttributeString('w', 'val', this.wNamespace, width);
                    writer.writeAttributeString('w', 'type', this.wNamespace, 'pct');
                    break;
                case 'Point':
                    let pointWidth = this.roundToTwoDecimal(rowFormat.gridAfterWidth * this.twipsInOnePoint).toString();
                    writer.writeAttributeString('w', 'val', this.wNamespace, pointWidth);
                    writer.writeAttributeString('w', 'type', this.wNamespace, 'dxa');
                    break;
            }
            writer.writeEndElement();
        }
        //Serialize 'cantSplit' element 
        if (!rowFormat.allowBreakAcrossPages) {
            writer.writeStartElement(undefined, 'cantSplit', this.wNamespace);
            writer.writeEndElement();
        }
        // //Serialize 'tblHeader' element 
        if (rowFormat.isHeader) {
            writer.writeStartElement(undefined, 'tblHeader', this.wNamespace);
            writer.writeEndElement();
        }
        writer.writeEndElement();
    }
    // serialize the table cells
    serializeCells(writer, cells) {
        for (let i = 0; i < cells.length; i++) {
            this.serializeCell(writer, cells[i]);
        }
    }
    // Serialize the table cell
    serializeCell(writer, cell) {
        let owner = this.blockOwner;
        this.blockOwner = cell;
        writer.writeStartElement(undefined, 'tc', this.wNamespace);
        this.serializeCellFormat(writer, cell.cellFormat);
        if (cell.blocks.length > 0) {
            let itemIndex = 0;
            let item = undefined;
            while (itemIndex < cell.blocks.length) {
                item = cell.blocks[itemIndex];
                this.serializeBodyItem(writer, item, false);
                itemIndex += 1;
            }
        }
        else {
            writer.writeStartElement(undefined, 'p', this.wNamespace);
            writer.writeStartElement(undefined, 'pPr', this.wNamespace);
            writer.writeStartElement(undefined, 'pStyle', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, 'Normal');
            writer.writeEndElement(); //end of pStyle
            writer.writeEndElement(); //end of pPr
            writer.writeEndElement(); //end of P
        }
        writer.writeEndElement(); //end of table cell 'tc'        
        this.blockOwner = owner;
    }
    // Serialize the cell formatting
    serializeCellFormat(writer, cellFormat) {
        let cell = this.blockOwner;
        //Get the table fomat
        let tf = this.table.tableFormat;
        //Get the row format
        let rf = this.row.rowFormat;
        writer.writeStartElement(undefined, 'tcPr', this.wNamespace);
        //w:cnfStyle -   Table Cell Conditional Formatting
        // SerializeCnfStyleElement(cell);
        //w:tcW -    Preferred Table Cell Width
        this.serializeCellWidth(writer, cell);
        //w:hMerge -    Horizontally Merged Cell and w:vMerge -    Vertically Merged Cell
        this.serializeCellMerge(writer, cellFormat);
        //w:gridSpan -   Grid Columns Spanned by Current Table Cell
        this.serializeGridSpan(writer, cell);
        //w:tcBorders -    Table Cell Borders
        writer.writeStartElement(undefined, 'tcBorders', this.wNamespace);
        this.serializeBorders(writer, cellFormat.borders, 8);
        writer.writeEndElement();
        //w:shd -  Table Cell Shading
        this.serializeShading(writer, cell.cellFormat.shading);
        // //w:noWrap -   Don't Wrap Cell Content
        // if (cellFormat.HasValue(CellFormat.TextWrapKey)) {
        //     m_writer.WriteStartElement('noWrap', W_namespace);
        //     if (cellFormat.TextWrap)
        //         m_writer.WriteAttributeString('w', 'val', W_namespace, 'false');
        //     m_writer.WriteEndElement();
        // }
        // //w:tcMar -  Single Table Cell Margins
        // if (!cellFormat.SamePaddingsAsTable) {
        //     m_writer.WriteStartElement('tcMar', W_namespace);
        //     SerializePaddings(cellFormat.Paddings);
        //     m_writer.WriteEndElement();
        // }
        //w:textDirection -   Table Cell Text Flow Direction
        this.serializeTableCellDirection(writer, cellFormat);
        // //w:tcFitText -  Fit Text Within Cell
        // if (cellFormat.FitText) {
        //     m_writer.WriteStartElement('tcFitText', W_namespace);
        //     m_writer.WriteEndElement();
        // }
        // //w:hideMark 
        // if (cellFormat.HideMark) {
        //     m_writer.WriteStartElement('hideMark', W_namespace);
        //     m_writer.WriteEndElement();
        // }
        //w:vAlign -  Table Cell Vertical Alignment
        // if (cellFormat.HasValue(CellFormat.VrAlignmentKey))
        this.serializeCellVerticalAlign(writer, cellFormat.verticalAlignment);
        // //w:hideMark -   Ignore End Of Cell Marker In Row Height Calculation
        // SerializeDocxProps(tempDocxProps, 'hideMark');
        // //w:cellIns -    Table Cell Insertion
        // SerializeDocxProps(tempDocxProps, 'cellIns');
        // //w:cellDel -    Table Cell Deletion
        // SerializeDocxProps(tempDocxProps, 'cellDel');
        // //w:cellMerge -   Vertically Merged/Split Table Cells
        // SerializeDocxProps(tempDocxProps, 'cellMerge');
        // if (cellFormat.OldPropertiesHash.length > 0 && !m_isAlternativeCellFormat) {
        //     m_isAlternativeCellFormat = true;
        //     SerializeTrackChangeProps('tcPrChange', cellFormat.FormatChangeAuthorName, cellFormat.FormatChangeDateTime);
        //     Dictionary < int, object > oldPropertyHash = new Dictionary<int, object>(cellFormat.OldPropertiesHash);
        //     Dictionary < int, object > propertyHash = new Dictionary<int, object>(cellFormat.PropertiesHash);
        //     cellFormat.PropertiesHash.Clear();
        //     cellFormat.OldPropertiesHash.Clear();
        //     foreach(KeyValuePair < int, object > keyValue in oldPropertyHash)
        //     cellFormat.PropertiesHash[keyValue.Key] = keyValue.Value;
        //     SerializeCellFormat(cellFormat);
        //     cellFormat.PropertiesHash.Clear();
        //     foreach(KeyValuePair < int, object > keyValue in propertyHash)
        //     cellFormat.PropertiesHash[keyValue.Key] = keyValue.Value;
        //     foreach(KeyValuePair < int, object > keyValue in oldPropertyHash)
        //     cellFormat.OldPropertiesHash[keyValue.Key] = keyValue.Value;
        //     m_writer.WriteEndElement();
        //     m_isAlternativeCellFormat = false;
        // }
        writer.writeEndElement();
    }
    // Serialize the cell width
    serializeCellWidth(writer, cell) {
        let cf = cell.cellFormat;
        writer.writeStartElement(undefined, 'tcW', this.wNamespace);
        if (cf.preferredWidthType === 'Percent') {
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'pct');
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString(undefined, 'w', this.wNamespace, this.roundToTwoDecimal(cf.preferredWidth * this.percentageFactor).toString());
        }
        else if (cf.preferredWidthType === 'Point') {
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString(undefined, 'w', this.wNamespace, this.roundToTwoDecimal(cf.preferredWidth * this.twipsInOnePoint).toString());
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'dxa');
        }
        else {
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'auto');
            writer.writeAttributeString(undefined, 'w', this.wNamespace, '0');
        }
        writer.writeEndElement();
    }
    // Serialize cell merge
    serializeCellMerge(writer, cellFormat) {
        let cell = this.blockOwner;
        let isserialized = false;
        let collKey;
        let currentIndex = cell.columnIndex;
        let cellIndex = this.row.cells.indexOf(cell);
        let prevIndex = cellIndex > 0 ? this.row.cells[cellIndex - 1].columnIndex : cell.columnIndex;
        if (cell.columnIndex === cellIndex) {
            collKey = cell.columnIndex;
            isserialized = true;
        }
        else {
            isserialized = false;
        }
        if (!isserialized) {
            if (cellIndex === 0) {
                currentIndex = cell.columnIndex;
                prevIndex = -1;
            }
            for (let i = prevIndex; i < currentIndex; i++) {
                collKey = prevIndex + 1;
                prevIndex += 1;
                if (this.mVerticalMerge.containsKey(collKey)) {
                    this.createMerge(writer, collKey, cell);
                }
            }
        }
        if (cellFormat.rowSpan > 1) {
            writer.writeStartElement(undefined, 'vMerge', this.wNamespace);
            this.mVerticalMerge.add(collKey, cellFormat.rowSpan - 1);
            if (cellFormat.columnSpan > 1) {
                this.mGridSpans.add(collKey, cellFormat.columnSpan);
            }
            writer.writeAttributeString('w', 'val', this.wNamespace, 'restart');
            writer.writeEndElement();
        }
        else if (this.mVerticalMerge.containsKey(collKey) && isserialized) {
            this.createMerge(writer, collKey, cell);
        }
        else if (this.mVerticalMerge.containsKey(cellIndex + 1) && isserialized && cell.nextNode === undefined) {
            collKey = cell.columnIndex + 1;
            writer.writeEndElement();
            writer.writeStartElement('w', 'p', this.wNamespace);
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement(undefined, 'tc', this.wNamespace);
            writer.writeStartElement(undefined, 'tcPr', this.wNamespace);
            this.serializeColumnSpan(collKey, writer);
            writer.writeStartElement(undefined, 'vMerge', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, 'continue');
            writer.writeEndElement();
            this.checkMergeCell(collKey);
        }
    }
    createMerge(writer, collKey, cell) {
        this.serializeColumnSpan(collKey, writer);
        writer.writeStartElement(undefined, 'vMerge', this.wNamespace);
        writer.writeAttributeString('w', 'val', this.wNamespace, 'continue');
        writer.writeEndElement();
        writer.writeEndElement(); //end tcPr
        writer.writeStartElement('w', 'p', this.wNamespace);
        writer.writeEndElement();
        writer.writeEndElement(); //end tc
        writer.writeStartElement(undefined, 'tc', this.wNamespace);
        writer.writeStartElement(undefined, 'tcPr', this.wNamespace);
        this.serializeCellWidth(writer, cell);
        this.checkMergeCell(collKey);
    }
    serializeColumnSpan(collKey, writer) {
        if (this.mGridSpans.keys.length > 0 && this.mGridSpans.containsKey(collKey)) {
            writer.writeStartElement(undefined, 'gridSpan', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, this.mGridSpans.get(collKey).toString());
            writer.writeEndElement();
        }
    }
    checkMergeCell(collKey) {
        if ((this.mVerticalMerge.get(collKey) - 1) === 0) {
            this.mVerticalMerge.remove(collKey);
            if (this.mGridSpans.keys.length > 0 && this.mGridSpans.containsKey(collKey)) {
                this.mGridSpans.remove(collKey);
            }
        }
        else {
            this.mVerticalMerge.set(collKey, this.mVerticalMerge.get(collKey) - 1);
        }
    }
    // Serialize the grid span element of cell.
    serializeGridSpan(writer, cell) {
        // int gridSpan = cell.cellFormat.GridSpan;
        if (cell.cellFormat.columnSpan > 1) {
            let num = cell.cellFormat.columnSpan;
            writer.writeStartElement(undefined, 'gridSpan', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, num.toString());
            writer.writeEndElement();
        }
    }
    // Serialize the table cell direction
    serializeTableCellDirection(writer, cellFormat) {
        // if (cellFormat..textDirection !== TextDirection.Horizontal)
        // {
        //     m_writer.WriteStartElement('textDirection', W_namespace);
        //     switch (cellFormat.TextDirection)
        //     {
        //         case TextDirection.Horizontal:
        //             m_writer.WriteAttributeString('w', 'val', W_namespace, 'lrTb');
        //             break;
        //         case TextDirection.VerticalBottomToTop:
        //             m_writer.WriteAttributeString('w', 'val', W_namespace, 'btLr');
        //             break;
        //         case TextDirection.VerticalTopToBottom:
        //             m_writer.WriteAttributeString('w', 'val', W_namespace, 'tbRl');
        //             break;
        //         case TextDirection.HorizontalFarEast:
        //             m_writer.WriteAttributeString('w', 'val', W_namespace, 'lrTbV');
        //             break;
        //         case TextDirection.Vertical:
        //             m_writer.WriteAttributeString('w', 'val', W_namespace, 'tbLrV');
        //             break;
        //         case TextDirection.VerticalFarEast:
        //             m_writer.WriteAttributeString('w', 'val', W_namespace, 'tbRlV');
        //             break;
        //     }
        //     m_writer.WriteEndElement();
        // }
    }
    // Serialize the cell vertical alignment
    serializeCellVerticalAlign(writer, alignment) {
        writer.writeStartElement(undefined, 'vAlign', this.wNamespace);
        switch (alignment) {
            case 'Top':
                writer.writeAttributeString('w', 'val', this.wNamespace, 'top');
                break;
            case 'Center':
                writer.writeAttributeString('w', 'val', this.wNamespace, 'center');
                break;
            default:
                writer.writeAttributeString('w', 'val', this.wNamespace, 'bottom');
                break;
        }
        writer.writeEndElement();
    }
    // Serialize the table grid columns.
    serializeGridColumns(writer, grid) {
        for (let i = 1, count = grid.length; i < count; i++) {
            let gridValue = Math.round(grid[i] * 20);
            writer.writeStartElement(undefined, 'gridCol', this.wNamespace);
            writer.writeAttributeString(undefined, 'w', this.wNamespace, gridValue.toString());
            writer.writeEndElement();
        }
    }
    // Serialize the row formattings.
    // Table parameter is passed for serializing table format and undefined for serializing row format.
    serializeTableFormat(writer, format, table) {
        // if (!isNullOrUndefined(table))
        // {
        //     List<Stream> tempDocxProps = new List<Stream>();
        //     for (int i = 0, cnt = table.DocxTableFormat.NodeArray.length; i < cnt; i++)
        //         tempDocxProps.Add(table.DocxTableFormat.NodeArray[i]);
        writer.writeStartElement(undefined, 'tblPr', this.wNamespace);
        //     SerializeTableStlye(format);
        //     if (format.WrapTextAround &&!((table.OwnerTextBody.Owner is WTextBox) || 
        //(table.OwnerTextBody.Owner is WComment) || (table.OwnerTextBody.Owner is WFootnote)))
        //     {
        //         SerializeTablePositioning(format.Positioning);
        //         if (!format.Positioning.AllowOverlap)
        //         {
        //             m_writer.WriteStartElement('tblOverlap', W_namespace);
        //             m_writer.WriteAttributeString('val', W_namespace, 'never');
        //             m_writer.WriteEndElement();
        //         }
        //     }
        //     if (format.Bidi)
        //     {
        //         m_writer.WriteStartElement('bidiVisual', W_namespace);
        //         m_writer.WriteEndElement();
        //     }
        //     SerializeDocxProps(tempDocxProps, 'tblStyleRowBandSize');
        //     SerializeDocxProps(tempDocxProps, 'tblStyleColBandSize');
        this.serializeTableWidth(writer, table);
        this.serializeTableAlignment(writer, table.tableFormat);
        this.serializeCellSpacing(writer, table.tableFormat);
        this.serializeTableIndentation(writer, table.tableFormat);
        this.serializeTableBorders(writer, table.tableFormat);
        this.serializeShading(writer, table.tableFormat.shading);
        this.serializeTblLayout(writer, table.tableFormat);
        // this.serializeTableCellMargin(writer, table.tableFormat);
        //     SerializeTableLook(table);
        //         if (!isNullOrUndefined(table.Title))
        //             SerializeTableTitle(table);
        //         if (!isNullOrUndefined(table.Description))
        //             SerializeTableDescription(table);
        // }
        // else
        // {
        //     SerializeCellSpacing(format);
        //     SerializeTableIndentation(format);
        //     SerializeTableBorders(format);
        //     SerializeTableShading(format);
        //     SerializeTblLayout(format);
        //     SerializeTableCellMargin(format);
        // }
        // if (!isNullOrUndefined(format.OwnerBase) && format.OwnerBase is WTable
        //   && format.OldPropertiesHash.length > 0 && !m_isAlternativeTableFormat)
        // {
        //     m_isAlternativeTableFormat = true;
        //     SerializeTrackChangeProps('tblPrChange', format.FormatChangeAuthorName, format.FormatChangeDateTime);
        //     SerializeTableTrackChanges(format, format.OwnerBase as WTable);
        //     m_writer.WriteEndElement();
        //     m_isAlternativeTableFormat = false;
        // }
        // if (!isNullOrUndefined(format.OwnerRow) && format.OldPropertiesHash.length > 0)
        // {
        //     SerializeTrackChangeProps('tblPrExChange', format.FormatChangeAuthorName, format.FormatChangeDateTime);
        //     SerializeTableTrackChanges(format, undefined);
        //     m_writer.WriteEndElement();
        // }
        // SerializeTblTrackChanges(format);
        if (!isNullOrUndefined(table)) {
            writer.writeEndElement(); //end of tblPr
        }
    }
    // Serialize the table borders
    serializeShading(writer, format) {
        // if (format.textureStyle !== 'TextureNone') {
        writer.writeStartElement(undefined, 'shd', this.wNamespace);
        writer.writeAttributeString(undefined, 'fill', this.wNamespace, this.getColor(format.backgroundColor));
        if (format.foregroundColor === 'empty') {
            writer.writeAttributeString(undefined, 'color', this.wNamespace, 'auto');
        }
        else {
            writer.writeAttributeString(undefined, 'color', this.wNamespace, this.getColor(format.foregroundColor));
        }
        writer.writeAttributeString('w', 'val', this.wNamespace, this.getTextureStyle(format.textureStyle));
        writer.writeEndElement();
        // }
    }
    getTextureStyle(textureStyle) {
        switch (textureStyle) {
            case 'Texture5Percent':
            case 'Texture2Pt5Percent':
            case 'Texture7Pt5Percent':
                return 'pct5';
            case 'Texture10Percent':
                return 'pct10';
            case 'Texture12Pt5Percent':
                return 'pct12';
            case 'Texture15Percent':
            case 'Texture17Pt5Percent':
                return 'pct15';
            case 'Texture20Percent':
            case 'Texture22Pt5Percent':
                return 'pct20';
            case 'Texture25Percent':
            case 'Texture27Pt5Percent':
                return 'pct25';
            case 'Texture30Percent':
            case 'Texture32Pt5Percent':
                return 'pct30';
            case 'Texture35Percent':
                return 'pct35';
            case 'Texture37Pt5Percent':
                return 'pct37';
            case 'Texture40Percent':
            case 'Texture42Pt5Percent':
                return 'pct40';
            case 'Texture45Percent':
            case 'Texture47Pt5Percent':
                return 'pct45';
            case 'Texture50Percent':
            case 'Texture52Pt5Percent':
                return 'pct50';
            case 'Texture55Percent':
            case 'Texture57Pt5Percent':
                return 'pct55';
            case 'Texture60Percent':
                return 'pct60';
            case 'Texture62Pt5Percent':
                return 'pct62';
            case 'Texture65Percent':
            case 'Texture67Pt5Percent':
                return 'pct65';
            case 'Texture70Percent':
            case 'Texture72Pt5Percent':
                return 'pct70';
            case 'Texture75Percent':
            case 'Texture77Pt5Percent':
                return 'pct75';
            case 'Texture80Percent':
            case 'Texture82Pt5Percent':
                return 'pct80';
            case 'Texture85Percent':
                return 'pct85';
            case 'Texture87Pt5Percent':
                return 'pct87';
            case 'Texture90Percent':
            case 'Texture92Pt5Percent':
                return 'pct90';
            case 'Texture95Percent':
            case 'Texture97Pt5Percent':
                return 'pct95';
            case 'TextureCross':
                return 'thinHorzCross';
            case 'TextureDarkCross':
                return 'horzCross';
            case 'TextureDarkDiagonalCross':
                return 'diagCross';
            case 'TextureDarkDiagonalDown':
                return 'reverseDiagStripe';
            case 'TextureDarkDiagonalUp':
                return 'diagStripe';
            case 'TextureDarkHorizontal':
                return 'horzStripe';
            case 'TextureDarkVertical':
                return 'vertStripe';
            case 'TextureDiagonalCross':
                return 'thinDiagCross';
            case 'TextureDiagonalDown':
                return 'thinReverseDiagStripe';
            case 'TextureDiagonalUp':
                return 'thinDiagStripe';
            case 'TextureHorizontal':
                return 'thinHorzStripe';
            case 'TextureSolid':
                return 'solid';
            case 'TextureVertical':
                return 'thinVertStripe';
            default:
                return 'clear';
        }
    }
    // Serialize the table borders
    serializeTableBorders(writer, format) {
        let borders = format.borders;
        // if (IsNoneBorder(borders))
        //     return;
        writer.writeStartElement(undefined, 'tblBorders', this.wNamespace);
        this.serializeBorders(writer, format.borders, 8);
        writer.writeEndElement();
    }
    // Serialize the borders.
    serializeBorders(writer, borders, multipler) {
        this.serializeBorder(writer, borders.top, 'top', multipler);
        this.serializeBorder(writer, borders.left, 'left', multipler);
        this.serializeBorder(writer, borders.bottom, 'bottom', multipler);
        this.serializeBorder(writer, borders.right, 'right', multipler);
        this.serializeBorder(writer, borders.horizontal, 'insideH', multipler);
        this.serializeBorder(writer, borders.vertical, 'insideV', multipler);
        this.serializeBorder(writer, borders.diagonalDown, 'tl2br', multipler);
        this.serializeBorder(writer, borders.diagonalUp, 'tr2bl', multipler);
    }
    // Serialize the table layout element
    serializeTblLayout(writer, format) {
        //TODO: AUTO size property is not mapped yet
        // if (!format.IsAutoResized)
        // {
        //     writer.writeStartElement(undefined, 'tblLayout', this.wNamespace);
        //     writer.writeAttributeString(undefined, 'type', this.wNamespace, 'fixed');
        //     writer.writeEndElement();
        // }
    }
    // Serializes the Border
    serializeBorder(writer, border, tagName, multiplier) {
        let borderStyle = border.lineStyle;
        let sz = (border.lineWidth * multiplier);
        let space = border.space;
        if (borderStyle === 'Cleared') {
            writer.writeStartElement(undefined, tagName, this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, 'nil');
            writer.writeEndElement();
            return;
        }
        else if ((borderStyle === 'None' && !border.hasNoneStyle) || sz <= 0) {
            return;
        }
        writer.writeStartElement(undefined, tagName, this.wNamespace);
        writer.writeAttributeString('w', 'val', this.wNamespace, this.getBorderStyle(borderStyle));
        // if (border.color === '#000000')
        // {
        //     writer.writeAttributeString(undefined, 'color', this.wNamespace, 'auto');
        // }
        // else
        // {
        writer.writeAttributeString(undefined, 'color', this.wNamespace, this.getColor(border.color));
        // }
        writer.writeAttributeString(undefined, 'sz', this.wNamespace, this.roundToTwoDecimal(sz).toString());
        writer.writeAttributeString(undefined, 'space', this.wNamespace, space.toString());
        if (border.shadow) {
            writer.writeAttributeString(undefined, 'shadow', this.wNamespace, 'on');
        }
        writer.writeEndElement();
    }
    // Get the border style as string
    getBorderStyle(borderStyle) {
        switch (borderStyle) {
            case 'Cleared':
                return 'cleared';
            case 'DashSmallGap':
                return 'dashSmallGap';
            case 'Triple':
                return 'triple';
            case 'Dot':
                return 'dotted';
            case 'DashDot':
                return 'dotDash';
            case 'DashLargeGap':
                return 'dashed';
            case 'DashDotDot':
                return 'dotDotDash';
            case 'Double':
                return 'double';
            case 'ThinThickSmallGap':
                return 'thinThickSmallGap';
            case 'ThickThinSmallGap':
                return 'thickThinSmallGap';
            case 'ThinThickThinSmallGap':
                return 'thinThickThinSmallGap';
            case 'ThickThinMediumGap':
                return 'thickThinMediumGap';
            case 'ThinThickMediumGap':
                return 'thinThickMediumGap';
            case 'ThinThickThinMediumGap':
                return 'thinThickThinMediumGap';
            case 'ThickThinLargeGap':
                return 'thickThinLargeGap';
            case 'ThinThickLargeGap':
                return 'thinThickLargeGap';
            case 'ThinThickThinLargeGap':
                return 'thinThickThinLargeGap';
            case 'Thick':
                return 'thick';
            case 'SingleWavy':
                return 'wave';
            case 'DoubleWavy':
                return 'doubleWave';
            case 'DashDotStroked':
                return 'dashDotStroked';
            case 'Engrave3D':
                return 'threeDEngrave';
            case 'Emboss3D':
                return 'threeDEmboss';
            case 'Outset':
                return 'outset';
            case 'Inset':
                return 'inset';
            // case 'None':
            //     return 'none';
            default:
                return 'single';
        }
    }
    // Serialize the table indentation.
    serializeTableIndentation(writer, format) {
        writer.writeStartElement(undefined, 'tblInd', this.wNamespace);
        let tableIndent = Math.round(format.leftIndent * this.twipsInOnePoint);
        writer.writeAttributeString(undefined, 'w', this.wNamespace, tableIndent.toString());
        writer.writeAttributeString(undefined, 'type', this.wNamespace, 'dxa');
        writer.writeEndElement();
    }
    // Serialize the cell spacing.
    serializeCellSpacing(writer, format) {
        if (!isNullOrUndefined(format.cellSpacing) && format.cellSpacing >= 0) {
            writer.writeStartElement(undefined, 'tblCellSpacing', this.wNamespace);
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString(undefined, 'w', this.wNamespace, this.roundToTwoDecimal(format.cellSpacing * this.twentiethOfPoint).toString());
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'dxa');
            writer.writeEndElement();
        }
    }
    // Serialize the table width
    serializeTableWidth(writer, table) {
        writer.writeStartElement(undefined, 'tblW', this.wNamespace);
        if (table.tableFormat.preferredWidthType === 'Percent') {
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString(undefined, 'w', this.wNamespace, (table.tableFormat.preferredWidth * this.percentageFactor).toString());
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'pct');
        }
        else if (table.tableFormat.preferredWidthType === 'Point') {
            let tableWidth = Math.round(table.tableFormat.preferredWidth * this.twipsInOnePoint);
            writer.writeAttributeString(undefined, 'w', this.wNamespace, tableWidth.toString());
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'dxa');
        }
        else {
            writer.writeAttributeString(undefined, 'w', this.wNamespace, '0');
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'auto');
        }
        writer.writeEndElement();
    }
    // Serialize the table alignment
    serializeTableAlignment(writer, format) {
        writer.writeStartElement(undefined, 'jc', this.wNamespace);
        switch (format.tableAlignment) {
            case 'Right':
                writer.writeAttributeString('w', 'val', this.wNamespace, 'right');
                break;
            case 'Center':
                writer.writeAttributeString('w', 'val', this.wNamespace, 'center');
                break;
            default:
                writer.writeAttributeString('w', 'val', this.wNamespace, 'left');
                break;
        }
        writer.writeEndElement();
    }
    // Serialize the field
    serializeFieldCharacter(writer, field) {
        writer.writeStartElement(undefined, 'r', this.wNamespace);
        this.serializeCharacterFormat(writer, field.characterFormat);
        writer.writeStartElement(undefined, 'fldChar', this.wNamespace);
        let type = field.fieldType === 0 ? 'begin'
            : field.fieldType === 1 ? 'end' : 'separate';
        writer.writeAttributeString(undefined, 'fldCharType', this.wNamespace, type);
        writer.writeEndElement();
        writer.writeEndElement();
    }
    // Serialize the text range.
    serializeTextRange(writer, span, previousNode) {
        writer.writeStartElement('w', 'r', this.wNamespace);
        this.serializeCharacterFormat(writer, span.characterFormat);
        if (span.text === '\t') {
            writer.writeElementString(undefined, 'tab', this.wNamespace, undefined);
        }
        else if (span.text === '\v') {
            writer.writeElementString(undefined, 'br', this.wNamespace, undefined);
        }
        else if (span.text === '\f') {
            writer.writeStartElement(undefined, 'br', this.wNamespace);
            writer.writeAttributeString('w', 'type', this.wNamespace, 'page');
            writer.writeEndElement();
        }
        else {
            let isField = !isNullOrUndefined(previousNode)
                && previousNode.hasOwnProperty('fieldType') && previousNode.fieldType !== 2;
            writer.writeStartElement(undefined, isField ? 'instrText' : 't', this.wNamespace);
            writer.writeAttributeString('xml', 'space', this.xmlNamespace, 'preserve');
            writer.writeString(span.text);
            writer.writeEndElement();
        }
        writer.writeEndElement();
    }
    // Serializes the paragraph format
    serializeParagraphFormat(writer, paragraphFormat, paragraph) {
        if (!isNullOrUndefined(paragraphFormat.styleName)) {
            writer.writeStartElement(undefined, 'pStyle', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, paragraphFormat.styleName);
            writer.writeEndElement(); //end of pStyle
        }
        if (!isNullOrUndefined(paragraph)) {
            this.serializeListFormat(writer, paragraph.paragraphFormat.listFormat);
        }
        else {
            this.serializeListFormat(writer, paragraphFormat.listFormat);
        }
        this.serializeParagraphSpacing(writer, paragraphFormat);
        this.serializeIndentation(writer, paragraphFormat);
        this.serializeParagraphAlignment(writer, paragraphFormat.textAlignment);
        if (!isNullOrUndefined(paragraphFormat.tabs) && paragraphFormat.tabs.length > 0) {
            this.serializeTabs(writer, paragraphFormat.tabs);
        }
    }
    // Serialize Tabs
    serializeTabs(writer, tabStops) {
        writer.writeStartElement('w', 'tabs', this.wNamespace);
        for (let i = 0; i < tabStops.length; i++) {
            this.serializeTab(writer, tabStops[i]);
        }
        writer.writeEndElement();
    }
    serializeTab(writer, tabStop) {
        let position = 0;
        writer.writeStartElement('w', 'tab', this.wNamespace);
        if (tabStop.position === 0 && tabStop.deletePosition !== 0) {
            position = tabStop.deletePosition * this.twentiethOfPoint;
            writer.writeAttributeString('w', 'val', this.wNamespace, 'clear');
        }
        else {
            position = tabStop.position * this.twentiethOfPoint;
            writer.writeAttributeString('w', 'val', this.wNamespace, this.getTabJustification(tabStop.tabJustification));
        }
        if (!isNullOrUndefined(tabStop.tabLeader) && (tabStop.tabLeader !== 'None')) {
            writer.writeAttributeString('w', 'leader', this.wNamespace, this.getTabLeader(tabStop.tabLeader));
        }
        writer.writeAttributeString('w', 'pos', this.wNamespace, position.toString() + '');
        writer.writeEndElement();
    }
    getTabLeader(tabLeader) {
        switch (tabLeader) {
            case 'Dot':
                return 'dot';
            case 'Hyphen':
                return 'hyphen';
            case 'Underscore':
                return 'underscore';
            default:
                return 'none';
        }
    }
    getTabJustification(tabJustification) {
        switch (tabJustification) {
            case 'Bar':
                return 'bar';
            case 'Center':
                return 'center';
            case 'Decimal':
                return 'decimal';
            case 'Left':
                return 'left';
            case 'List':
                return 'num';
            case 'Right':
                return 'right';
            default:
                return 'clear';
        }
    }
    // // Seraializes the pargraph list format
    // private serializeListParagraph(writer: XmlWriter, paragraph: any): void {
    //     if (!isNullOrUndefined(paragraph.paragraphFormat.listFormat)) {
    //         this.serializeListFormat(writer, paragraph.paragraphFormat.listFormat);
    //     }
    // }
    // Serialize the list format
    serializeListFormat(writer, lf) {
        // let pStyleName = undefined;
        // if (lf.CurrentListStyle.IsBuiltInStyle && !isNullOrUndefined(lf.OwnerParagraph))
        // {
        //     pStyleName = lf.OwnerParagraph.StyleName;
        // }
        // int listId = GetListId(lf);
        // if (!isNullOrUndefined(pStyleName) && string.IsNullOrEmpty(lf.LFOStyleName)) 
        // {
        //     WordDocument doc = lf.OwnerParagraph.Document;
        //     WParagraphStyle style = doc.Styles.FindByName(pStyleName, StyleType.ParagraphStyle) as WParagraphStyle;
        //     if (style.ListIndex === -1)
        //     {
        //         ListStyle lstStyle = lf.OwnerParagraph.Document.ListStyles.FindByName(lf.CustomStyleName);
        //         style.ListIndex = listId;
        //         if (lstStyle.Levels.length > 1)
        //         {
        //             style.ListLevel = lf.ListLevelNumber;
        //         }
        //         pStyleName = pStyleName.Replace(' ', '');
        //         lstStyle.Levels[lf.ListLevelNumber].ParaStyleName = pStyleName;
        //     }
        // }
        // else
        // {
        // if (!isNullOrUndefined(lf.listId) && !isNullOrUndefined(lf.listLevelNumber)) {
        //     this.serializeNumPr(writer, lf.listId, lf.listLevelNumber);
        // }
        // }
        if (!isNullOrUndefined(lf.listId) || !isNullOrUndefined(lf.listLevelNumber)) {
            writer.writeStartElement(undefined, 'numPr', this.wNamespace);
            if (!isNullOrUndefined(lf.listLevelNumber) && lf.listLevelNumber !== -1) {
                writer.writeStartElement(undefined, 'ilvl', this.wNamespace);
                writer.writeAttributeString('w', 'val', this.wNamespace, lf.listLevelNumber.toString());
                writer.writeEndElement();
            }
            if (!isNullOrUndefined(lf.listId) && lf.listId !== -1) {
                writer.writeStartElement(undefined, 'numId', this.wNamespace);
                writer.writeAttributeString('w', 'val', this.wNamespace, (lf.listId + 1).toString());
                writer.writeEndElement();
            }
            writer.writeEndElement();
        }
    }
    // // Serializes the numbering properties to the paragraph
    // private serializeNumPr(writer: XmlWriter, listId: number, listLevel: number): void {
    //     writer.writeStartElement(undefined, 'numPr', this.wNamespace);
    //     if (listLevel !== -1) {
    //         writer.writeStartElement(undefined, 'ilvl', this.wNamespace);
    //         writer.writeAttributeString('w', 'val', this.wNamespace, listLevel.toString());
    //         writer.writeEndElement();
    //     }
    //     if (listId !== -1) {
    //         writer.writeStartElement(undefined, 'numId', this.wNamespace);
    //         writer.writeAttributeString('w', 'val', this.wNamespace, listId.toString());
    //         writer.writeEndElement();
    //     }
    //     writer.writeEndElement();
    // }
    serializeParagraphAlignment(writer, txtAlignment) {
        if (!isNullOrUndefined(txtAlignment)) {
            writer.writeStartElement(undefined, 'jc', this.wNamespace);
            let alignment;
            switch (txtAlignment) {
                case 'Center':
                    alignment = 'center';
                    break;
                case 'Right':
                    alignment = 'right';
                    break;
                case 'Justify':
                    alignment = 'both';
                    break;
                default:
                    alignment = 'left';
                    break;
            }
            writer.writeAttributeString('w', 'val', this.wNamespace, alignment);
            writer.writeEndElement();
        }
    }
    // Serializes the paragraph spacings
    serializeParagraphSpacing(writer, paragraphFormat) {
        writer.writeStartElement(undefined, 'spacing', this.wNamespace);
        // if (paragraphFormat.HasValue(WParagraphFormat.BeforeLinesKey))
        // {
        //     short beforeLines = (short)Math.Round(paragraphFormat.BeforeLines * DLSConstants.HundredthsUnit);
        //     writer.WriteAttributeString('beforeLines', this.wNamespace, ToString((float)beforeLines));               
        // }
        // if (paragraphFormat.HasValue(WParagraphFormat.AfterLinesKey))
        // {
        //     short afterLines = (short)Math.Round(paragraphFormat.AfterLines * DLSConstants.HundredthsUnit);
        //     writer.WriteAttributeString('afterLines', this.wNamespace, ToString((float)afterLines));                 
        // }
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(paragraphFormat.beforeSpacing)) {
            writer.writeAttributeString(undefined, 'before', this.wNamespace, this.roundToTwoDecimal(paragraphFormat.beforeSpacing * this.twentiethOfPoint).toString());
        }
        //TODO:ISSUEFIX(paragraphFormat.beforeSpacing * this.twentiethOfPoint).toString());
        // if (paragraphFormat.HasValue(WParagraphFormat.SpacingBeforeAutoKey))
        // {
        //     if (paragraphFormat.SpaceBeforeAuto)
        //     {
        //         writer.WriteAttributeString('beforeAutospacing', this.wNamespace, '1');
        //     }
        //     else
        //     {
        //         writer.WriteAttributeString('beforeAutospacing', this.wNamespace, '0');
        //     }
        // }
        if (!isNullOrUndefined(paragraphFormat.afterSpacing)) {
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString(undefined, 'after', this.wNamespace, this.roundToTwoDecimal(paragraphFormat.afterSpacing * this.twentiethOfPoint).toString());
        }
        //TODO:ISSUEFIX(paragraphFormat.afterSpacing * this.twentiethOfPoint).toString());
        // if (paragraphFormat.HasValue(WParagraphFormat.SpacingAfterAutoKey))
        // {
        //     if (paragraphFormat.SpaceAfterAuto)
        //     {
        //         writer.WriteAttributeString('afterAutospacing', this.wNamespace, '1');
        //     }
        //     else
        //     {
        //         writer.WriteAttributeString('afterAutospacing', this.wNamespace, '0');
        //     }
        // }
        writer.writeAttributeString(undefined, 'line', this.wNamespace, '240');
        //TODO:ISSUEFIX((paragraphFormat.lineSpacing) * this.twentiethOfPoint).toString());
        switch (paragraphFormat.lineSpacingType) {
            case 'AtLeast':
                writer.writeAttributeString(undefined, 'lineRule', this.wNamespace, 'atLeast');
                break;
            case 'Exactly':
                writer.writeAttributeString(undefined, 'lineRule', this.wNamespace, 'exact');
                break;
            default:
                writer.writeAttributeString(undefined, 'lineRule', this.wNamespace, 'auto');
                break;
        }
        writer.writeEndElement();
    }
    // Serializes the paragraph indentation
    serializeIndentation(writer, paragraphFormat) {
        writer.writeStartElement(undefined, 'ind', this.wNamespace);
        if (!isNullOrUndefined(paragraphFormat.leftIndent)) {
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString(undefined, 'left', this.wNamespace, this.roundToTwoDecimal(paragraphFormat.leftIndent * this.twipsInOnePoint).toString());
        }
        if (!isNullOrUndefined(paragraphFormat.rightIndent)) {
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString(undefined, 'right', this.wNamespace, this.roundToTwoDecimal(paragraphFormat.rightIndent * this.twipsInOnePoint).toString());
        }
        if (!isNullOrUndefined(paragraphFormat.firstLineIndent)) {
            if (paragraphFormat.firstLineIndent < 0) {
                // tslint:disable-next-line:max-line-length
                writer.writeAttributeString(undefined, 'hanging', this.wNamespace, this.roundToTwoDecimal(-1 * paragraphFormat.firstLineIndent * this.twipsInOnePoint).toString());
            }
            else {
                // tslint:disable-next-line:max-line-length
                writer.writeAttributeString(undefined, 'firstLine', this.wNamespace, this.roundToTwoDecimal(paragraphFormat.firstLineIndent * this.twipsInOnePoint).toString());
            }
        }
        writer.writeEndElement();
    }
    // Serialize the styles (styles.xml)
    serializeStyles() {
        let writer = new XmlWriter();
        writer.writeStartElement('w', 'styles', this.wNamespace);
        writer.writeAttributeString('xmlns', 'mc', undefined, this.veNamespace);
        writer.writeAttributeString('xmlns', 'r', undefined, this.rNamespace);
        writer.writeAttributeString('xmlns', 'w', undefined, this.wNamespace);
        writer.writeAttributeString('xmlns', 'w14', undefined, this.w14Namespace);
        writer.writeAttributeString('xmlns', 'w15', undefined, this.w15Namespace);
        writer.writeAttributeString('mc', 'Ignorable', undefined, 'w14 w15');
        //writes the document defaults, latent styles and default styles.
        this.serializeDefaultStyles(writer);
        //writes the document styles
        this.serializeDocumentStyles(writer);
        writer.writeEndElement(); //end of styles tag
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, this.stylePath);
        this.mArchive.addItem(zipArchiveItem); //this.stylePath, styleStream, false, FileAttributes.Archive);
    }
    // Serializes the default styles (document default paragraph and character format)
    serializeDefaultStyles(writer) {
        writer.writeStartElement(undefined, 'docDefaults', this.wNamespace);
        //if (HasDefaultCharFormat())
        //{
        writer.writeStartElement(undefined, 'rPrDefault', this.wNamespace);
        // if (!isNullOrUndefined(this.mDocument.characterFormat)) {
        this.serializeCharacterFormat(writer, this.defCharacterFormat);
        writer.writeEndElement(); // end of rPrDefault
        // }
        // else {
        //     writer.writeStartElement(undefined, 'rPr', this.wNamespace);
        //     writer.writeStartElement(undefined, 'rFonts', this.wNamespace);
        //     if (!string.IsNullOrEmpty(m_document.StandardAsciiFont))
        //         writer.WriteAttributeString('ascii', this.wNamespace, m_document.StandardAsciiFont);
        //     if (!string.IsNullOrEmpty(m_document.StandardFarEastFont))
        //         writer.WriteAttributeString('eastAsia', this.wNamespace, m_document.StandardFarEastFont);
        //     if (!string.IsNullOrEmpty(m_document.StandardNonFarEastFont))
        //         writer.WriteAttributeString('hAnsi', this.wNamespace, m_document.StandardNonFarEastFont);
        //     if (!string.IsNullOrEmpty(m_document.StandardBidiFont))
        //         writer.WriteAttributeString('cs', this.wNamespace, m_document.StandardBidiFont);
        //     writer.WriteEndElement();
        //     float fontSize = GetDefFontSize(m_document, WCharacterFormat.FontSizeKey);
        //     if (fontSize !== 0f)
        //     {
        //         writer.WriteStartElement('sz', this.wNamespace);
        //         writer.WriteAttributeString('val', this.wNamespace, (fontSize * 2).ToString(CultureInfo.InvariantCulture));
        //         writer.WriteEndElement();
        //     }
        //     fontSize = GetDefFontSize(m_document, WCharacterFormat.FontSizeBidiKey);
        //     if (fontSize !== 0f)
        //     {
        //         writer.WriteStartElement('szCs', this.wNamespace);
        //         writer.WriteAttributeString('val', this.wNamespace, (fontSize * 2).ToString(CultureInfo.InvariantCulture));
        //         writer.WriteEndElement();
        //     }
        //     writer.WriteEndElement();
        // }
        // writer.WriteEndElement();
        // //}
        writer.writeStartElement(undefined, 'pPrDefault', this.wNamespace);
        if (!isNullOrUndefined(this.defParagraphFormat)) {
            writer.writeStartElement(undefined, 'pPr', this.wNamespace);
            this.serializeParagraphFormat(writer, this.defParagraphFormat, undefined);
            writer.writeEndElement(); //end of pPr
        }
        writer.writeEndElement(); //end of pPrDefault
        // writer.WriteEndElement();
        // SerializeLatentStyles();
        // //Default styles
        // if (m_document.Styles.length === 0 || isNullOrUndefined(m_document.Styles.FindByName('Normal')))
        // {
        //     SerializeDefaultParagraphStyle();
        // }
        // if (!IsDocumentContainsDefaultTableStyle())
        // {
        //     SerializeTableNormalStyle();
        // }
        // if (isNullOrUndefined(m_document.Styles.FindByName('No List')) && isNullOrUndefined(m_document.Styles.FindByName('NoList')))
        //     SerializeNoListStyle();
        // tslint:disable-next-line:max-line-length
        // if (isNullOrUndefined(m_document.Styles.FindByName('Table Grid')) && isNullOrUndefined(m_document.Styles.FindByName('TableGrid')))
        // {
        //     SerializeTableGridStyle();
        // }
        // }        
        writer.writeEndElement();
    }
    serializeDocumentStyles(writer) {
        for (let i = 0; i < this.mStyles.length; i++) {
            let style = this.mStyles[i];
            writer.writeStartElement(undefined, 'style', this.wNamespace);
            let type = style.type === 'Paragraph' ? 'paragraph' : 'character';
            writer.writeAttributeString('w', 'type', this.wNamespace, type);
            writer.writeAttributeString('w', 'styleId', this.wNamespace, style.name);
            //name
            writer.writeStartElement(undefined, 'name', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, style.name);
            writer.writeEndElement();
            //basedOn
            if (!isNullOrUndefined(style.basedOn)) {
                writer.writeStartElement(undefined, 'basedOn', this.wNamespace);
                writer.writeAttributeString('w', 'val', this.wNamespace, style.basedOn);
                writer.writeEndElement();
            }
            //next
            if (!isNullOrUndefined(style.next)) {
                writer.writeStartElement(undefined, 'next', this.wNamespace);
                writer.writeAttributeString('w', 'val', this.wNamespace, style.next);
                writer.writeEndElement();
            }
            //link
            if (!isNullOrUndefined(style.link)) {
                writer.writeStartElement(undefined, 'link', this.wNamespace);
                writer.writeAttributeString('w', 'val', this.wNamespace, style.link);
                writer.writeEndElement();
            }
            if (style.type === 'Paragraph') {
                writer.writeStartElement(undefined, 'pPr', this.wNamespace);
                this.serializeParagraphFormat(writer, style.paragraphFormat, undefined);
                writer.writeEndElement();
            }
            // let value = (style.characterFormat as WCharacterFormat).newgetCharacterFormat();
            this.serializeCharacterFormat(writer, style.characterFormat);
            writer.writeEndElement(); //end of Style
        }
    }
    // Serializes the Character format
    serializeCharacterFormat(writer, characterFormat) {
        writer.writeStartElement(undefined, 'rPr', this.wNamespace);
        if (!isNullOrUndefined(characterFormat.styleName)) {
            writer.writeStartElement(undefined, 'rStyle', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, characterFormat.styleName);
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(characterFormat.fontFamily)) {
            writer.writeStartElement(undefined, 'rFonts', this.wNamespace);
            writer.writeAttributeString(undefined, 'ascii', this.wNamespace, characterFormat.fontFamily);
            writer.writeAttributeString(undefined, 'hAnsi', this.wNamespace, characterFormat.fontFamily);
            writer.writeAttributeString(undefined, 'eastAsia', this.wNamespace, characterFormat.fontFamily);
            writer.writeAttributeString(undefined, 'cs', this.wNamespace, characterFormat.fontFamily);
            writer.writeEndElement(); //end         
        }
        if (!isNullOrUndefined(characterFormat.bold)) {
            this.serializeBoolProperty(writer, 'b', characterFormat.bold);
        }
        if (!isNullOrUndefined(characterFormat.italic)) {
            this.serializeBoolProperty(writer, 'i', characterFormat.italic);
        }
        if (!isNullOrUndefined(characterFormat.strikethrough)) {
            switch (characterFormat.strikethrough) {
                case 'SingleStrike':
                    this.serializeBoolProperty(writer, 'strike', true);
                    break;
                case 'DoubleStrike':
                    this.serializeBoolProperty(writer, 'dstrike', true);
                    break;
                default:
                    this.serializeBoolProperty(writer, 'strike', false);
                    this.serializeBoolProperty(writer, 'dstrike', false);
                    break;
            }
        }
        if (!isNullOrUndefined(characterFormat.fontColor)) {
            writer.writeStartElement(undefined, 'color', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, this.getColor(characterFormat.fontColor));
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(characterFormat.fontSize)) {
            writer.writeStartElement(undefined, 'sz', this.wNamespace);
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString('w', 'val', this.wNamespace, this.roundToTwoDecimal(characterFormat.fontSize * 2).toString());
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(characterFormat.highlightColor) && characterFormat.highlightColor !== 'NoColor') {
            writer.writeStartElement(undefined, 'highlight', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, this.getHighlightColor(characterFormat.highlightColor));
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(characterFormat.underline) && characterFormat.underline !== 'None') {
            writer.writeStartElement(undefined, 'u', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, this.getUnderlineStyle(characterFormat.underline));
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(characterFormat.baselineAlignment)) {
            writer.writeStartElement(undefined, 'vertAlign', this.wNamespace);
            switch (characterFormat.baselineAlignment) {
                case 'Subscript':
                    writer.writeAttributeString('w', 'val', this.wNamespace, 'subscript');
                    break;
                case 'Superscript':
                    writer.writeAttributeString('w', 'val', this.wNamespace, 'superscript');
                    break;
                default:
                    writer.writeAttributeString('w', 'val', this.wNamespace, 'baseline');
                    break;
            }
            writer.writeEndElement();
        }
        writer.writeEndElement(); //end of rPrChange
    }
    getColor(color) {
        if (color.length > 0) {
            if (color[0] === '#') {
                color = color.substr(1);
            }
            if (color.length > 6) {
                color = color.substr(0, 6);
            }
        }
        return color;
    }
    // Get the underline style as string
    getUnderlineStyle(underlineStyle) {
        switch (underlineStyle) {
            case 'DotDotDashHeavy':
                return 'dashDotDotHeavy';
            case 'DotDashHeavy':
                return 'dashDotHeavy';
            case 'DashHeavy':
                return 'dashedHeavy';
            case 'DashLong':
                return 'dashLong';
            case 'DashLongHeavy':
                return 'dashLongHeavy';
            case 'DotDash':
                return 'dotDash';
            case 'DotDotDash':
                return 'dotDotDash';
            case 'Dotted':
                return 'dotted';
            case 'DottedHeavy':
                return 'dottedHeavy';
            case 'Double':
                return 'double';
            case 'Single':
                return 'single';
            case 'Thick':
                return 'thick';
            case 'Wavy':
                return 'wave';
            case 'WavyDouble':
                return 'wavyDouble';
            case 'WavyHeavy':
                return 'wavyHeavy';
            case 'Words':
                return 'words';
            default:
                return 'dash';
        }
    }
    getHighlightColor(highlight) {
        switch (highlight) {
            // Highlights the content with bright green (#ff00ff00) color.
            case 'BrightGreen':
                return 'green';
            // Highlights the content with turquoise (#ff00ffff) color.
            case 'Turquoise':
                return 'cyan';
            // Highlights the content with pink (#ffff00ff) color.
            case 'Pink':
                return 'magenta';
            // Highlights the content with blue (#ff0000ff) color.
            case 'Blue':
                return 'blue';
            // Highlights the content with red (#ffff0000) color.
            case 'Red':
                return 'red';
            // Highlights the content with dark blue (#ff000080) color.
            case 'DarkBlue':
                return 'darkBlue';
            // Highlights the content with teal (#ff008080) color.
            case 'Teal':
                return 'darkCyan';
            // Highlights the content with green (#ff008000) color.
            case 'Green':
                return 'darkGreen';
            // Highlights the content with violet (#ff800080) color.
            case 'Violet':
                return 'darkMagenta';
            // Highlights the content with dark red (#ff800000) color.
            case 'DarkRed':
                return 'darkRed';
            // Highlights the content with dark yellow (#ff808000)  color.
            case 'DarkYellow':
                return 'darkYellow';
            // Highlights the content with gray 50 (#ff808080) color.
            case 'Gray50':
                return 'darkGray';
            // Highlights the content with gray 25 (#ffc0c0c0) color.
            case 'Gray25':
                return 'lightGray';
            // Highlights the content with black (#ff000000) color.
            case 'Black':
                return 'black';
            // Highlights the content with yellow (#ffffff00) color.
            default:
                return 'yellow';
        }
    }
    /*private toggleFirstCahar(text: string) {
        return text.charAt(0).toLowerCase() + text.slice(1);
    }*/
    // Serializes the bool character format property
    serializeBoolProperty(writer, tag, value) {
        writer.writeStartElement(undefined, tag, this.wNamespace);
        if (!value) {
            writer.writeAttributeString(undefined, 'val', this.wNamespace, '0');
        }
        writer.writeEndElement();
    }
    // Serialize the list styles and numberings (numberings.xml)
    serializeNumberings() {
        if (this.document.lists.length === 0) {
            return;
        }
        let writer = new XmlWriter();
        writer.writeStartElement('w', 'numbering', this.wNamespace);
        this.writeCommonAttributeStrings(writer);
        // this.serializePictureBullets(writer, this.mDocument.lists);
        this.serializeAbstractListStyles(writer, this.document.abstractLists);
        this.serializeListInstances(writer, this.document.lists);
        // SerializeListOverrides(writer, this.mDocument.ridesm_document.ListOverrides);
        writer.writeEndElement();
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, this.numberingPath);
        this.mArchive.addItem(zipArchiveItem);
    }
    // Serializes the abstract list styles
    serializeAbstractListStyles(writer, listStyles) {
        for (let i = 0; i < listStyles.length; i++) {
            let abstractList = listStyles[i];
            writer.writeStartElement(undefined, 'abstractNum', this.wNamespace);
            writer.writeAttributeString(undefined, 'abstractNumId', this.wNamespace, abstractList.abstractListId.toString());
            writer.writeStartElement(undefined, 'nsid', this.wNamespace);
            writer.writeAttributeString(undefined, 'val', this.wNamespace, this.generateHex());
            writer.writeEndElement();
            for (let ilvl = 0, cnt = abstractList.levels.length; ilvl < cnt; ilvl++) {
                this.serializeListLevel(writer, abstractList.levels[ilvl], ilvl);
            }
            writer.writeEndElement(); //end of abstractNum
        }
    }
    // Serializes the list styles
    serializeListInstances(writer, listStyles) {
        for (let i = 0; i < listStyles.length; i++) {
            let list = listStyles[i];
            writer.writeStartElement(undefined, 'num', this.wNamespace);
            writer.writeAttributeString(undefined, 'numId', this.wNamespace, (list.listId + 1).toString());
            writer.writeStartElement(undefined, 'abstractNumId', this.wNamespace);
            writer.writeAttributeString(undefined, 'val', this.wNamespace, list.abstractListId.toString());
            writer.writeEndElement();
            writer.writeEndElement();
        }
    }
    generateHex() {
        return (Math.floor(Math.random() * (4000000000 - 270000000)) + 270000000).toString(16).toUpperCase();
    }
    roundToTwoDecimal(num) {
        return Math.round(num); // * 100) / 100;
    }
    // Serialize the list level
    serializeListLevel(writer, listLevel, levelIndex) {
        writer.writeStartElement(undefined, 'lvl', this.wNamespace);
        writer.writeAttributeString(undefined, 'ilvl', this.wNamespace, levelIndex.toString());
        writer.writeStartElement(undefined, 'start', this.wNamespace);
        writer.writeAttributeString(undefined, 'val', this.wNamespace, listLevel.startAt.toString());
        writer.writeEndElement();
        writer.writeStartElement(undefined, 'numFmt', this.wNamespace);
        writer.writeAttributeString(undefined, 'val', this.wNamespace, this.getLevelPattern(listLevel.listLevelPattern));
        writer.writeEndElement();
        if (listLevel.restartLevel > 0) {
            writer.writeStartElement(undefined, 'lvlRestart', this.wNamespace);
            writer.writeAttributeString(undefined, 'val', this.wNamespace, '0');
            writer.writeEndElement();
        }
        // if (!isNullOrUndefined(listLevel.paragraphFormat)) {
        //     string name = listLevel.ParaStyleName.Substring(0, 1).ToUpper() + listLevel.ParaStyleName.Remove(0, 1);
        //     writer.WriteStartElement('pStyle', this.wNamespace);
        //     writer.WriteAttributeString('val', this.wNamespace, name);
        //     writer.WriteEndElement();
        // }
        // if (listLevel.IsLegalStyleNumbering) {
        //     writer.WriteStartElement('isLgl', this.wNamespace);
        //     writer.WriteEndElement();
        // }
        this.serializeLevelFollow(writer, listLevel);
        this.serializeLevelText(writer, listLevel, levelIndex + 1);
        // SerializeLegacyProperties(listLevel);
        // if (listLevel.PicBulletId > 0) {
        //     writer.WriteStartElement('lvlPicBulletId', this.wNamespace);
        //     writer.WriteAttributeString('val', this.wNamespace, listLevel.PicBulletId.ToString());
        //     writer.WriteEndElement();
        // }
        // //lvlJc
        // if (listLevel.NumberAlignment !== ListNumberAlignment.Left) {
        //     writer.WriteStartElement('lvlJc', this.wNamespace);
        //     string alignment = string.Empty;
        //     if (listLevel.NumberAlignment === ListNumberAlignment.Right) {
        //         alignment = 'right';
        //     }
        //     else {
        //         alignment = 'center';
        //     }
        //     writer.WriteAttributeString('val', this.wNamespace, alignment);
        //     writer.WriteEndElement();
        // }
        writer.writeStartElement(undefined, 'pPr', this.wNamespace);
        this.serializeParagraphFormat(writer, listLevel.paragraphFormat, undefined);
        writer.writeEndElement(); //end of pPr
        this.serializeCharacterFormat(writer, listLevel.characterFormat);
        writer.writeEndElement();
    }
    getLevelPattern(levelPattern) {
        let patternType;
        switch (levelPattern) {
            case 'Arabic':
                patternType = 'decimal';
                break;
            case 'UpRoman':
                patternType = 'upperRoman';
                break;
            case 'LowRoman':
                patternType = 'lowerRoman';
                break;
            case 'UpLetter':
                patternType = 'upperLetter';
                break;
            case 'LowLetter':
                patternType = 'lowerLetter';
                break;
            // case 'Ordinal':
            //     patternType = 'ordinal';
            //     break;
            // case 'Number':
            //     patternType = 'cardinalText';
            //     break;
            // case 'OrdinalText':
            //     patternType = 'ordinalText';
            //     break;
            // case 'LeadingZero':
            //     patternType = 'decimalZero';
            //     break;
            // case 'Bullet':
            default:
                patternType = 'bullet';
                break;
        }
        return patternType;
    }
    // Serializes the level text
    serializeLevelText(writer, listLevel, lvlIndex) {
        writer.writeStartElement(undefined, 'lvlText', this.wNamespace);
        writer.writeAttributeString(undefined, 'val', this.wNamespace, (listLevel.numberFormat));
        writer.writeEndElement();
    }
    // Serialize the level follow character
    serializeLevelFollow(writer, listLevel) {
        let fc;
        //TODO:Type issue returns number instead of string
        if (listLevel.followCharacter === 'Tab') {
            fc = 'tab';
        }
        else if (listLevel.followCharacter === 'Space') {
            fc = 'space';
        }
        else {
            fc = 'nothing';
        }
        writer.writeStartElement(undefined, 'suff', this.wNamespace);
        writer.writeAttributeString(undefined, 'val', this.wNamespace, fc);
        writer.writeEndElement();
    }
    serializeSettings() {
        let writer = new XmlWriter();
        writer.writeStartElement('w', 'settings', this.wNamespace);
        this.writeCustom(writer);
        // writer.writeAttributeString('xmlns', 'mc', undefined, this.veNamespace);
        // writer.writeAttributeString('xmlns', 'o', undefined, this.oNamespace);
        // writer.writeAttributeString('xmlns', 'r', undefined, this.rNamespace);
        // writer.writeAttributeString('xmlns', 'm', undefined, this.mNamespace);
        // writer.writeAttributeString('xmlns', 'v', undefined, this.vNamespace);
        writer.writeAttributeString('xmlns', 'w10', undefined, this.w10Namespace);
        writer.writeAttributeString('xmlns', 'w14', undefined, this.w14Namespace);
        writer.writeAttributeString('xmlns', 'w15', undefined, this.w15Namespace);
        writer.writeAttributeString('xmlns', 'sl', undefined, this.slNamespace);
        writer.writeAttributeString('mc', 'Ignorable', undefined, 'w14 w15');
        // //w:writeProtection - Write Protection
        // if (m_document.WriteProtected)
        // {
        //     writer.writeStartElement('w', 'writeProtection', this.wNamespace);
        //     writer.writeAttributeString('recommended', this.wNamespace, '1');
        //     writer.writeEndElement();
        // }
        //w:view - Document View Setting
        // if (this.mDocument.ViewSetup.DocumentViewType !== DocumentViewType.PrintLayout &&
        //   m_document.ViewSetup.DocumentViewType !== DocumentViewType.NormalLayout)
        // {
        //     writer.writeStartElement('view', this.wNamespace);
        //     string viewTypeStr = string.Empty;
        //     if (m_document.ViewSetup.DocumentViewType === DocumentViewType.OutlineLayout)
        //     {
        //         viewTypeStr = 'outline';
        //     }
        //     else if (m_document.ViewSetup.DocumentViewType === DocumentViewType.WebLayout)
        //     {
        //         viewTypeStr = 'web';
        //     }
        //     writer.writeAttributeString('val', this.wNamespace, viewTypeStr);
        //     writer.writeEndElement();
        // }
        //w:zoom - Magnification Setting
        writer.writeStartElement('w', 'zoom', this.wNamespace);
        // switch (m_document.ViewSetup.ZoomType)
        // {
        //     case ZoomType.FullPage:
        //         writer.writeAttributeString('w', 'val', this.wNamespace, 'fullPage');
        //         break;
        //     case ZoomType.PageWidth:
        //         writer.writeAttributeString('w', 'val', this.wNamespace, 'bestFit');
        //         break;
        //     case ZoomType.TextFit:
        //         writer.writeAttributeString('w', 'val', this.wNamespace, 'textFit');
        //         break;
        // default:
        writer.writeAttributeString('w', 'val', this.wNamespace, 'none');
        // break;
        // }
        writer.writeAttributeString('w', 'percent', this.wNamespace, '100');
        writer.writeEndElement();
        //w:displayBackgroundShape - Display Background Objects When Displaying Document
        // if (m_document.Background.Type !== BackgroundType.NoBackground)
        // {
        writer.writeStartElement(undefined, 'displayBackgroundShape', this.wNamespace);
        writer.writeEndElement();
        // }
        //w:defaultTabStop - Distance Between Automatic Tab Stops
        writer.writeStartElement(undefined, 'defaultTabStop', this.wNamespace);
        let tabWidth = Math.round(this.defaultTabWidthValue * this.twipsInOnePoint);
        writer.writeAttributeString(undefined, 'val', this.wNamespace, tabWidth.toString());
        writer.writeEndElement();
        //w:evenAndOddHeaders - Different Even/Odd Page Headers and Footers        
        if (this.mDifferentFirstPage) {
            writer.writeStartElement(undefined, 'evenAndOddHeaders', this.wNamespace);
            writer.writeEndElement();
        }
        //w:footnotePr - Document-Wide Footnote Properties and w:endnotePr - Document-Wide Endnote Properties
        // SerializeFootnoteSettings();
        //w:compat - Compatibility Settings
        writer.writeStartElement(undefined, 'compat', this.wNamespace);
        writer.writeStartElement(undefined, 'compatSetting', this.wNamespace);
        writer.writeAttributeString(undefined, 'name', this.wNamespace, 'compatibilityMode');
        writer.writeAttributeString(undefined, 'uri', this.wNamespace, 'http://schemas.microsoft.com/office/word');
        writer.writeAttributeString(undefined, 'val', this.wNamespace, '15');
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeEndElement();
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, this.settingsPath);
        this.mArchive.addItem(zipArchiveItem);
    }
    serializeCoreProperties() {
        //implementation
    }
    serializeAppProperties() {
        //implementation
    }
    serializeFontTable(contentType) {
        //implementation
    }
    serializeSettingsRelation() {
        //implementation
    }
    serializeHeaderFooters() {
        this.serializeHeaderFooter('EvenFooter');
        this.serializeHeaderFooter('EvenHeader');
        this.serializeHeaderFooter('FirstPageFooter');
        this.serializeHeaderFooter('FirstPageHeader');
        this.serializeHeaderFooter('OddFooter');
        this.serializeHeaderFooter('OddHeader');
    }
    // Serializes the Header/Footer
    serializeHeaderFooter(hfType) {
        if (this.headersFooters.length === 0) {
            return;
        }
        let headerFooterPath;
        let headerFooterRelsPath;
        if (!this.headersFooters.containsKey(hfType)) {
            return;
        }
        let hfColl = this.headersFooters.get(hfType);
        let hf = undefined;
        for (let i = 0; i < hfColl.keys.length; i++) {
            let id = hfColl.keys[i];
            hf = hfColl.get(id);
            if (hfType === 'EvenHeader' || hfType === 'FirstPageHeader' ||
                hfType === 'OddHeader') {
                headerFooterPath = this.headerPath + id.replace('rId', '') + '.xml';
                headerFooterRelsPath = this.headerRelationPath + id.replace('rId', '') + '.xml.rels';
                this.serializeHeader(hf, id, headerFooterPath, headerFooterRelsPath);
            }
            else {
                headerFooterPath = this.footerPath + id.replace('rId', '') + '.xml';
                headerFooterRelsPath = this.footerRelationPath + id.replace('rId', '') + '.xml.rels';
                this.serializeFooter(hf, id, headerFooterPath, headerFooterRelsPath);
            }
        }
    }
    // Serialize the header part
    serializeHeader(header, id, headerFooterPath, headerFooterRelsPath) {
        this.headerFooter = header;
        let writer = new XmlWriter();
        writer.writeStartElement('w', 'hdr', this.wNamespace);
        this.writeHFCommonAttributes(writer);
        let owner = this.blockOwner;
        this.blockOwner = header;
        this.serializeBodyItems(writer, header.blocks, true);
        this.blockOwner = owner;
        writer.writeEndElement();
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, headerFooterPath);
        this.mArchive.addItem(zipArchiveItem);
        this.serializeHFRelations(id, headerFooterRelsPath);
        this.headerFooter = undefined;
    }
    // Serializes the HeaderFooter relations
    serializeHFRelations(hfId, headerFooterRelsPath) {
        let hasHFImage = this.headerFooterImages.containsKey(hfId);
        // let hasHFHyperlinks = HeaderFooterHyperlinks.ContainsKey(hfId);
        // let hasHFInclPics = HeaderFooterInclPicUrls.ContainsKey(hfId);
        // let hasHFAlternateChunks = HeaderFooterAlternateChunks.ContainsKey(hfId);
        if (hasHFImage) {
            let writer = new XmlWriter();
            writer.writeStartElement(undefined, 'Relationships', this.rpNamespace);
            this.serializeImagesRelations(this.headerFooterImages.get(hfId), writer);
            // if (hasHFHyperlinks)
            //     SerializeHyperlinkRelations(stream, HeaderFooterHyperlinks[hfId]);
            // if (hasHFAlternateChunks)
            //     SerializeAltChunkRelations(stream, HeaderFooterAlternateChunks[hfId]);
            // if (hasHFInclPics)
            //     SerializeIncludePictureUrlRelations(stream, HeaderFooterInclPicUrls[hfId]);
            // if (HFOleContainers.ContainsKey(hfId))
            // {
            //     AddOLEToZip(HFOleContainers[hfId]);
            // }
            // if (HFRelations.ContainsKey(hfId))
            //     SerializeHFCommonRelations(stream, HFRelations[hfId]);
            writer.writeEndElement();
            let zipArchiveItem = new ZipArchiveItem(writer.buffer, headerFooterRelsPath);
            this.mArchive.addItem(zipArchiveItem);
        }
        else {
            return;
        }
    }
    writeHFCommonAttributes(writer) {
        writer.writeAttributeString('xmlns', 'v', undefined, this.vNamespace);
        writer.writeAttributeString('xmlns', 'w10', undefined, this.w10Namespace);
        writer.writeAttributeString('xmlns', 'o', undefined, this.oNamespace);
        writer.writeAttributeString('xmlns', 've', undefined, this.veNamespace);
        writer.writeAttributeString('xmlns', 'r', undefined, this.rNamespace);
        writer.writeAttributeString('xmlns', 'm', undefined, this.mNamespace);
        writer.writeAttributeString('xmlns', 'wne', undefined, this.wneNamespace);
        writer.writeAttributeString('xmlns', 'a', undefined, this.aNamespace);
        writer.writeAttributeString('xmlns', 'pic', undefined, this.pictureNamespace);
        writer.writeAttributeString('xmlns', 'wp', undefined, this.wpNamespace);
        writer.writeAttributeString('xmlns', 'wpc', undefined, this.wpCanvasNamespace);
        writer.writeAttributeString('xmlns', 'wp14', undefined, this.wpDrawingNamespace);
        this.writeDup(writer);
        writer.writeAttributeString('xmlns', 'wps', undefined, this.wpShapeNamespace);
        writer.writeAttributeString('ve', 'Ignorable', undefined, 'w14 w15 wp14');
    }
    // Serailize the footer and its relations
    serializeFooter(footer, id, headerFooterPath, headerFooterRelsPath) {
        this.headerFooter = footer;
        let writer = new XmlWriter();
        writer.writeStartElement('w', 'ftr', this.wNamespace);
        this.writeHFCommonAttributes(writer);
        this.serializeBodyItems(writer, footer.blocks, true);
        writer.writeEndElement();
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, headerFooterPath);
        this.mArchive.addItem(zipArchiveItem);
        this.serializeHFRelations(id, headerFooterRelsPath);
    }
    serializeDocumentRelations() {
        let writer = new XmlWriter();
        writer.writeStartElement(undefined, 'Relationships', this.rpNamespace);
        this.serializeRelationShip(writer, this.getNextRelationShipID(), this.stylesRelType, 'styles.xml');
        this.serializeRelationShip(writer, this.getNextRelationShipID(), this.settingsRelType, 'settings.xml');
        // this.serializeRelationShip(writer, this.getNextRelationShipID(), this.ThemeRelType, 'theme/theme1.xml');
        if (this.document.lists.length > 0) {
            this.serializeRelationShip(writer, this.getNextRelationShipID(), this.numberingRelType, 'numbering.xml');
        }
        this.serializeHeaderFooterRelations(writer);
        // if (HasFontTable) {
        //     SerializeRelationShip(docRelstream, GetNextRelationShipID(), this.FontTableRelType, 'fontTable.xml');
        // }
        // SerializeIncludePictureUrlRelations(docRelstream, InclPicFieldUrl);
        // //// Creating relationships for every hyperlink and image containing in the document
        this.serializeImagesRelations(this.documentImages, writer);
        // SerializeSvgImageRelation();
        //this.serializeExternalLinkImages(writer);
        // if (HasHyperlink && HyperlinkTargets.length > 0) {
        //     SerializeHyperlinkRelations(docRelstream, HyperlinkTargets);
        // }
        // if (m_document.HasMacros
        //     && IsMacroEnabled)
        //     SerializeRelationShip(docRelstream, GetNextRelationShipID(), this.VbaProjectRelType, this.VbaProject);
        writer.writeEndElement();
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, this.wordRelationPath);
        this.mArchive.addItem(zipArchiveItem);
        this.headerFooter = undefined;
    }
    // Serializes the image relations
    serializeImagesRelations(images, writer) {
        if (images.length > 0) {
            let imagePath = '';
            let base64ImageString;
            let keys = images.keys;
            for (let i = 0; i < keys.length; i++) {
                let mImage = images.get(keys[i]);
                base64ImageString = mImage.imageString;
                if (isNullOrUndefined(base64ImageString)) {
                    imagePath = this.imagePath + '/0.jpeg';
                    this.serializeRelationShip(writer, keys[i], this.imageRelType, imagePath.replace('word/', ''));
                }
                else {
                    let extension = '';
                    let formatClippedString = '';
                    if (this.startsWith(base64ImageString, 'data:image/bmp;base64,')) {
                        extension = '.bmp';
                        formatClippedString = base64ImageString.replace('data:image/bmp;base64,', '');
                    }
                    else if (this.startsWith(base64ImageString, 'data:image/x-emf;base64,')) {
                        extension = '.emf';
                        formatClippedString = base64ImageString.replace('data:image/x-emf;base64,', '');
                    }
                    else if (this.startsWith(base64ImageString, 'data:image/exif;base64,')) {
                        extension = '.exif';
                        formatClippedString = base64ImageString.replace('data:image/exif;base64,', '');
                    }
                    else if (this.startsWith(base64ImageString, 'data:image/gif;base64,')) {
                        extension = '.gif';
                        formatClippedString = base64ImageString.replace('data:image/gif;base64,', '');
                    }
                    else if (this.startsWith(base64ImageString, 'data:image/icon;base64,')) {
                        extension = '.ico';
                        formatClippedString = base64ImageString.replace('data:image/icon;base64,', '');
                    }
                    else if (this.startsWith(base64ImageString, 'data:image/jpeg;base64,')) {
                        extension = '.jpeg';
                        formatClippedString = base64ImageString.replace('data:image/jpeg;base64,', '');
                    }
                    else if (this.startsWith(base64ImageString, 'data:image/jpg;base64,')) {
                        extension = '.jpg';
                        formatClippedString = base64ImageString.replace('data:image/jpg;base64,', '');
                    }
                    else if (this.startsWith(base64ImageString, 'data:image/png;base64,')) {
                        extension = '.png';
                        formatClippedString = base64ImageString.replace('data:image/png;base64,', '');
                    }
                    else if (this.startsWith(base64ImageString, 'data:image/tiff;base64,')) {
                        extension = '.tif';
                        formatClippedString = base64ImageString.replace('data:image/tiff;base64,', '');
                    }
                    else if (this.startsWith(base64ImageString, 'data:image/x-wmf;base64,')) {
                        extension = '.wmf';
                        formatClippedString = base64ImageString.replace('data:image/x-wmf;base64,', '');
                    }
                    else {
                        extension = '.jpeg';
                    }
                    imagePath = this.imagePath + keys[i] + extension;
                    this.serializeRelationShip(writer, keys[i], this.imageRelType, imagePath.replace('word/', ''));
                    //if (m_archive.Find(imagePath.Replace('\\', '/')) === -1)
                    // {
                    let imageBlob = new Blob([this.encodedString(formatClippedString)]);
                    let zipArchiveItem = new ZipArchiveItem(imageBlob, imagePath);
                    // let TestArchive = new ZipArchive();
                    this.mArchive.addItem(zipArchiveItem);
                    // TestArchive.save('image.zip').then(function (): void {
                    //     TestArchive.destroy();
                    // });
                    // }
                }
            }
        }
    }
    /**
     * @private
     */
    encodedString(input) {
        let keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        let chr1;
        let chr2;
        let chr3;
        let enc1;
        let enc2;
        let enc3;
        let enc4;
        let i = 0;
        let resultIndex = 0;
        /*let dataUrlPrefix: string = 'data:';*/
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
        let totalLength = input.length * 3 / 4;
        if (input.charAt(input.length - 1) === keyStr.charAt(64)) {
            totalLength--;
        }
        if (input.charAt(input.length - 2) === keyStr.charAt(64)) {
            totalLength--;
        }
        if (totalLength % 1 !== 0) {
            // totalLength is not an integer, the length does not match a valid
            // base64 content. That can happen if:
            // - the input is not a base64 content
            // - the input is *almost* a base64 content, with a extra chars at the
            // beginning or at the end
            // - the input uses a base64 variant (base64url for example)
            throw new Error('Invalid base64 input, bad content length.');
        }
        let output = new Uint8Array(totalLength | 0);
        while (i < input.length) {
            enc1 = keyStr.indexOf(input.charAt(i++));
            enc2 = keyStr.indexOf(input.charAt(i++));
            enc3 = keyStr.indexOf(input.charAt(i++));
            enc4 = keyStr.indexOf(input.charAt(i++));
            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;
            output[resultIndex++] = chr1;
            if (enc3 !== 64) {
                output[resultIndex++] = chr2;
            }
            if (enc4 !== 64) {
                output[resultIndex++] = chr3;
            }
        }
        return output;
    }
    serializeExternalLinkImages(writer) {
        let keys = this.externalImages.keys;
        for (let i = 0; i < this.externalImages.keys.length; i++) {
            this.serializeRelationShip(writer, keys[i], this.imageRelType, this.externalImages.get(keys[i]));
        }
    }
    // Serializes the HeaderFooters relations to the document relations stream
    serializeHeaderFooterRelations(writer) {
        this.serializeHFRelation(writer, 'EvenFooter');
        this.serializeHFRelation(writer, 'EvenHeader');
        this.serializeHFRelation(writer, 'FirstPageFooter');
        this.serializeHFRelation(writer, 'FirstPageHeader');
        this.serializeHFRelation(writer, 'OddFooter');
        this.serializeHFRelation(writer, 'OddHeader');
    }
    // Serializes the headers footers relations.
    serializeHFRelation(writer, hfType) {
        let headerFooterPath = '';
        let relType;
        if (!this.headersFooters.containsKey(hfType)) {
            return;
        }
        let hfColl = this.headersFooters.get(hfType);
        for (let i = 0; i < hfColl.keys.length; i++) {
            let id = hfColl.keys[i];
            if (hfType === 'EvenHeader' || hfType === 'FirstPageHeader' ||
                hfType === 'OddHeader') {
                headerFooterPath = 'header' + id.replace('rId', '') + '.xml';
                relType = this.headerRelType;
            }
            else {
                headerFooterPath = 'footer' + id.replace('rId', '') + '.xml';
                relType = this.footerRelType;
            }
            this.serializeRelationShip(writer, id, relType, headerFooterPath);
        }
    }
    // Serializes the relationship
    serializeRelationShip(writer, relationshipID, relationshipType, targetPath) {
        writer.writeStartElement(undefined, 'Relationship', undefined);
        writer.writeAttributeString(undefined, 'Id', undefined, relationshipID);
        writer.writeAttributeString(undefined, 'Type', undefined, relationshipType);
        writer.writeAttributeString(undefined, 'Target', undefined, targetPath.replace('\\', '/').replace('\v', ''));
        // tslint:disable-next-line:max-line-length
        if (relationshipType === this.hyperlinkRelType || this.startsWith(targetPath, 'http://') || this.startsWith(targetPath, 'https://') || this.startsWith(targetPath, 'file:///')) {
            // Uri targetUri;
            // if ((!targetPath.StartsWith('file:///')) && Uri.TryCreate(targetPath, UriKind.Absolute, out targetUri))
            // {
            //     //Handled using Try catch to avoid exception if the Host name type is None because in 
            //Silverlight 'HostNameType' property is not available.
            //     try
            //     {
            //         m_writer.WriteAttributeString('Target', targetUri.AbsoluteUri);
            //     }
            //     catch
            //     {
            //         m_writer.WriteAttributeString('Target', targetPath.Replace('\\', '/').Replace(ControlChar.LineBreak, string.Empty));
            //     }
            // }
            // else
            // {
            //     m_writer.WriteAttributeString('Target', targetPath.Replace('\\', '/').Replace(ControlChar.LineBreak, string.Empty));
            // }
            writer.writeAttributeString(undefined, 'TargetMode', undefined, 'External');
        }
        writer.writeEndElement();
    }
    // Get the next relationship ID
    getNextRelationShipID() {
        return 'rId' + (++this.mRelationShipID);
    }
    serializeGeneralRelations() {
        let writer = new XmlWriter();
        this.resetRelationShipID();
        writer.writeStartElement(undefined, 'Relationships', this.rpNamespace);
        this.serializeRelationShip(writer, this.getNextRelationShipID(), this.documentRelType, this.documentPath);
        // this.serializeRelationShip(writer, this.getNextRelationShipID(), this.AppRelType, this.appPath);
        // this.serializeRelationShip(writer, this.getNextRelationShipID(), this.CoreRelType, this.corePath);
        //End of Relationships tag
        writer.writeEndElement();
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, this.generalRelationPath);
        this.mArchive.addItem(zipArchiveItem);
    }
    serializeContentTypes(contentType) {
        let writer = new XmlWriter();
        writer.writeStartElement(undefined, 'Types', 'http://schemas.openxmlformats.org/package/2006/content-types');
        //if (m_hasOleObject)
        //{
        //    //<Default Extension='bin' ContentType='application/vnd.openxmlformats-officedocument.oleObject'/>
        //    SerializeDefaultContentType(contentStream, 'bin', 'application/vnd.openxmlformats-officedocument.oleObject');
        //}
        this.serializeDefaultContentType(writer, 'rels', this.relationContentType);
        this.serializeDefaultContentType(writer, 'xml', this.xmlContentType);
        // if (m_hasEmbedFonts && !string.IsNullOrEmpty(type))
        // {
        //     SerializeDefaultContentType(contentStream,type, this.fontContentType);
        // }
        if (this.documentImages.length > 0 || this.externalImages.length > 0 || this.headerFooterImages.length > 0) {
            this.serializeDefaultContentType(writer, 'png', 'image/png');
            this.serializeDefaultContentType(writer, 'bmp', 'image/bmp');
            this.serializeDefaultContentType(writer, 'emf', 'image/x-emf');
            this.serializeDefaultContentType(writer, 'wmf', 'image/x-wmf');
            this.serializeDefaultContentType(writer, 'gif', 'image/gif');
            this.serializeDefaultContentType(writer, 'ico', 'image/x-icon');
            this.serializeDefaultContentType(writer, 'tif', 'image/tiff');
            this.serializeDefaultContentType(writer, 'tiff', 'image/tiff');
            this.serializeDefaultContentType(writer, 'jpeg', 'image/jpeg');
            this.serializeDefaultContentType(writer, 'jpg', 'image/jpeg');
            this.serializeDefaultContentType(writer, 'svg', 'image/svg+xml');
        }
        // if (m_document.HasMacros
        //     && IsMacroEnabled && !m_isSkipBinExtension)
        // {
        //     SerializeDefaultContentType(contentStream, 'bin', this.VbaProjectContentType);
        //     m_isSkipBinExtension = true;
        // }
        // if (m_hasOleObject)
        // {
        //     SerializeOleContentType(contentStream);
        // }
        //document.xml
        this.serializeOverrideContentType(writer, this.documentPath, this.documentContentType);
        // tslint:disable-next-line:max-line-length
        //<Override PartName='/word/numbering.xml' ContentType='application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml'/>
        // if (HasNumbering) {
        this.serializeOverrideContentType(writer, this.numberingPath, this.numberingContentType);
        // }
        //Add the header/footer Alternate chunks
        // if (HeaderFooterAlternateChunks.length > 0) {
        //     foreach(Dictionary < string, string > item in m_headerFooterAlternateChunks.Values)
        //     AddAlternateChunkItem(item);
        // }
        //styles.xml
        this.serializeOverrideContentType(writer, this.stylePath, this.stylesContentType);
        //settings.xml
        this.serializeOverrideContentType(writer, this.settingsPath, this.settingsContentType);
        //             //core.xml
        //             SerializeOverrideContentType(contentStream, this.corePath, this.CoreContentType);
        //             //app.xml
        //             SerializeOverrideContentType(contentStream, this.appPath, this.AppContentType);
        //             //custom.xml
        //             if (!isNullOrUndefined(m_document.CustomDocumentProperties) && m_document.CustomDocumentProperties.length > 0)
        //                 SerializeOverrideContentType(contentStream, this.CustomPath, this.CustomContentType);
        // #if Chart
        //             if (m_hasChart)
        //                 SerializeChartContentType(contentStream);
        // #endif
        this.serializeHFContentTypes(writer);
        // WriteXmlItemsContentTypes(contentStream);
        //End of Types tag
        writer.writeEndElement();
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, this.contentTypesPath);
        this.mArchive.addItem(zipArchiveItem);
    }
    // Serializes the HeaderFooter content types
    serializeHFContentTypes(writer) {
        this.serializeHeaderFootersContentType(writer, 'EvenFooter');
        this.serializeHeaderFootersContentType(writer, 'EvenHeader');
        this.serializeHeaderFootersContentType(writer, 'FirstPageFooter');
        this.serializeHeaderFootersContentType(writer, 'FirstPageHeader');
        this.serializeHeaderFootersContentType(writer, 'OddFooter');
        this.serializeHeaderFootersContentType(writer, 'OddHeader');
    }
    // Serializes the HeaderFooter content types.
    serializeHeaderFootersContentType(writer, headerFooterType) {
        let contentType;
        let partName;
        if (!this.headersFooters.containsKey(headerFooterType)) {
            return;
        }
        let hfColl = this.headersFooters.get(headerFooterType);
        for (let i = 0; i < hfColl.keys.length; i++) {
            let id = hfColl.keys[i];
            if (headerFooterType === 'EvenHeader' || headerFooterType === 'FirstPageHeader' ||
                headerFooterType === 'OddHeader') {
                partName = this.headerPath + id.replace('rId', '') + '.xml';
                contentType = this.headerContentType;
            }
            else {
                partName = this.footerPath + id.replace('rId', '') + '.xml';
                contentType = this.footerContentType;
            }
            this.serializeOverrideContentType(writer, partName, contentType);
        }
    }
    // Serializes the Override content type.
    serializeOverrideContentType(writer, partName, contentType) {
        writer.writeStartElement(undefined, 'Override', undefined);
        writer.writeAttributeString(undefined, 'PartName', undefined, '/' + partName.replace('\\', '/'));
        writer.writeAttributeString(undefined, 'ContentType', undefined, contentType);
        writer.writeEndElement();
    }
    // Serializes the default content type
    serializeDefaultContentType(writer, extension, contentType) {
        writer.writeStartElement(undefined, 'Default', undefined);
        writer.writeAttributeString(undefined, 'Extension', undefined, extension);
        writer.writeAttributeString(undefined, 'ContentType', undefined, contentType);
        writer.writeEndElement();
    }
    // Reset the relationship id counter
    resetRelationShipID() {
        this.mRelationShipID = 0;
    }
    close() {
        //Implement
    }
}

/**
 * Exports the document to Text format.
 */
class TextExport {
    constructor() {
        this.text = '';
        this.curSectionIndex = 0;
        this.inField = false;
    }
    getModuleName() {
        return 'TextExport';
    }
    /**
     * @private
     */
    save(viewer, fileName) {
        this.serialize(viewer);
        let writer = new StreamWriter();
        this.writeInternal(writer);
        writer.save(fileName + '.txt');
    }
    /**
     * @private
     */
    saveAsBlob(viewer) {
        this.serialize(viewer);
        let streamWriter = new StreamWriter();
        this.writeInternal(streamWriter);
        let blob = streamWriter.buffer;
        streamWriter.destroy();
        return new Promise((resolve, reject) => {
            resolve(blob);
        });
    }
    serialize(viewer) {
        let document = viewer.owner.sfdtExportModule.write();
        this.setDocument(document);
    }
    setDocument(document) {
        this.document = document;
        this.mSections = document.sections;
    }
    writeInternal(streamWriter) {
        let section = undefined;
        let sectionCount = this.document.sections.length - 1;
        let isLastSection = false;
        this.updateLastParagraph();
        for (let i = 0; i <= sectionCount; i++) {
            section = this.document.sections[i];
            isLastSection = (i === sectionCount) ? true : false;
            this.writeBody(streamWriter, section.blocks);
            this.writeNewLine(streamWriter);
            this.writeSectionEnd(section, isLastSection);
        }
        for (let j = 0; j <= sectionCount; j++) {
            section = this.document.sections[j];
            this.writeHeadersFooters(streamWriter, section);
        }
    }
    /// <summary>
    /// Writes the specified document content to the text file.
    /// </summary>
    writeBody(streamWriter, body) {
        let bodyItemsCount = body.length - 1;
        let bodyItem = undefined;
        for (let i = 0; i <= bodyItemsCount; i++) {
            bodyItem = body[i];
            if (bodyItem.hasOwnProperty('inlines')) {
                let isLastPara = (bodyItem === this.lastPara) ? true : false;
                this.writeParagraph(streamWriter, bodyItem, isLastPara);
            }
            else {
                this.writeTable(streamWriter, bodyItem);
            }
        }
    }
    writeParagraph(streamWriter, paragraph, isLastPara) {
        for (let i = 0; i < paragraph.inlines.length; i++) {
            let item = paragraph.inlines[i];
            if (item.hasOwnProperty('fieldType')) {
                this.inField = item.fieldType === 0;
            }
            else if (item.hasOwnProperty('text') && !this.inField) {
                this.writeText(streamWriter, item.text);
            }
        }
        if (!isLastPara) {
            this.writeNewLine(streamWriter);
        }
    }
    /// }
    /// <summary>
    /// Writes the specified table text content to the text file.
    /// </summary>
    writeTable(streamWriter, table) {
        for (let i = 0; i < table.rows.length; i++) {
            let row = table.rows[i];
            for (let j = 0; j < row.cells.length; j++) {
                let cell = row.cells[j];
                this.writeBody(streamWriter, cell.blocks);
            }
        }
    }
    /// <summary>
    /// Writes the specified Header Footer text content to the text file.
    /// </summary>
    writeHeadersFooters(streamWriter, section) {
        let headersFooters = section.headersFooters;
        if (isNullOrUndefined(headersFooters)) {
            return;
        }
        this.writeHeaderFooter(streamWriter, section.headersFooters.header);
        this.writeHeaderFooter(streamWriter, section.headersFooters.footer);
        this.writeHeaderFooter(streamWriter, section.headersFooters.evenFooter);
        this.writeHeaderFooter(streamWriter, section.headersFooters.evenHeader);
        this.writeHeaderFooter(streamWriter, section.headersFooters.firstPageHeader);
        this.writeHeaderFooter(streamWriter, section.headersFooters.firstPageFooter);
    }
    writeHeaderFooter(streamWriter, headerFooter) {
        if (headerFooter && headerFooter.blocks) {
            this.writeBody(streamWriter, headerFooter.blocks);
        }
    }
    /// <summary>
    /// Writes the end of the section.
    /// </summary>
    writeSectionEnd(section, lastSection) {
        this.curSectionIndex++;
    }
    writeNewLine(writer) {
        writer.writeLine('');
    }
    writeText(writer, text) {
        writer.write(text);
    }
    updateLastParagraph() {
        let cnt = this.document.sections.length;
        let sec;
        if (cnt > 0) {
            sec = this.document.sections[cnt - 1];
        }
        if (!isNullOrUndefined(sec)) {
            let paragraphs = [];
            for (let i = 0; i < sec.blocks.length; i++) {
                if (sec.blocks[i].hasOwnProperty('inlines')) {
                    paragraphs.push(sec.blocks[i]);
                }
            }
            let pCount = paragraphs.length;
            if (pCount > 0) {
                this.lastPara = paragraphs[pCount - 1];
            }
        }
    }
    /**
     * @private
     */
    destroy() {
        this.document = undefined;
        this.lastPara = undefined;
        this.mSections = undefined;
        this.sections = undefined;
    }
}

/**
 * Exports the document to Sfdt format.
 */
class SfdtExport {
    /**
     * @private
     */
    constructor(owner) {
        /* tslint:disable:no-any */
        this.endLine = undefined;
        this.endOffset = undefined;
        this.endCell = undefined;
        this.startColumnIndex = undefined;
        this.endColumnIndex = undefined;
        this.lists = undefined;
        this.viewer = undefined;
        this.document = undefined;
        this.writeInlineStyles = undefined;
        this.viewer = owner;
    }
    getModuleName() {
        return 'SfdtExport';
    }
    clear() {
        this.writeInlineStyles = undefined;
        this.endLine = undefined;
        this.lists = undefined;
        this.document = undefined;
    }
    /**
     * Serialize the data as Syncfusion document text.
     * @private
     */
    serialize() {
        return JSON.stringify(this.write());
    }
    /**
     * @private
     */
    saveAsBlob(viewer) {
        let streamWriter = new StreamWriter();
        streamWriter.write(this.serialize());
        let blob = streamWriter.buffer;
        streamWriter.destroy();
        return new Promise((resolve, reject) => {
            resolve(blob);
        });
    }
    // tslint:disable-next-line:max-line-length
    /**
     * @private
     */
    write(line, startOffset, endLine, endOffset, writeInlineStyles) {
        if (writeInlineStyles) {
            this.writeInlineStyles = true;
        }
        this.lists = [];
        this.document = {};
        this.document.sections = [];
        this.document.characterFormat = this.writeCharacterFormat(this.viewer.characterFormat);
        this.document.paragraphFormat = this.writeParagraphFormat(this.viewer.paragraphFormat);
        if (line instanceof LineWidget && endLine instanceof LineWidget) {
            // For selection
            let startPara = line.paragraph;
            let endPara = endLine.paragraph;
            let startCell = startPara.associatedCell;
            let endCell = endPara.associatedCell;
            // Creates section
            let bodyWidget = startPara.bodyWidget;
            let section = this.createSection(line.paragraph.bodyWidget);
            this.document.sections.push(section);
            if (startCell === endCell || isNullOrUndefined(endCell)) {
                this.endLine = endLine;
                this.endOffset = endOffset;
            }
            else {
                // Todo: Handle nested table cases
                if (startCell instanceof TableCellWidget) {
                    let startTable = startCell.getContainerTable();
                    let endTable = endCell.getContainerTable();
                    if (startTable.tableFormat === endTable.tableFormat) {
                        this.endCell = endCell;
                        this.endColumnIndex = this.endCell.columnIndex + this.endCell.cellFormat.columnSpan;
                        this.startColumnIndex = startCell.columnIndex;
                    }
                }
                else {
                    this.endCell = endCell;
                }
            }
            if (startCell === endCell || isNullOrUndefined(startCell)) {
                let paragraph = this.createParagraph(line.paragraph);
                section.blocks.push(paragraph);
                if (!this.writeParagraph(line.paragraph, paragraph, section.blocks, line.indexInOwner, startOffset)) {
                    // Todo:continue in next section
                }
            }
            else {
                let table = this.createTable(startCell.ownerTable);
                section.blocks.push(table);
                this.writeTable(startCell.ownerTable, table, startCell.ownerRow.indexInOwner, section.blocks);
            }
        }
        else {
            if (this.viewer.pages.length > 0) {
                let page = this.viewer.pages[0];
                if (page.bodyWidgets.length > 0) {
                    this.writeBodyWidget(page.bodyWidgets[0], 0);
                }
            }
        }
        this.writeStyles(this.viewer);
        this.writeLists(this.viewer);
        let doc = this.document;
        this.clear();
        return doc;
    }
    writeBodyWidget(bodyWidget, index) {
        if (!(bodyWidget instanceof BodyWidget)) {
            return true;
        }
        let section = this.createSection(bodyWidget);
        this.document.sections.push(section);
        this.writeHeaderFooters(this.viewer.headersFooters[bodyWidget.index], section);
        if (this.writeBlock(bodyWidget.childWidgets[index], 0, section.blocks)) {
            return true;
        }
        let next = bodyWidget;
        do {
            bodyWidget = next;
            next = next.nextRenderedWidget;
        } while (next instanceof BodyWidget && next.index === bodyWidget.index);
        return this.writeBodyWidget(next, index);
    }
    writeHeaderFooters(hfs, section) {
        if (isNullOrUndefined(hfs)) {
            return;
        }
        section.headersFooters.header = this.writeHeaderFooter(hfs[0]);
        section.headersFooters.footer = this.writeHeaderFooter(hfs[1]);
        section.headersFooters.evenHeader = this.writeHeaderFooter(hfs[2]);
        section.headersFooters.evenFooter = this.writeHeaderFooter(hfs[3]);
        section.headersFooters.firstPageHeader = this.writeHeaderFooter(hfs[4]);
        section.headersFooters.firstPageFooter = this.writeHeaderFooter(hfs[5]);
    }
    writeHeaderFooter(widget) {
        if (isNullOrUndefined(widget)) {
            return undefined;
        }
        let headerFooter = {};
        if (widget && widget.childWidgets && widget.childWidgets.length > 0) {
            headerFooter.blocks = [];
            this.writeBlock(widget.firstChild, 0, headerFooter.blocks);
        }
        return headerFooter;
    }
    createSection(bodyWidget) {
        let section = {};
        section.sectionFormat = {};
        section.sectionFormat.pageWidth = bodyWidget.sectionFormat.pageWidth;
        section.sectionFormat.pageHeight = bodyWidget.sectionFormat.pageHeight;
        section.sectionFormat.leftMargin = bodyWidget.sectionFormat.leftMargin;
        section.sectionFormat.rightMargin = bodyWidget.sectionFormat.rightMargin;
        section.sectionFormat.topMargin = bodyWidget.sectionFormat.topMargin;
        section.sectionFormat.bottomMargin = bodyWidget.sectionFormat.bottomMargin;
        section.sectionFormat.differentFirstPage = bodyWidget.sectionFormat.differentFirstPage;
        section.sectionFormat.differentOddAndEvenPages = bodyWidget.sectionFormat.differentOddAndEvenPages;
        section.sectionFormat.headerDistance = bodyWidget.sectionFormat.headerDistance;
        section.sectionFormat.footerDistance = bodyWidget.sectionFormat.footerDistance;
        section.blocks = [];
        section.headersFooters = {};
        return section;
    }
    writeBlock(widget, index, blocks) {
        if (!(widget instanceof BlockWidget)) {
            return true;
        }
        if (widget instanceof ParagraphWidget) {
            let paragraph = this.createParagraph(widget);
            blocks.push(paragraph);
            if (this.writeParagraph(widget, paragraph, blocks)) {
                return true;
            }
        }
        else {
            let tableWidget = widget;
            let table = this.createTable(tableWidget);
            blocks.push(table);
            if (this.writeTable(tableWidget, table, 0, blocks)) {
                return true;
            }
        }
        return false;
    }
    writeNextBlock(widget, blocks) {
        let next = widget.nextRenderedWidget;
        if (next instanceof BlockWidget && next.containerWidget.index === widget.containerWidget.index) {
            return this.writeBlock(widget.nextRenderedWidget, 0, blocks);
        }
        return false;
    }
    writeParagraph(paragraphWidget, paragraph, blocks, lineIndex, start) {
        if (isNullOrUndefined(lineIndex)) {
            lineIndex = 0;
        }
        if (isNullOrUndefined(start)) {
            start = 0;
        }
        let next = paragraphWidget;
        while (next instanceof ParagraphWidget) {
            if (this.writeLines(next, lineIndex, start, paragraph.inlines)) {
                return true;
            }
            lineIndex = 0;
            start = 0;
            paragraphWidget = next;
            next = paragraphWidget.nextSplitWidget;
        }
        return this.writeNextBlock(paragraphWidget, blocks);
    }
    writeInlines(line, inlines) {
        for (let i = 0; i < line.children.length; i++) {
            let element = line.children[i];
            if (element instanceof ListTextElementBox) {
                continue;
            }
            let inline = this.writeInline(element);
            if (!isNullOrUndefined(inline)) {
                inlines.push(inline);
            }
        }
    }
    writeInline(element) {
        let inline = {};
        inline.characterFormat = this.writeCharacterFormat(element.characterFormat);
        if (element instanceof FieldElementBox) {
            inline.fieldType = element.fieldType;
        }
        else if (element instanceof ImageElementBox) {
            inline.imageString = element.imageString;
            inline.width = HelperMethods.convertPixelToPoint(element.width);
            inline.height = HelperMethods.convertPixelToPoint(element.height);
        }
        else if (element instanceof BookmarkElementBox) {
            inline.bookmarkType = element.bookmarkType;
            inline.name = element.name;
        }
        else if (element instanceof TextElementBox) {
            inline.text = element.text;
        }
        else {
            inline = undefined;
        }
        return inline;
    }
    writeLines(paragraph, lineIndex, offset, inlines) {
        let startIndex = lineIndex;
        let endParagraph = this.endLine instanceof LineWidget && this.endLine.paragraph === paragraph;
        let endIndex = endParagraph ? this.endLine.indexInOwner : paragraph.childWidgets.length - 1;
        for (let i = startIndex; i <= endIndex; i++) {
            let child = paragraph.childWidgets[i];
            if (this.endLine === child || (lineIndex === i && offset !== 0)) {
                this.writeLine(child, offset, inlines);
            }
            else {
                this.writeInlines(child, inlines);
            }
        }
        return endParagraph;
    }
    writeLine(line, offset, inlines) {
        let isEnd = line === this.endLine;
        let started = false;
        let ended = false;
        let length = 0;
        for (let j = 0; j < line.children.length; j++) {
            let element = line.children[j];
            if (element instanceof ListTextElementBox) {
                continue;
            }
            let inline = undefined;
            length += element.length;
            started = length > offset;
            ended = isEnd && length >= this.endOffset;
            if (!started) {
                continue;
            }
            inline = this.writeInline(element);
            inlines[inlines.length] = inline;
            if (length > offset || ended) {
                if (inline.hasOwnProperty('text')) {
                    let startIndex = length - element.length;
                    let indexInInline = offset - startIndex;
                    let endIndex = ended ? this.endOffset - startIndex : element.length;
                    inline.text = inline.text.substring(indexInInline, endIndex);
                }
                offset = -1;
            }
            if (ended) {
                break;
            }
        }
    }
    createParagraph(paragraphWidget) {
        let paragraph = {};
        paragraph.paragraphFormat = this.writeParagraphFormat(paragraphWidget.paragraphFormat);
        paragraph.characterFormat = this.writeCharacterFormat(paragraphWidget.characterFormat);
        paragraph.inlines = [];
        return paragraph;
    }
    /**
     * @private
     */
    writeCharacterFormat(format, isInline) {
        let characterFormat = {};
        HelperMethods.writeCharacterFormat(characterFormat, isInline, format);
        if (this.writeInlineStyles && !isInline) {
            characterFormat.inlineFormat = this.writeCharacterFormat(format, true);
        }
        return characterFormat;
    }
    writeParagraphFormat(format, isInline) {
        let paragraphFormat = {};
        paragraphFormat.leftIndent = isInline ? format.leftIndent : format.getValue('leftIndent');
        paragraphFormat.rightIndent = isInline ? format.rightIndent : format.getValue('rightIndent');
        paragraphFormat.firstLineIndent = isInline ? format.firstLineIndent : format.getValue('firstLineIndent');
        paragraphFormat.textAlignment = isInline ? format.textAlignment : format.getValue('textAlignment');
        paragraphFormat.beforeSpacing = isInline ? format.beforeSpacing : format.getValue('beforeSpacing');
        paragraphFormat.afterSpacing = isInline ? format.afterSpacing : format.getValue('afterSpacing');
        paragraphFormat.lineSpacing = isInline ? format.lineSpacing : format.getValue('lineSpacing');
        paragraphFormat.lineSpacingType = isInline ? format.lineSpacingType : format.getValue('lineSpacingType');
        paragraphFormat.styleName = !isNullOrUndefined(format.baseStyle) ? format.baseStyle.name : undefined;
        paragraphFormat.outlineLevel = isInline ? format.outlineLevel : format.getValue('outlineLevel');
        paragraphFormat.listFormat = this.writeListFormat(format.listFormat, isInline);
        paragraphFormat.tabs = this.writeTabs(format.tabs);
        if (this.writeInlineStyles && !isInline) {
            paragraphFormat.inlineFormat = this.writeParagraphFormat(format, true);
        }
        return paragraphFormat;
    }
    writeTabs(tabStops) {
        if (isNullOrUndefined(tabStops) || tabStops.length < 1) {
            return undefined;
        }
        let tabs = [];
        for (let i = 0; i < tabStops.length; i++) {
            let tabStop = tabStops[i];
            let tab = {};
            tab.position = tabStop.position;
            tab.deletePosition = tabStop.deletePosition;
            tab.tabJustification = tabStop.tabJustification;
            tab.tabLeader = tabStop.tabLeader;
            tabs.push(tab);
        }
        return tabs;
    }
    /**
     * @private
     */
    writeListFormat(format, isInline) {
        let listFormat = {};
        let listIdValue = format.getValue('listId');
        if (!isNullOrUndefined(listIdValue) && listIdValue > -1) {
            listFormat.listId = listIdValue;
            listFormat.listLevelNumber = format.getValue('listLevelNumber');
            if (this.lists.indexOf(format.listId) < 0) {
                this.lists.push(format.listId);
            }
        }
        return listFormat;
    }
    writeTable(tableWidget, table, index, blocks) {
        let widget = tableWidget.childWidgets[index];
        if (widget instanceof TableRowWidget) {
            if (this.writeRow(widget, table.rows)) {
                return true;
            }
        }
        let next = tableWidget;
        do {
            tableWidget = next;
            next = tableWidget.nextSplitWidget;
        } while (next instanceof BlockWidget);
        return this.writeNextBlock(tableWidget, blocks);
    }
    writeRow(rowWidget, rows) {
        if (!(rowWidget instanceof TableRowWidget)) {
            return false;
        }
        let row = this.createRow(rowWidget);
        rows.push(row);
        for (let i = 0; i < rowWidget.childWidgets.length; i++) {
            let widget = rowWidget.childWidgets[i];
            if (widget instanceof TableCellWidget) {
                if (rowWidget.index === widget.rowIndex
                    && (isNullOrUndefined(this.startColumnIndex) || widget.columnIndex >= this.startColumnIndex)
                    && (isNullOrUndefined(this.endColumnIndex) || widget.columnIndex < this.endColumnIndex)) {
                    if (this.writeCell(widget, row.cells)) {
                        return true;
                    }
                }
            }
        }
        let next = rowWidget;
        do {
            rowWidget = next;
            next = rowWidget.nextRenderedWidget;
        } while (next instanceof TableRowWidget && next.index === rowWidget.index);
        return this.writeRow(next, rows);
    }
    writeCell(cellWidget, cells) {
        let cell = this.createCell(cellWidget);
        cells.push(cell);
        if (this.writeBlock(cellWidget.firstChild, 0, cell.blocks)) {
            return true;
        }
        return this.endCell instanceof TableCellWidget ? this.endCell.cellFormat === cellWidget.cellFormat : false;
    }
    createTable(tableWidget) {
        let table = {};
        table.rows = [];
        table.grid = [];
        for (let i = 0; i < tableWidget.tableHolder.columns.length; i++) {
            table.grid[i] = tableWidget.tableHolder.columns[i].preferredWidth;
        }
        table.tableFormat = this.writeTableFormat(tableWidget.tableFormat);
        table.description = tableWidget.description;
        table.title = tableWidget.title;
        return table;
    }
    createRow(rowWidget) {
        let row = {};
        row.cells = [];
        row.rowFormat = this.writeRowFormat(rowWidget.rowFormat);
        return row;
    }
    createCell(cellWidget) {
        let cell = {};
        cell.blocks = [];
        cell.cellFormat = this.writeCellFormat(cellWidget.cellFormat);
        cell.columnIndex = cellWidget.columnIndex;
        return cell;
    }
    writeShading(wShading) {
        let shading = {};
        shading.backgroundColor = wShading.backgroundColor;
        shading.foregroundColor = wShading.foregroundColor;
        shading.textureStyle = wShading.textureStyle;
        return shading;
    }
    writeBorder(wBorder) {
        let border = {};
        border.color = wBorder.color;
        border.hasNoneStyle = wBorder.hasNoneStyle;
        border.lineStyle = wBorder.lineStyle;
        border.lineWidth = wBorder.lineWidth;
        border.shadow = wBorder.shadow;
        border.space = wBorder.space;
        return border;
    }
    writeBorders(wBorders) {
        let borders = {};
        borders.top = this.writeBorder(wBorders.top);
        borders.left = this.writeBorder(wBorders.left);
        borders.right = this.writeBorder(wBorders.right);
        borders.bottom = this.writeBorder(wBorders.bottom);
        borders.diagonalDown = this.writeBorder(wBorders.diagonalDown);
        borders.diagonalUp = this.writeBorder(wBorders.diagonalUp);
        borders.horizontal = this.writeBorder(wBorders.horizontal);
        borders.vertical = this.writeBorder(wBorders.vertical);
        return borders;
    }
    writeCellFormat(wCellFormat) {
        let cellFormat = {};
        cellFormat.borders = this.writeBorders(wCellFormat.borders);
        cellFormat.shading = this.writeShading(wCellFormat.shading);
        cellFormat.topMargin = wCellFormat.topMargin;
        cellFormat.rightMargin = wCellFormat.rightMargin;
        cellFormat.leftMargin = wCellFormat.leftMargin;
        cellFormat.bottomMargin = wCellFormat.bottomMargin;
        cellFormat.preferredWidth = wCellFormat.preferredWidth;
        cellFormat.preferredWidthType = wCellFormat.preferredWidthType;
        cellFormat.cellWidth = wCellFormat.cellWidth;
        cellFormat.columnSpan = wCellFormat.columnSpan;
        cellFormat.rowSpan = wCellFormat.rowSpan;
        cellFormat.verticalAlignment = wCellFormat.verticalAlignment;
        return cellFormat;
    }
    writeRowFormat(wRowFormat) {
        let rowFormat = {};
        rowFormat.height = wRowFormat.height;
        rowFormat.allowBreakAcrossPages = wRowFormat.allowBreakAcrossPages;
        rowFormat.heightType = wRowFormat.heightType;
        rowFormat.isHeader = wRowFormat.isHeader;
        rowFormat.borders = this.writeBorders(wRowFormat.borders);
        rowFormat.gridBefore = wRowFormat.gridBefore;
        rowFormat.gridBeforeWidth = wRowFormat.gridBeforeWidth;
        rowFormat.gridBeforeWidthType = wRowFormat.gridBeforeWidthType;
        rowFormat.gridAfter = wRowFormat.gridAfter;
        rowFormat.gridAfterWidth = wRowFormat.gridAfterWidth;
        rowFormat.gridAfterWidthType = wRowFormat.gridAfterWidthType;
        return rowFormat;
    }
    writeTableFormat(wTableFormat) {
        let tableFormat = {};
        tableFormat.borders = this.writeBorders(wTableFormat.borders);
        tableFormat.shading = this.writeShading(wTableFormat.shading);
        tableFormat.cellSpacing = wTableFormat.cellSpacing;
        tableFormat.leftIndent = wTableFormat.leftIndent;
        tableFormat.tableAlignment = wTableFormat.tableAlignment;
        tableFormat.topMargin = wTableFormat.topMargin;
        tableFormat.rightMargin = wTableFormat.rightMargin;
        tableFormat.leftMargin = wTableFormat.leftMargin;
        tableFormat.bottomMargin = wTableFormat.bottomMargin;
        tableFormat.preferredWidth = wTableFormat.preferredWidth;
        tableFormat.preferredWidthType = wTableFormat.preferredWidthType;
        return tableFormat;
    }
    writeStyles(viewer) {
        this.document.styles = [];
        for (let i = 0; i < viewer.styles.length; i++) {
            this.document.styles.push(this.writeStyle(viewer.styles.getItem(i)));
        }
    }
    writeStyle(style) {
        let wStyle = {};
        wStyle.name = style.name;
        if (style.type === 'Paragraph') {
            wStyle.type = 'Paragraph';
            wStyle.paragraphFormat = this.writeParagraphFormat(style.paragraphFormat);
            wStyle.characterFormat = this.writeCharacterFormat(style.characterFormat);
        }
        if (style.type === 'Character') {
            wStyle.type = 'Character';
            wStyle.characterFormat = this.writeCharacterFormat(style.characterFormat);
        }
        if (!isNullOrUndefined(style.basedOn)) {
            wStyle.basedOn = style.basedOn.name;
        }
        if (!isNullOrUndefined(style.link)) {
            wStyle.link = style.link.name;
        }
        if (!isNullOrUndefined(style.next)) {
            wStyle.next = style.next.name;
        }
        return wStyle;
    }
    writeLists(viewer) {
        let abstractLists = [];
        this.document.lists = [];
        for (let i = 0; i < viewer.lists.length; i++) {
            let list = viewer.lists[i];
            if (this.lists.indexOf(list.listId) > -1) {
                this.document.lists.push(this.writeList(list));
                if (abstractLists.indexOf(list.abstractListId) < 0) {
                    abstractLists.push(list.abstractListId);
                }
            }
        }
        this.document.abstractLists = [];
        for (let i = 0; i < viewer.abstractLists.length; i++) {
            let abstractList = viewer.abstractLists[i];
            if (this.lists.indexOf(abstractList.abstractListId) > -1) {
                this.document.abstractLists.push(this.writeAbstractList(abstractList));
            }
        }
    }
    writeAbstractList(wAbstractList) {
        let abstractList = {};
        abstractList.abstractListId = wAbstractList.abstractListId;
        abstractList.levels = [];
        for (let i = 0; i < wAbstractList.levels.length; i++) {
            abstractList.levels[i] = this.writeListLevel(wAbstractList.levels[i]);
        }
        return abstractList;
    }
    writeList(wList) {
        let list = {};
        list.abstractListId = wList.abstractListId;
        //list.levelOverrides = wList.levelOverrides;
        list.listId = wList.listId;
        return list;
    }
    writeListLevel(wListLevel) {
        let listLevel = {};
        listLevel.characterFormat = this.writeCharacterFormat(wListLevel.characterFormat);
        listLevel.paragraphFormat = this.writeParagraphFormat(wListLevel.paragraphFormat);
        listLevel.followCharacter = wListLevel.followCharacter;
        listLevel.listLevelPattern = wListLevel.listLevelPattern;
        listLevel.numberFormat = wListLevel.numberFormat;
        listLevel.restartLevel = wListLevel.restartLevel;
        listLevel.startAt = wListLevel.startAt;
        return listLevel;
    }
    /**
     * @private
     */
    destroy() {
        this.lists = undefined;
        this.endLine = undefined;
        this.endOffset = undefined;
        this.viewer = undefined;
    }
}

/**
 * Export Export
 */

/**
 * The Hyperlink dialog is used to insert or edit hyperlink at selection.
 */
/* tslint:disable:max-line-length */
class HyperlinkDialog {
    /**
     * @private
     */
    constructor(viewer) {
        this.displayText = '';
        this.navigationUrl = undefined;
        this.bookmarkDropdown = undefined;
        this.bookmarkCheckbox = undefined;
        this.bookmarks = [];
        /**
         * @private
         */
        this.onKeyUpOnUrlBox = (event) => {
            if (event.keyCode === 13) {
                if (this.displayTextBox.value !== '' && this.urlTextBox.value !== '') {
                    this.onInsertHyperlink();
                }
                return;
            }
            let selectedText = this.owner.selection.text;
            let urlValue = this.urlTextBox.value;
            if (urlValue.substring(0, 4).toLowerCase() === 'www.') {
                this.urlTextBox.value = 'http://' + urlValue;
            }
            if (this.displayText === '') {
                this.displayTextBox.value = urlValue;
            }
            this.enableOrDisableInsertButton();
        };
        /**
         * @private
         */
        this.onKeyUpOnDisplayBox = () => {
            this.displayText = this.displayTextBox.value;
            this.enableOrDisableInsertButton();
        };
        /**
         * @private
         */
        this.onInsertButtonClick = () => {
            this.onInsertHyperlink();
        };
        /**
         * @private
         */
        this.onCancelButtonClick = () => {
            this.owner.dialog.hide();
            this.clearValue();
        };
        /**
         * @private
         */
        this.loadHyperlinkDialog = () => {
            this.owner.updateFocus();
            this.bookmarks = [];
            for (let i = 0; i < this.owner.bookmarks.keys.length; i++) {
                let bookmark = this.owner.bookmarks.keys[i];
                if (bookmark.indexOf('_') !== 0) {
                    this.bookmarks.push(bookmark);
                }
            }
            let fieldBegin = this.owner.selection.getHyperlinkField();
            if (!isNullOrUndefined(fieldBegin)) {
                if (!isNullOrUndefined(fieldBegin.fieldSeparator)) {
                    let format = undefined;
                    // tslint:disable-next-line:max-line-length
                    let fieldObj = this.owner.selection.getHyperlinkDisplayText(fieldBegin.fieldSeparator.line.paragraph, fieldBegin.fieldSeparator, fieldBegin.fieldEnd, false, format);
                    this.displayText = fieldObj.displayText;
                    this.displayTextBox.disabled = fieldObj.isNestedField;
                }
                this.displayTextBox.value = this.displayText;
                let link = this.owner.selection.getLinkText(fieldBegin);
                this.urlTextBox.value = this.navigationUrl = link;
                this.owner.dialog.header = this.localObj.getConstant('Edit Hyperlink');
            }
            else {
                this.displayText = this.owner.selection.getText(true);
                if (this.displayText !== '') {
                    if (this.displayText.indexOf(String.fromCharCode(65532)) !== -1 ||
                        this.displayText.indexOf('\r') !== -1 && (this.displayText.lastIndexOf('\r') !== -1 &&
                            this.displayText.slice(0, -1).indexOf('\r') !== -1)) {
                        this.displayTextBox.value = '<<Selection in document>>';
                        this.displayTextBox.disabled = true;
                    }
                    else {
                        this.displayTextBox.value = this.displayText;
                    }
                }
            }
            this.bookmarkDiv.style.display = 'none';
            this.addressText.style.display = 'block';
            this.urlTextBox.style.display = 'block';
            this.bookmarkCheckbox.checked = false;
            this.bookmarkDropdown.dataSource = this.owner.bookmarks.keys;
            this.insertButton = document.getElementsByClassName('e-hyper-insert')[0];
            this.enableOrDisableInsertButton();
            this.urlTextBox.focus();
            if (this.owner.selection.caret.style.display !== 'none') {
                this.owner.selection.caret.style.display = 'none';
            }
        };
        /**
         * @private
         */
        this.closeHyperlinkDialog = () => {
            this.clearValue();
            this.owner.updateFocus();
        };
        /* tslint:disable:no-any */
        this.onUseBookmarkChange = (args) => {
            if (args.checked) {
                this.bookmarkDiv.style.display = 'block';
                this.bookmarkDropdown.dataSource = this.bookmarks;
                this.addressText.style.display = 'none';
                this.urlTextBox.style.display = 'none';
            }
            else {
                this.bookmarkDiv.style.display = 'none';
                this.addressText.style.display = 'block';
                this.urlTextBox.style.display = 'block';
            }
        };
        this.onBookmarkchange = (args) => {
            if (this.bookmarkDropdown.value !== '') {
                this.insertButton.disabled = false;
            }
        };
        this.owner = viewer;
    }
    /**
     * @private
     */
    getModuleName() {
        return 'HyperlinkDialog';
    }
    /**
     * @private
     */
    initHyperlinkDialog(localValue) {
        let instance = this;
        let id = this.owner.owner.containerId + '_insert_hyperlink';
        this.target = createElement('div', { id: id, className: 'e-de-hyperlink' });
        let container = createElement('div');
        let displayText = createElement('div', { className: 'e-de-hyperlink-dlg-title', innerHTML: localValue.getConstant('Text to display') });
        this.displayTextBox = createElement('input', { id: this.owner.owner.containerId + '_display_text', className: 'e-input e-de-hyperlink-dlg-input' });
        this.displayTextBox.addEventListener('keyup', instance.onKeyUpOnDisplayBox);
        container.appendChild(displayText);
        container.appendChild(this.displayTextBox);
        this.addressText = createElement('div', { className: 'e-de-hyperlink-dlg-title', innerHTML: localValue.getConstant('Address') });
        this.urlTextBox = createElement('input', { id: this.owner.owner.containerId + '_url_text', className: 'e-input e-de-hyperlink-dlg-input', attrs: { autofocus: 'true' } });
        this.urlTextBox.addEventListener('input', instance.onKeyUpOnUrlBox);
        this.urlTextBox.addEventListener('keyup', instance.onKeyUpOnUrlBox);
        container.appendChild(this.addressText);
        container.appendChild(this.urlTextBox);
        this.bookmarkDiv = createElement('div', { styles: 'display:none;' });
        let bookmarkText = createElement('div', { className: 'e-de-hyperlink-dlg-title', innerHTML: localValue.getConstant('Bookmark') });
        let bookmarkTextElement = createElement('div', { className: 'e-de-hyperlink-dlg-bookmark' });
        // tslint:disable-next-line:max-line-length
        let bookmarkValue = createElement('input', { id: 'e-de-hyperlink-dlg-bookmark-value' });
        bookmarkTextElement.appendChild(bookmarkValue);
        // tslint:disable-next-line:max-line-length
        this.bookmarkDropdown = new DropDownList({ dataSource: [], change: this.onBookmarkchange, popupHeight: '230px', width: '230px', noRecordsTemplate: localValue.getConstant('No bookmarks found') });
        this.bookmarkDropdown.appendTo(bookmarkValue);
        this.bookmarkDiv.appendChild(bookmarkText);
        this.bookmarkDiv.appendChild(bookmarkTextElement);
        container.appendChild(this.bookmarkDiv);
        // tslint:disable-next-line:max-line-length
        let bookmarkCheckDiv = createElement('div', { className: 'e-de-hyperlink-bookmark-check e-de-hyperlink-dlg-title' });
        let bookmarkCheck = createElement('input', { attrs: { type: 'checkbox' }, id: this.target.id + '_bookmark', className: this.target.id + '_bookmarkcheck' });
        bookmarkCheckDiv.appendChild(bookmarkCheck);
        this.bookmarkCheckbox = new CheckBox({ label: localValue.getConstant('Use bookmarks'), change: this.onUseBookmarkChange });
        this.bookmarkCheckbox.appendTo(bookmarkCheck);
        container.appendChild(bookmarkCheckDiv);
        this.target.appendChild(container);
    }
    /**
     * @private
     */
    show() {
        this.localObj = new L10n('documenteditor', this.owner.owner.defaultLocale);
        this.localObj.setLocale(this.owner.owner.locale);
        setCulture(this.owner.owner.locale);
        if (!this.target) {
            this.initHyperlinkDialog(this.localObj);
        }
        this.owner.dialog.header = this.localObj.getConstant('Insert Hyperlink');
        this.owner.dialog.height = 'auto';
        this.owner.dialog.width = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.buttons = [{
                click: this.onInsertButtonClick,
                buttonModel: { content: this.localObj.getConstant('Ok'), cssClass: 'e-flat e-hyper-insert', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: this.localObj.getConstant('Cancel'), cssClass: 'e-flat e-hyper-cancel' }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.beforeOpen = this.loadHyperlinkDialog;
        this.owner.dialog.close = this.closeHyperlinkDialog;
        this.owner.dialog.show();
    }
    /**
     * @private
     */
    hide() {
        this.closeHyperlinkDialog();
    }
    enableOrDisableInsertButton() {
        if (!isNullOrUndefined(this.insertButton)) {
            // tslint:disable-next-line:max-line-length
            this.insertButton.disabled = (this.urlTextBox.value === '' || this.displayTextBox.value === '');
        }
    }
    /**
     * @private
     */
    onInsertHyperlink() {
        let displayText = this.displayTextBox.value.trim();
        let address = this.urlTextBox.value.trim();
        let isBookmark = false;
        if (!isNullOrUndefined(this.bookmarkDropdown.value) && this.bookmarkDropdown.value !== '') {
            address = this.bookmarkDropdown.value;
            isBookmark = true;
        }
        if (address === '') {
            this.owner.dialog.hide();
            return;
        }
        if (displayText === '' && address !== '') {
            displayText = address;
        }
        else {
            displayText = this.displayTextBox.value;
        }
        if (!isNullOrUndefined(this.navigationUrl)) {
            this.owner.owner.editorModule.editHyperlink(this.owner.selection, address, displayText, isBookmark);
        }
        else {
            let remove = this.owner.selection.text !== displayText && !this.displayTextBox.disabled;
            this.owner.owner.editorModule.insertHyperlink(address, displayText, remove, isBookmark);
        }
        this.owner.dialog.hide();
        this.navigationUrl = undefined;
    }
    /* tslint:enable:no-any */
    /**
     * @private
     */
    clearValue() {
        this.displayTextBox.value = '';
        this.urlTextBox.value = '';
        this.displayText = '';
        this.displayTextBox.disabled = false;
        this.bookmarks = [];
    }
    /**
     * @private
     */
    destroy() {
        if (this.displayTextBox) {
            this.displayTextBox.innerHTML = '';
            this.displayTextBox = undefined;
        }
        if (this.urlTextBox) {
            this.urlTextBox.parentElement.removeChild(this.urlTextBox);
            this.urlTextBox = undefined;
        }
        this.owner = undefined;
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            this.target.innerHTML = '';
            this.target = undefined;
        }
    }
}

/**
 * The Table dialog is used to insert table at selection.
 */
class TableDialog {
    /**
     * @private
     */
    constructor(viewer) {
        /**
         * @private
         */
        this.keyUpInsertTable = (event) => {
            if (event.keyCode === 13) {
                if (this.rowsCountBox.value !== '' && this.columnsCountBox.value !== '') {
                    this.onInsertTableClick();
                }
            }
        };
        /**
         * @private
         */
        this.onCancelButtonClick = () => {
            this.owner.dialog.hide();
        };
        /**
         * @private
         */
        this.onInsertTableClick = () => {
            let rowCount = this.rowValueTextBox.value;
            let columnCount = this.columnValueTexBox.value;
            if (!(isNullOrUndefined(rowCount) && isNullOrUndefined(columnCount))) {
                this.owner.owner.editor.insertTable(rowCount, columnCount);
            }
            this.owner.dialog.hide();
        };
        this.owner = viewer;
    }
    getModuleName() {
        return 'TableDialog';
    }
    /**
     * @private
     */
    initTableDialog(localValue) {
        let instance = this;
        let id = this.owner.owner.containerId + '_insert_Table';
        this.target = createElement('div', { id: id, className: 'e-de-insert-table' });
        let parentDiv = createElement('div');
        let columnContainer = createElement('div', {
            className: 'e-de-insert-table-dlg-sub-header', innerHTML: localValue.getConstant('Number of columns')
        });
        let columnValue = createElement('div', { className: 'e-de-insert-table-dlg-input' });
        this.columnsCountBox = createElement('input', {
            attrs: { type: 'text' }, id: this.owner.owner.containerId + '_column'
        });
        columnValue.appendChild(this.columnsCountBox);
        let rowContainer = createElement('div', {
            className: 'e-de-insert-table-dlg-sub-header', innerHTML: localValue.getConstant('Number of rows')
        });
        let rowValue = createElement('div', { className: 'e-de-insert-table-dlg-input' });
        this.rowsCountBox = createElement('input', {
            attrs: { type: 'text' }, id: this.owner.owner.containerId + 'row'
        });
        rowValue.appendChild(this.rowsCountBox);
        parentDiv.appendChild(columnContainer);
        parentDiv.appendChild(columnValue);
        parentDiv.appendChild(rowContainer);
        parentDiv.appendChild(rowValue);
        this.target.appendChild(parentDiv);
        this.columnsCountBox.addEventListener('keyup', instance.keyUpInsertTable);
        this.rowsCountBox.addEventListener('keyup', instance.keyUpInsertTable);
        this.rowValueTextBox = new NumericTextBox({
            format: '#',
            value: 2,
            min: 1,
            max: 32767,
            enablePersistence: false
        });
        this.rowValueTextBox.appendTo(this.rowsCountBox);
        this.columnValueTexBox = new NumericTextBox({
            format: '#',
            value: 2,
            min: 1,
            max: 63,
            enablePersistence: false
        });
        this.columnValueTexBox.appendTo(this.columnsCountBox);
    }
    /**
     * @private
     */
    show() {
        let localValue = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localValue.setLocale(this.owner.owner.locale);
        setCulture(this.owner.owner.locale);
        if (!this.target) {
            this.initTableDialog(localValue);
        }
        if (this.owner.selection.caret.style.display !== 'none') {
            this.owner.selection.caret.style.display = 'none';
        }
        this.owner.dialog.header = localValue.getConstant('Insert Table');
        this.owner.dialog.height = 'auto';
        this.owner.dialog.width = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = this.owner.updateFocus;
        this.owner.dialog.buttons = [{
                click: this.onInsertTableClick,
                buttonModel: { content: localValue.getConstant('Ok'), cssClass: 'e-flat e-table-ok', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: localValue.getConstant('Cancel'), cssClass: 'e-flat e-table-cancel' }
            }];
        this.rowValueTextBox.value = 2;
        this.columnValueTexBox.value = 2;
        this.owner.dialog.close = this.owner.updateFocus;
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    }
    /**
     * @private
     */
    destroy() {
        if (this.columnsCountBox) {
            if (this.columnsCountBox.parentElement) {
                this.columnsCountBox.parentElement.removeChild(this.columnsCountBox);
            }
            this.columnsCountBox = undefined;
        }
        if (this.rowsCountBox) {
            if (this.rowsCountBox.parentElement) {
                this.rowsCountBox.parentElement.removeChild(this.rowsCountBox);
            }
            this.rowsCountBox = undefined;
        }
        if (this.columnValueTexBox) {
            this.columnValueTexBox.destroy();
            this.columnValueTexBox = undefined;
        }
        if (this.rowValueTextBox) {
            this.rowValueTextBox.destroy();
            this.rowValueTextBox = undefined;
        }
        this.columnsCountBox = undefined;
        this.rowsCountBox = undefined;
        this.owner = undefined;
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (let i = 0; i < this.target.childNodes.length; i++) {
                this.target.removeChild(this.target.childNodes[i]);
                i--;
            }
            this.target = undefined;
        }
    }
}

/**
 * The Bookmark dialog is used to add, navigate or delete bookmarks.
 */
class BookmarkDialog {
    /**
     * @private
     */
    constructor(viewer) {
        this.addBookmark = () => {
            this.owner.owner.editorModule.insertBookmark(this.textBoxInput.value);
            this.owner.dialog.hide();
        };
        /* tslint:disable:no-any */
        this.selectHandler = (args) => {
            this.textBoxInput.value = args.text;
            /* tslint:disable:no-any */
            let value = document.getElementById('bookmark_text_box');
            value.setSelectionRange(0, args.text.length);
            value.focus();
        };
        this.gotoBookmark = () => {
            this.owner.selection.selectBookmark(this.textBoxInput.value);
        };
        this.deleteBookmark = () => {
            this.owner.owner.editorModule.deleteBookmark(this.textBoxInput.value);
            this.show();
        };
        this.owner = viewer;
    }
    /**
     * @private
     */
    getModuleName() {
        return 'BookmarkDialog';
    }
    /**
     * @private
     */
    initBookmarkDialog(localValue, bookmarks) {
        let id = this.owner.owner.containerId + '_insert_bookmark';
        this.target = createElement('div', { id: id, className: 'e-de-bookmark' });
        let headerValue = localValue.getConstant('Bookmark name') + ':';
        let dlgFields = createElement('div', { innerHTML: headerValue, className: 'e-bookmark-dlgfields' });
        this.target.appendChild(dlgFields);
        let commonDiv = createElement('div', { className: 'e-bookmark-common' });
        this.target.appendChild(commonDiv);
        let searchDiv = createElement('div', { className: 'e-bookmark-list' });
        commonDiv.appendChild(searchDiv);
        let textBoxDiv = createElement('div', { className: 'e-bookmark-textboxdiv' });
        searchDiv.appendChild(textBoxDiv);
        // tslint:disable-next-line:max-line-length
        this.textBoxInput = createElement('input', { className: 'e-input e-bookmark-textbox-input', id: 'bookmark_text_box' });
        this.textBoxInput.setAttribute('type', 'text');
        textBoxDiv.appendChild(this.textBoxInput);
        let listviewDiv = createElement('div', { className: 'e-bookmark-listViewDiv', id: 'bookmark_listview' });
        searchDiv.appendChild(listviewDiv);
        let arts = this.owner.bookmarks.keys;
        this.listviewInstance = new ListView({
            dataSource: bookmarks,
            cssClass: 'e-bookmark-listview',
        });
        this.listviewInstance.appendTo(listviewDiv);
        this.listviewInstance.addEventListener('select', this.selectHandler);
        let buttonDiv = createElement('div', { className: 'e-bookmark-button' });
        commonDiv.appendChild(buttonDiv);
        let addbuttonDiv = createElement('div', { className: 'e-bookmark-addbutton' });
        buttonDiv.appendChild(addbuttonDiv);
        let addButtonElement = createElement('button', { innerHTML: 'Add', id: 'add' });
        addbuttonDiv.appendChild(addButtonElement);
        let addbutton = new Button({ cssClass: 'e-button-custom' });
        addbutton.appendTo(addButtonElement);
        addButtonElement.addEventListener('click', this.addBookmark);
        let deleteButtonDiv = createElement('div', { className: 'e-bookmark-deletebutton' });
        buttonDiv.appendChild(deleteButtonDiv);
        let deleteButtonElement = createElement('button', { innerHTML: 'Delete', id: 'delete' });
        deleteButtonDiv.appendChild(deleteButtonElement);
        let deletebutton = new Button({ cssClass: 'e-button-custom' });
        deletebutton.appendTo(deleteButtonElement);
        deleteButtonElement.addEventListener('click', this.deleteBookmark);
        let gotoButtonDiv = createElement('div', { className: 'e-bookmark-gotobutton' });
        buttonDiv.appendChild(gotoButtonDiv);
        let gotoButtonElement = createElement('button', { innerHTML: 'Go To', id: 'goto' });
        gotoButtonDiv.appendChild(gotoButtonElement);
        let gotobutton = new Button({ cssClass: 'e-button-custom' });
        gotobutton.appendTo(gotoButtonElement);
        gotoButtonElement.addEventListener('click', this.gotoBookmark);
    }
    /**
     * @private
     */
    show() {
        let bookmarks = this.owner.getBookmarks();
        let localObj = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localObj.setLocale(this.owner.owner.locale);
        setCulture(this.owner.owner.locale);
        // if (!this.target) {
        this.initBookmarkDialog(localObj, bookmarks);
        //}
        this.owner.dialog.header = 'Bookmark';
        this.owner.dialog.height = 'auto';
        this.owner.dialog.width = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = this.owner.updateFocus;
        this.owner.dialog.close = this.owner.updateFocus;
        this.owner.dialog.buttons = [{
                click: this.removeObjects.bind(this),
                buttonModel: { content: localObj.getConstant('Cancel'), cssClass: 'e-flat e-hyper-insert', isPrimary: true }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    }
    removeObjects() {
        this.owner.dialog.hide();
    }
    /**
     * @private
     */
    destroy() {
        if (this.textBoxInput) {
            this.textBoxInput.remove();
            this.textBoxInput = undefined;
        }
        if (this.listviewInstance) {
            this.listviewInstance.destroy();
            this.listviewInstance = undefined;
        }
    }
}

/**
 * The Table of contents dialog is used to insert or edit table of contents at selection.
 */
class TableOfContentsDialog {
    /**
     * @private
     */
    constructor(viewer) {
        /**
         * @private
         */
        this.loadTableofContentDialog = () => {
            this.owner.updateFocus();
            this.pageNumber.checked = true;
            this.rightAlign.disabled = false;
            this.rightAlign.checked = true;
            this.tabLeader.enabled = true;
            this.hyperlink.checked = true;
            this.style.checked = true;
            this.outline.checked = true;
            this.outline.disabled = false;
            this.showLevel.enabled = true;
        };
        /**
         * @private
         */
        this.closeTableOfContentDialog = () => {
            this.unWireEventsAndBindings();
            this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.onCancelButtonClick = () => {
            this.owner.dialog.hide();
            this.unWireEventsAndBindings();
        };
        /* tslint:disable:no-any */
        this.selectHandler = (args) => {
            this.textBoxInput.value = args.text;
            /* tslint:disable:no-any */
            let value = document.getElementById('toclist');
            value.setSelectionRange(0, args.text.length);
            value.focus();
        };
        this.showStyleDialog = () => {
            if (!isNullOrUndefined(this.owner.owner.styleDialogModule)) {
                this.owner.owner.styleDialogModule.show(this.textBoxInput.value);
            }
        };
        this.changeShowLevelValue = (event) => {
            let levels = event.value;
            let values = [];
            switch (levels) {
                case 1:
                    values = ['1', null, null, null, null, null, null, null, null];
                    this.changeByValue(values);
                    break;
                case 2:
                    values = ['1', '2', null, null, null, null, null, null, null];
                    this.changeByValue(values);
                    break;
                case 3:
                    values = ['1', '2', '3', null, null, null, null, null, null];
                    this.changeByValue(values);
                    break;
                case 4:
                    values = ['1', '2', '3', '4', null, null, null, null, null];
                    this.changeByValue(values);
                    break;
                case 5:
                    values = ['1', '2', '3', '4', '5', null, null, null, null];
                    this.changeByValue(values);
                    break;
                case 6:
                    values = ['1', '2', '3', '4', '5', '6', null, null, null];
                    this.changeByValue(values);
                    break;
                case 7:
                    values = ['1', '2', '3', '4', '5', '6', '7', null, null];
                    this.changeByValue(values);
                    break;
                case 8:
                    values = ['1', '2', '3', '4', '5', '6', '7', '8', null];
                    this.changeByValue(values);
                    break;
                case 9:
                    values = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];
                    this.changeByValue(values);
                    break;
            }
        };
        this.changeByValue = (headings) => {
            this.heading1.value = headings[0];
            this.heading2.value = headings[1];
            this.heading3.value = headings[2];
            this.heading4.value = headings[3];
            this.heading5.value = headings[4];
            this.heading6.value = headings[5];
            this.heading7.value = headings[6];
            this.heading8.value = headings[7];
            this.heading9.value = headings[8];
        };
        this.reset = () => {
            this.showLevel.enabled = true;
            this.showLevel.value = 3;
            this.outline.disabled = false;
            this.outline.checked = true;
            let values = ['1', '2', '3', null, null, null, null, null, null];
            this.changeByValue(values);
            this.normal.value = null;
        };
        this.changeStyle = (args) => {
            let headingValue = args.srcElement.value;
            let value = this.getElementValue(args.srcElement);
            if (headingValue !== value && headingValue !== '') {
                this.showLevel.enabled = false;
            }
            else {
                this.showLevel.enabled = true;
                this.checkLevel();
            }
        };
        this.changeHeadingStyle = (args) => {
            let headingValue = args.srcElement.value;
            if (headingValue === '') {
                this.showLevel.enabled = true;
            }
            else {
                this.showLevel.enabled = false;
            }
            if (this.normal === args.srcElement) {
                this.outline.checked = false;
                this.outline.disabled = true;
            }
        };
        /**
         * @private
         */
        this.changePageNumberValue = (args) => {
            if (args.checked) {
                this.rightAlign.checked = true;
                this.rightAlign.disabled = false;
                this.tabLeader.enabled = true;
            }
            else {
                this.rightAlign.disabled = true;
                this.tabLeader.enabled = false;
            }
        };
        /**
         * @private
         */
        this.changeRightAlignValue = (args) => {
            if (args.checked) {
                this.tabLeader.enabled = true;
            }
            else {
                this.tabLeader.enabled = false;
            }
        };
        /**
         * @private
         */
        this.changeStyleValue = (args) => {
            if (args.checked) {
                this.heading1.disabled = false;
                this.heading2.disabled = false;
                this.heading3.disabled = false;
                this.heading4.disabled = false;
                this.heading5.disabled = false;
                this.heading6.disabled = false;
                this.heading7.disabled = false;
                this.heading8.disabled = false;
                this.heading9.disabled = false;
                this.normal.disabled = false;
            }
            else {
                this.heading1.disabled = true;
                this.heading2.disabled = true;
                this.heading3.disabled = true;
                this.heading4.disabled = true;
                this.heading5.disabled = true;
                this.heading6.disabled = true;
                this.heading7.disabled = true;
                this.heading8.disabled = true;
                this.heading9.disabled = true;
                this.normal.disabled = true;
            }
        };
        /**
         * @private
         */
        this.applyTableOfContentProperties = () => {
            let tocSettings = {
                startLevel: 1,
                endLevel: this.showLevel.value,
                includeHyperlink: this.hyperlink.checked,
                includePageNumber: this.pageNumber.checked,
                rightAlign: this.rightAlign.checked,
                tabLeader: this.tabLeader.value,
                includeOutlineLevels: this.outline.checked
            };
            this.applyLevelSetting(tocSettings);
            this.owner.owner.editorModule.insertTableOfContents(tocSettings);
            this.owner.dialog.hide();
        };
        /**
         * @private
         */
        this.unWireEventsAndBindings = () => {
            this.pageNumber.checked = false;
            this.rightAlign.checked = false;
            this.tabLeader.value = '';
            this.hyperlink.checked = false;
            this.style.checked = false;
            this.outline.checked = false;
            this.normal.value = '';
        };
        this.owner = viewer;
    }
    getModuleName() {
        return 'TableOfContentsDialog';
    }
    /*tslint:disable max-func-body-length*/
    /**
     * @private
     */
    initTableOfContentDialog(locale) {
        let ownerId = this.owner.owner.containerId;
        let id = ownerId + '_toc_dialog';
        this.target = createElement('div', { id: id, className: 'e-de-toc-dlg-container' });
        this.owner.owner.element.appendChild(this.target);
        // tslint:disable-next-line:max-line-length
        let generalDiv = createElement('div', { id: 'general_div', className: 'e-de-toc-dlg-sub-container' });
        this.target.appendChild(generalDiv);
        // tslint:disable-next-line:max-line-length
        let genLabel = createElement('div', { id: ownerId + '_genLabel', className: 'e-de-toc-dlg-main-heading', styles: 'margin-bottom: 13px;', innerHTML: locale.getConstant('General') });
        generalDiv.appendChild(genLabel);
        // tslint:disable-next-line:max-line-length
        let leftGeneralDiv = createElement('div', { id: 'left_general', styles: 'float:left;position:relative;' });
        generalDiv.appendChild(leftGeneralDiv);
        // tslint:disable-next-line:max-line-length
        let rightGeneralDiv = createElement('div', { styles: 'position:relative;', className: 'e-de-toc-dlg-right-general-div' });
        generalDiv.appendChild(rightGeneralDiv);
        // tslint:disable-next-line:max-line-length
        let leftBottomGeneralDiv = createElement('div', { id: 'leftBottom_general', styles: 'float:left;position:absolute;top:210px;' });
        generalDiv.appendChild(leftBottomGeneralDiv);
        // tslint:disable-next-line:max-line-length
        let rightBottomGeneralDiv = createElement('div', { className: 'e-de-toc-dlg-right-sub-container', styles: 'float:right;' });
        generalDiv.appendChild(rightBottomGeneralDiv);
        // tslint:disable-next-line:max-line-length
        let pageNumberDiv = createElement('div', { id: 'pageNumber_div', className: 'e-de-toc-dlg-sub-container' });
        let pageNumber = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_pageNumber'
        });
        pageNumberDiv.appendChild(pageNumber);
        // tslint:disable-next-line:max-line-length
        let rightAlignDiv = createElement('div', { id: 'rightAlign_div', className: 'e-de-toc-dlg-sub-container' });
        let rightAlign = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_rightAlign'
        });
        rightAlignDiv.appendChild(rightAlign);
        // tslint:disable-next-line:max-line-length
        this.pageNumber = new CheckBox({ label: locale.getConstant('Show page numbers'), checked: true, change: this.changePageNumberValue });
        // tslint:disable-next-line:max-line-length
        this.rightAlign = new CheckBox({ label: locale.getConstant('Right align page numbers'), checked: true, change: this.changeRightAlignValue });
        this.pageNumber.appendTo(pageNumber);
        this.rightAlign.appendTo(rightAlign);
        let tabDiv = createElement('div', { id: 'tab_div', className: 'e-de-toc-dlg-tab-div' });
        // tslint:disable-next-line:max-line-length
        let tabLeaderLabelDiv = createElement('div', { id: 'tabLeaderLabel_div' });
        // tslint:disable-next-line:max-line-length
        let tabLeaderLabel = createElement('label', { id: ownerId + '_tabLeaderLabel', className: 'e-de-toc-dlg-heading', innerHTML: locale.getConstant('Tab leader') + ':' });
        tabLeaderLabelDiv.appendChild(tabLeaderLabel);
        let tabLeaderDiv = createElement('div', { id: 'tabLeader_div' });
        let tabLeader = createElement('select', {
            id: ownerId + '_tabLeader',
            innerHTML: '<option value="None">' + '(' + locale.getConstant('None').toLocaleLowerCase() + ')' +
                '</option><option value="Dot" selected>' + '....................' +
                '</option><option value="Hyphen">' + '-------------------' +
                '</option><option value="Underscore">' + '____________' + '</option>'
        });
        tabLeaderDiv.appendChild(tabLeader);
        tabDiv.appendChild(tabLeaderLabelDiv);
        tabDiv.appendChild(tabLeaderDiv);
        leftGeneralDiv.appendChild(pageNumberDiv);
        leftGeneralDiv.appendChild(rightAlignDiv);
        leftGeneralDiv.appendChild(tabDiv);
        this.tabLeader = new DropDownList({ width: 210 });
        this.tabLeader.appendTo(tabLeader);
        let hyperlink = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_hyperlink'
        });
        rightGeneralDiv.appendChild(hyperlink);
        this.hyperlink = new CheckBox({ label: locale.getConstant('Use hyperlinks instead of page numbers'), checked: true });
        this.hyperlink.appendTo(hyperlink);
        // tslint:disable-next-line:max-line-length
        let showDiv = createElement('div', { id: 'show_div', className: 'e-de-toc-dlg-style-label' });
        // tslint:disable-next-line:max-line-length
        let showLevelLabelDiv = createElement('div', { id: 'showLevelLabel_div', className: 'e-de-toc-dlg-show-level-div' });
        // tslint:disable-next-line:max-line-length
        let showLevelLabel = createElement('label', { id: ownerId + '_showLevelLabel', className: 'e-de-toc-dlg-heading', innerHTML: locale.getConstant('Show levels') + ':' });
        showLevelLabelDiv.appendChild(showLevelLabel);
        // tslint:disable-next-line:max-line-length
        let showLevelDiv = createElement('div', { id: 'showLevel_div', className: 'e-de-toc-dlg-showlevel-div' });
        // tslint:disable-next-line:max-line-length
        let showLevel = createElement('input', { id: ownerId + '_showLevel', attrs: { 'type': 'text' } });
        showLevelDiv.appendChild(showLevel);
        showDiv.appendChild(showLevelLabelDiv);
        showDiv.appendChild(showLevelDiv);
        rightGeneralDiv.appendChild(showDiv);
        this.showLevel = new NumericTextBox({ format: '#', value: 3, min: 1, max: 9, width: 210, change: this.changeShowLevelValue });
        this.showLevel.appendTo(showLevel);
        // tslint:disable-next-line:max-line-length
        let buildTableDiv = createElement('div', { id: 'buildTable_div', className: 'e-de-toc-dlg-sub-container' });
        // tslint:disable-next-line:max-line-length
        let buildTableLabel = createElement('div', { id: ownerId + '_buildTableLabel', className: 'e-de-toc-dlg-main-heading e-de-toc-dlg-build-table', styles: 'margin-bottom: 13px;', innerHTML: locale.getConstant('Build table of contents from') + ':' });
        leftBottomGeneralDiv.appendChild(buildTableDiv);
        leftBottomGeneralDiv.appendChild(buildTableLabel);
        let style = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_style',
        });
        leftBottomGeneralDiv.appendChild(style);
        this.style = new CheckBox({ label: locale.getConstant('Styles'), checked: true, change: this.changeStyleValue });
        this.style.appendTo(style);
        let table = createElement('TABLE', { styles: 'margin-top:3px;' });
        let tr1 = createElement('tr');
        let td1 = createElement('td', { styles: 'width:120px;padding-left:10px;' });
        let availableLabel = createElement('label', {
            // tslint:disable-next-line:max-line-length
            innerHTML: locale.getConstant('Available styles'), className: 'e-de-toc-dlg-main-heading e-de-toc-dlg-sub-level-heading', id: this.target.id + '_availableLabel'
        });
        td1.appendChild(availableLabel);
        let td2 = createElement('td');
        let tocLabel = createElement('label', {
            innerHTML: locale.getConstant('TOC level') + ':', className: 'e-de-toc-dlg-main-heading e-de-toc-dlg-sub-level-heading',
            id: this.target.id + '_tocLabel'
        });
        td2.appendChild(tocLabel);
        tr1.appendChild(td1);
        tr1.appendChild(td2);
        table.appendChild(tr1);
        // tslint:disable-next-line:max-line-length
        let tableDiv = createElement('div', { id: 'table_div', className: 'e-de-toc-table-div' });
        let table1 = createElement('TABLE');
        let tr2 = createElement('tr');
        let td3 = createElement('td');
        let heading1Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 1',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading1Label'
        });
        td3.appendChild(heading1Label);
        let td4 = createElement('td');
        this.heading1 = createElement('input', { id: '_heading1', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading1.value = '1';
        this.heading1.addEventListener('keyup', this.changeStyle);
        td4.appendChild(this.heading1);
        tr2.appendChild(td3);
        tr2.appendChild(td4);
        let tr3 = createElement('tr');
        let td5 = createElement('td');
        let heading2Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 2',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading2Label'
        });
        td5.appendChild(heading2Label);
        let td6 = createElement('td');
        this.heading2 = createElement('input', { id: '_heading2', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading2.value = '2';
        this.heading2.addEventListener('keyup', this.changeStyle);
        td6.appendChild(this.heading2);
        tr3.appendChild(td5);
        tr3.appendChild(td6);
        let tr4 = createElement('tr');
        let td7 = createElement('td');
        let heading3Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 3',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading3Label'
        });
        td7.appendChild(heading3Label);
        let td8 = createElement('td');
        this.heading3 = createElement('input', { id: '_heading3', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading3.value = '3';
        this.heading3.addEventListener('keyup', this.changeStyle);
        td8.appendChild(this.heading3);
        tr4.appendChild(td7);
        tr4.appendChild(td8);
        let tr5 = createElement('tr');
        let td9 = createElement('td');
        let heading4Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 4',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading4Label'
        });
        td9.appendChild(heading4Label);
        let td10 = createElement('td');
        this.heading4 = createElement('input', { id: '_heading4', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading4.addEventListener('keyup', this.changeStyle);
        td10.appendChild(this.heading4);
        tr5.appendChild(td9);
        tr5.appendChild(td10);
        let tr6 = createElement('tr');
        let td11 = createElement('td');
        let heading5Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 5',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading5Label'
        });
        td11.appendChild(heading5Label);
        let td12 = createElement('td');
        this.heading5 = createElement('input', { id: '_heading5', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading5.addEventListener('keyup', this.changeStyle);
        td12.appendChild(this.heading5);
        tr6.appendChild(td11);
        tr6.appendChild(td12);
        let tr7 = createElement('tr');
        let td13 = createElement('td');
        let heading6Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 6',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading6Label'
        });
        td13.appendChild(heading6Label);
        let td14 = createElement('td');
        this.heading6 = createElement('input', { id: '_heading6', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading6.addEventListener('keyup', this.changeStyle);
        td14.appendChild(this.heading6);
        tr7.appendChild(td13);
        tr7.appendChild(td14);
        let tr8 = createElement('tr');
        let td15 = createElement('td');
        let heading7Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 7',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading7Label'
        });
        td15.appendChild(heading7Label);
        let td16 = createElement('td');
        this.heading7 = createElement('input', { id: '_heading7', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading7.addEventListener('keyup', this.changeStyle);
        td16.appendChild(this.heading7);
        tr8.appendChild(td15);
        tr8.appendChild(td16);
        let tr9 = createElement('tr');
        let td17 = createElement('td');
        let heading8Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 8',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading8Label'
        });
        td17.appendChild(heading8Label);
        let td18 = createElement('td');
        this.heading8 = createElement('input', { id: '_heading8', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading8.addEventListener('keyup', this.changeStyle);
        td18.appendChild(this.heading8);
        tr9.appendChild(td17);
        tr9.appendChild(td18);
        let tr10 = createElement('tr');
        let td19 = createElement('td');
        let heading9Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 9',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading9Label'
        });
        td19.appendChild(heading9Label);
        let td20 = createElement('td');
        this.heading9 = createElement('input', { id: '_heading9', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading9.addEventListener('keyup', this.changeStyle);
        td20.appendChild(this.heading9);
        tr10.appendChild(td19);
        tr10.appendChild(td20);
        let tr12 = createElement('tr');
        let td23 = createElement('td');
        let normalLabel = createElement('label', {
            innerHTML: locale.getConstant('Normal'),
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_normalLabel'
        });
        td23.appendChild(normalLabel);
        let td24 = createElement('td');
        this.normal = createElement('input', { id: '_normal', className: 'e-input e-de-toc-dlg-toc-level' });
        this.normal.addEventListener('keyup', this.changeHeadingStyle);
        td24.appendChild(this.normal);
        tr12.appendChild(td23);
        tr12.appendChild(td24);
        table1.appendChild(tr2);
        table1.appendChild(tr3);
        table1.appendChild(tr4);
        table1.appendChild(tr5);
        table1.appendChild(tr6);
        table1.appendChild(tr7);
        table1.appendChild(tr8);
        table1.appendChild(tr9);
        table1.appendChild(tr10);
        table1.appendChild(tr12);
        tableDiv.appendChild(table1);
        let stylesLevelDiv = createElement('div', { className: 'e-de-toc-styles-table-div' });
        stylesLevelDiv.appendChild(table);
        stylesLevelDiv.appendChild(tableDiv);
        leftBottomGeneralDiv.appendChild(stylesLevelDiv);
        //leftBottomGeneralDiv.appendChild(table); leftBottomGeneralDiv.appendChild(tableDiv);
        let fieldsDiv = createElement('div', { id: 'fields_div', styles: 'display: flex;' });
        leftBottomGeneralDiv.appendChild(fieldsDiv);
        let outDiv = createElement('div', { id: 'out_div' });
        // tslint:disable-next-line:max-line-length
        let outlineDiv = createElement('div', { id: 'outline_div', className: 'e-de-toc-dlg-sub-container e-de-toc-dlg-outline-levels' });
        let outline = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: '_outline'
        });
        outlineDiv.appendChild(outline);
        outDiv.appendChild(outlineDiv);
        fieldsDiv.appendChild(outDiv);
        this.outline = new CheckBox({ label: locale.getConstant('Outline levels'), checked: true });
        this.outline.appendTo(outline);
        let resetButtonDiv = createElement('div', { className: 'e-de-toc-reset-button' });
        fieldsDiv.appendChild(resetButtonDiv);
        let resetElement = createElement('button', { innerHTML: 'Reset', id: 'reset' });
        resetButtonDiv.appendChild(resetElement);
        let resetButton = new Button({ cssClass: 'e-btn e-flat' });
        resetButton.appendTo(resetElement);
        resetElement.addEventListener('click', this.reset);
        // tslint:disable-next-line:max-line-length
        let tocStylesDiv = createElement('div', { id: 'tocStyles_div', className: 'e-de-toc-dlg-sub-container' });
        // tslint:disable-next-line:max-line-length
        let tocStylesLabel = createElement('div', {
            id: ownerId + '_tocStylesLabel', className: 'e-de-toc-dlg-main-heading e-de-toc-dlg-styles',
            innerHTML: locale.getConstant('Styles') + ':'
        });
        rightBottomGeneralDiv.appendChild(tocStylesDiv);
        rightBottomGeneralDiv.appendChild(tocStylesLabel);
        let textBoxDiv = createElement('div', { className: 'e-de-toc-dlg-style-input' });
        rightBottomGeneralDiv.appendChild(textBoxDiv);
        this.textBoxInput = createElement('input', { className: 'e-input', id: 'toclist' });
        this.textBoxInput.setAttribute('type', 'text');
        textBoxDiv.appendChild(this.textBoxInput);
        let listViewDiv = createElement('div', { className: 'e-de-toc-list-view' });
        let styleValues = ['TOC 1', 'TOC 2', 'TOC 3', 'TOC 4', 'TOC 5', 'TOC 6', 'TOC 7', 'TOC 8', 'TOC 9'];
        this.listViewInstance = new ListView({ dataSource: styleValues, cssClass: 'e-toc-list-view' });
        this.listViewInstance.appendTo(listViewDiv);
        this.listViewInstance.addEventListener('select', this.selectHandler);
        rightBottomGeneralDiv.appendChild(listViewDiv);
        let modifyButtonDiv = createElement('div', { className: 'e-de-toc-modify-button' });
        rightBottomGeneralDiv.appendChild(modifyButtonDiv);
        let modifyElement = createElement('button', { innerHTML: 'Modify', id: 'modify' });
        modifyButtonDiv.appendChild(modifyElement);
        let modifyButton = new Button({ cssClass: 'e-btn e-flat' });
        modifyButton.appendTo(modifyElement);
        modifyElement.addEventListener('click', this.showStyleDialog);
    }
    /**
     * @private
     */
    show() {
        let localValue = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localValue.setLocale(this.owner.owner.locale);
        setCulture(this.owner.owner.locale);
        if (!this.target) {
            this.initTableOfContentDialog(localValue);
        }
        this.owner.dialog.header = localValue.getConstant('Table of Contents');
        this.owner.dialog.width = 'auto';
        this.owner.dialog.height = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = this.loadTableofContentDialog;
        this.owner.dialog.close = this.closeTableOfContentDialog;
        this.owner.dialog.buttons = [{
                click: this.applyTableOfContentProperties,
                buttonModel: { content: localValue.getConstant('Ok'), cssClass: 'e-flat e-toc-okay', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: localValue.getConstant('Cancel'), cssClass: 'e-flat e-toc-cancel' }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    }
    checkLevel() {
        if (this.heading1.value !== '') {
            this.showLevel.value = 1;
        }
        if (this.heading2.value !== '') {
            this.showLevel.value = 2;
        }
        if (this.heading3.value !== '') {
            this.showLevel.value = 3;
        }
        if (this.heading4.value !== '') {
            this.showLevel.value = 4;
        }
        if (this.heading5.value !== '') {
            this.showLevel.value = 5;
        }
        if (this.heading6.value !== '') {
            this.showLevel.value = 6;
        }
        if (this.heading7.value !== '') {
            this.showLevel.value = 7;
        }
        if (this.heading8.value !== '') {
            this.showLevel.value = 8;
        }
        if (this.heading9.value !== '') {
            this.showLevel.value = 9;
        }
    }
    getElementValue(element) {
        switch (element) {
            case this.heading1:
                return '1';
            case this.heading2:
                return '2';
            case this.heading3:
                return '3';
            case this.heading4:
                return '4';
            case this.heading5:
                return '5';
            case this.heading6:
                return '6';
            case this.heading7:
                return '7';
            case this.heading8:
                return '8';
            case this.heading9:
                return '9';
            default:
                return '1';
        }
    }
    getHeadingLevel(index) {
        switch (index) {
            case 1:
                return parseInt(this.heading1.value);
            case 2:
                return parseInt(this.heading2.value);
            case 3:
                return parseInt(this.heading3.value);
            case 4:
                return parseInt(this.heading4.value);
            case 5:
                return parseInt(this.heading5.value);
            case 6:
                return parseInt(this.heading6.value);
            case 7:
                return parseInt(this.heading7.value);
            case 8:
                return parseInt(this.heading8.value);
            case 9:
                return parseInt(this.heading9.value);
            default:
                return 0;
        }
    }
    applyLevelSetting(tocSettings) {
        tocSettings.levelSettings = {};
        let headingPrefix = 'Heading ';
        let newStartLevel = 0;
        let newEndLevel = 0;
        let isEndLevel = false;
        for (let i = 1; i <= tocSettings.endLevel; i++) {
            let outlineLevel = this.getHeadingLevel(i);
            if (i === outlineLevel) {
                if (newStartLevel === 0) {
                    newStartLevel = i;
                    isEndLevel = false;
                }
                if (!isEndLevel) {
                    newEndLevel = i;
                }
            }
            else {
                isEndLevel = true;
                if (outlineLevel !== 0) {
                    let headingStyle = headingPrefix + i.toString();
                    tocSettings.levelSettings[headingStyle] = outlineLevel;
                }
            }
        }
        tocSettings.startLevel = newStartLevel;
        tocSettings.endLevel = newEndLevel;
        if (this.normal.value !== '') {
            tocSettings.levelSettings['Normal'] = +this.normal.value;
        }
    }
    /**
     * @private
     */
    destroy() {
        if (this.pageNumber) {
            this.pageNumber.destroy();
            this.pageNumber = undefined;
        }
        if (this.rightAlign) {
            this.rightAlign.destroy();
            this.rightAlign = undefined;
        }
        if (this.tabLeader) {
            this.tabLeader.destroy();
            this.tabLeader = undefined;
        }
        if (this.showLevel) {
            this.showLevel.destroy();
            this.showLevel = undefined;
        }
        if (this.hyperlink) {
            this.hyperlink.destroy();
            this.hyperlink = undefined;
        }
        if (this.style) {
            this.style.destroy();
            this.style = undefined;
        }
        if (this.outline) {
            this.outline.destroy();
            this.outline = undefined;
        }
        if (this.listViewInstance) {
            this.listViewInstance.destroy();
            this.listViewInstance = undefined;
        }
        this.heading1 = undefined;
        this.heading2 = undefined;
        this.heading3 = undefined;
        this.heading4 = undefined;
        this.heading5 = undefined;
        this.heading6 = undefined;
        this.heading7 = undefined;
        this.heading8 = undefined;
        this.heading9 = undefined;
        this.normal = undefined;
        this.textBoxInput = undefined;
        this.owner = undefined;
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (let count = 0; count < this.target.childNodes.length; count++) {
                this.target.removeChild(this.target.childNodes[count]);
                count--;
            }
            this.target = undefined;
        }
    }
}

/**
 * The Page setup dialog is used to modify formatting of selected sections.
 */
class PageSetupDialog {
    /**
     * @private
     */
    constructor(viewer) {
        this.isPortrait = true;
        /**
         * @private
         */
        this.loadPageSetupDialog = () => {
            this.owner.updateFocus();
            let sectionFormat = this.owner.selection.sectionFormat;
            this.topMarginBox.value = sectionFormat.topMargin;
            this.leftMarginBox.value = sectionFormat.leftMargin;
            this.bottomMarginBox.value = sectionFormat.bottomMargin;
            this.rightMarginBox.value = sectionFormat.rightMargin;
            this.widthBox.value = sectionFormat.pageWidth;
            this.heightBox.value = sectionFormat.pageHeight;
            this.checkBox1.checked = sectionFormat.differentOddAndEvenPages;
            this.checkBox2.checked = sectionFormat.differentFirstPage;
            this.headerBox.value = sectionFormat.headerDistance;
            this.footerBox.value = sectionFormat.footerDistance;
            if (this.widthBox.value > this.heightBox.value) {
                this.landscape.checked = true;
            }
            else {
                this.portrait.checked = true;
            }
        };
        /**
         * @private
         */
        this.closePageSetupDialog = () => {
            this.unWireEventsAndBindings();
            this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.onCancelButtonClick = () => {
            this.owner.dialog.hide();
            this.unWireEventsAndBindings();
        };
        /**
         * @private
         */
        this.keyUpInsertPageSettings = (event) => {
            if (event.keyCode === 13) {
                this.applyPageSetupProperties();
            }
        };
        /**
         * @private
         */
        this.applyPageSetupProperties = () => {
            let sectionFormat = new WSectionFormat();
            sectionFormat.bottomMargin = this.bottomMarginBox.value;
            sectionFormat.topMargin = this.topMarginBox.value;
            sectionFormat.leftMargin = this.leftMarginBox.value;
            sectionFormat.rightMargin = this.rightMarginBox.value;
            sectionFormat.pageWidth = this.widthBox.value;
            sectionFormat.pageHeight = this.heightBox.value;
            sectionFormat.differentOddAndEvenPages = this.checkBox1.checked;
            sectionFormat.differentFirstPage = this.checkBox2.checked;
            sectionFormat.headerDistance = this.headerBox.value;
            sectionFormat.footerDistance = this.footerBox.value;
            this.owner.owner.editorModule.onApplySectionFormat(undefined, sectionFormat);
            this.owner.dialog.hide();
        };
        /**
         * @private
         */
        this.changeByPaperSize = (event) => {
            let value = event.value;
            let sectionFormat = this.owner.selection.sectionFormat;
            let width = sectionFormat.pageWidth;
            let height = sectionFormat.pageHeight;
            if (this.owner.selection.sectionFormat.pageWidth > this.owner.selection.sectionFormat.pageHeight || this.landscape.checked) {
                this.isPortrait = false;
            }
            else {
                this.isPortrait = true;
            }
            if (value === 'letter') {
                if (this.isPortrait) {
                    this.widthBox.value = 612;
                    this.heightBox.value = 792;
                }
                else {
                    this.widthBox.value = 792;
                    this.heightBox.value = 612;
                }
            }
            else if (value === 'tabloid') {
                if (this.isPortrait) {
                    this.widthBox.value = 792;
                    this.heightBox.value = 1224;
                }
                else {
                    this.widthBox.value = 1224;
                    this.heightBox.value = 792;
                }
            }
            else if (value === 'legal') {
                if (this.isPortrait) {
                    this.widthBox.value = 612;
                    this.heightBox.value = 1008;
                }
                else {
                    this.widthBox.value = 1008;
                    this.heightBox.value = 612;
                }
            }
            else if (value === 'statement') {
                if (this.isPortrait) {
                    this.widthBox.value = 392;
                    this.heightBox.value = 612;
                }
                else {
                    this.widthBox.value = 612;
                    this.heightBox.value = 392;
                }
            }
            else if (value === 'executive') {
                if (this.isPortrait) {
                    this.widthBox.value = 522;
                    this.heightBox.value = 756;
                }
                else {
                    this.widthBox.value = 756;
                    this.heightBox.value = 522;
                }
            }
            else if (value === 'a3') {
                if (this.isPortrait) {
                    this.widthBox.value = 841.9;
                    this.heightBox.value = 1190.55;
                }
                else {
                    this.widthBox.value = 1190.55;
                    this.heightBox.value = 841.9;
                }
            }
            else if (value === 'a4') {
                if (this.isPortrait) {
                    this.widthBox.value = 595.3;
                    this.heightBox.value = 841.9;
                }
                else {
                    this.widthBox.value = 841.9;
                    this.heightBox.value = 595.3;
                }
            }
            else if (value === 'a5') {
                if (this.isPortrait) {
                    this.widthBox.value = 419.55;
                    this.heightBox.value = 595.3;
                }
                else {
                    this.widthBox.value = 595.3;
                    this.heightBox.value = 419.55;
                }
            }
            else if (value === 'b4') {
                if (this.isPortrait) {
                    this.widthBox.value = 728.5;
                    this.heightBox.value = 1031.8;
                }
                else {
                    this.widthBox.value = 1031.8;
                    this.heightBox.value = 728.5;
                }
            }
            else if (value === 'b5') {
                if (this.isPortrait) {
                    this.widthBox.value = 515.9;
                    this.heightBox.value = 728.5;
                }
                else {
                    this.widthBox.value = 728.5;
                    this.heightBox.value = 515.9;
                }
            }
            else if (value === 'customsize') {
                if (this.isPortrait) {
                    this.widthBox.value = 515.9;
                    this.heightBox.value = 728.5;
                }
                else {
                    this.widthBox.value = 728.5;
                    this.heightBox.value = 515.9;
                }
            }
        };
        /**
         * @private
         */
        this.onPortrait = (event) => {
            this.landscape.checked = false;
            let width = this.widthBox.value;
            let height = this.heightBox.value;
            if (width > height) {
                this.widthBox.value = height;
                this.heightBox.value = width;
            }
        };
        /**
         * @private
         */
        this.onLandscape = (event) => {
            this.portrait.checked = false;
            let width = this.widthBox.value;
            let height = this.heightBox.value;
            if (width < height) {
                this.widthBox.value = height;
                this.heightBox.value = width;
            }
        };
        /**
         * @private
         */
        this.unWireEventsAndBindings = () => {
            this.paperSize.value = undefined;
            this.topMarginBox.value = undefined;
            this.bottomMarginBox.value = undefined;
            this.leftMarginBox.value = undefined;
            this.rightMarginBox.value = undefined;
            this.headerBox.value = undefined;
            this.footerBox.value = undefined;
            this.widthBox.value = undefined;
            this.heightBox.value = undefined;
            this.checkBox1.checked = false;
            this.checkBox2.checked = false;
            this.portrait.checked = false;
            this.landscape.checked = false;
        };
        this.owner = viewer;
    }
    getModuleName() {
        return 'PageSetupDialog';
    }
    /**
     * @private
     */
    initPageSetupDialog(locale) {
        let id = this.owner.owner.containerId + '_pagesetup_dialog';
        this.target = createElement('div', { id: id, className: 'e-de-pagesetup-dlg-container' });
        this.owner.owner.element.appendChild(this.target);
        let ejtabContainer = createElement('div', { id: this.target.id + '_MarginTabContainer' });
        this.target.appendChild(ejtabContainer);
        this.marginTab = createElement('div', {
            id: this.target.id + '_marginPropertyTab', styles: 'position: relative;width:400px;'
        });
        this.paperTab = createElement('div', {
            id: this.target.id + '_paperSizePropertyTab', styles: 'position: relative;width:400px;'
        });
        this.layoutTab = createElement('div', {
            id: this.target.id + '_CellPropertiesDialogTab', styles: 'position: relative;width:400px;'
        });
        // tslint:disable-next-line:max-line-length
        let ejtab = createElement('div', { id: this.target.id + '_PageSetupDialogTab', className: 'e-de-page-setup-ppty-tab' });
        let headerContainer = createElement('div', { className: 'e-tab-header' });
        let marginHeader = createElement('div', {
            id: this.target.id + '_marginHeader', innerHTML: locale.getConstant('Margin')
        });
        let paperHeader = createElement('div', {
            id: this.target.id + '_paperHeader', innerHTML: locale.getConstant('Paper')
        });
        let layoutHeader = createElement('div', {
            id: this.target.id + '_layoutHeader', innerHTML: locale.getConstant('Layout')
        });
        headerContainer.appendChild(marginHeader);
        headerContainer.appendChild(paperHeader);
        headerContainer.appendChild(layoutHeader);
        let contentContainer = createElement('div', { className: 'e-content' });
        let marginContent = createElement('div', { id: this.target.id + '_marginContent' });
        let paperContent = createElement('div', { id: this.target.id + '_paperContent' });
        let layoutContent = createElement('div', { id: this.target.id + '_layoutContent' });
        marginContent.appendChild(this.marginTab);
        paperContent.appendChild(this.paperTab);
        layoutContent.appendChild(this.layoutTab);
        contentContainer.appendChild(marginContent);
        contentContainer.appendChild(paperContent);
        contentContainer.appendChild(layoutContent);
        ejtab.appendChild(headerContainer);
        ejtab.appendChild(contentContainer);
        ejtabContainer.appendChild(ejtab);
        this.initMarginProperties(this.marginTab, locale);
        this.initPaperSizeProperties(this.paperTab, locale);
        this.initLayoutProperties(this.layoutTab, locale);
        let tabObj = new Tab({}, ejtab);
        this.target.addEventListener('keyup', this.keyUpInsertPageSettings);
        let marginTabHeader = tabObj.element.getElementsByClassName('e-item e-toolbar-item')[0];
        let marginTabHeaderItem = marginTabHeader.getElementsByClassName('e-tab-wrap')[0];
        marginTabHeaderItem.classList.add('e-de-page-setup-dlg-margin-tab-header');
    }
    /**
     * @private
     */
    initMarginProperties(element, locale) {
        let marginDiv = createElement('div', {
            id: 'margin_div',
            className: 'e-de-page-setup-dlg-sub-container', styles: 'height:135px;'
        });
        // tslint:disable-next-line:max-line-length
        let leftMarginDiv = createElement('div', { id: 'left_margin', className: 'e-de-page-setup-dlg-left-sub-container' });
        marginDiv.appendChild(leftMarginDiv);
        // tslint:disable-next-line:max-line-length
        let rightMarginDiv = createElement('div', { className: 'e-de-page-setup-dlg-right-sub-container' });
        marginDiv.appendChild(rightMarginDiv);
        let topLabel = createElement('label', {
            innerHTML: locale.getConstant('Top'), className: 'e-de-page-setup-dlg-sub-header',
            id: this.target.id + '_TopLabel', styles: 'padding-top:0px;width:190px;'
        });
        let topTextBox = createElement('input', {
            attrs: { 'type': 'text' }, id: this.target.id + '_Top'
        });
        let bottomBoxLabel = createElement('label', {
            innerHTML: locale.getConstant('Bottom'),
            className: 'e-de-page-setup-dlg-sub-title-header', id: this.target.id + '_bottomLabel'
        });
        let bottomTextBox = createElement('input', {
            attrs: { 'type': 'text' },
            id: this.target.id + '_bottom'
        });
        leftMarginDiv.appendChild(topLabel);
        leftMarginDiv.appendChild(topTextBox);
        leftMarginDiv.appendChild(bottomBoxLabel);
        leftMarginDiv.appendChild(bottomTextBox);
        let leftBoxLabel = createElement('label', {
            innerHTML: locale.getConstant('Left'), className: 'e-de-page-setup-dlg-sub-header', styles: 'padding-top:0px;width:190px;',
            id: this.target.id + '_leftLabel'
        });
        let leftTextBox = createElement('input', {
            attrs: { 'type': 'text' }, id: this.target.id + '_left'
        });
        let rightLabel = createElement('label', {
            innerHTML: locale.getConstant('Right'),
            id: this.target.id + '_rightLabel', className: 'e-de-page-setup-dlg-sub-title-header'
        });
        let rightTextBox = createElement('input', {
            attrs: { 'type': 'text' },
            id: this.target.id + '_right'
        });
        rightMarginDiv.appendChild(leftBoxLabel);
        rightMarginDiv.appendChild(leftTextBox);
        rightMarginDiv.appendChild(rightLabel);
        rightMarginDiv.appendChild(rightTextBox);
        element.appendChild(marginDiv);
        this.topMarginBox = new NumericTextBox({ value: 71, width: 170, decimals: 2 });
        this.topMarginBox.appendTo(topTextBox);
        this.leftMarginBox = new NumericTextBox({ value: 73, width: 170, decimals: 2 });
        this.leftMarginBox.appendTo(leftTextBox);
        this.bottomMarginBox = new NumericTextBox({ value: 72, width: 170, decimals: 2 });
        this.bottomMarginBox.appendTo(bottomTextBox);
        this.rightMarginBox = new NumericTextBox({ value: 74, width: 170, decimals: 2 });
        this.rightMarginBox.appendTo(rightTextBox);
        // tslint:disable-next-line:max-line-length
        let orientationDiv = createElement('div', { id: 'orientation_div', className: 'e-de-page-setup-dlg-sub-container-port' });
        // tslint:disable-next-line:max-line-length
        let orientationLabeldiv = createElement('div', { id: '_orientationLabelDiv', className: 'e-de-page-setup-dlg-sub-label', innerHTML: locale.getConstant('Orientation') });
        let orientationPropDiv = createElement('div', { id: '_orientationPropDiv', styles: 'display: flex;', className: 'e-de-page-setup-dlg-orientation-prop' });
        let portraitDiv = createElement('div', { id: '_portraitDiv', styles: 'padding-right: 30px;' });
        let portrait = createElement('input', {
            attrs: { 'type': 'radiobutton' }, id: this.target.id + '_portrait'
        });
        let landscapeDiv = createElement('div', { id: '_landscapeDiv' });
        let landscape = createElement('input', {
            attrs: { 'type': 'radiobutton' }, id: this.target.id + '_landscape'
        });
        portraitDiv.appendChild(portrait);
        landscapeDiv.appendChild(landscape);
        orientationPropDiv.appendChild(portraitDiv);
        orientationPropDiv.appendChild(landscapeDiv);
        orientationDiv.appendChild(orientationLabeldiv);
        orientationDiv.appendChild(orientationPropDiv);
        this.portrait = new RadioButton({ label: locale.getConstant('Portrait'), checked: true, change: this.onPortrait });
        this.landscape = new RadioButton({ label: locale.getConstant('Landscape'), change: this.onLandscape });
        this.portrait.appendTo(portrait);
        this.landscape.appendTo(landscape);
        element.appendChild(orientationDiv);
    }
    /**
     * @private
     */
    initPaperSizeProperties(element, locale) {
        let sizeDiv = createElement('div', {
            id: 'size_div',
            className: 'e-de-page-setup-dlg-sub-size-container'
        });
        // tslint:disable-next-line:max-line-length
        let leftSizeDiv = createElement('div', { id: 'left_size', className: 'e-de-page-setup-dlg-left-sub-container' });
        sizeDiv.appendChild(leftSizeDiv);
        // tslint:disable-next-line:max-line-length
        let rightSizeDiv = createElement('div', { className: 'e-de-page-setup-dlg-right-sub-container' });
        sizeDiv.appendChild(rightSizeDiv);
        let widthLabel = createElement('label', {
            innerHTML: locale.getConstant('Width'), className: 'e-de-page-setup-dlg-sub-header',
            id: this.target.id + '_widthLabel', styles: 'padding-top:0px;width:190px;'
        });
        let widthTextBox = createElement('input', {
            attrs: { 'type': 'text' }, id: this.target.id + '_Width'
        });
        leftSizeDiv.appendChild(widthLabel);
        leftSizeDiv.appendChild(widthTextBox);
        let heightLabel = createElement('label', {
            innerHTML: locale.getConstant('Height'), className: 'e-de-page-setup-dlg-sub-header', styles: 'padding-top:0px;width:190px;',
            id: this.target.id + '_heightLabel'
        });
        let heightTextBox = createElement('input', {
            attrs: { 'type': 'text' }, id: this.target.id + '_height'
        });
        rightSizeDiv.appendChild(heightLabel);
        rightSizeDiv.appendChild(heightTextBox);
        element.appendChild(sizeDiv);
        this.widthBox = new NumericTextBox({ value: 612, width: 170, decimals: 2 });
        this.widthBox.appendTo(widthTextBox);
        this.heightBox = new NumericTextBox({ value: 792, width: 170, decimals: 2 });
        this.heightBox.appendTo(heightTextBox);
        // tslint:disable-next-line:max-line-length
        let paperSizeDiv = createElement('div', { id: '_paperSizeDiv', styles: 'height:37px;', className: 'e-de-page-setup-dlg-sub-container' });
        let paperSize = createElement('select', {
            id: this.target.id + '_papersize', styles: 'width:170px;padding-bottom: 20px;',
            innerHTML: '<option value="letter">' + locale.getConstant('Letter') +
                '</option><option value="tabloid">' + locale.getConstant('Tabloid') +
                '</option><option value="legal">' + locale.getConstant('Legal') +
                '</option><option value="statement">' + locale.getConstant('Statement') +
                '</option><option value="executive">' + locale.getConstant('Executive') +
                '</option><option value="a3">' + locale.getConstant('A3') +
                '</option><option value="a4">' + locale.getConstant('A4') +
                '</option><option value="a5">' + locale.getConstant('A5') +
                '</option><option value="b4">' + locale.getConstant('B4') +
                '</option><option value="b5">' + locale.getConstant('B5') +
                '</option><option value="customsize">' + locale.getConstant('Custom Size') + '</option>'
        });
        paperSizeDiv.appendChild(paperSize);
        this.paperSize = new DropDownList({ change: this.changeByPaperSize, width: '170px' });
        this.paperSize.appendTo(paperSize);
        element.appendChild(paperSizeDiv);
    }
    /**
     * @private
     */
    initLayoutProperties(element, locale) {
        // tslint:disable-next-line:max-line-length
        let layoutDiv = createElement('div', { id: '_layoutDiv', className: 'e-de-page-setup-dlg-layout-sub-container', });
        // tslint:disable-next-line:max-line-length
        let firstPageDiv = createElement('div', { id: '_firstPageDiv', styles: 'height: 27px;', className: 'e-de-page-setup-dlg-first-page-prop' });
        let checkBox1 = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_oddoreven'
        });
        firstPageDiv.appendChild(checkBox1);
        // tslint:disable-next-line:max-line-length
        let oddOrEvenDiv = createElement('div', { id: '_oddOrEvenDiv', styles: 'height: 27px;', className: 'e-de-page-setup-dlg-odd-or-even-prop' });
        let checkBox2 = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_even'
        });
        oddOrEvenDiv.appendChild(checkBox2);
        layoutDiv.appendChild(firstPageDiv);
        layoutDiv.appendChild(oddOrEvenDiv);
        this.checkBox1 = new CheckBox({ label: locale.getConstant('Different odd and even') });
        this.checkBox2 = new CheckBox({ label: locale.getConstant('Different first page') });
        this.checkBox1.appendTo(checkBox1);
        this.checkBox2.appendTo(checkBox2);
        element.appendChild(layoutDiv);
        // tslint:disable-next-line:max-line-length
        let textLabelDiv = createElement('div', { id: '_textLabelDiv', className: 'e-de-page-setup-dlg-sub-label' });
        let textLabel = createElement('label', {
            innerHTML: locale.getConstant('From edge'), id: this.target.id + '_textLabel'
        });
        textLabelDiv.appendChild(textLabel);
        element.appendChild(textLabelDiv);
        // tslint:disable-next-line:max-line-length
        let propertyDiv = createElement('div', { id: '_headerFooeterPropDiv', className: 'e-de-page-setup-dlg-sub-container', styles: 'height: 65px;' });
        // tslint:disable-next-line:max-line-length
        let leftLayoutDiv = createElement('div', { id: '_leftLayoutDiv', className: 'e-de-page-setup-dlg-left-layout-container' });
        propertyDiv.appendChild(leftLayoutDiv);
        // tslint:disable-next-line:max-line-length
        let rightLayoutDiv = createElement('div', { className: 'e-de-page-setup-dlg-right-layout-container' });
        propertyDiv.appendChild(rightLayoutDiv);
        let headerLabel = createElement('label', {
            innerHTML: locale.getConstant('Header'), className: 'e-de-page-setup-dlg-sub-header',
            id: this.target.id + '_headerLabel', styles: 'padding-top:0px;width:190px;'
        });
        let headerBox = createElement('input', {
            attrs: { 'type': 'text' }, id: this.target.id + '_header'
        });
        leftLayoutDiv.appendChild(headerLabel);
        leftLayoutDiv.appendChild(headerBox);
        let footerLabel = createElement('label', {
            innerHTML: locale.getConstant('Footer'), className: 'e-de-page-setup-dlg-sub-header', styles: 'padding-top:0px;width:190px;',
            id: this.target.id + '_footerLabel'
        });
        let footerBox = createElement('input', {
            attrs: { 'type': 'text' }, id: this.target.id + '_footer'
        });
        rightLayoutDiv.appendChild(footerLabel);
        rightLayoutDiv.appendChild(footerBox);
        element.appendChild(propertyDiv);
        this.headerBox = new NumericTextBox({ value: 612, width: 170, decimals: 2 });
        this.headerBox.appendTo(headerBox);
        this.footerBox = new NumericTextBox({ value: 792, width: 170, decimals: 2 });
        this.footerBox.appendTo(footerBox);
    }
    /**
     * @private
     */
    show() {
        let localValue = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localValue.setLocale(this.owner.owner.locale);
        setCulture(this.owner.owner.locale);
        if (!this.target) {
            this.initPageSetupDialog(localValue);
        }
        this.owner.dialog.header = localValue.getConstant('Page Setup');
        this.owner.dialog.width = 'auto';
        this.owner.dialog.height = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = this.loadPageSetupDialog;
        this.owner.dialog.close = this.closePageSetupDialog;
        this.owner.dialog.buttons = [{
                click: this.applyPageSetupProperties,
                buttonModel: { content: localValue.getConstant('Ok'), cssClass: 'e-flat e-layout-ppty-okay', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: localValue.getConstant('Cancel'), cssClass: 'e-flat e-layout-ppty-cancel' }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    }
    /**
     * @private
     */
    destroy() {
        if (this.topMarginBox) {
            this.topMarginBox.destroy();
            this.topMarginBox = undefined;
        }
        if (this.leftMarginBox) {
            this.leftMarginBox.destroy();
            this.leftMarginBox = undefined;
        }
        if (this.bottomMarginBox) {
            this.bottomMarginBox.destroy();
            this.bottomMarginBox = undefined;
        }
        if (this.rightMarginBox) {
            this.rightMarginBox.destroy();
            this.rightMarginBox = undefined;
        }
        if (this.headerBox) {
            this.headerBox.destroy();
            this.headerBox = undefined;
        }
        if (this.footerBox) {
            this.footerBox.destroy();
            this.footerBox = undefined;
        }
        if (this.widthBox) {
            this.widthBox.destroy();
            this.widthBox = undefined;
        }
        if (this.heightBox) {
            this.heightBox.destroy();
            this.heightBox = undefined;
        }
        if (this.paperSize) {
            this.paperSize.destroy();
            this.paperSize = undefined;
        }
        if (this.checkBox1) {
            this.checkBox1.destroy();
            this.checkBox1 = undefined;
        }
        if (this.checkBox2) {
            this.checkBox2.destroy();
            this.checkBox2 = undefined;
        }
        if (this.portrait) {
            this.portrait.destroy();
            this.portrait = undefined;
        }
        if (this.landscape) {
            this.landscape.destroy();
            this.landscape = undefined;
        }
        this.owner = undefined;
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (let s = 0; s < this.target.childNodes.length; s++) {
                this.target.removeChild(this.target.childNodes[s]);
                s--;
            }
            this.target = undefined;
        }
    }
}

/**
 * The Paragraph dialog is used to modify formatting of selected paragraphs.
 */
class ParagraphDialog {
    /**
     * @private
     */
    constructor(viewer) {
        //paragraph Format properties
        this.leftIndent = undefined;
        this.rightIndent = undefined;
        this.beforeSpacing = undefined;
        this.afterSpacing = undefined;
        this.textAlignment = undefined;
        this.firstLineIndent = undefined;
        this.lineSpacingIn = undefined;
        this.lineSpacingType = undefined;
        this.paragraphFormat = undefined;
        /**
         * @private
         */
        this.keyUpParagraphSettings = (event) => {
            if (event.keyCode === 13) {
                this.applyParagraphFormat();
            }
        };
        this.changeBeforeSpacing = (event) => {
            this.beforeSpacing = event.value;
        };
        this.changeAfterSpacing = (event) => {
            this.afterSpacing = event.value;
        };
        this.changeLeftIndent = (event) => {
            this.leftIndent = event.value;
        };
        this.changeRightIndent = (event) => {
            this.rightIndent = event.value;
        };
        this.changeLineSpacingValue = (event) => {
            this.lineSpacingIn = event.value;
        };
        this.changeFirstLineIndent = (event) => {
            this.firstLineIndent = event.value;
        };
        this.changeByTextAlignment = (args) => {
            this.textAlignment = args.value;
        };
        /**
         * @private
         */
        this.changeByValue = (event) => {
            let paragraphFormat = this.owner.selection.paragraphFormat;
            switch (this.special.index) {
                case 0:
                    if (paragraphFormat.firstLineIndent !== 0) {
                        this.byIn.value = 0;
                    }
                    break;
                case 1:
                    if (paragraphFormat.firstLineIndent === 0 || isNullOrUndefined(paragraphFormat.firstLineIndent)) {
                        this.byIn.value = 0.1;
                    }
                    else if (paragraphFormat.firstLineIndent < 0) {
                        this.byIn.value = -(paragraphFormat.firstLineIndent);
                    }
                    break;
                case 2:
                    if (paragraphFormat.firstLineIndent === 0 || isNullOrUndefined(paragraphFormat.firstLineIndent)) {
                        paragraphFormat.firstLineIndent = -0.1;
                    }
                    else if (paragraphFormat.firstLineIndent > 0) {
                        this.byIn.value = -(paragraphFormat.firstLineIndent);
                    }
                    break;
            }
        };
        /**
         * @private
         */
        this.changeBySpacing = (event) => {
            if (isNullOrUndefined(this.lineSpacing)) {
                return;
            }
            switch (this.lineSpacing.index) {
                case 0:
                    this.lineSpacingType = 'AtLeast';
                    this.atIn.value = 12;
                    break;
                case 1:
                    this.lineSpacingType = 'Exactly';
                    this.atIn.value = 12;
                    break;
                case 2:
                    this.lineSpacingType = 'Multiple';
                    this.atIn.value = 1;
                    break;
            }
        };
        /* tslint:enable */
        /**
         * @private
         */
        this.loadParagraphDialog = () => {
            let selectionFormat;
            if (this.paragraphFormat) {
                selectionFormat = this.paragraphFormat;
            }
            else {
                selectionFormat = this.owner.selection.paragraphFormat;
            }
            let alignValue = this.alignment.index;
            if (selectionFormat.textAlignment === 'Center') {
                alignValue = 0;
            }
            else if (selectionFormat.textAlignment === 'Left') {
                alignValue = 1;
            }
            else if (selectionFormat.textAlignment === 'Right') {
                alignValue = 2;
            }
            else {
                alignValue = 3;
            }
            this.alignment.index = alignValue;
            this.beforeSpacingIn.value = selectionFormat.beforeSpacing;
            this.afterSpacingIn.value = selectionFormat.afterSpacing;
            this.leftIndentIn.value = selectionFormat.leftIndent;
            this.rightIndentIn.value = selectionFormat.rightIndent;
            this.byIn.value = selectionFormat.firstLineIndent;
            let lineSpaceValue = this.lineSpacing.index;
            if (selectionFormat.lineSpacingType === 'AtLeast') {
                lineSpaceValue = 0;
            }
            else if (selectionFormat.lineSpacingType === 'Exactly') {
                lineSpaceValue = 1;
            }
            else {
                lineSpaceValue = 2;
            }
            this.lineSpacing.index = lineSpaceValue;
            this.atIn.value = selectionFormat.lineSpacing;
            if (this.owner.selection.caret.style.display !== 'none') {
                this.owner.selection.caret.style.display = 'none';
            }
        };
        /**
         * @private
         */
        this.applyParagraphFormat = () => {
            let paraFormat;
            let isApply;
            if (this.paragraphFormat) {
                paraFormat = this.paragraphFormat;
                isApply = false;
            }
            else {
                paraFormat = new WParagraphFormat();
                isApply = true;
            }
            if (!isNullOrUndefined(this.beforeSpacing)) {
                paraFormat.beforeSpacing = this.beforeSpacing;
            }
            if (!isNullOrUndefined(this.afterSpacing)) {
                paraFormat.afterSpacing = this.afterSpacing;
            }
            if (!isNullOrUndefined(this.lineSpacingType)) {
                paraFormat.lineSpacingType = this.lineSpacingType;
            }
            if (!isNullOrUndefined(this.leftIndent)) {
                paraFormat.leftIndent = this.leftIndent;
            }
            if (!isNullOrUndefined(this.rightIndent)) {
                paraFormat.rightIndent = this.rightIndent;
            }
            if (!isNullOrUndefined(this.lineSpacingIn)) {
                paraFormat.lineSpacing = this.lineSpacingIn;
            }
            if (!isNullOrUndefined(this.firstLineIndent)) {
                paraFormat.firstLineIndent = this.firstLineIndent;
            }
            if (!isNullOrUndefined(this.textAlignment)) {
                paraFormat.textAlignment = this.textAlignment;
            }
            if (isApply) {
                this.onParagraphFormat(paraFormat);
            }
            else {
                this.owner.owner.styleDialogModule.updateParagraphFormat();
            }
            this.owner.dialog.hide();
        };
        /**
         * @private
         */
        this.closeParagraphDialog = () => {
            this.leftIndent = undefined;
            this.afterSpacing = undefined;
            this.beforeSpacing = undefined;
            this.firstLineIndent = undefined;
            this.textAlignment = undefined;
            this.rightIndent = undefined;
            this.lineSpacingIn = undefined;
            this.lineSpacingType = undefined;
            this.paragraphFormat = undefined;
            this.owner.dialog.hide();
            this.owner.updateFocus();
        };
        this.owner = viewer;
    }
    /**
     * @private
     */
    getModuleName() {
        return 'ParagraphDialog';
    }
    /*tslint:disable max-func-body-length*/
    /**
     * @private
     */
    initParagraphDialog(locale) {
        let instance = this;
        let ownerId = this.owner.owner.containerId;
        let id = ownerId + '_paragraph_dialog';
        this.target = createElement('div', { id: id, className: 'e-de-para-dlg-container' });
        // tslint:disable-next-line:max-line-length
        let div = createElement('div', { id: 'property_div', styles: 'width:400px;' });
        let generalDiv = createElement('div', { id: 'genral_div', styles: 'width:200px;height:85px;', className: 'e-de-para-dlg-sub-container' });
        // tslint:disable-next-line:max-line-length
        let genLabel = createElement('div', { id: ownerId + '_genLabel', className: 'e-de-para-dlg-heading', innerHTML: locale.getConstant('General') });
        let alignLabel = createElement('div', { id: ownerId + '_AlignLabel', className: 'e-de-dlg-sub-header', innerHTML: locale.getConstant('Alignment') });
        let alignment = createElement('select', {
            id: ownerId + '_Alignment',
            innerHTML: '<option value="Center">' + locale.getConstant('Center') +
                '</option><option value="Left">' + locale.getConstant('Left') +
                '</option><option value="Right">' + locale.getConstant('Right') +
                '</option><option value="Justify">' + locale.getConstant('Justify') + '</option>'
        });
        generalDiv.appendChild(genLabel);
        generalDiv.appendChild(alignLabel);
        generalDiv.appendChild(alignment);
        // tslint:disable-next-line:max-line-length
        let indentionDiv = createElement('div', { id: 'indention_div', styles: 'width: 400px;height: 150px;', className: 'e-de-para-dlg-sub-container' });
        let leftIndentionDiv = createElement('div', { id: 'left_indention', styles: 'float:left;position:relative;' });
        indentionDiv.appendChild(leftIndentionDiv);
        // tslint:disable-next-line:max-line-length
        let rightIndentionDiv = createElement('div', { className: 'e-de-para-dlg-right-sub-container', styles: 'float:right;position:relative;' });
        indentionDiv.appendChild(rightIndentionDiv);
        // tslint:disable-next-line:max-line-length
        let spacingDiv = createElement('div', { id: 'spacing_div', styles: 'width: 400px;height: 150px;', className: 'e-de-para-dlg-sub-container' });
        let leftSpacingDiv = createElement('div', { id: 'left_spacing', styles: 'float:left;position:relative;' });
        spacingDiv.appendChild(leftSpacingDiv);
        // tslint:disable-next-line:max-line-length
        let rightSpacingDiv = createElement('div', { className: 'e-de-para-dlg-right-sub-container', styles: 'float:right;position:relative;' });
        spacingDiv.appendChild(rightSpacingDiv);
        // tslint:disable-next-line:max-line-length
        let indentLabel = createElement('div', {
            id: ownerId + '_indentLabel', className: 'e-de-para-dlg-heading', innerHTML: locale.getConstant('Indentation')
        });
        let beforeTextLabel = createElement('div', {
            id: ownerId + '_bfTextLabel',
            className: 'e-de-dlg-sub-header', innerHTML: locale.getConstant('Before text')
        });
        // tslint:disable-next-line:max-line-length
        let leftIndent = createElement('input', { id: ownerId + '_leftIndent', attrs: { 'type': 'text' } });
        let specialLabel = createElement('div', { id: ownerId + '_specialLabel', className: 'e-de-dlg-sub-header', innerHTML: locale.getConstant('Special') });
        let special = createElement('select', {
            id: ownerId + '_special',
            innerHTML: '<option value="None">' + locale.getConstant('None') +
                '</option><option value="First Line">' + locale.getConstant('First line') +
                '</option><option value="Hanging">' + locale.getConstant('Hanging') + '</option> '
        });
        leftIndentionDiv.appendChild(indentLabel);
        leftIndentionDiv.appendChild(beforeTextLabel);
        leftIndentionDiv.appendChild(leftIndent);
        leftIndentionDiv.appendChild(specialLabel);
        leftIndentionDiv.appendChild(special);
        // tslint:disable-next-line:max-line-length
        let afterTextLabel = createElement('div', { id: ownerId + '_afTextLabel', className: 'e-de-dlg-sub-header', innerHTML: locale.getConstant('After text') });
        let rightIndent = createElement('input', { id: ownerId + '_rightIndent', attrs: { 'type': 'text' } });
        // tslint:disable-next-line:max-line-length
        let byLabel = createElement('label', { id: ownerId + '_byLabel', className: 'e-de-dlg-sub-header', innerHTML: locale.getConstant('By') });
        let by = createElement('input', { id: ownerId + '_By', attrs: { 'type': 'text' } });
        rightIndentionDiv.appendChild(afterTextLabel);
        rightIndentionDiv.appendChild(rightIndent);
        rightIndentionDiv.appendChild(byLabel);
        rightIndentionDiv.appendChild(by);
        // tslint:disable-next-line:max-line-length
        let spaceLabel = createElement('div', { innerHTML: locale.getConstant('Spacing'), className: 'e-de-para-dlg-heading', id: ownerId + '_spaceLabel' });
        let beforeLabel = createElement('div', { className: 'e-de-dlg-sub-header', innerHTML: locale.getConstant('Before'), id: ownerId + '_beforeLabel' });
        // tslint:disable-next-line:max-line-length
        let beforeSpacing = createElement('input', { id: ownerId + '_beforeSpacing', attrs: { 'type': 'text' } });
        let lineSpaceLabel = createElement('div', { id: ownerId + '_lineSpaceLabel', className: 'e-de-dlg-sub-header', innerHTML: locale.getConstant('Line Spacing') });
        // tslint:disable-next-line:max-line-length
        let lineSpacing = createElement('select', {
            id: ownerId + '_lineSpacing', styles: 'width:180px;',
            innerHTML: '<option value="At least">' + locale.getConstant('At least') +
                '</option><option value="Exactly">' + locale.getConstant('Exactly') +
                '</option><option value="Multiple">' + locale.getConstant('Multiple') + '</option>'
        });
        leftSpacingDiv.appendChild(spaceLabel);
        leftSpacingDiv.appendChild(beforeLabel);
        leftSpacingDiv.appendChild(beforeSpacing);
        leftSpacingDiv.appendChild(lineSpaceLabel);
        leftSpacingDiv.appendChild(lineSpacing);
        // tslint:disable-next-line:max-line-length
        let afterLabel = createElement('div', { innerHTML: locale.getConstant('After'), className: 'e-de-dlg-sub-header', id: ownerId + '_afterLabel' });
        let afterSpacing = createElement('input', { id: ownerId + '_afterSpacing', attrs: { 'type': 'text' } });
        // tslint:disable-next-line:max-line-length
        let atLabel = createElement('div', { innerHTML: locale.getConstant('At'), id: ownerId + '_atLabel', className: 'e-de-dlg-sub-header' });
        let lineSpacingAt = createElement('input', { id: ownerId + '_lineSpacingAt', attrs: { 'type': 'text' } });
        rightSpacingDiv.appendChild(afterLabel);
        rightSpacingDiv.appendChild(afterSpacing);
        rightSpacingDiv.appendChild(atLabel);
        rightSpacingDiv.appendChild(lineSpacingAt);
        div.appendChild(generalDiv);
        div.appendChild(indentionDiv);
        div.appendChild(spacingDiv);
        this.target.appendChild(div);
        this.leftIndentIn = new NumericTextBox({
            format: 'n1', value: 0, min: -1584, max: 1584, width: 180, enablePersistence: false, change: this.changeLeftIndent
        });
        this.leftIndentIn.appendTo(leftIndent);
        this.rightIndentIn = new NumericTextBox({
            format: 'n1', value: 0, min: -1584, max: 1584, width: 180, enablePersistence: false, change: this.changeRightIndent
        });
        this.rightIndentIn.appendTo(rightIndent);
        this.byIn = new NumericTextBox({
            format: 'n1', value: 0, min: 0, max: 1584, width: 180, enablePersistence: false, change: this.changeFirstLineIndent
        });
        this.byIn.appendTo(by);
        this.beforeSpacingIn = new NumericTextBox({
            format: 'n1', value: 0, min: 0, max: 1584, width: 180, step: 6, enablePersistence: false,
            change: this.changeBeforeSpacing
        });
        this.beforeSpacingIn.appendTo(beforeSpacing);
        this.afterSpacingIn = new NumericTextBox({
            format: 'n1', value: 0, min: 0, max: 1584, width: 180, step: 6, enablePersistence: false,
            change: this.changeAfterSpacing
        });
        this.afterSpacingIn.appendTo(afterSpacing);
        this.atIn = new NumericTextBox({
            format: 'n1', value: 0, min: 1, max: 1584, width: 180, step: 0.5, enablePersistence: false, change: this.changeLineSpacingValue
        });
        this.special = new DropDownList({ change: this.changeByValue, width: 180 });
        this.special.appendTo(special);
        this.lineSpacing = new DropDownList({ change: this.changeBySpacing, width: '180px' });
        this.lineSpacing.appendTo(lineSpacing);
        this.alignment = new DropDownList({ width: 180, change: this.changeByTextAlignment });
        this.alignment.appendTo(alignment);
        this.atIn.appendTo(lineSpacingAt);
        this.target.addEventListener('keyup', instance.keyUpParagraphSettings);
    }
    /**
     * Applies Paragraph Format
     * @param  {WParagraphFormat} paragraphFormat
     * @private
     */
    onParagraphFormat(paragraphFormat) {
        this.owner.owner.editorModule.initHistory('ParagraphFormat');
        let selection = this.owner.selection;
        this.owner.owner.isShiftingEnabled = true;
        if (this.owner.selection.isEmpty) {
            this.owner.owner.editorModule.applyParaFormatProperty(selection.start.paragraph, undefined, paragraphFormat, false);
            this.owner.owner.editor.layoutItemBlock(selection.start.paragraph, false);
        }
        else {
            this.owner.owner.editorModule.updateSelectionParagraphFormatting('ParagraphFormat', paragraphFormat, false);
        }
        this.owner.owner.editorModule.reLayout(selection);
    }
    /**
     * @private
     */
    show(paragraphFormat) {
        if (paragraphFormat) {
            this.paragraphFormat = paragraphFormat;
        }
        let local = new L10n('documenteditor', this.owner.owner.defaultLocale);
        local.setLocale(this.owner.owner.locale);
        setCulture(this.owner.owner.locale);
        if (!this.target) {
            this.initParagraphDialog(local);
        }
        this.loadParagraphDialog();
        this.owner.dialog.header = 'Paragraph';
        this.owner.dialog.content = this.target;
        this.owner.dialog.height = 'auto';
        this.owner.dialog.width = 'auto';
        this.owner.dialog.buttons = [{
                click: this.applyParagraphFormat,
                buttonModel: { content: local.getConstant('Ok'), cssClass: 'e-flat e-para-okay', isPrimary: true }
            },
            {
                click: this.closeParagraphDialog,
                buttonModel: { content: local.getConstant('Cancel'), cssClass: 'e-flat e-para-cancel' }
            }];
        this.owner.dialog.beforeOpen = this.owner.updateFocus;
        this.owner.dialog.close = this.owner.updateFocus;
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    }
    /**
     * @private
     */
    destroy() {
        if (this.afterSpacingIn) {
            this.afterSpacingIn.destroy();
            this.afterSpacingIn = undefined;
        }
        if (this.beforeSpacingIn) {
            this.beforeSpacingIn.destroy();
            this.beforeSpacingIn = undefined;
        }
        if (this.leftIndentIn) {
            this.leftIndentIn.destroy();
            this.leftIndentIn = undefined;
        }
        if (this.rightIndentIn) {
            this.rightIndentIn.destroy();
            this.rightIndentIn = undefined;
        }
        if (this.byIn) {
            this.byIn.destroy();
            this.byIn = undefined;
        }
        if (this.atIn) {
            this.atIn.destroy();
            this.atIn = undefined;
        }
        if (this.alignment) {
            this.alignment.change = undefined;
            this.alignment.destroy();
        }
        this.alignment = undefined;
        if (this.lineSpacing) {
            this.lineSpacing.change = undefined;
            this.lineSpacing.destroy();
        }
        this.lineSpacing = undefined;
        if (this.special) {
            this.special.change = undefined;
            this.special.destroy();
        }
        this.special = undefined;
        this.owner = undefined;
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (let q = 0; q < this.target.childNodes.length; q++) {
                this.target.removeChild(this.target.childNodes[q]);
                q--;
            }
            this.target = undefined;
        }
    }
}

/**
 * List view model implementation
 * @private
 */
class ListViewModel {
    /**
     * @private
     */
    constructor() {
        this.listIn = undefined;
        this.levelNumberIn = undefined;
        /**
         * @private
         */
        this.dialog = undefined;
        this.levelNumber = 0;
    }
    /**
     * @private
     */
    get levelNumber() {
        return this.levelNumberIn;
    }
    /**
     * @private
     */
    set levelNumber(value) {
        this.levelNumberIn = value;
    }
    /**
     * @private
     */
    get list() {
        return this.listIn;
    }
    /**
     * @private
     */
    set list(value) {
        if (isNullOrUndefined(value)) {
            this.createList();
        }
        else {
            this.listIn = value;
        }
    }
    /**
     * @private
     */
    get listLevel() {
        if (!isNullOrUndefined(this.list) && this.levelNumber >= 0 && this.levelNumber < 9) {
            if (!isNullOrUndefined(this.dialog.owner.getAbstractListById(this.list.abstractListId))) {
                if (this.dialog.owner.getAbstractListById(this.list.abstractListId).levels.length <= this.levelNumber) {
                    this.addListLevels();
                }
                return this.dialog.owner.getAbstractListById(this.list.abstractListId).levels[this.levelNumber];
            }
            else {
                this.dialog.owner.lists.push(this.list);
                let abstractList = this.list.abstractList;
                if (!this.list.abstractList) {
                    abstractList = new WAbstractList();
                    abstractList.abstractListId = this.list.abstractListId;
                }
                let listLevelAdv = new WListLevel(abstractList);
                listLevelAdv.characterFormat = new WCharacterFormat(listLevelAdv);
                listLevelAdv.paragraphFormat = new WParagraphFormat(listLevelAdv);
                listLevelAdv.paragraphFormat.leftIndent = (1) * 48;
                listLevelAdv.paragraphFormat.firstLineIndent = -24;
                listLevelAdv.numberFormat = '%' + (1).toString() + '.';
                listLevelAdv.listLevelPattern = 'UpRoman';
                listLevelAdv.followCharacter = 'Tab';
                listLevelAdv.startAt = 1;
                listLevelAdv.restartLevel = 1;
                this.dialog.owner.abstractLists.push(abstractList);
                return this.dialog.owner.getAbstractListById(this.list.abstractListId).levels[0];
                // return this.dialog.owner.getAbstractListById(this.list.abstractListId).levels.getItem(0);
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    get listLevelPattern() {
        if (!isNullOrUndefined(this.listLevel)) {
            return this.listLevel.listLevelPattern;
        }
        return 'Arabic';
    }
    /**
     * @private
     */
    set listLevelPattern(value) {
        if (!isNullOrUndefined(this.listLevel)) {
            this.listLevel.listLevelPattern = value;
        }
    }
    /**
     * @private
     */
    get followCharacter() {
        if (!isNullOrUndefined(this.listLevel)) {
            return this.listLevel.followCharacter;
        }
        return 'None';
    }
    /**
     * @private
     */
    set followCharacter(value) {
        if (!isNullOrUndefined(this.listLevel)) {
            this.listLevel.followCharacter = value;
        }
    }
    createList() {
        this.list = new WList();
        this.list.listId = this.dialog.owner.lists.length + 1;
        let abstractList = new WAbstractList();
        abstractList.abstractListId = this.dialog.owner.abstractLists.length + 1;
        this.list.abstractListId = abstractList.abstractListId;
        this.dialog.owner.lists.push(this.list);
        let listLevel = new WListLevel(abstractList);
        listLevel.paragraphFormat = new WParagraphFormat(listLevel);
        listLevel.paragraphFormat.leftIndent = 48;
        listLevel.paragraphFormat.firstLineIndent = -24;
        listLevel.characterFormat = new WCharacterFormat(listLevel);
        listLevel.numberFormat = '%1.';
        listLevel.startAt = 1;
        abstractList.levels.push(listLevel);
        this.dialog.owner.abstractLists.push(abstractList);
    }
    addListLevels() {
        if (!isNullOrUndefined(this.list) && !isNullOrUndefined(this.list.abstractListId)) {
            for (let i = this.dialog.owner.getAbstractListById(this.list.abstractListId).levels.length; i < 9; i++) {
                let listLevelAdv = new WListLevel(this.dialog.owner.getAbstractListById(this.list.abstractListId));
                listLevelAdv.characterFormat = new WCharacterFormat(listLevelAdv);
                listLevelAdv.paragraphFormat = new WParagraphFormat(listLevelAdv);
                listLevelAdv.paragraphFormat.leftIndent = (i + 1) * 48;
                listLevelAdv.paragraphFormat.firstLineIndent = -24;
                listLevelAdv.numberFormat = '%' + (i + 1).toString() + '.';
                listLevelAdv.listLevelPattern = 'Arabic';
                listLevelAdv.followCharacter = 'Tab';
                listLevelAdv.startAt = 1;
                listLevelAdv.restartLevel = i;
                (this.dialog.owner).getAbstractListById(this.list.abstractListId).levels.push(listLevelAdv);
            }
        }
    }
    /**
     * @private
     */
    destroy() {
        this.list = undefined;
        this.followCharacter = undefined;
        this.levelNumber = undefined;
        this.listLevelPattern = undefined;
    }
}

// tslint:disable-next-line:max-line-length
/**
 * The List dialog is used to create or modify lists.
 */
/* tslint:disable:no-any */
class ListDialog {
    /**
     * @private
     */
    constructor(viewer) {
        /**
         * @private
         */
        this.dialog = undefined;
        this.target = undefined;
        /**
         * @private
         */
        this.owner = undefined;
        this.viewModel = undefined;
        this.startAt = undefined;
        this.textIndent = undefined;
        this.alignedAt = undefined;
        this.listLevelElement = undefined;
        this.followNumberWith = undefined;
        this.numberStyle = undefined;
        this.numberFormat = undefined;
        this.restartBy = undefined;
        /**
         * @private
         */
        this.isListCharacterFormat = false;
        this.onTextIndentChanged = (args) => {
            this.viewModel.listLevel.paragraphFormat.leftIndent = args.value;
        };
        this.onStartValueChanged = (args) => {
            this.viewModel.listLevel.startAt = args.value;
        };
        this.onListLevelValueChanged = (args) => {
            this.viewModel.levelNumber = parseInt(args.value.slice(args.value.length - 1), 10) - 1;
            if (isNullOrUndefined(this.listLevel)) {
                return;
            }
            if (isNullOrUndefined(this.listLevel.characterFormat)) {
                this.listLevel.characterFormat = new WCharacterFormat(this.viewModel.listLevel);
            }
            if (!isNullOrUndefined(this.listLevel.paragraphFormat)) {
                this.listLevel.paragraphFormat = new WParagraphFormat(this.viewModel.listLevel);
            }
            this.updateDialogValues();
            this.updateRestartLevelBox();
        };
        this.onNumberFormatChanged = (args) => {
            this.viewModel.listLevel.numberFormat = args.target.value;
        };
        this.onAlignedAtValueChanged = (args) => {
            this.viewModel.listLevel.paragraphFormat.firstLineIndent = args.value;
        };
        this.onFollowCharacterValueChanged = (args) => {
            if (args.value) {
                this.viewModel.followCharacter = args.value;
            }
        };
        this.onLevelPatternValueChanged = (args) => {
            this.viewModel.listLevelPattern = args.value;
            let numberFormat = '%' + (this.levelNumber + 1).toString();
            // tslint:disable-next-line:max-line-length
            let numberFormatTextBox = document.getElementById(this.owner.owner.containerId + '_numberFormat');
            if (this.listLevel.listLevelPattern === 'Bullet') {
                this.listLevel.numberFormat = '\uf0b7';
                numberFormatTextBox.value = this.listLevel.numberFormat;
                this.listLevel.characterFormat.fontFamily = 'Wingdings';
            }
            else {
                if (this.listLevel.listLevelPattern === 'None') {
                    this.listLevel.numberFormat = '';
                }
                if (!this.listLevel.numberFormat.match(numberFormat) && this.listLevel.listLevelPattern !== 'None') {
                    this.listLevel.numberFormat = numberFormat + '.';
                }
                numberFormatTextBox.value = this.listLevel.numberFormat;
            }
        };
        this.loadListDialog = () => {
            this.owner.updateFocus();
            if (isNullOrUndefined(this.owner.owner)) {
                return;
            }
            this.viewModel = new ListViewModel();
            this.viewModel.dialog = this;
            if (this.owner.selection.paragraphFormat.listLevelNumber > 0) {
                this.viewModel.levelNumber = this.owner.selection.paragraphFormat.listLevelNumber;
            }
            this.viewModel.list = this.owner.selection.paragraphFormat.getList();
            if (isNullOrUndefined(this.listLevel)) {
                return;
            }
            if (isNullOrUndefined(this.listLevel.characterFormat)) {
                this.listLevel.characterFormat = new WCharacterFormat(this.viewModel.listLevel);
            }
            if (isNullOrUndefined(this.listLevel.paragraphFormat)) {
                this.listLevel.paragraphFormat = new WParagraphFormat(this.viewModel.listLevel);
            }
            this.updateDialogValues();
            if (this.owner.selection.caret.style.display !== 'none') {
                this.owner.selection.caret.style.display = 'none';
            }
        };
        this.showFontDialog = () => {
            this.owner.owner.fontDialogModule.showFontDialog(this.listLevel.characterFormat);
        };
        this.onApplyList = () => {
            if (!isNullOrUndefined(this.owner)) {
                this.owner.selection.paragraphFormat.setList(this.list);
            }
            this.owner.dialog2.hide();
            this.owner.updateFocus();
        };
        this.onCancelButtonClick = () => {
            this.disposeBindingForListUI();
            this.owner.dialog2.hide();
            this.owner.updateFocus();
            this.isListCharacterFormat = false;
        };
        this.closeListDialog = () => {
            this.disposeBindingForListUI();
            this.owner.updateFocus();
            this.isListCharacterFormat = false;
        };
        this.owner = viewer;
        this.viewModel = new ListViewModel();
    }
    /**
     * @private
     */
    get listLevel() {
        if (!isNullOrUndefined(this.viewModel)) {
            return this.viewModel.listLevel;
        }
        return undefined;
    }
    /**
     * @private
     */
    get list() {
        if (!isNullOrUndefined(this.viewModel)) {
            return this.viewModel.list;
        }
        return undefined;
    }
    /**
     * @private
     */
    get levelNumber() {
        if (this.listLevel.ownerBase instanceof WLevelOverride) {
            return this.listLevel.ownerBase.levelNumber;
            // tslint:disable-next-line:max-line-length
        }
        else if (this.listLevel.ownerBase instanceof WAbstractList && !isNullOrUndefined(this.listLevel.ownerBase.levels)) {
            return this.listLevel.ownerBase.levels.indexOf(this.listLevel);
        }
        else {
            return -1;
        }
    }
    /**
     * @private
     */
    getModuleName() {
        return 'ListDialog';
    }
    /**
     * @private
     */
    showListDialog() {
        let locale = new L10n('documenteditor', this.owner.owner.defaultLocale);
        locale.setLocale(this.owner.owner.locale);
        setCulture(this.owner.owner.locale);
        if (!this.target) {
            this.initListDialog(locale);
        }
        this.isListCharacterFormat = true;
        this.owner.dialog2.header = locale.getConstant('Define new Multilevel list');
        this.owner.dialog2.height = 'auto';
        this.owner.dialog2.width = 'auto';
        this.owner.dialog2.content = this.target;
        this.owner.dialog2.buttons = [{
                click: this.showFontDialog,
                buttonModel: { content: locale.getConstant('Font'), cssClass: 'e-flat e-list-dlg-font e-font' }
            }, {
                click: this.onApplyList,
                buttonModel: { content: locale.getConstant('Ok'), cssClass: 'e-flat e-list-dlg', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: locale.getConstant('Cancel'), cssClass: 'e-flat e-list-dlg' }
            }];
        this.owner.dialog2.dataBind();
        this.owner.dialog2.beforeOpen = this.loadListDialog;
        this.owner.dialog2.close = this.closeListDialog;
        this.owner.dialog2.position = { X: 'center', Y: 'top' };
        this.owner.dialog2.show();
    }
    /**
     * Shows the table properties dialog
     * @private
     */
    initListDialog(locale) {
        let instance = this;
        let containerId = this.owner.owner.containerId;
        let id = containerId + '_insert_list';
        this.target = createElement('div', { id: id, className: 'e-de-list-dlg' });
        this.owner.owner.element.appendChild(this.target);
        // tslint:disable-next-line:max-line-length
        let listLevelDiv = createElement('div', { innerHTML: '<label id="' + containerId + '_listLevellabel" style="display:block;" class=e-de-list-ddl-header-list-level>' + locale.getConstant('List level') + '</label><label id="' + containerId + '_modifyLabel" style="display:block;" class=e-de-list-ddl-subheader>' + locale.getConstant('Choose level to modify') + '</label><select style="height:20px;width:43%" id="' + containerId + '_listLevel"><option>' + locale.getConstant('Level') + ' 1' + '</option><option>' + locale.getConstant('Level') + ' 2' + '</option><option>' + locale.getConstant('Level') + ' 3' + '</option><option>' + locale.getConstant('Level') + ' 4' + '</option><option>' + locale.getConstant('Level') + ' 5' + '</option><option>' + locale.getConstant('Level') + ' 6' + '</option><option>' + locale.getConstant('Level') + ' 7' + '</option><option>' + locale.getConstant('Level') + ' 8' + '</option><option>' + locale.getConstant('Level') + ' 9' + '</option></select>' });
        this.target.appendChild(listLevelDiv);
        let div = createElement('div');
        // tslint:disable-next-line:max-line-length
        let numberStyleDiv = createElement('div', { innerHTML: '<div style="float:left;display:block;"><label id="' + containerId + '_numberFormatLabel" style="display:block;" class=e-de-list-ddl-header>' + locale.getConstant('Number format') + '</label><label id="' + containerId + '_numberStyleLabel" style="display:block;" class=e-de-list-ddl-subheader>' + locale.getConstant('Number style for this level') + '</label><select style="height:20px;width:100%" id="' + containerId + '_numberStyle"><option>' + locale.getConstant('Arabic') + '</option><option>' + locale.getConstant('UpRoman') + '</option><option>' + locale.getConstant('LowRoman') + '</option><option>' + locale.getConstant('UpLetter') + '</option><option>' + locale.getConstant('LowLetter') + '</option><option>' + locale.getConstant('Number') + '</option><option>' + locale.getConstant('Leading zero') + '</option><option>' + locale.getConstant('Bullet') + '</option><option>' + locale.getConstant('Ordinal') + '</option><option>' + locale.getConstant('Ordinal Text') + '</option><option>' + locale.getConstant('Special') + '</option><option>' + locale.getConstant('For East') + '</option></select><label id="' + containerId + '_startAtLabel" style="display:block;" class=e-de-list-ddl-subheaderbottom>' + locale.getConstant('Start at') + '</label><input type="text" id="' + containerId + '_startAt">' });
        div.appendChild(numberStyleDiv);
        // tslint:disable-next-line:max-line-length
        let numberFormatDiv = createElement('div', { className: 'e-de-list-dlg-subdiv', innerHTML: '<div><div><label id="' + containerId + '_formatLabel" style="display:inline-block;width:86%" class=e-de-list-ddl-subheader>' + locale.getConstant('Enter formatting for number') + '</label><button id="' + containerId + '_list_info" class="e-control e-btn e-primary e-de-list-format-info">i</button></div><input style=width:180px; type="text" id="' + containerId + '_numberFormat" class=e-input></div><label id="' + containerId + '_restartLabel" style="display:block;" class=e-de-list-ddl-subheaderbottom>' + locale.getConstant('Restart list after') + '</label><select style="height:20px;width:100%" id="' + containerId + '_restartBy"><option>' + locale.getConstant('No Restart') + '</option></select></div>' });
        div.appendChild(numberFormatDiv);
        this.target.appendChild(div);
        // tslint:disable-next-line:max-line-length
        let indentsDiv = createElement('div', { innerHTML: '<div style="float:left;display:block;"><label id="' + containerId + '_IndentsLabel" style="display:block;" class=e-de-list-ddl-header>' + locale.getConstant('Position') + '</label><label id="' + containerId + '_textIndentLabel" style="display:block;" class=e-de-list-ddl-subheader>' + locale.getConstant('Text indent at') + '</label><input type="text" id="' + containerId + '_textIndent"><label id="' + containerId + '_followCharacterLabel" style="display:block;" class=e-de-list-ddl-subheaderbottom>' + locale.getConstant('Follow number with') + '</label><select style="height:20px;width:100%" id="' + containerId + '_followCharacter"><option>' + locale.getConstant('Tab character') + '</option><option>' + locale.getConstant('Space') + '</option><option>' + locale.getConstant('Nothing') + '</option></select></div><div class="e-de-list-dlg-div"><label id="' + containerId + '_alignedAtLabel" style="display:block;" class=e-de-list-ddl-subheader>' + locale.getConstant('Aligned at') + '</label><input type="text" id="' + containerId + '_alignedAt"></div>', });
        this.target.appendChild(indentsDiv);
        let startAtTextBox = document.getElementById(containerId + '_startAt');
        let textIndentAtTextBox = document.getElementById(containerId + '_textIndent');
        let alignedAtTextBox = document.getElementById(containerId + '_alignedAt');
        this.startAt = new NumericTextBox({
            format: '#',
            decimals: 0,
            min: 0,
            max: 50,
            width: '180px',
            enablePersistence: false,
        });
        this.startAt.addEventListener('change', instance.onStartValueChanged);
        this.startAt.appendTo(startAtTextBox);
        this.textIndent = new NumericTextBox({
            format: '#',
            decimals: 0,
            min: 0,
            max: 1584,
            width: '180px',
            step: 4,
            enablePersistence: false
        });
        this.textIndent.addEventListener('change', instance.onTextIndentChanged);
        this.textIndent.appendTo(textIndentAtTextBox);
        this.alignedAt = new NumericTextBox({
            format: '#',
            max: 1584,
            step: 6,
            width: '180px',
            enablePersistence: false
        });
        this.alignedAt.addEventListener('change', instance.onAlignedAtValueChanged);
        this.alignedAt.appendTo(alignedAtTextBox);
        let listLevel = document.getElementById(containerId + '_listLevel');
        this.listLevelElement = new DropDownList({ popupHeight: '150px', width: '180px', change: instance.onListLevelValueChanged });
        this.listLevelElement.appendTo(listLevel);
        let followCharacterElement = document.getElementById(containerId + '_followCharacter');
        this.followNumberWith = new DropDownList({ popupHeight: '150px', width: '180px', change: instance.onFollowCharacterValueChanged });
        this.followNumberWith.appendTo(followCharacterElement);
        let numberStyleEle = document.getElementById(containerId + '_numberStyle');
        this.numberStyle = new DropDownList({ popupHeight: '150px', width: '180px', change: instance.onLevelPatternValueChanged });
        this.numberStyle.appendTo(numberStyleEle);
        this.numberFormat = document.getElementById(containerId + '_numberFormat');
        this.numberFormat.addEventListener('change', instance.onNumberFormatChanged);
        let restartElement = document.getElementById(containerId + '_restartBy');
        this.restartBy = new DropDownList({ popupHeight: '150px', width: '180px' });
        this.restartBy.appendTo(restartElement);
        let button = document.getElementById(containerId + '_list_info');
        this.formatInfoToolTip = new Tooltip({ width: 200 });
        // tslint:disable-next-line:max-line-length
        this.formatInfoToolTip.content = locale.getConstant('Number format tooltip information');
        this.formatInfoToolTip.position = 'RightTop';
        this.formatInfoToolTip.appendTo(button);
    }
    updateRestartLevelBox() {
        let containerId = this.owner.owner.containerId;
        let listLevel = document.getElementById(containerId + '_listLevel');
        let restartBy = document.getElementById(containerId + '_restartBy');
        for (let i = 0; i < restartBy.options.length; i) {
            restartBy.options.remove(i);
        }
        if (listLevel.selectedIndex === 0) {
            let option = document.createElement('option');
            option.value = 'No Restart';
            option.innerHTML = 'No Restart';
            restartBy.appendChild(option);
        }
        else {
            for (let i = listLevel.selectedIndex; i > 0; i--) {
                let option = document.createElement('option');
                option.value = 'Level ' + i;
                option.innerHTML = 'Level ' + i;
                restartBy.appendChild(option);
            }
            let option = document.createElement('option');
            option.value = 'No Restart';
            option.innerHTML = 'No Restart';
            restartBy.appendChild(option);
        }
        restartBy.selectedIndex = 0;
    }
    listPatternConverter(listLevelPattern) {
        switch (listLevelPattern) {
            case 'Arabic': return 0;
            case 'UpRoman': return 1;
            case 'LowRoman': return 2;
            case 'UpLetter': return 3;
            case 'LowLetter': return 4;
            case 'Number': return 5;
            case 'LeadingZero': return 6;
            case 'Bullet': return 7;
            case 'Ordinal': return 8;
            case 'OrdinalText': return 9;
            case 'Special': return 10;
            case 'FarEast': return 11;
            default: return 12;
        }
    }
    followCharacterConverter(followCharacter) {
        switch (followCharacter) {
            case 'Tab':
                return 0;
            case 'Space':
                return 1;
            default:
                return 2;
        }
    }
    updateDialogValues() {
        // tslint:disable-next-line:max-line-length
        let restartByTextBox = document.getElementById(this.owner.owner.containerId + '_restartBy');
        this.startAt.value = this.viewModel.listLevel.startAt;
        this.textIndent.value = this.viewModel.listLevel.paragraphFormat.leftIndent;
        this.alignedAt.value = this.viewModel.listLevel.paragraphFormat.firstLineIndent;
        this.followNumberWith.index = this.followCharacterConverter(this.viewModel.followCharacter);
        this.numberFormat.value = this.viewModel.listLevel.numberFormat;
        this.numberStyle.index = this.listPatternConverter(this.viewModel.listLevelPattern);
        this.listLevelElement.index = this.viewModel.levelNumber;
        this.viewModel.levelNumber = this.viewModel.levelNumber;
    }
    disposeBindingForListUI() {
        this.followNumberWith.index = -1;
        this.numberFormat.value = ' ';
        this.numberStyle.index = -1;
        this.listLevelElement.index = -1;
        this.restartBy.index = -1;
        this.viewModel.destroy();
    }
    /**
     * @private
     */
    destroy() {
        if (this.alignedAt) {
            this.alignedAt.destroy();
        }
        this.alignedAt = undefined;
        this.dialog = undefined;
        if (this.followNumberWith) {
            this.followNumberWith.destroy();
        }
        this.followNumberWith = undefined;
        if (this.listLevelElement) {
            this.listLevelElement.destroy();
        }
        this.listLevelElement = undefined;
        if (this.textIndent) {
            this.textIndent.destroy();
        }
        this.textIndent = undefined;
        if (this.startAt) {
            this.startAt.destroy();
        }
        this.startAt = undefined;
        if (this.numberStyle) {
            this.numberStyle.destroy();
        }
        this.numberStyle = undefined;
        this.numberFormat = undefined;
        if (this.restartBy) {
            this.restartBy.destroy();
        }
        this.restartBy = undefined;
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (let l = 0; l < this.target.childNodes.length; l++) {
                this.target.removeChild(this.target.childNodes[l]);
                l--;
            }
            this.target = undefined;
        }
        this.owner = undefined;
        this.viewModel = undefined;
    }
}
/* tslint:enable:no-any */

/**
 * The Style dialog is used to create or modify styles.
 */
class StyleDialog {
    /**
     * @private
     */
    constructor(viewer) {
        this.target = undefined;
        this.styleType = undefined;
        this.styleBasedOn = undefined;
        this.styleParagraph = undefined;
        this.onlyThisDocument = undefined;
        this.template = undefined;
        this.fontFamily = undefined;
        this.fontSize = undefined;
        this.characterFormat = undefined;
        this.paragraphFormat = undefined;
        /* tslint:disable-next-line:no-any */
        this.openDialog = (args) => {
            switch (args.item.id) {
                case 'style_font':
                    this.showFontDialog();
                    break;
                case 'style_paragraph':
                    this.showParagraphDialog();
                    break;
                case 'style_numbering':
                    this.showNumberingBulletDialog();
                    break;
            }
        };
        this.setBoldProperty = () => {
            this.characterFormat.bold = !this.characterFormat.bold;
            this.fontButtonClicked(undefined);
        };
        this.setItalicProperty = () => {
            this.characterFormat.italic = !this.characterFormat.italic;
            this.fontButtonClicked(undefined);
        };
        this.setUnderlineProperty = () => {
            this.characterFormat.underline = this.characterFormat.underline === 'None' ? 'Single' : 'None';
            this.fontButtonClicked(undefined);
        };
        /* tslint:disable-next-line:no-any */
        this.fontButtonClicked = (args) => {
            if (this.characterFormat.bold) {
                if (!this.bold.classList.contains('e-active')) {
                    this.bold.classList.add('e-active');
                }
            }
            else {
                if (this.bold.classList.contains('e-active')) {
                    this.bold.classList.remove('e-active');
                }
            }
            if (this.characterFormat.italic) {
                if (!this.italic.classList.contains('e-active')) {
                    this.italic.classList.add('e-active');
                }
            }
            else {
                if (this.italic.classList.contains('e-active')) {
                    this.italic.classList.remove('e-active');
                }
            }
            if (this.characterFormat.underline !== undefined && this.characterFormat.underline !== 'None') {
                if (!this.underline.classList.contains('e-active')) {
                    this.underline.classList.add('e-active');
                    this.characterFormat.underline = 'Single';
                }
            }
            else {
                if (this.underline.classList.contains('e-active')) {
                    this.underline.classList.remove('e-active');
                    this.characterFormat.underline = 'None';
                }
            }
        };
        /* tslint:disable-next-line:no-any */
        this.fontSizeUpdate = (args) => {
            this.characterFormat.fontSize = args.value;
        };
        /* tslint:disable-next-line:no-any */
        this.fontFamilyChanged = (args) => {
            this.characterFormat.fontFamily = args.value;
        };
        /* tslint:disable-next-line:no-any */
        this.fontColorUpdate = (args) => {
            this.characterFormat.fontColor = args.currentValue.rgba;
        };
        this.setLeftAlignment = () => {
            if (this.paragraphFormat.textAlignment === 'Left') {
                this.paragraphFormat.textAlignment = 'Justify';
            }
            else {
                this.paragraphFormat.textAlignment = 'Left';
            }
            this.updateParagraphFormat();
        };
        this.setRightAlignment = () => {
            if (this.paragraphFormat.textAlignment === 'Right') {
                this.paragraphFormat.textAlignment = 'Left';
            }
            else {
                this.paragraphFormat.textAlignment = 'Right';
            }
            this.updateParagraphFormat();
        };
        this.setCenterAlignment = () => {
            if (this.paragraphFormat.textAlignment === 'Center') {
                this.paragraphFormat.textAlignment = 'Left';
            }
            else {
                this.paragraphFormat.textAlignment = 'Center';
            }
            this.updateParagraphFormat();
        };
        this.setJustifyAlignment = () => {
            if (this.paragraphFormat.textAlignment === 'Justify') {
                this.paragraphFormat.textAlignment = 'Left';
            }
            else {
                this.paragraphFormat.textAlignment = 'Justify';
            }
            this.updateParagraphFormat();
        };
        this.increaseBeforeAfterSpacing = () => {
            this.paragraphFormat.beforeSpacing += 6;
            this.paragraphFormat.afterSpacing += 6;
        };
        this.decreaseBeforeAfterSpacing = () => {
            if (this.paragraphFormat.beforeSpacing >= 6) {
                this.paragraphFormat.beforeSpacing -= 6;
            }
            else {
                this.paragraphFormat.beforeSpacing = 0;
            }
            if (this.paragraphFormat.afterSpacing >= 6) {
                this.paragraphFormat.afterSpacing -= 6;
            }
            else {
                this.paragraphFormat.afterSpacing = 0;
            }
        };
        /**
         * @private
         */
        this.updateNextStyle = (args) => {
            let typedName = args.srcElement.value;
            if (this.getTypeValue() === 'Paragraph' && !isNullOrUndefined(typedName) && typedName !== '' && !this.isUserNextParaUpdated) {
                let styles = this.owner.owner.viewer.styles.getStyleNames(this.getTypeValue());
                if (this.isEdit) {
                    styles = styles.filter((e) => e !== this.editStyleName);
                }
                styles.push(typedName);
                this.styleParagraph.dataSource = styles;
                this.styleParagraph.index = null;
                this.styleParagraph.index = styles.indexOf(typedName);
                this.styleParagraph.dataBind();
            }
        };
        /**
         * @private
         */
        this.updateOkButton = () => {
            let styleName = this.target.getElementsByClassName('e-input e-de-style-dlg-name-input').item(0).value;
            this.enableOrDisableOkButton();
        };
        /**
         * @private
         */
        /* tslint:disable-next-line:no-any */
        this.styleTypeChange = (args) => {
            if (args.isInteracted) {
                let type;
                if (args.value === 'Character') {
                    this.style = new WCharacterStyle();
                    type = 'Character';
                }
                if (args.value === 'Paragraph' || args.value === 'Linked(Paragraph and Character)') {
                    this.style = new WParagraphStyle();
                    type = 'Paragraph';
                }
                this.toggleDisable();
                this.updateStyleNames(type);
            }
        };
        /* tslint:disable-next-line:no-any */
        this.styleBasedOnChange = (args) => {
            //Based on change
        };
        /**
         * @private
         */
        /* tslint:disable-next-line:no-any */
        this.styleParagraphChange = (args) => {
            if (args.isInteracted) {
                this.isUserNextParaUpdated = true;
            }
            //Next change
        };
        /**
         * @private
         */
        this.showFontDialog = () => {
            if (!isNullOrUndefined(this.owner.owner.fontDialogModule)) {
                this.owner.owner.showFontDialog(this.characterFormat);
            }
            this.updateCharacterFormat();
        };
        /**
         * @private
         */
        this.showParagraphDialog = () => {
            if (!isNullOrUndefined(this.owner.owner.paragraphDialogModule)) {
                this.owner.owner.showParagraphDialog(this.paragraphFormat);
            }
        };
        /**
         * @private
         */
        this.showNumberingBulletDialog = () => {
            this.numberingBulletDialog = new BulletsAndNumberingDialog(this.owner.owner.viewer);
            if (this.style instanceof WParagraphStyle && (!isNullOrUndefined(this.style.paragraphFormat))) {
                // tslint:disable-next-line:max-line-length
                this.numberingBulletDialog.showNumberBulletDialog(this.style.paragraphFormat.listFormat, this.abstractList);
            }
        };
        /**
         * @private
         */
        this.onOkButtonClick = () => {
            let styleName = this.styleNameElement.value;
            if (styleName.length > 0) {
                let style = this.owner.owner.viewer.styles.findByName(styleName);
                let name;
                if (!isNullOrUndefined(style)) {
                    this.style.type = this.getTypeValue();
                    this.style.basedOn = this.owner.owner.viewer.styles.findByName(this.styleBasedOn.value);
                    if (this.styleType.value === 'Paragraph' || this.styleType.value === 'Linked(Paragraph and Character)') {
                        this.style.next = this.owner.owner.viewer.styles.findByName(this.styleParagraph.value);
                        this.style.characterFormat.mergeFormat(style.characterFormat);
                        this.style.paragraphFormat.mergeFormat(style.paragraphFormat);
                        this.updateList();
                        // tslint:disable-next-line:max-line-length
                        this.style.link = (this.styleType.value === 'Linked(Paragraph and Character)') ? this.createLinkStyle(styleName, this.isEdit) : undefined;
                    }
                    //Updating existing style implementation
                    this.style.name = style.name;
                    name = style.name;
                    style = this.style;
                    this.owner.owner.isShiftingEnabled = true;
                    this.owner.owner.editorModule.layoutWholeDocument();
                    this.owner.owner.isShiftingEnabled = false;
                }
                else {
                    /* tslint:disable-next-line:no-any */
                    let basedOn = this.owner.owner.viewer.styles.findByName(this.styleBasedOn.value);
                    if (this.styleType.value === 'Paragraph' || this.styleType.value === 'Linked(Paragraph and Character)') {
                        if (styleName === this.styleParagraph.value) {
                            this.style.next = this.style;
                        }
                        else {
                            this.style.next = this.owner.owner.viewer.styles.findByName(this.styleParagraph.value);
                        }
                        this.updateList();
                    }
                    // tslint:disable-next-line:max-line-length
                    this.style.link = (this.styleType.value === 'Linked(Paragraph and Character)') ? this.createLinkStyle(styleName) : undefined;
                    this.style.type = this.getTypeValue();
                    this.style.name = styleName;
                    this.style.basedOn = basedOn;
                    /* tslint:disable-next-line:no-any */
                    this.owner.owner.viewer.styles.push(this.style);
                    name = styleName;
                    this.owner.owner.editorModule.applyStyle(name);
                }
                this.owner.owner.viewer.dialog2.hide();
            }
            else {
                throw new Error('Enter valid Style name');
            }
            if (this.style) {
                //this.style.destroy();
            }
        };
        /* tslint:disable-next-line:no-any */
        this.loadStyleDialog = (args) => {
            this.owner.owner.viewer.updateFocus();
            this.isUserNextParaUpdated = false;
            /* tslint:disable-next-line:max-line-length */
            this.styleNameElement = this.target.getElementsByClassName('e-input e-de-style-dlg-name-input').item(0);
            this.styleNameElement.value = null;
            if (!this.isEdit) {
                this.styleType.index = 0; //Set to paragraph            
            }
            let name;
            if (this.isEdit) {
                this.styleNameElement.value = this.editStyleName;
                name = this.editStyleName;
            }
            /* tslint:disable-next-line:max-line-length */
            this.okButton = this.owner.dialog2.element.getElementsByClassName('e-flat e-style-okay').item(0);
            this.enableOrDisableOkButton();
            this.updateStyleNames(this.getTypeValue(), name);
            this.updateCharacterFormat(this.style.characterFormat);
            this.updateParagraphFormat(this.style.paragraphFormat);
        };
        /**
         * @private
         */
        this.onCancelButtonClick = () => {
            if (!this.isEdit && this.style) {
                this.style.destroy();
            }
            this.owner.owner.viewer.dialog2.hide();
        };
        /**
         * @private
         */
        this.closeStyleDialog = () => {
            this.owner.owner.viewer.updateFocus();
        };
        this.owner = viewer;
    }
    /**
     * @private
     */
    getModuleName() {
        return 'StyleDialog';
    }
    /**
     * @private
     */
    //tslint:disable: max-func-body-length
    initStyleDialog(localValue) {
        let id = this.owner.owner.containerId + '_style';
        this.target = createElement('div', { id: id, className: 'e-de-style-dialog' });
        let container = createElement('div');
        // tslint:disable-next-line:max-line-length
        let properties = createElement('div', { className: 'e-de-style-properties', innerHTML: localValue.getConstant('Properties') });
        container.appendChild(properties);
        let styleNameTypeDiv = createElement('div', { styles: 'display:flex', className: 'e-de-style-nametype-div' });
        container.appendChild(styleNameTypeDiv);
        let nameWholeDiv = createElement('div', { className: 'e-de-style-left-div' });
        styleNameTypeDiv.appendChild(nameWholeDiv);
        let name = createElement('div', { className: 'e-de-style-name', innerHTML: localValue.getConstant('Name') + ':' });
        nameWholeDiv.appendChild(name);
        // tslint:disable-next-line:max-line-length
        let nameValue = createElement('input', { id: this.owner.owner.containerId + '_style_name', styles: 'width:210px;', className: 'e-input e-de-style-dlg-name-input' });
        nameValue.addEventListener('keyup', this.updateOkButton);
        nameValue.addEventListener('input', this.updateOkButton);
        nameValue.addEventListener('blur', this.updateNextStyle);
        nameWholeDiv.appendChild(nameValue);
        let styleTypeWholeDiv = createElement('div');
        styleNameTypeDiv.appendChild(styleTypeWholeDiv);
        // tslint:disable-next-line:max-line-length
        let styleType = createElement('div', { className: 'e-de-style-styletype', innerHTML: localValue.getConstant('Style type') + ':' });
        styleTypeWholeDiv.appendChild(styleType);
        let styleTypeDivElement = createElement('div', { className: 'e-de-style-style-type-div' });
        let styleTypeValue = createElement('select', { id: 'e-de-style-style-type' });
        // tslint:disable-next-line:max-line-length
        styleTypeValue.innerHTML = '<option>Paragraph</option><option>Character</option><option>Linked(Paragraph and Character)</option>'; //<option>Linked(Paragraph and Character)</option><option>Table</option><option>List</option>';
        styleTypeDivElement.appendChild(styleTypeValue);
        this.styleType = new DropDownList({ change: this.styleTypeChange, popupHeight: '253px', width: '210px' });
        this.styleType.appendTo(styleTypeValue);
        styleTypeWholeDiv.appendChild(styleTypeDivElement);
        // tslint:disable-next-line:max-line-length
        let styleBasedParaDiv = createElement('div', { styles: 'display:flex', className: 'e-de-style-based-para-div' });
        container.appendChild(styleBasedParaDiv);
        let styleBasedOnWholeDiv = createElement('div', { className: 'e-de-style-left-div' });
        styleBasedParaDiv.appendChild(styleBasedOnWholeDiv);
        // tslint:disable-next-line:max-line-length
        let styleBasedOn = createElement('div', { className: 'e-de-style-style-based-on', innerHTML: localValue.getConstant('Style based on') + ':' });
        styleBasedOnWholeDiv.appendChild(styleBasedOn);
        let styleBasedOnDivElement = createElement('div', { className: 'e-de-style-style-based-on-div' });
        // tslint:disable-next-line:max-line-length
        let styleBasedOnValue = createElement('input', { id: 'e-de-style-style-based-on-value' });
        //styleBasedOnValue.innerHTML = '<option>Normal</option><option>Heading 1</option><option>Heading 2</option><option>Heading 3</option><option>Heading 4</option><option>Heading 5</option><option>Heading 6</option>';
        styleBasedOnDivElement.appendChild(styleBasedOnValue);
        this.styleBasedOn = new DropDownList({ dataSource: [], select: this.styleBasedOnChange, popupHeight: '253px', width: '210px' });
        this.styleBasedOn.appendTo(styleBasedOnValue);
        styleBasedOnWholeDiv.appendChild(styleBasedOnDivElement);
        let styleParagraphWholeDiv = createElement('div', { className: 'e-de-style-left-div' });
        styleBasedParaDiv.appendChild(styleParagraphWholeDiv);
        // tslint:disable-next-line:max-line-length
        let styleParagraph = createElement('div', { className: 'e-de-style-style-paragraph', innerHTML: localValue.getConstant('Style for following paragraph') + ':' });
        styleParagraphWholeDiv.appendChild(styleParagraph);
        let styleParagraphDivElement = createElement('div', { className: 'e-de-style-style-paragraph-div' });
        // tslint:disable-next-line:max-line-length
        let styleParagraphValue = createElement('input', { id: 'e-de-style-style-paragraph-value' });
        // tslint:disable-next-line:max-line-length
        //styleParagraphValue.innerHTML = '<option>Normal</option><option>Heading 1</option><option>Heading 2</option><option>Heading 3</option><option>Heading 4</option><option>Heading 5</option><option>Heading 6</option>';
        styleParagraphDivElement.appendChild(styleParagraphValue);
        this.styleParagraph = new DropDownList({ dataSource: [], select: this.styleParagraphChange, popupHeight: '253px', width: '210px' });
        this.styleParagraph.appendTo(styleParagraphValue);
        styleParagraphWholeDiv.appendChild(styleParagraphDivElement);
        // tslint:disable-next-line:max-line-length
        let formatting = createElement('div', { className: 'e-de-style-formatting', innerHTML: localValue.getConstant('Formatting') });
        container.appendChild(formatting);
        let optionsDiv = createElement('div', { className: 'e-de-style-options-div' });
        container.appendChild(optionsDiv);
        let fontOptionsDiv = createElement('div', { styles: 'display:flex;margin-bottom: 15px;' });
        optionsDiv.appendChild(fontOptionsDiv);
        this.createFontOptions(fontOptionsDiv);
        let paragraphOptionsDiv = createElement('div', { styles: 'display:flex', className: 'e-style-paragraph' });
        optionsDiv.appendChild(paragraphOptionsDiv);
        this.createParagraphOptions(paragraphOptionsDiv);
        // let radioOptionsDiv: HTMLElement = createElement('div', { styles: 'display:flex' });
        // container.appendChild(radioOptionsDiv);
        // let onlyThisDocumentDiv: HTMLElement = createElement('div', { className: 'e-de-style-radio-button' });
        // tslint:disable-next-line:max-line-length
        // let onlyThisDocument: HTMLInputElement = createElement('input', { className: 'e-de-style-only-this-doc', attrs: { type: 'radio' } }) as HTMLInputElement;
        // onlyThisDocumentDiv.appendChild(onlyThisDocument);
        // tslint:disable-next-line:max-line-length
        // this.onlyThisDocument = new RadioButton({ label: 'Only in this document', value: 'only in this document', checked: true, name: 'styles' });
        // this.onlyThisDocument.appendTo(onlyThisDocument);
        // radioOptionsDiv.appendChild(onlyThisDocumentDiv);
        // let templateDiv: HTMLElement = createElement('div', { className: 'e-de-style-radio-button' });
        // tslint:disable-next-line:max-line-length
        // let template: HTMLInputElement = createElement('input', { className: 'e-de-style-temp', attrs: { type: 'radio' } }) as HTMLInputElement;
        // templateDiv.appendChild(template);
        // this.template = new RadioButton({ label: 'Template', value: 'template', name: 'styles' });
        // this.template.appendTo(template);
        // radioOptionsDiv.appendChild(templateDiv);
        this.createFormatDropdown(container, localValue);
        this.target.appendChild(container);
    }
    createFormatDropdown(parentDiv, localValue) {
        let formatBtn = createElement('button', { id: 'style_format_dropdown', innerHTML: localValue.getConstant('Format') });
        formatBtn.style.height = '35px';
        parentDiv.appendChild(formatBtn);
        let items = [{ text: localValue.getConstant('Font') + '..', id: 'style_font' },
            { text: localValue.getConstant('Paragraph') + '..', id: 'style_paragraph' },
            { text: localValue.getConstant('Numbering') + '..', id: 'style_numbering' }];
        let dropDownbtn = new DropDownButton({
            items: items, cssClass: 'e-de-style-format-dropdwn',
            beforeItemRender: (args) => {
                if (this.styleType.value === 'Character') {
                    if (args.item.text === 'Paragraph') {
                        args.element.classList.add('e-disabled');
                    }
                    if (args.item.text === 'Numbering') {
                        args.element.classList.add('e-disabled');
                    }
                }
                else {
                    if (args.item.text === 'Paragraph') {
                        args.element.classList.remove('e-disabled');
                    }
                    if (args.item.text === 'Numbering') {
                        args.element.classList.remove('e-disabled');
                    }
                }
            }
        });
        dropDownbtn.appendTo(formatBtn);
        dropDownbtn.addEventListener('select', this.openDialog);
    }
    createFontOptions(parentDiv) {
        let fontFamilyElement = createElement('select', { id: this.target.id + '_fontName' });
        fontFamilyElement.innerHTML = '<option>Arial</option><option>Calibri</option><option>Candara</option>' +
            '<option>Comic Sans MS</option><option>Consolas</option><option>Constantia</option><option>Corbel</option>' +
            '<option>Courier New</option><option>Ebrima</option><option>Franklin Gothic</option>' +
            '<option>Gabriola</option><option>Gadugi</option><option>Georgia</option><option>Impact</option>' +
            '<option>Javanese Text</option><option>Microsoft Sans Serif</option><option>MS Gothic</option><option>MS UI Gothic</option>' +
            '<option>Segoe Print</option><option>Times New Roman</option><option>Verdana</option><option>Segoe UI</option>' +
            '<option>Algerian</option><option>Cambria</option><option>Georgia</option><option>Consolas</option>';
        parentDiv.appendChild(fontFamilyElement);
        this.fontFamily = new ComboBox({
            width: '123px', popupWidth: '123px',
            cssClass: 'e-style-font-fmaily-right', change: this.fontFamilyChanged
        });
        this.fontFamily.showClearButton = false;
        this.fontFamily.appendTo(fontFamilyElement);
        let fontSizeElement = createElement('input');
        parentDiv.appendChild(fontSizeElement);
        let sizeDataSource = [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72];
        this.fontSize = new ComboBox({
            dataSource: sizeDataSource, width: '73px', cssClass: 'e-style-font-fmaily-right',
            change: this.fontSizeUpdate
        });
        this.fontSize.showClearButton = false;
        this.fontSize.appendTo(fontSizeElement);
        let fontGroupButton = createElement('div', { className: 'e-de-style-font-group-button' });
        parentDiv.appendChild(fontGroupButton);
        // tslint:disable-next-line:max-line-length
        this.bold = this.createButtonElement(fontGroupButton, 'e-de-bold', 'e-de-style-bold-button-size', this.owner.owner.containerId + '_style_bold');
        this.bold.addEventListener('click', this.setBoldProperty);
        // tslint:disable-next-line:max-line-length
        this.italic = this.createButtonElement(fontGroupButton, 'e-de-italic', 'e-de-style-icon-button-size', this.owner.owner.containerId + '_style_italic');
        this.italic.addEventListener('click', this.setItalicProperty);
        // tslint:disable-next-line:max-line-length
        this.underline = this.createButtonElement(fontGroupButton, 'e-de-underline', 'e-de-style-icon-button-size', this.owner.owner.containerId + '_style_underline');
        this.underline.addEventListener('click', this.setUnderlineProperty);
        let fontColorElement = createElement('input', { attrs: { type: 'color' }, className: 'e-de-style-icon-button-size' });
        parentDiv.appendChild(fontColorElement);
        this.fontColor = new ColorPicker({ cssClass: 'e-de-style-font-color-picker', change: this.fontColorUpdate });
        this.fontColor.appendTo(fontColorElement);
    }
    createParagraphOptions(parentDiv) {
        let alignmentDiv = createElement('div', { className: 'e-de-style-paragraph-group-button' });
        parentDiv.appendChild(alignmentDiv);
        this.leftAlign = this.createButtonElement(alignmentDiv, 'e-de-align-left', 'e-de-style-icon-button-size');
        this.leftAlign.addEventListener('click', this.setLeftAlignment);
        this.centerAlign = this.createButtonElement(alignmentDiv, 'e-de-align-center', 'e-de-style-icon-button-size');
        this.centerAlign.addEventListener('click', this.setCenterAlignment);
        this.rightAlign = this.createButtonElement(alignmentDiv, 'e-de-align-right', 'e-de-style-icon-button-size');
        this.rightAlign.addEventListener('click', this.setRightAlignment);
        this.justify = this.createButtonElement(alignmentDiv, 'e-de-justify', 'e-de-style-icon-button-last-size');
        this.justify.addEventListener('click', this.setJustifyAlignment);
        let lineSpacingDiv = createElement('div', { className: 'e-de-style-paragraph-group-button' });
        parentDiv.appendChild(lineSpacingDiv);
        this.singleLineSpacing = this.createButtonElement(lineSpacingDiv, 'e-de-single-spacing', 'e-de-style-icon-button-first-size');
        this.singleLineSpacing.addEventListener('click', () => {
            this.paragraphFormat.lineSpacing = 1;
            this.updateParagraphFormat();
        });
        // tslint:disable-next-line:max-line-length
        this.onePointFiveLineSpacing = this.createButtonElement(lineSpacingDiv, 'e-de-one-point-five-spacing', 'e-de-style-icon-button-size');
        this.onePointFiveLineSpacing.addEventListener('click', () => {
            this.paragraphFormat.lineSpacing = 1.5;
            this.updateParagraphFormat();
        });
        this.doubleLineSpacing = this.createButtonElement(lineSpacingDiv, 'e-de-double-spacing', 'e-de-style-icon-button-last-size');
        this.doubleLineSpacing.addEventListener('click', () => {
            this.paragraphFormat.lineSpacing = 2;
            this.updateParagraphFormat();
        });
        let spacingDiv = createElement('div', { className: 'e-de-style-paragraph-group-button' });
        parentDiv.appendChild(spacingDiv);
        let beforeSpacing = this.createButtonElement(spacingDiv, 'e-de-before-spacing', 'e-de-style-icon-button-first-size');
        let afterSpacing = this.createButtonElement(spacingDiv, 'e-de-after-spacing', 'e-de-style-icon-button-last-size');
        beforeSpacing.addEventListener('click', this.increaseBeforeAfterSpacing);
        afterSpacing.addEventListener('click', this.decreaseBeforeAfterSpacing);
        let indentingDiv = createElement('div', { className: 'e-de-style-paragraph-indent-group-button' });
        parentDiv.appendChild(indentingDiv);
        let decreaseIndent = this.createButtonElement(indentingDiv, 'e-de-indent', 'e-de-style-icon-button-first-size');
        decreaseIndent.addEventListener('click', () => {
            if (this.paragraphFormat.leftIndent >= 36) {
                this.paragraphFormat.leftIndent -= 36;
            }
            else {
                this.paragraphFormat.leftIndent = 0;
            }
        });
        let increaseindent = this.createButtonElement(indentingDiv, 'e-de-outdent', 'e-de-style-icon-button-size');
        increaseindent.addEventListener('click', () => {
            this.paragraphFormat.leftIndent += 36;
        });
    }
    createButtonElement(parentDiv, iconCss, className, id) {
        let buttonElement = createElement('button');
        if (!isNullOrUndefined(id)) {
            buttonElement.id = id;
        }
        parentDiv.appendChild(buttonElement);
        let button = new Button({ iconCss: iconCss, cssClass: className });
        button.appendTo(buttonElement);
        return buttonElement;
    }
    toggleDisable() {
        if (this.styleType.value === 'Character') {
            this.styleParagraph.enabled = false;
            // tslint:disable-next-line:max-line-length
            this.target.getElementsByClassName('e-style-paragraph').item(0).setAttribute('style', 'display:flex;pointer-events:none;opacity:0.5');
        }
        else {
            this.styleParagraph.enabled = true;
            this.target.getElementsByClassName('e-style-paragraph').item(0).removeAttribute('style');
            this.target.getElementsByClassName('e-style-paragraph').item(0).setAttribute('style', 'display:flex');
        }
        this.styleBasedOn.enabled = true;
    }
    /**
     * @private
     */
    show(styleName, header) {
        let localObj = new L10n('documenteditor', this.owner.owner.defaultLocale);
        this.isEdit = (!isNullOrUndefined(styleName) && styleName.length > 0) ? true : false;
        this.editStyleName = styleName;
        this.abstractList = new WAbstractList();
        // tslint:disable-next-line:max-line-length
        let style = this.owner.owner.viewer.styles.findByName(styleName);
        this.style = !this.isEdit ? new WParagraphStyle() : style ? style : this.getStyle(styleName);
        localObj.setLocale(this.owner.owner.locale);
        setCulture(this.owner.owner.locale);
        if (!this.target) {
            this.initStyleDialog(localObj);
        }
        if (isNullOrUndefined(header)) {
            header = localObj.getConstant('Create New Style');
        }
        this.owner.owner.viewer.dialog2.header = header;
        this.owner.owner.viewer.dialog2.height = 'auto';
        this.owner.owner.viewer.dialog2.width = 'auto';
        this.owner.owner.viewer.dialog2.content = this.target;
        this.owner.owner.viewer.dialog2.buttons = [{
                click: this.onOkButtonClick,
                buttonModel: { content: localObj.getConstant('Ok'), cssClass: 'e-flat e-style-okay', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: localObj.getConstant('Cancel'), cssClass: 'e-flat e-style-cancel' }
            }];
        this.toggleDisable();
        this.owner.owner.viewer.dialog2.dataBind();
        this.owner.owner.viewer.dialog2.beforeOpen = this.loadStyleDialog;
        this.owner.owner.viewer.dialog2.close = this.closeStyleDialog;
        this.owner.owner.viewer.dialog2.position = { X: 'center', Y: 'center' };
        this.owner.owner.viewer.dialog2.show();
    }
    updateList() {
        let listId = this.style.paragraphFormat.listFormat.listId;
        if (listId > -1) {
            if (this.owner.owner.viewer.lists.filter((a) => (a.listId === listId)).length === 0) {
                this.owner.owner.viewer.lists.push(this.style.paragraphFormat.listFormat.list);
            }
            else {
                this.owner.owner.viewer.lists = this.owner.owner.viewer.lists.filter((a) => (a.listId !== listId));
                this.owner.owner.viewer.lists.push(this.style.paragraphFormat.listFormat.list);
            }
        }
        if (this.abstractList.abstractListId !== -1) {
            this.owner.owner.viewer.abstractLists.push(this.abstractList);
        }
    }
    createLinkStyle(name, isEdit) {
        let charStyle;
        if (isEdit) {
            charStyle = this.owner.owner.viewer.styles.findByName((name + ' Char'), 'Character');
        }
        else {
            charStyle = new WCharacterStyle();
        }
        charStyle.type = 'Character';
        charStyle.name = name + ' Char';
        charStyle.characterFormat = this.style.characterFormat.cloneFormat();
        charStyle.basedOn = this.style.basedOn;
        if (!isEdit) {
            this.owner.owner.viewer.styles.push(charStyle);
        }
        return this.owner.owner.viewer.styles.findByName(charStyle.name, 'Character');
    }
    /**
     * @private
     */
    updateCharacterFormat(characterFormat) {
        if (!isNullOrUndefined(characterFormat)) {
            this.characterFormat = characterFormat;
        }
        this.fontFamily.value = this.characterFormat.fontFamily;
        this.fontSize.value = this.characterFormat.fontSize;
        this.fontColor.value = this.characterFormat.fontColor;
        this.fontButtonClicked(undefined);
    }
    /**
     * @private
     */
    updateParagraphFormat(paragraphFOrmat) {
        if (!isNullOrUndefined(paragraphFOrmat)) {
            this.paragraphFormat = paragraphFOrmat;
        }
        if (this.paragraphFormat.textAlignment === 'Left') {
            if (!this.leftAlign.classList.contains('e-active')) {
                this.leftAlign.classList.add('e-active');
            }
            if (this.rightAlign.classList.contains('e-active')) {
                this.rightAlign.classList.remove('e-active');
            }
            if (this.centerAlign.classList.contains('e-active')) {
                this.centerAlign.classList.remove('e-active');
            }
            if (this.justify.classList.contains('e-active')) {
                this.justify.classList.remove('e-active');
            }
        }
        else if (this.paragraphFormat.textAlignment === 'Right') {
            if (this.leftAlign.classList.contains('e-active')) {
                this.leftAlign.classList.remove('e-active');
            }
            if (!this.rightAlign.classList.contains('e-active')) {
                this.rightAlign.classList.add('e-active');
            }
            if (this.centerAlign.classList.contains('e-active')) {
                this.centerAlign.classList.remove('e-active');
            }
            if (this.justify.classList.contains('e-active')) {
                this.justify.classList.remove('e-active');
            }
        }
        else if (this.paragraphFormat.textAlignment === 'Center') {
            if (this.leftAlign.classList.contains('e-active')) {
                this.leftAlign.classList.remove('e-active');
            }
            if (this.rightAlign.classList.contains('e-active')) {
                this.rightAlign.classList.remove('e-active');
            }
            if (!this.centerAlign.classList.contains('e-active')) {
                this.centerAlign.classList.add('e-active');
            }
            if (this.justify.classList.contains('e-active')) {
                this.justify.classList.remove('e-active');
            }
        }
        else if (this.paragraphFormat.textAlignment === 'Justify') {
            if (this.leftAlign.classList.contains('e-active')) {
                this.leftAlign.classList.remove('e-active');
            }
            if (this.rightAlign.classList.contains('e-active')) {
                this.rightAlign.classList.remove('e-active');
            }
            if (this.centerAlign.classList.contains('e-active')) {
                this.centerAlign.classList.remove('e-active');
            }
            if (!this.justify.classList.contains('e-active')) {
                this.justify.classList.add('e-active');
            }
        }
        if (this.paragraphFormat.lineSpacing === 1) {
            this.singleLineSpacing.classList.add('e-active');
            this.onePointFiveLineSpacing.classList.remove('e-active');
            this.doubleLineSpacing.classList.remove('e-active');
        }
        else if (this.paragraphFormat.lineSpacing === 1.5) {
            this.singleLineSpacing.classList.remove('e-active');
            this.onePointFiveLineSpacing.classList.add('e-active');
            this.doubleLineSpacing.classList.remove('e-active');
        }
        else if (this.paragraphFormat.lineSpacing === 2) {
            this.singleLineSpacing.classList.remove('e-active');
            this.onePointFiveLineSpacing.classList.remove('e-active');
            this.doubleLineSpacing.classList.add('e-active');
        }
        else {
            this.singleLineSpacing.classList.remove('e-active');
            this.onePointFiveLineSpacing.classList.remove('e-active');
            this.doubleLineSpacing.classList.remove('e-active');
        }
    }
    enableOrDisableOkButton() {
        if (!isNullOrUndefined(this.okButton)) {
            this.okButton.disabled = (this.styleNameElement.value === '');
        }
    }
    getTypeValue() {
        if (this.styleType.value === 'Linked(Paragraph and Character)' || this.styleType.value === 'Paragraph') {
            return 'Paragraph';
        }
        else {
            return 'Character';
        }
    }
    updateStyleNames(type, name) {
        let styles = this.owner.owner.viewer.styles.getStyleNames(type);
        this.styleParagraph.dataSource = styles;
        this.styleParagraph.index = null;
        if (name) {
            this.styleBasedOn.dataSource = styles.filter((e) => e !== name);
            this.styleBasedOn.index = null;
            let style = this.getStyle(name);
            if (style.basedOn instanceof String || isNullOrUndefined(style.basedOn)) {
                this.styleBasedOn.enabled = false;
            }
            else {
                /* tslint:disable-next-line:max-line-length */
                this.styleBasedOn.index = styles.indexOf(style.basedOn.name) > -1 ? styles.indexOf(style.basedOn.name) : 0;
            }
            if (style.type === 'Paragraph') {
                if (!isNullOrUndefined(style.link)) {
                    this.styleType.index = 2;
                }
                else {
                    this.styleType.index = 0;
                }
            }
            else {
                this.styleType.index = 1;
            }
            if (!isNullOrUndefined(style.next)) {
                let nxtName = style.next.name;
                let index = 0;
                if (styles.indexOf(nxtName) > -1) {
                    index = styles.indexOf(nxtName);
                }
                this.styleParagraph.index = index;
                this.isUserNextParaUpdated = (nxtName === name) ? false : true;
            }
        }
        else {
            this.styleBasedOn.dataSource = styles;
            this.styleBasedOn.index = null;
            let basedOnIndex = 0;
            if (this.owner.owner.selectionModule) {
                let styleName;
                if (type === 'Character') {
                    styleName = this.owner.owner.selection.characterFormat.styleName;
                }
                else {
                    styleName = this.owner.owner.selection.paragraphFormat.styleName;
                }
                basedOnIndex = styles.indexOf(styleName);
            }
            this.styleBasedOn.index = basedOnIndex;
            this.styleParagraph.index = 0;
        }
        if (this.isEdit) {
            this.styleType.enabled = false;
        }
        else {
            this.styleType.enabled = true;
        }
        this.styleBasedOn.dataBind();
        this.styleParagraph.dataBind();
    }
    getStyle(styleName) {
        /* tslint:disable-next-line:max-line-length */
        if (isNullOrUndefined(this.owner.owner.viewer.styles.findByName(styleName))) {
            /* tslint:disable-next-line:max-line-length */
            this.owner.owner.editor.createStyle(this.owner.owner.viewer.preDefinedStyles.get(styleName));
        }
        return this.owner.owner.viewer.styles.findByName(styleName);
    }
    /**
     * @private
     */
    destroy() {
        this.owner = undefined;
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (let n = 0; n < this.target.childNodes.length; n++) {
                this.target.removeChild(this.target.childNodes[n]);
                n--;
            }
            this.target = undefined;
        }
        if (this.styleType) {
            this.styleType.destroy();
        }
        this.styleType = undefined;
        if (this.styleBasedOn) {
            this.styleBasedOn.destroy();
        }
        this.styleBasedOn = undefined;
        if (this.styleParagraph) {
            this.styleParagraph.destroy();
        }
        this.styleParagraph = undefined;
        if (this.onlyThisDocument) {
            this.onlyThisDocument.destroy();
        }
        this.onlyThisDocument = undefined;
        if (this.template) {
            this.template.destroy();
        }
        this.template = undefined;
        if (this.style) {
            this.style = undefined;
        }
        if (this.abstractList) {
            this.abstractList = undefined;
        }
        if (this.numberingBulletDialog) {
            this.numberingBulletDialog.destroy();
        }
        this.numberingBulletDialog = undefined;
    }
}

/**
 * The Bullets and Numbering dialog is used to apply list format for a paragraph style.
 */
/* tslint:disable:no-any */
class BulletsAndNumberingDialog {
    /**
     * @private
     */
    constructor(layoutViewer) {
        this.isBullet = false;
        /**
         * @private
         */
        this.numberListClick = (args) => {
            this.isBullet = false;
            this.setActiveElement(args);
            if (args.currentTarget.classList.contains('e-de-list-numbered-none')) {
                this.numberFormat = undefined;
                this.listLevelPattern = undefined;
            }
            else if (args.currentTarget.classList.contains('e-de-list-numbered-number-dot')) {
                this.numberFormat = '%1.';
                this.listLevelPattern = 'Arabic';
            }
            else if (args.currentTarget.classList.contains('e-de-list-numbered-number-brace')) {
                this.numberFormat = '%1)';
                this.listLevelPattern = 'Arabic';
            }
            else if (args.currentTarget.classList.contains('e-de-list-numbered-up-roman')) {
                this.numberFormat = '%1.';
                this.listLevelPattern = 'UpRoman';
            }
            else if (args.currentTarget.classList.contains('e-de-list-numbered-up-letter')) {
                this.numberFormat = '%1.';
                this.listLevelPattern = 'UpLetter';
            }
            else if (args.currentTarget.classList.contains('e-de-list-numbered-low-letter-brace')) {
                this.numberFormat = '%1)';
                this.listLevelPattern = 'LowLetter';
            }
            else if (args.currentTarget.classList.contains('e-de-numbered-low-letter-dot')) {
                this.numberFormat = '%1.';
                this.listLevelPattern = 'LowLetter';
            }
            else if (args.currentTarget.classList.contains('e-de-list-numbered-low-roman')) {
                this.numberFormat = '%1.';
                this.listLevelPattern = 'LowRoman';
            }
        };
        /**
         * @private
         */
        this.bulletListClick = (args) => {
            this.isBullet = true;
            this.setActiveElement(args);
            if (args.currentTarget.classList.contains('e-bullet-none')) {
                this.symbol = undefined;
                this.fontFamily = undefined;
            }
            else if (args.currentTarget.classList.contains('e-bullet-dot')) {
                this.symbol = '\uf0b7';
                this.fontFamily = 'Symbol';
            }
            else if (args.currentTarget.classList.contains('e-bullet-circle')) {
                this.symbol = '\uf06f' + '\u0020';
                this.fontFamily = 'Symbol';
            }
            else if (args.currentTarget.classList.contains('e-bullet-square')) {
                this.symbol = '\uf0a7';
                this.fontFamily = 'Wingdings';
            }
            else if (args.currentTarget.classList.contains('e-bullet-flower')) {
                this.symbol = '\uf076';
                this.fontFamily = 'Wingdings';
            }
            else if (args.currentTarget.classList.contains('e-bullet-arrow')) {
                this.symbol = '\uf0d8';
                this.fontFamily = 'Wingdings';
            }
            else if (args.currentTarget.classList.contains('e-bullet-tick')) {
                this.symbol = '\uf0fc';
                this.fontFamily = 'Wingdings';
            }
        };
        /**
         * @private
         */
        this.loadNumberingBulletDialog = () => {
            //Load 
            this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.closeNumberingBulletDialog = () => {
            this.unWireEventsAndBindings();
            this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.onCancelButtonClick = () => {
            this.isBullet = false;
            this.listLevelPattern = undefined;
            this.numberFormat = undefined;
            this.symbol = undefined;
            this.fontFamily = undefined;
            this.owner.dialog.hide();
            this.unWireEventsAndBindings();
        };
        /**
         * @private
         */
        this.onOkButtonClick = () => {
            if (this.owner.owner.viewer.lists.length > 0) {
                this.listFormat.list.listId = this.owner.owner.viewer.lists[this.owner.owner.viewer.lists.length - 1].listId + 1;
                this.listFormat.listId = this.listFormat.list.listId;
            }
            else {
                this.listFormat.list.listId = 0;
                this.listFormat.listId = 0;
            }
            if (this.owner.owner.viewer.abstractLists.length > 0) {
                /* tslint:disable-next-line:max-line-length */
                this.abstractList.abstractListId = this.owner.owner.viewer.abstractLists[this.owner.owner.viewer.abstractLists.length - 1].abstractListId + 1;
            }
            else {
                this.abstractList.abstractListId = 0;
            }
            this.listFormat.list.abstractListId = this.abstractList.abstractListId;
            let listLevel = new WListLevel(this.abstractList);
            listLevel.listLevelPattern = !isNullOrUndefined(this.listLevelPattern) ? this.listLevelPattern : 'Bullet';
            listLevel.numberFormat = this.isBullet ? this.symbol : this.numberFormat;
            if (listLevel.listLevelPattern !== 'Bullet') {
                listLevel.startAt = 1;
            }
            listLevel.characterFormat.fontFamily = !isNullOrUndefined(this.fontFamily) ? this.fontFamily : 'Verdana';
            listLevel.paragraphFormat.leftIndent = 36;
            listLevel.paragraphFormat.firstLineIndent = -18;
            this.abstractList.levels.push(listLevel);
            this.listFormat.listLevelNumber = 0;
            this.listFormat.list.abstractList = this.abstractList;
            this.owner.dialog.hide();
        };
        this.owner = layoutViewer;
    }
    /**
     * @private
     */
    getModuleName() {
        return 'BulletsAndNumberingDialog';
    }
    /**
     * @private
     */
    initNumberingBulletDialog(locale) {
        let id = this.owner.owner.containerId;
        this.target = createElement('div', { id: id + '_insertNumberBulletDialog', className: 'e-de-number-bullet-dlg' });
        let tabTarget = createElement('div', { id: id + '_tabNumberBulletDialog', className: 'e-de-tab-number-bullet-dlg' });
        this.target.appendChild(tabTarget);
        this.createNumberList(id);
        this.createBulletList(id);
        //Initialize Tab component
        let tabObj = new Tab({
            items: [
                {
                    header: { 'text': locale.getConstant('Numbering') },
                    /* tslint:disable-next-line:max-line-length */
                    content: ('#' + id + '_Number'),
                },
                {
                    header: { 'text': locale.getConstant('Bullets') },
                    /* tslint:disable-next-line:max-line-length */
                    content: ('#' + id + '_Bullet'),
                },
            ],
            heightAdjustMode: 'None',
            width: 272,
        });
        //Render initialized Tab component
        tabObj.appendTo(tabTarget);
        this.owner.owner.element.appendChild(this.target);
        tabObj.refresh();
    }
    createNumberList(id) {
        let numberListDiv = createElement('div', { className: 'e-de-style-numbered-list', id: id + '_Number' });
        numberListDiv.style.display = 'none';
        numberListDiv.style.height = '270px';
        let ulTag = createElement('ul', {
            styles: 'display: block; outline: 0px;',
            id: 'listMenu',
            className: 'e-de-ui-wfloating-menu e-de-ui-bullets-menu e-de-list-container e-de-list-thumbnail'
        });
        numberListDiv.appendChild(ulTag);
        let numberedNone = this.createNumberNoneListTag(ulTag);
        let numberedNumberDot = this.createNumberListTag(ulTag, '1.', '2.', '3.', 'e-de-list-numbered-number-dot');
        let numberedNumberBrace = this.createNumberListTag(ulTag, '1)', '2)', '3)', 'e-de-list-numbered-number-brace');
        let numberedUpRoman = this.createNumberListTag(ulTag, 'I.', 'II.', 'III.', 'e-de-list-numbered-up-roman');
        let numberedUpLettter = this.createNumberListTag(ulTag, 'A.', 'B.', 'C.', 'e-de-list-numbered-up-letter');
        let numberedLowLetterDot = this.createNumberListTag(ulTag, 'a.', 'b.', 'c.', 'e-de-numbered-low-letter-dot');
        let numberedLowLetterBrace = this.createNumberListTag(ulTag, 'a)', 'b)', 'c)', 'e-de-list-numbered-low-letter-brace');
        let numberedLowRoman = this.createNumberListTag(ulTag, 'i.', 'ii.', 'iii.', 'e-de-list-numbered-low-roman');
        numberedNone.addEventListener('click', this.numberListClick);
        numberedNumberDot.addEventListener('click', this.numberListClick);
        numberedNumberBrace.addEventListener('click', this.numberListClick);
        numberedUpRoman.addEventListener('click', this.numberListClick);
        numberedUpLettter.addEventListener('click', this.numberListClick);
        numberedLowLetterBrace.addEventListener('click', this.numberListClick);
        numberedLowLetterDot.addEventListener('click', this.numberListClick);
        numberedLowRoman.addEventListener('click', this.numberListClick);
        this.target.appendChild(numberListDiv);
    }
    createNumberListTag(ulTag, text1, text2, text3, className) {
        let liTag = createElement('li', {
            styles: 'display:block',
            className: 'e-de-ui-wfloating-menuitem e-de-ui-wfloating-menuitem-md e-de-list-items  e-de-list-item-size ' + className
        });
        ulTag.appendChild(liTag);
        /* tslint:disable-next-line:max-line-length */
        let innerHTML = '<div>' + text1 + '<span class="e-de-ui-list-line"></span></div><div>' + text2 + '<span class="e-de-ui-list-line">';
        innerHTML += '</span></div><div>' + text3 + '<span class="e-de-ui-list-line"> </span></div >';
        let liInnerDiv = createElement('div', {
            className: 'e-de-ui-list-header-presetmenu',
            id: 'e-de-ui-zlist0', innerHTML: innerHTML
        });
        liTag.style.cssFloat = 'left';
        liTag.appendChild(liInnerDiv);
        return liTag;
    }
    createNumberNoneListTag(ulTag) {
        let liTag = createElement('li', {
            styles: 'display:block',
            /* tslint:disable-next-line:max-line-length */
            className: 'e-de-ui-wfloating-menuitem e-de-ui-wfloating-menuitem-md e-de-list-items  e-de-list-item-size e-de-list-numbered-none'
        });
        ulTag.appendChild(liTag);
        let innerHTML = '<div class="e-de-ui-bullets e-de-bullet-icons">None</div>';
        let liInnerDiv = createElement('div', {
            className: 'e-de-ui-list-header-presetmenu',
            id: 'e-de-ui-zlist0', innerHTML: innerHTML
        });
        liTag.style.cssFloat = 'left';
        liTag.appendChild(liInnerDiv);
        return liTag;
    }
    createBulletListTag(ulTag, iconCss, className) {
        let liTag = createElement('li', {
            styles: 'display:block;',
            className: 'e-de-ui-wfloating-menuitem e-de-ui-wfloating-bullet-menuitem-md e-de-list-items  e-de-list-item-size ' + className
        });
        ulTag.appendChild(liTag);
        /* tslint:disable-next-line:max-line-length */
        let liInnerDiv = createElement('div', { className: 'e-de-ui-bullet-list-header-presetmenu e-de-bullet-icon-size', id: 'e-de-ui-zlist0' });
        let liNextDiv = createElement('div', { className: iconCss });
        liInnerDiv.appendChild(liNextDiv);
        liTag.appendChild(liInnerDiv);
        return liTag;
    }
    createBulletList(id) {
        let bulletListDiv = createElement('div', { className: 'e-de-ui-bullet-list-header-presetmenu', id: id + '_Bullet' });
        bulletListDiv.style.display = 'none';
        bulletListDiv.style.height = '270px';
        let ulTag = createElement('ul', {
            styles: 'display: block; outline: 0px;', id: 'listMenu',
            className: 'e-de-ui-wfloating-menu e-de-ui-bullets-menu e-de-list-container e-de-list-thumbnail'
        });
        bulletListDiv.appendChild(ulTag);
        let bulletNone = this.createBulletListTag(ulTag, 'e-de-icon-bullet-list-none e-de-bullet-icons', 'e-bullet-none');
        let bulletDot = this.createBulletListTag(ulTag, 'e-de-icon-bullet-list-dot e-de-bullet-icons', 'e-bullet-dot');
        /* tslint:disable-next-line:max-line-length */
        let bulletCircle = this.createBulletListTag(ulTag, 'e-de-icon-bullet-list-circle e-de-bullet-icons', 'e-bullet-circle');
        let bulletSquare = this.createBulletListTag(ulTag, 'e-de-icon-bullet-list-square e-de-bullet-icons', 'e-bullet-square');
        /* tslint:disable-next-line:max-line-length */
        let bulletFlower = this.createBulletListTag(ulTag, 'e-de-icon-bullet-list-flower e-de-bullet-icons', 'e-bullet-flower');
        let bulletArrow = this.createBulletListTag(ulTag, 'e-de-icon-bullet-list-arrow e-de-bullet-icons', 'e-bullet-arrow');
        let bulletTick = this.createBulletListTag(ulTag, 'e-de-icon-bullet-list-tick e-de-bullet-icons', 'e-bullet-tick');
        bulletNone.addEventListener('click', this.bulletListClick);
        bulletDot.addEventListener('click', this.bulletListClick);
        bulletCircle.addEventListener('click', this.bulletListClick);
        bulletSquare.addEventListener('click', this.bulletListClick);
        bulletFlower.addEventListener('click', this.bulletListClick);
        bulletArrow.addEventListener('click', this.bulletListClick);
        bulletTick.addEventListener('click', this.bulletListClick);
        // bulletListDiv.appendChild(table1);        
        this.target.appendChild(bulletListDiv);
    }
    /**
     * @private
     */
    showNumberBulletDialog(listFormat, abstractList) {
        if (!isNullOrUndefined(listFormat)) {
            this.listFormat = listFormat;
        }
        else {
            this.listFormat = new WListFormat();
        }
        if (isNullOrUndefined(this.listFormat.list)) {
            this.listFormat.list = new WList();
        }
        if (!isNullOrUndefined(abstractList)) {
            this.abstractList = abstractList;
        }
        else {
            this.abstractList = new WAbstractList();
        }
        let locale = new L10n('documenteditor', this.owner.owner.defaultLocale);
        locale.setLocale(this.owner.owner.locale);
        setCulture(this.owner.owner.locale);
        if (!this.target) {
            this.initNumberingBulletDialog(locale);
        }
        this.owner.dialog.header = locale.getConstant('Numbering and Bullets');
        this.owner.dialog.width = 'auto';
        this.owner.dialog.height = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = this.loadNumberingBulletDialog;
        this.owner.dialog.close = this.closeNumberingBulletDialog;
        this.owner.dialog.position = { X: 'center', Y: 'center' };
        this.owner.dialog.buttons = [{
                click: this.onOkButtonClick,
                buttonModel: { content: locale.getConstant('Ok'), cssClass: 'e-flat e-numbering-bullet-okay', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: locale.getConstant('Cancel'), cssClass: 'e-flat e-numbering-bullet-cancel' }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    }
    setActiveElement(args) {
        let html = args.currentTarget.parentElement;
        for (let i = 0; i < html.childElementCount; i++) {
            if (html.childNodes[i].classList.contains('e-de-list-active')) {
                html.childNodes[i].classList.remove('e-de-list-active');
            }
        }
        args.currentTarget.classList.add('e-de-list-active');
    }
    /**
     * @private
     */
    unWireEventsAndBindings() {
        //Unwire events
    }
    /**
     * @private
     */
    destroy() {
        this.owner = undefined;
        if (this.listFormat) {
            this.listFormat.destroy();
            this.listFormat = undefined;
        }
        if (this.abstractList) {
            this.abstractList.destroy();
            this.abstractList = undefined;
        }
        if (this.target && this.target.parentElement) {
            this.target.parentElement.removeChild(this.target);
            for (let m = 0; m < this.target.childNodes.length; m++) {
                this.target.removeChild(this.target.childNodes[m]);
                m--;
            }
            this.target = undefined;
        }
    }
}
/* tslint:enable:no-any */

/**
 * The Font dialog is used to modify formatting of selected text.
 */
/* tslint:disable:no-any */
class FontDialog {
    /**
     * @private
     */
    constructor(layoutViewer) {
        this.fontStyleInternal = undefined;
        this.fontNameList = undefined;
        this.fontStyleText = undefined;
        this.fontSizeText = undefined;
        this.colorPicker = undefined;
        this.underlineDrop = undefined;
        this.strikethroughBox = undefined;
        this.doublestrikethrough = undefined;
        this.superscript = undefined;
        this.subscript = undefined;
        //Character Format Property
        this.bold = undefined;
        this.italic = undefined;
        this.underline = undefined;
        this.strikethrough = undefined;
        this.baselineAlignment = undefined;
        this.fontSize = undefined;
        this.fontFamily = undefined;
        this.fontColor = undefined;
        /**
         * @private
         */
        this.characterFormat = undefined;
        /**
         * @private
         */
        this.loadFontDialog = () => {
            this.owner.updateFocus();
            let characterFormat;
            if (this.characterFormat) {
                characterFormat = this.characterFormat;
            }
            else {
                characterFormat = this.owner.owner.selection.characterFormat;
            }
            this.fontNameList.value = characterFormat.fontFamily;
            if (!characterFormat.bold && !characterFormat.italic) {
                this.fontStyleText.value = this.fontSizeText.value;
                this.fontStyleText.index = 0;
            }
            else if (characterFormat.bold && !characterFormat.italic) {
                this.fontStyleText.value = this.fontSizeText.value;
                this.fontStyleText.index = 1;
            }
            else if (!characterFormat.bold && characterFormat.italic) {
                this.fontStyleText.value = this.fontSizeText.value;
                this.fontStyleText.index = 2;
            }
            else if (characterFormat.bold && characterFormat.italic) {
                this.fontStyleText.value = this.fontSizeText.value;
                this.fontStyleText.index = 3;
            }
            if (!isNullOrUndefined(characterFormat.fontSize)) {
                for (let i = 0; i <= 15; i++) {
                    let items = this.fontSizeText.getItems();
                    if (characterFormat.fontSize.toString() === items[i].innerHTML) {
                        this.fontSizeText.value = characterFormat.fontSize;
                        this.fontSizeText.index = i;
                        break;
                    }
                }
            }
            if (!isNullOrUndefined(characterFormat.fontColor)) {
                this.colorPicker.value = characterFormat.fontColor;
            }
            else {
                this.colorPicker.value = '#000000';
            }
            if (characterFormat.underline === 'None') {
                this.underlineDrop.index = 0;
            }
            else if (characterFormat.underline === 'Single') {
                this.underlineDrop.index = 1;
            }
            if (characterFormat.strikethrough === 'SingleStrike') {
                this.strikethroughBox.checked = true;
            }
            else if (characterFormat.strikethrough === 'DoubleStrike') {
                this.doublestrikethrough.checked = true;
            }
            else {
                this.strikethroughBox.checked = false;
                this.doublestrikethrough.checked = false;
            }
            if (characterFormat.baselineAlignment === 'Superscript') {
                this.superscript.checked = true;
            }
            else if (characterFormat.baselineAlignment === 'Subscript') {
                this.subscript.checked = true;
            }
            else {
                this.superscript.checked = false;
                this.subscript.checked = false;
            }
            if (this.owner.selection.caret.style.display !== 'none') {
                this.owner.selection.caret.style.display = 'none';
            }
        };
        /**
         * @private
         */
        this.closeFontDialog = () => {
            this.unWireEventsAndBindings();
            this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.onCancelButtonClick = () => {
            this.owner.dialog.hide();
            this.unWireEventsAndBindings();
        };
        /**
         * @private
         */
        this.onInsertFontFormat = () => {
            let format;
            if (this.characterFormat) {
                format = this.characterFormat;
            }
            else {
                format = new WCharacterFormat(undefined);
            }
            if (!isNullOrUndefined(this.bold)) {
                format.bold = this.bold;
            }
            if (!isNullOrUndefined(this.italic)) {
                format.italic = this.italic;
            }
            if (!isNullOrUndefined(this.fontSize) && this.fontSize > 0) {
                format.fontSize = this.fontSize;
            }
            if (!isNullOrUndefined(this.fontColor)) {
                format.fontColor = this.fontColor;
            }
            if (!isNullOrUndefined(this.baselineAlignment)) {
                format.baselineAlignment = this.baselineAlignment;
            }
            if (!isNullOrUndefined(this.strikethrough)) {
                format.strikethrough = this.strikethrough;
            }
            if (!isNullOrUndefined(this.underline)) {
                format.underline = this.underline;
            }
            if (!isNullOrUndefined(this.fontFamily)) {
                format.fontFamily = this.fontFamily;
            }
            if (!this.characterFormat) {
                this.onCharacterFormat(this.owner.selection, format);
            }
            else {
                this.owner.owner.styleDialogModule.updateCharacterFormat();
            }
            this.owner.dialog.hide();
        };
        this.fontSizeUpdate = (args) => {
            this.fontSize = args.value;
        };
        this.fontStyleUpdate = (args) => {
            this.fontStyle = args.value;
        };
        this.fontFamilyUpdate = (args) => {
            this.fontFamily = args.value;
        };
        this.underlineUpdate = (args) => {
            this.underline = args.value;
        };
        this.fontColorUpdate = (args) => {
            if (!isNullOrUndefined(args.currentValue)) {
                this.fontColor = args.currentValue.hex;
            }
        };
        this.singleStrikeUpdate = (args) => {
            this.enableCheckBoxProperty(args);
            if (args.checked) {
                this.strikethrough = 'SingleStrike';
            }
            else {
                this.strikethrough = 'None';
            }
        };
        this.doubleStrikeUpdate = (args) => {
            this.enableCheckBoxProperty(args);
            if (args.checked) {
                this.strikethrough = 'DoubleStrike';
            }
            else {
                this.strikethrough = 'None';
            }
        };
        this.superscriptUpdate = (args) => {
            this.enableCheckBoxProperty(args);
            if (args.checked) {
                this.baselineAlignment = 'Superscript';
            }
            else {
                this.baselineAlignment = 'Normal';
            }
        };
        this.subscriptUpdate = (args) => {
            this.enableCheckBoxProperty(args);
            if (args.checked) {
                this.baselineAlignment = 'Subscript';
            }
            else {
                this.baselineAlignment = 'Normal';
            }
        };
        this.owner = layoutViewer;
    }
    /**
     * @private
     */
    get fontStyle() {
        return this.fontStyleInternal;
    }
    /**
     * @private
     */
    set fontStyle(value) {
        this.fontStyleInternal = value;
        switch (this.fontStyle) {
            case 'Bold':
                this.bold = true;
                this.italic = false;
                break;
            case 'Italic':
                this.bold = false;
                this.italic = true;
                break;
            case 'BoldItalic':
                this.bold = true;
                this.italic = true;
                break;
            case 'Regular':
                this.bold = false;
                this.italic = false;
                break;
        }
    }
    /**
     * @private
     */
    getModuleName() {
        return 'FontDialog';
    }
    createInputElement(type, id, className) {
        let element = createElement('input', {
            attrs: { type: type },
            id: id,
            className: className
        });
        return element;
    }
    /**
     * @private
     */
    initFontDialog(locale) {
        let effectLabel;
        let strikeThroughElement;
        let superScriptElement;
        let subScriptElement;
        let doubleStrikeThroughElement;
        let id = this.owner.owner.containerId;
        this.target = createElement('div', { id: id + '_insertFontDialog', className: 'e-de-font-dlg' });
        let fontDiv = this.getFontDiv(locale);
        this.target.appendChild(fontDiv);
        let sizeDiv = this.getFontSizeDiv(locale);
        this.target.appendChild(sizeDiv);
        let colorDiv = createElement('div', { id: id + '_fontColor', styles: 'margin-top:15px;' });
        this.fontColorDiv = createElement('div', { id: id + '_fontColorDiv', className: 'e-de-font-dlg-display' });
        let fontColorLabel = createElement('label', {
            className: 'e-de-font-dlg-header-font-color e-de-font-color-margin', innerHTML: locale.getConstant('Font color')
        });
        this.fontColorDiv.appendChild(fontColorLabel);
        let fontColorElement = this.createInputElement('color', this.target.id + '_ColorDiv', 'e-de-font-dlg-color');
        this.fontColorDiv.appendChild(fontColorElement);
        colorDiv.appendChild(this.fontColorDiv);
        this.target.appendChild(colorDiv);
        let fontEffectsDiv = createElement('div', { id: id + '_fontEffectsDiv' });
        let fontEffectSubDiv1 = createElement('div', {
            className: 'e-de-font-color-label e-de-font-dlg-display',
            id: this.target.id + '_fontEffectsSubDiv1'
        });
        effectLabel = createElement('label', { className: 'e-de-font-dlg-header-effects', innerHTML: locale.getConstant('Effects') });
        fontEffectSubDiv1.appendChild(effectLabel);
        strikeThroughElement = this.createInputElement('checkbox', this.target.id + '_strikeThrough', '');
        fontEffectSubDiv1.appendChild(strikeThroughElement);
        superScriptElement = this.createInputElement('checkbox', this.target.id + '_superScript', '');
        fontEffectSubDiv1.appendChild(superScriptElement);
        fontEffectsDiv.appendChild(fontEffectSubDiv1);
        let fontEffectSubDiv2 = createElement('div', { className: 'e-de-font-checkbox', id: id + '_fontEffectsSubDiv2' });
        subScriptElement = this.createInputElement('checkbox', this.target.id + '_subScript', '');
        fontEffectSubDiv2.appendChild(subScriptElement);
        doubleStrikeThroughElement = this.createInputElement('checkbox', this.target.id + '_doubleStrikeThrough', '');
        fontEffectSubDiv2.appendChild(doubleStrikeThroughElement);
        fontEffectsDiv.appendChild(fontEffectSubDiv2);
        this.target.appendChild(fontEffectsDiv);
        this.owner.owner.element.appendChild(this.target);
        this.colorPicker = new ColorPicker({
            change: this.fontColorUpdate, value: '#000000',
        });
        this.colorPicker.appendTo(fontColorElement);
        this.strikethroughBox = new CheckBox({
            change: this.singleStrikeUpdate,
            cssClass: 'e-de-font-content-label',
            label: locale.getConstant('Strikethrough')
        });
        this.strikethroughBox.appendTo(strikeThroughElement);
        this.doublestrikethrough = new CheckBox({
            change: this.doubleStrikeUpdate,
            cssClass: 'e-de-font-content-checkbox-label',
            label: locale.getConstant('Double strikethrough')
        });
        this.doublestrikethrough.appendTo(doubleStrikeThroughElement);
        this.subscript = new CheckBox({
            label: locale.getConstant('Subscript'),
            change: this.subscriptUpdate
        });
        this.subscript.appendTo(subScriptElement);
        this.superscript = new CheckBox({
            label: locale.getConstant('Superscript'),
            cssClass: 'e-de-font-content-label', change: this.superscriptUpdate
        });
        this.superscript.appendTo(superScriptElement);
    }
    getFontSizeDiv(locale) {
        let fontSize;
        let sizeDiv;
        let id = this.owner.owner.containerId;
        sizeDiv = createElement('div', { id: id + '_fontSizeAndUnderlineDiv', className: 'e-de-font-dlg-padding e-de-font-dlg-display' });
        let sizeSubDiv1 = createElement('div', { id: id + '_fontSizeAndUnderlineSubDiv1' });
        let sizeLabel = createElement('label', { className: 'e-de-font-dlg-header', innerHTML: locale.getConstant('Size') });
        let styles = 'font-family:Roboto;font-size:14px;opacity:0.8;';
        fontSize = createElement('select', { id: this.target.id + '_fontSize', styles: styles });
        fontSize.innerHTML = '<option>8</option><option>9</option><option>10</option><option>11</option><option>12</option>' +
            '<option>14</option><option>16</option><option>18</option><option>20</option><option>24</option><option>26</option>' +
            '<option>28</option><option>36</option><option>48</option><option>72</option><option>96</option>';
        sizeSubDiv1.appendChild(sizeLabel);
        sizeSubDiv1.appendChild(fontSize);
        sizeDiv.appendChild(sizeSubDiv1);
        let sizeSubDiv2 = createElement('div', {
            className: 'e-de-font-dlg-cb-right',
            id: id + '_fontSizeAndUnderlineSubDiv2'
        });
        let html = locale.getConstant('Underline style');
        let underlineLabel = createElement('label', { className: 'e-de-font-dlg-header', innerHTML: html });
        let underlineElement;
        underlineElement = createElement('select', { id: this.target.id + '_underLine', styles: styles });
        underlineElement.innerHTML = '<option>' + locale.getConstant('None') + '</option><option>________</option>';
        sizeSubDiv2.appendChild(underlineLabel);
        sizeSubDiv2.appendChild(underlineElement);
        sizeDiv.appendChild(sizeSubDiv2);
        this.fontSizeText = new ComboBox({ change: this.fontSizeUpdate, popupHeight: '170px', width: '170px' });
        this.fontSizeText.showClearButton = false;
        this.fontSizeText.appendTo(fontSize);
        this.underlineDrop = new DropDownList({ change: this.underlineUpdate, popupHeight: '100px', width: '170px' });
        this.underlineDrop.appendTo(underlineElement);
        return sizeDiv;
    }
    getFontDiv(locale) {
        let id = this.owner.owner.containerId;
        let fontDiv = createElement('div', { id: id + '_fontDiv', className: 'e-de-font-dlg-display' });
        let fontSubDiv1 = createElement('div', { id: id + '_fontSubDiv1' });
        let fontNameLabel = createElement('label', {
            className: 'e-de-font-dlg-header',
            innerHTML: locale.getConstant('Font')
        });
        let fontNameValues = createElement('select', { id: this.target.id + '_fontName' });
        fontNameValues.innerHTML = '<option>Arial</option><option>Calibri</option><option>Candara</option><option>Comic Sans MS</option>' +
            '<option>Consolas</option><option>Constantia</option><option>Corbel</option>' +
            '<option>Courier New</option><option>Ebrima</option><option>Franklin Gothic</option>' +
            '<option>Gabriola</option><option>Gadugi</option><option>Georgia</option><option>Impact</option>' +
            '<option>Javanese Text</option><option>Microsoft Sans Serif</option><option>MS Gothic</option><option>MS UI Gothic</option>' +
            '<option>Segoe Print</option><option>Times New Roman</option><option>Verdana</option><option>Segoe UI</option>' +
            '<option>Algerian</option><option>Cambria</option><option>Georgia</option><option>Consolas</option>';
        fontSubDiv1.appendChild(fontNameLabel);
        fontSubDiv1.appendChild(fontNameValues);
        fontDiv.appendChild(fontSubDiv1);
        let fontSubDiv2;
        let fontStyleLabel;
        let fontStyleValues;
        fontSubDiv2 = createElement('div', { className: 'e-de-font-dlg-cb-right', id: id + '_fontSubDiv2', styles: 'float:right;' });
        fontStyleLabel = createElement('label', { className: 'e-de-font-dlg-header', innerHTML: locale.getConstant('Font style') });
        let fontStyle = 'font-family:Roboto;font-size:14px;opacity:0.8;';
        fontStyleValues = createElement('select', { id: this.target.id + '_fontStyle', styles: fontStyle });
        fontStyleValues.innerHTML = '<option>' +
            locale.getConstant('Regular') + '</option><option>' + locale.getConstant('Bold') + '</option><option>' +
            locale.getConstant('Italic') + '</option><option>' + locale.getConstant('Bold') + locale.getConstant('Italic') + '</option>';
        fontSubDiv2.appendChild(fontStyleLabel);
        fontSubDiv2.appendChild(fontStyleValues);
        fontDiv.appendChild(fontSubDiv2);
        this.fontNameList = new ComboBox({ change: this.fontFamilyUpdate, popupHeight: '200px', width: '170px' });
        this.fontNameList.showClearButton = false;
        this.fontNameList.appendTo(fontNameValues);
        this.fontStyleText = new DropDownList({ change: this.fontStyleUpdate, popupHeight: '170px', width: '170px' });
        this.fontStyleText.appendTo(fontStyleValues);
        return fontDiv;
    }
    /**
     * @private
     */
    showFontDialog(characterFormat) {
        if (characterFormat) {
            this.characterFormat = characterFormat;
        }
        let locale = new L10n('documenteditor', this.owner.owner.defaultLocale);
        locale.setLocale(this.owner.owner.locale);
        setCulture(this.owner.owner.locale);
        if (!this.target) {
            this.initFontDialog(locale);
        }
        this.owner.dialog.header = locale.getConstant('Font');
        this.owner.dialog.width = 'auto';
        this.owner.dialog.height = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = this.loadFontDialog;
        this.owner.dialog.close = this.closeFontDialog;
        this.owner.dialog.buttons = [{
                click: this.onInsertFontFormat,
                buttonModel: { content: locale.getConstant('Ok'), cssClass: 'e-flat e-font-okay', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: locale.getConstant('Cancel'), cssClass: 'e-flat e-font-cancel' }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    }
    /**
     * Applies character format
     * @param  {Selection} selection
     * @param  {WCharacterFormat} format
     * @private
     */
    onCharacterFormat(selection, format) {
        this.owner.owner.editorModule.initHistory('CharacterFormat');
        if (selection.isEmpty) {
            if (selection.start.offset === selection.getParagraphLength(selection.start.paragraph)) {
                // tslint:disable-next-line:max-line-length
                this.owner.owner.editorModule.applyCharFormatValueInternal(selection, selection.start.paragraph.characterFormat, undefined, format);
                this.owner.owner.editorModule.reLayout(selection);
            }
            this.owner.updateFocus();
            return;
        }
        else {
            //Iterate and update formating.
            this.owner.owner.editorModule.setOffsetValue(this.owner.selection);
            this.owner.owner.editorModule.updateSelectionCharacterFormatting('CharacterFormat', format, false);
        }
    }
    /**
     * @private
     */
    enableCheckBoxProperty(args) {
        if (this.strikethroughBox.checked && this.doublestrikethrough.checked) {
            this.strikethroughBox.checked = false;
            this.doublestrikethrough.checked = false;
            if (args.event.currentTarget.id === this.target.id + '_doubleStrikeThrough') {
                this.doublestrikethrough.checked = true;
            }
            else {
                this.strikethroughBox.checked = true;
            }
        }
        if (this.superscript.checked && this.subscript.checked) {
            this.subscript.checked = false;
            this.superscript.checked = false;
            if (args.event.currentTarget.id === this.target.id + '_subScript') {
                this.subscript.checked = true;
            }
            else {
                this.superscript.checked = true;
            }
        }
    }
    /**
     * @private
     */
    unWireEventsAndBindings() {
        this.fontNameList.value = '';
        this.fontSizeText.value = '';
        this.fontStyleText.value = '';
        this.strikethroughBox.checked = false;
        this.doublestrikethrough.checked = false;
        this.superscript.checked = false;
        this.subscript.checked = false;
        this.bold = undefined;
        this.italic = undefined;
        this.underline = undefined;
        this.strikethrough = undefined;
        this.baselineAlignment = undefined;
        this.fontColor = undefined;
        this.fontSize = undefined;
        this.fontFamily = undefined;
    }
    /**
     * @private
     */
    destroy() {
        this.owner = undefined;
        if (this.characterFormat) {
            this.characterFormat.destroy();
            this.characterFormat = undefined;
        }
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (let m = 0; m < this.target.childNodes.length; m++) {
                this.target.removeChild(this.target.childNodes[m]);
                m--;
            }
            this.target = undefined;
        }
        if (this.fontNameList) {
            this.fontNameList.destroy();
        }
        this.fontNameList = undefined;
        if (this.fontStyleText) {
            this.fontStyleText.destroy();
        }
        this.fontStyleText = undefined;
        if (this.fontSizeText) {
            this.fontSizeText.destroy();
        }
        this.fontSizeText = undefined;
        if (this.colorPicker) {
            this.colorPicker.destroy();
        }
        this.colorPicker = undefined;
        if (this.underlineDrop) {
            this.underlineDrop.destroy();
        }
        this.underlineDrop = undefined;
        if (this.strikethroughBox) {
            this.strikethroughBox.destroy();
        }
        this.strikethroughBox = undefined;
        if (this.doublestrikethrough) {
            this.doublestrikethrough.destroy();
        }
        this.doublestrikethrough = undefined;
        if (this.superscript) {
            this.superscript.destroy();
        }
        this.superscript = undefined;
        if (this.subscript) {
            this.subscript.destroy();
        }
        this.subscript = undefined;
    }
}
/* tslint:enable:no-any */

/**
 * The Table properties dialog is used to modify properties of selected table.
 */
class TablePropertiesDialog {
    /**
     * @private
     */
    constructor(viewer) {
        this.hasTableWidth = false;
        this.hasCellWidth = false;
        /**
         * @private
         */
        this.isTableBordersAndShadingUpdated = false;
        /**
         * @private
         */
        this.isCellBordersAndShadingUpdated = false;
        this.tabObj = undefined;
        /**
         * @private
         */
        this.isCellOptionsUpdated = false;
        /**
         * @private
         */
        this.isTableOptionsUpdated = false;
        this.onBeforeOpen = () => {
            this.owner.updateFocus();
            this.loadTableProperties();
        };
        /**
         * @private
         */
        this.onCloseTablePropertyDialog = () => {
            this.unWireEvent.bind(this);
            this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.applyTableProperties = () => {
            let selection = this.owner.selection;
            if (!this.preferCheckBox.checked && !this.preferCheckBox.indeterminate) {
                if (isNullOrUndefined(selection.tableFormat.preferredWidth) || selection.tableFormat.preferredWidth !== 0) {
                    this.tableFormat.preferredWidth = 0;
                    this.tableFormat.preferredWidthType = 'Point';
                }
            }
            if (this.tableFormat.hasValue('tableAlignment') && this.tableFormat.tableAlignment !== 'Left') {
                if (isNullOrUndefined(selection.tableFormat.leftIndent) || selection.tableFormat.leftIndent !== 0) {
                    this.tableFormat.leftIndent = 0;
                }
            }
            if (!this.rowHeightCheckBox.checked && !this.rowHeightCheckBox.indeterminate) {
                if (isNullOrUndefined(selection.rowFormat.height) || selection.rowFormat.height !== 0) {
                    this.rowFormat.heightType = 'AtLeast';
                    this.rowFormat.height = 0;
                }
            }
            if (!this.preferredCellWidthCheckBox.checked && !this.preferredCellWidthCheckBox.indeterminate) {
                if (isNullOrUndefined(selection.cellFormat.preferredWidth) || selection.cellFormat.preferredWidth === 0) {
                    this.cellFormat.preferredWidthType = 'Point';
                    this.cellFormat.preferredWidth = 0;
                }
            }
            else {
                if (this.cellFormat.preferredWidthType === 'Percent') {
                    if (!this.tableFormat.hasValue('preferredWidth') && !this.tableFormat.hasValue('preferredWidthType')
                        && this.owner.selection.start.paragraph.associatedCell.ownerTable.tableFormat.preferredWidth === 0) {
                        // tslint:disable-next-line:max-line-length
                        let containerWidth = this.owner.selection.start.paragraph.associatedCell.ownerTable.getOwnerWidth(true);
                        let tableWidth = this.owner.selection.start.paragraph.associatedCell.ownerTable.getTableClientWidth(containerWidth);
                        this.tableFormat.preferredWidthType = 'Percent';
                        this.tableFormat.preferredWidth = tableWidth / HelperMethods.convertPixelToPoint(this.owner.clientArea.width) * 100;
                    }
                }
            }
            if (this.rowHeightValue) {
                this.rowFormat.height = this.rowHeightValue;
            }
            this.owner.owner.editorModule.initComplexHistory('TableProperties');
            this.owner.owner.editorModule.onTableFormat(this.tableFormat);
            this.owner.owner.editorModule.onRowFormat(this.rowFormat);
            this.owner.owner.editorModule.onCellFormat(this.cellFormat);
            this.owner.owner.editorHistory.updateComplexHistory();
            this.closeTablePropertiesDialog();
            this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.applyTableSubProperties = () => {
            if (this.isCellOptionsUpdated) {
                let cellFormat = this.owner.owner.cellOptionsDialogModule.cellFormat;
                this.owner.owner.cellOptionsDialogModule.applySubCellOptions(cellFormat);
            }
            if (this.isTableOptionsUpdated) {
                let tableFormat = this.owner.owner.tableOptionsDialogModule.tableFormat;
                this.owner.owner.tableOptionsDialogModule.applySubTableOptions(tableFormat);
            }
            this.isCellOptionsUpdated = false;
            this.isTableOptionsUpdated = false;
        };
        /**
         * @private
         */
        this.unWireEvent = () => {
            //Table Format
            this.preferCheckBox.change = undefined;
            this.tableWidthBox.change = undefined;
            this.tableWidthType.change = undefined;
            this.leftIndentBox.change = undefined;
            //Row Format
            this.rowHeightCheckBox.change = undefined;
            this.rowHeightBox.change = undefined;
            this.rowHeightType.change = undefined;
            this.repeatHeader.change = undefined;
            this.allowRowBreak.change = undefined;
            //Cell Format
            this.preferredCellWidthCheckBox.change = undefined;
            this.cellWidthBox.change = undefined;
            this.cellWidthType.change = undefined;
            this.cellFormat.destroy();
            this.rowFormat.destroy();
            this.tableFormat.destroy();
            this.rowHeightValue = undefined;
            this.owner.dialog2.open = this.owner.selection.hideCaret.bind(this.owner);
        };
        /**
         * @private
         */
        this.closeTablePropertiesDialog = () => {
            this.owner.dialog2.hide();
            this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.changeTableCheckBox = () => {
            let enable = (this.preferCheckBox.checked || this.preferCheckBox.indeterminate);
            this.tableWidthBox.enabled = enable;
            this.tableWidthType.enabled = enable;
            if (enable) {
                this.tableFormat.preferredWidthType = (this.tableWidthType.value === 'Points') ?
                    'Point' : this.tableWidthType.value;
            }
            else {
                this.tableFormat.preferredWidthType = this.owner.selection.tableFormat.preferredWidthType;
            }
        };
        /**
         * @private
         */
        this.changeTableAlignment = (event) => {
            this.updateClassForAlignmentProperties(this.tableTab);
            let element = event.target;
            classList(element, ['e-de-table-alignment-active'], ['e-de-table-properties-alignment']);
            if (element.classList.contains('e-de-table-left-alignment')) {
                this.leftIndentBox.enabled = true;
            }
            else {
                this.leftIndentBox.enabled = false;
            }
            this.tableFormat.tableAlignment = this.getTableAlignment();
        };
        /**
         * @private
         */
        this.changeTableRowCheckBox = () => {
            this.rowHeightType.enabled = this.rowHeightCheckBox.checked;
            this.rowHeightBox.enabled = this.rowHeightCheckBox.checked;
            if (this.rowHeightType.enabled) {
                this.rowFormat.heightType = this.rowHeightType.value;
            }
            else {
                this.rowFormat.heightType = this.owner.selection.rowFormat.heightType;
            }
        };
        /**
         * @private
         */
        this.changeTableCellCheckBox = () => {
            this.cellWidthType.enabled = this.preferredCellWidthCheckBox.checked;
            this.cellWidthBox.enabled = this.preferredCellWidthCheckBox.checked;
        };
        /**
         * @private
         */
        this.changeCellAlignment = (event) => {
            this.updateClassForCellAlignment(this.cellTab);
            let element = event.target;
            classList(element, ['e-de-table-alignment-active'], ['e-de-tablecell-alignment']);
            this.cellFormat.verticalAlignment = this.getCellAlignment();
        };
        //#endregion
        /**
         * @private
         */
        this.showTableOptionsDialog = () => {
            this.owner.owner.tableOptionsDialogModule.show();
            this.owner.dialog2.element.style.pointerEvents = 'none';
        };
        /**
         * @private
         */
        this.showBordersShadingsPropertiesDialog = () => {
            this.owner.owner.bordersAndShadingDialogModule.show();
            this.owner.dialog2.element.style.pointerEvents = 'none';
        };
        /**
         * @private
         */
        this.showCellOptionsDialog = () => {
            this.owner.owner.cellOptionsDialogModule.show();
            this.owner.dialog2.element.style.pointerEvents = 'none';
        };
        this.owner = viewer;
    }
    /**
     * @private
     */
    get cellFormat() {
        if (isNullOrUndefined(this.cellFormatIn)) {
            return this.cellFormatIn = new WCellFormat();
        }
        return this.cellFormatIn;
    }
    /**
     * @private
     */
    set cellFormat(value) {
        this.cellFormatIn = value;
    }
    /**
     * @private
     */
    get tableFormat() {
        if (isNullOrUndefined(this.tableFormatIn)) {
            this.tableFormatIn = new WTableFormat();
            return this.tableFormatIn;
        }
        return this.tableFormatIn;
    }
    /**
     * @private
     */
    set tableFormat(value) {
        this.tableFormatIn = value;
    }
    /**
     * @private
     */
    get rowFormat() {
        if (isNullOrUndefined(this.rowFormatInternal)) {
            this.rowFormatInternal = new WRowFormat();
            return this.rowFormatInternal;
        }
        return this.rowFormatInternal;
    }
    getModuleName() {
        return 'TablePropertiesDialog';
    }
    /**
     * @private
     */
    initTablePropertyDialog(localValue) {
        let id = this.owner.owner.containerId + '_TablePropertiesDialog';
        this.target = createElement('div', { id: id, className: 'e-de-table-properties-dlg' });
        this.owner.owner.element.appendChild(this.target);
        let ejtabContainer = createElement('div', { id: this.target.id + '_TabContainer' });
        this.target.appendChild(ejtabContainer);
        this.tableTab = createElement('div', {
            id: this.target.id + '_TablePropertiesContentDialogTab', className: 'e-de-table-ppty-dlg-tabs'
        });
        this.rowTab = createElement('div', {
            id: this.target.id + '_RowPropertiesDialogTab', className: 'e-de-table-ppty-dlg-tabs'
        });
        this.cellTab = createElement('div', {
            id: this.target.id + '_CellPropertiesDialogTab', className: 'e-de-table-ppty-dlg-tabs'
        });
        let separatorLine = createElement('div', { className: 'e-de-table-dialog-separator-line' });
        // tslint:disable-next-line:max-line-length
        let ejtab = createElement('div', { id: this.target.id + '_TablePropertiesDialogTab', className: 'e-de-table-ppty-tab' });
        let headerContainer = createElement('div', { className: 'e-tab-header' });
        let tableHeader = createElement('div', {
            id: this.target.id + '_tableHeader', innerHTML: localValue.getConstant('Table')
        });
        let rowHeader = createElement('div', {
            id: this.target.id + '_rowHeader', innerHTML: localValue.getConstant('Row')
        });
        let cellHeader = createElement('div', {
            id: this.target.id + '_cellHeader', innerHTML: localValue.getConstant('Cell')
        });
        headerContainer.appendChild(tableHeader);
        headerContainer.appendChild(rowHeader);
        headerContainer.appendChild(cellHeader);
        let contentContainer = createElement('div', { className: 'e-content' });
        let tableContent = createElement('div', { id: this.target.id + '_tableContent' });
        let rowContent = createElement('div', { id: this.target.id + '_rowContent' });
        let cellContent = createElement('div', { id: this.target.id + '_cellContent' });
        tableContent.appendChild(this.tableTab);
        rowContent.appendChild(this.rowTab);
        cellContent.appendChild(this.cellTab);
        contentContainer.appendChild(tableContent);
        contentContainer.appendChild(rowContent);
        contentContainer.appendChild(cellContent);
        ejtab.appendChild(headerContainer);
        ejtab.appendChild(contentContainer);
        ejtabContainer.appendChild(ejtab);
        this.initTableProperties(this.tableTab, localValue);
        this.initTableRowProperties(this.rowTab, localValue);
        this.initTableCellProperties(this.cellTab, localValue);
        this.tabObj = new Tab({}, ejtab);
        this.target.appendChild(separatorLine);
        let alignMentButtons = this.tableTab.getElementsByClassName(this.tableTab.id + 'e-de-table-alignment');
        for (let i = 0; i < alignMentButtons.length; i++) {
            alignMentButtons[i].addEventListener('click', this.changeTableAlignment);
        }
        let cellAlignment = this.cellTab.getElementsByClassName(this.cellTab.id + 'e-de-table-cell-alignment');
        for (let i = 0; i < cellAlignment.length; i++) {
            cellAlignment[i].addEventListener('click', this.changeCellAlignment);
        }
        let tableTabHeader = this.tabObj.element.getElementsByClassName('e-item e-toolbar-item')[0];
        let tableTabHeaderItem = tableTabHeader.getElementsByClassName('e-tab-wrap')[0];
        tableTabHeaderItem.classList.add('e-de-table-ppty-dlg-table-header');
        let rowTabHeader = this.tabObj.element.getElementsByClassName('e-item e-toolbar-item')[1];
        let rowTabHeaderItem = rowTabHeader.getElementsByClassName('e-tab-wrap')[0];
        rowTabHeaderItem.classList.add('e-de-table-ppty-dlg-row-header');
        let cellTabHeader = this.tabObj.element.getElementsByClassName('e-item e-toolbar-item')[2];
        let cellTabHeaderItem = cellTabHeader.getElementsByClassName('e-tab-wrap')[0];
        cellTabHeaderItem.classList.add('e-de-table-ppty-dlg-cell-header');
        this.tabObj.element.getElementsByClassName('e-indicator')[0].style.right = '155px';
    }
    /**
     * @private
     */
    show() {
        let localValue = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localValue.setLocale(this.owner.owner.locale);
        setCulture(this.owner.owner.locale);
        if (!this.target) {
            this.initTablePropertyDialog(localValue);
        }
        if (this.owner.selection.caret.style.display !== 'none') {
            this.owner.selection.caret.style.display = 'none';
        }
        this.owner.dialog2.header = localValue.getConstant('Table Properties');
        this.owner.dialog2.position = { X: 'center', Y: 'center' };
        this.owner.dialog2.width = 'auto';
        this.owner.dialog2.height = 'auto';
        this.owner.dialog2.content = this.target;
        this.owner.dialog2.beforeOpen = this.onBeforeOpen;
        this.owner.dialog2.close = this.onCloseTablePropertyDialog;
        this.owner.dialog2.open = this.wireEvent.bind(this);
        this.owner.dialog2.buttons = [{
                click: this.applyTableProperties,
                buttonModel: { content: localValue.getConstant('Ok'), cssClass: 'e-flat e-table-ppty-okay', isPrimary: true }
            },
            {
                click: this.closeTablePropertiesDialog,
                buttonModel: { content: localValue.getConstant('Cancel'), cssClass: 'e-flat e-table-ppty-cancel' }
            }];
        //this.tabObj.select(0);
        this.owner.dialog2.dataBind();
        this.owner.dialog2.show();
    }
    /**
     * @private
     */
    calculateGridValue(table) {
        table.calculateGrid();
        table.isGridUpdated = false;
        table.buildTableColumns();
        table.isGridUpdated = true;
        this.owner.selection.owner.isLayoutEnabled = true;
        this.owner.layout.reLayoutTable(table);
        this.owner.owner.editorModule.reLayout(this.owner.selection);
        this.owner.owner.editorModule.updateSelectionTextPosition(true);
        let history = this.owner.owner.editorHistory;
        if (history && history.currentBaseHistoryInfo) {
            if (history.currentBaseHistoryInfo.modifiedProperties.length > 0) {
                history.currentBaseHistoryInfo.updateSelection();
            }
            history.updateHistory();
        }
        this.owner.owner.editorModule.fireContentChange();
    }
    /**
     * @private
     */
    loadTableProperties() {
        this.setTableProperties();
        this.setTableRowProperties();
        this.setTableCellProperties();
        if (!this.owner.owner.bordersAndShadingDialogModule) {
            this.bordersAndShadingButton.disabled = true;
        }
        else {
            this.bordersAndShadingButton.disabled = false;
        }
        // if (!this.owner.owner.tableOptionsDialogModule) {
        //     this.tableOptionButton.disabled = true;
        // } else {
        this.tableOptionButton.disabled = false;
        // }
        // if (!this.owner.owner.cellOptionsDialogModule) {
        //     this.cellOptionButton.disabled = true;
        // } else {
        this.cellOptionButton.disabled = false;
        // }
    }
    /**
     * @private
     */
    wireEvent() {
        this.owner.selection.hideCaret();
        //Table Format
        this.preferCheckBox.change = this.changeTableCheckBox.bind(this);
        this.tableWidthBox.change = this.onTableWidthChange.bind(this);
        this.tableWidthType.change = this.onTableWidthTypeChange.bind(this);
        this.leftIndentBox.change = this.onLeftIndentChange.bind(this);
        //Row Format
        this.rowHeightCheckBox.change = this.changeTableRowCheckBox.bind(this);
        this.rowHeightBox.change = this.onRowHeightChange.bind(this);
        this.rowHeightType.change = this.onRowHeightTypeChange.bind(this);
        this.allowRowBreak.change = this.onAllowBreakAcrossPage.bind(this);
        this.repeatHeader.change = this.onRepeatHeader.bind(this);
        //Cell Format
        this.preferredCellWidthCheckBox.change = this.changeTableCellCheckBox.bind(this);
        this.cellWidthBox.change = this.onCellWidthChange.bind(this);
        this.cellWidthType.change = this.onCellWidthTypeChange.bind(this);
    }
    //#region Table Format
    /**
     * @private
     */
    // tslint:disable-next-line:max-func-body-length
    initTableProperties(element, localValue) {
        let container = createElement('div', { id: element.id + '_table_TabContainer' });
        let sizeHeader = createElement('div', {
            id: container.id + '_sizeLabel', innerHTML: localValue.getConstant('Size'),
            styles: 'width:100%;margin:0px;padding-top: 20px;padding-bottom: 0px;', className: 'e-de-table-dialog-options-label'
        });
        let parentContainer = createElement('div', { styles: 'display: inline-flex;' });
        let childContainer1 = createElement('div', {
            styles: 'float: left;',
            className: 'e-de-table-container-div'
        });
        let childContainer2 = createElement('div', {
            className: 'e-de-table-ppty-dlg-preferred-width-div'
        });
        let child1 = createElement('div', {
            styles: 'display: inline;',
            className: 'e-de-table-ppty-dlg-measure-div'
        });
        let child2 = createElement('div', {
            styles: 'display: inline;position: absolute;',
            className: 'e-de-table-ppty-dlg-measure-drop-down-div'
        });
        let childContainer3 = createElement('div');
        let preferCheckBox = createElement('input', {
            id: element.id + '_Prefer_Width_CheckBox', attrs: { 'type': 'checkbox' }
        });
        this.preferredWidth = createElement('input', { id: element.id + 'preferred_Width' });
        let controlDiv = createElement('div');
        let tableWidthType = createElement('select', {
            innerHTML: '<option>' + localValue.getConstant('Points') +
                '</option><option>' + localValue.getConstant('Percent') + '</option>', id: element.id + '_width_dropdown'
        });
        let labeltext = createElement('label', {
            innerHTML: localValue.getConstant('Measure in'), styles: 'width: 60px;font-size: 11px; font-weight: normal;'
        });
        let alignmentHeader = createElement('div', {
            innerHTML: localValue.getConstant('Alignment'), className: 'e-de-table-dialog-options-label',
            styles: 'width: 100%;margin: 0px;padding-bottom: 15px'
        });
        let alignmentContainer = createElement('div', { styles: 'height:70px;' });
        let classDivName = element.id + 'e-de-table-alignment';
        let leftAlignDiv = createElement('div', { className: 'e-de-table-dia-align-div' });
        this.left = createElement('div', {
            className: 'e-icons e-de-table-properties-alignment e-de-table-left-alignment ' + classDivName,
            id: element.id + '_left_alignment', styles: 'width:54px;height:54px;margin:2px'
        });
        leftAlignDiv.appendChild(this.left);
        let centerAlignDiv = createElement('div', { className: 'e-de-table-dia-align-div' });
        this.center = createElement('div', {
            className: 'e-icons e-de-table-properties-alignment  e-de-table-center-alignment ' + classDivName,
            id: element.id + '_center_alignment', styles: 'width:54px;height:54px;margin:2px'
        });
        centerAlignDiv.appendChild(this.center);
        this.right = createElement('div', {
            styles: 'width:54px;height:54px;margin:2px', id: element.id + '_right_alignment',
            className: 'e-icons e-de-table-properties-alignment  e-de-table-right-alignment ' + classDivName
        });
        let rightAlignDiv = createElement('div', { className: 'e-de-table-dia-align-div' });
        rightAlignDiv.appendChild(this.right);
        let leftlabel = createElement('label', {
            innerHTML: localValue.getConstant('Left'), className: 'e-de-table-dia-align-label'
        });
        let centerlabel = createElement('label', {
            innerHTML: localValue.getConstant('Center'), className: 'e-de-table-dia-align-label'
        });
        let rightlabel = createElement('label', {
            innerHTML: localValue.getConstant('Right'), className: 'e-de-table-dia-align-label'
        });
        let leftIndenetContainer = createElement('div', {
            className: 'e-de-table-ppty-dlg-left-indent-container'
        });
        let leftIndentLabel = createElement('label', {
            innerHTML: localValue.getConstant('Indent from left'),
            styles: 'font-weight: normal;font-size: 11px;float:right;margin-right:121px;'
        });
        let leftIndentBox = createElement('div', {
            styles: 'margin-top: 27px;'
        });
        this.leftIndent = createElement('input', { id: element.id + '_left_indent' });
        let tableOptionContiner = createElement('div', {
            className: 'e-de-tbl-dlg-border-btn'
        });
        this.bordersAndShadingButton = createElement('button', {
            innerHTML: localValue.getConstant('Borders and Shading'),
            id: element.id + '_borders_and_shadings', className: 'e-control e-btn e-flat e-de-ok-button'
        });
        this.tableOptionButton = createElement('button', {
            className: 'e-control e-btn e-flat', innerHTML: localValue.getConstant('Options'),
            id: element.id + '_table_cellmargin'
        });
        this.tableOptionButton.addEventListener('click', this.showTableOptionsDialog);
        this.bordersAndShadingButton.addEventListener('click', this.showBordersShadingsPropertiesDialog);
        tableOptionContiner.appendChild(this.bordersAndShadingButton);
        tableOptionContiner.appendChild(this.tableOptionButton);
        leftIndenetContainer.appendChild(leftIndentLabel);
        leftIndentBox.appendChild(this.leftIndent);
        leftIndenetContainer.appendChild(leftIndentBox);
        alignmentContainer.appendChild(leftAlignDiv);
        alignmentContainer.appendChild(centerAlignDiv);
        alignmentContainer.appendChild(rightAlignDiv);
        leftAlignDiv.appendChild(leftlabel);
        centerAlignDiv.appendChild(centerlabel);
        rightAlignDiv.appendChild(rightlabel);
        alignmentContainer.appendChild(leftIndenetContainer);
        container.appendChild(sizeHeader);
        element.appendChild(container);
        childContainer1.appendChild(preferCheckBox);
        parentContainer.appendChild(childContainer1);
        childContainer2.appendChild(this.preferredWidth);
        parentContainer.appendChild(childContainer2);
        controlDiv.appendChild(tableWidthType);
        child1.appendChild(labeltext);
        child2.appendChild(controlDiv);
        childContainer3.appendChild(child1);
        childContainer3.appendChild(child2);
        parentContainer.appendChild(childContainer3);
        element.appendChild(parentContainer);
        element.appendChild(alignmentHeader);
        element.appendChild(alignmentContainer);
        element.appendChild(tableOptionContiner);
        this.tableWidthBox = new NumericTextBox({
            value: 0, decimals: 2, min: 0, max: 1584, width: 120, enablePersistence: false
        });
        this.tableWidthBox.appendTo(this.preferredWidth);
        this.leftIndentBox = new NumericTextBox({
            value: 0, decimals: 2, min: -1584, max: 1584, width: 140, enablePersistence: false
        });
        this.leftIndentBox.appendTo(this.leftIndent);
        this.preferCheckBox = new CheckBox({
            label: localValue.getConstant('Preferred Width')
        });
        this.preferCheckBox.appendTo(preferCheckBox);
        this.tableWidthType = new DropDownList({ width: '120px' });
        this.tableWidthType.appendTo(tableWidthType);
    }
    /**
     * @private
     */
    onTableWidthChange() {
        this.tableFormat.preferredWidth = this.tableWidthBox.value;
    }
    /**
     * @private
     */
    onTableWidthTypeChange() {
        let value;
        let table = this.owner.selection.start.paragraph.associatedCell.ownerTable;
        let width = HelperMethods.convertPixelToPoint(this.owner.clientArea.width);
        if (this.tableWidthType.text === 'Percent' && this.owner.selection.tableFormat.preferredWidthType !== 'Percent') {
            value = this.tableWidthBox.value / width * 100;
            this.formatNumericTextBox(this.tableWidthBox, 'Percent', value);
        }
        else if (this.tableWidthType.text === 'Points' && this.owner.selection.tableFormat.preferredWidthType !== 'Point') {
            value = width / 100 * this.tableWidthBox.value;
            this.formatNumericTextBox(this.tableWidthBox, 'Point', value);
        }
        else {
            if (this.tableWidthBox.format === '#\'\%\'') {
                if (this.tableWidthType.text === 'Points') {
                    value = width / 100 * this.tableWidthBox.value;
                }
                else {
                    value = this.tableWidthBox.value;
                }
            }
            else {
                if (this.tableWidthType.text === 'Percent') {
                    value = this.tableWidthBox.value / width * 100;
                }
                else {
                    value = this.tableWidthBox.value;
                }
            }
            // tslint:disable-next-line:max-line-length
            this.formatNumericTextBox(this.tableWidthBox, (this.tableWidthType.text === 'Points') ? 'Point' : this.tableWidthType.text, value);
        }
        this.tableFormat.preferredWidthType = (this.tableWidthType.text === 'Points') ? 'Point' : this.tableWidthType.text;
    }
    /**
     * @private
     */
    onLeftIndentChange() {
        this.tableFormat.leftIndent = this.leftIndentBox.value;
    }
    setTableProperties() {
        //instance of Table Property values
        let tableFormat = this.owner.selection.tableFormat;
        let tableHasWidth = tableFormat.preferredWidth > 0;
        let preferredWidth = tableFormat.preferredWidth;
        if (isNullOrUndefined(tableFormat.preferredWidth)) {
            this.preferCheckBox.indeterminate = true;
            let startTable = this.owner.selection.start.paragraph.associatedCell.ownerTable;
            let table = startTable.combineWidget(this.owner);
            preferredWidth = table.tableFormat.preferredWidth;
        }
        else {
            this.preferCheckBox.checked = tableHasWidth;
        }
        this.tableWidthBox.enabled = tableHasWidth;
        this.tableWidthType.enabled = tableHasWidth;
        this.formatNumericTextBox(this.tableWidthBox, tableFormat.preferredWidthType, preferredWidth);
        if (tableFormat.preferredWidthType === 'Auto' || tableFormat.preferredWidthType === 'Point') {
            this.tableWidthType.index = 0;
        }
        else {
            this.tableWidthType.index = 1;
        }
        this.leftIndentBox.value = tableFormat.leftIndent;
        this.leftIndentBox.enabled = tableFormat.tableAlignment === 'Left';
        classList(this.left, [], ['e-de-table-alignment-active']);
        classList(this.right, [], ['e-de-table-alignment-active']);
        classList(this.center, [], ['e-de-table-alignment-active']);
        if (tableFormat.tableAlignment === 'Left') {
            this.left.classList.add('e-de-table-alignment-active');
        }
        else if (tableFormat.tableAlignment === 'Center') {
            this.center.classList.add('e-de-table-alignment-active');
        }
        else if (tableFormat.tableAlignment === 'Right') {
            this.right.classList.add('e-de-table-alignment-active');
        }
    }
    /**
     * @private
     */
    getTableAlignment() {
        let id = this.tableTab.id;
        let groupButtons = this.tableTab.getElementsByClassName(id + 'e-de-table-alignment');
        for (let j = 0; j < groupButtons.length; j++) {
            let groupButton = groupButtons[j];
            if (groupButton.classList.contains('e-de-table-alignment-active')) {
                if (j === 0) {
                    return 'Left';
                }
                else if (j === 1) {
                    return 'Center';
                }
                else {
                    return 'Right';
                }
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    updateClassForAlignmentProperties(element) {
        let id = element.id;
        let groupButtons = element.getElementsByClassName(id + 'e-de-table-alignment');
        for (let j = 0; j < groupButtons.length; j++) {
            let groupButton = groupButtons[j];
            if (groupButton.classList.contains('e-de-table-alignment-active')) {
                classList(groupButton, ['e-de-table-properties-alignment'], ['e-de-table-alignment-active']);
            }
        }
    }
    //#endregion
    //#region Row Format
    /**
     * @private
     */
    initTableRowProperties(element, localValue) {
        let rowDiv = createElement('div', { styles: 'width: 100%;' });
        let sizeLabeldiv = createElement('div', {
            innerHTML: localValue.getConstant('Size'),
            styles: 'width: 100%;padding-top: 20px;padding-bottom: 10px;',
            className: 'e-de-table-dialog-options-label'
        });
        let parentDiv = createElement('div', { styles: 'display: inline;width: 100%;' });
        let childDiv1 = createElement('div', {
            styles: 'display: inline;float: left;',
            className: 'e-de-table-header-div'
        });
        let rowHeightCheckBox = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: element.id + '_height_CheckBox'
        });
        let childdiv2 = createElement('div', {
            styles: 'display: inline-block;',
            className: 'e-de-row-ht-top'
        });
        this.rowHeight = createElement('input', {
            attrs: { 'type': 'text' }, 'id': element.id + '_table_row_height'
        });
        let child2 = createElement('div', {
            styles: 'float: right;display: inline;width: auto;margin-top: 5px;'
        });
        let child3 = createElement('div', {
            styles: 'display: inline;',
            className: 'e-de-table-ppty-dlg-row-height-label'
        });
        let child4 = createElement('div', {
            styles: 'display: inline;',
            className: 'e-de-table-subheader-div'
        });
        let controlDiv = createElement('div');
        let rowHeightType = createElement('select', {
            innerHTML: '<option>' + localValue.getConstant('At least')
                + '</option><option>' + localValue.getConstant('Exactly') + '</option>',
            id: element.id + '_height_type'
        });
        let labeltext = createElement('label', {
            innerHTML: localValue.getConstant('Row height is'), styles: 'font-size: 11px;font-weight: normal;width: 75px;'
        });
        rowDiv.appendChild(sizeLabeldiv);
        element.appendChild(rowDiv);
        childDiv1.appendChild(rowHeightCheckBox);
        parentDiv.appendChild(childDiv1);
        childdiv2.appendChild(this.rowHeight);
        parentDiv.appendChild(childdiv2);
        controlDiv.appendChild(rowHeightType);
        child3.appendChild(labeltext);
        child4.appendChild(controlDiv);
        child2.appendChild(child3);
        child2.appendChild(child4);
        parentDiv.appendChild(child2);
        element.appendChild(parentDiv);
        let alignmentDiv = createElement('div', {
            innerHTML: localValue.getConstant('Options'), styles: 'width: 100%;',
            className: 'e-de-table-dialog-options-label'
        });
        // tslint:disable-next-line:max-line-length
        let allowRowContainer = createElement('div', { className: 'e-de-table-ppty-options-break' });
        let repeatHeaderContaniner = createElement('div', { className: 'e-de-table-ppty-options-header-row' });
        let allowRowBreak = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: element.id + '_allow_row_break'
        });
        let repeatHeader = createElement('input', {
            attrs: { 'type': 'checkbox' }, 'id': element.id + '_repeat_header'
        });
        allowRowContainer.appendChild(allowRowBreak);
        repeatHeaderContaniner.appendChild(repeatHeader);
        element.appendChild(alignmentDiv);
        element.appendChild(allowRowContainer);
        element.appendChild(repeatHeaderContaniner);
        this.rowHeightBox = new NumericTextBox({
            value: 0, decimals: 2, min: 0, max: 1584, width: 120, enablePersistence: false
        });
        this.rowHeightBox.appendTo(this.rowHeight);
        this.rowHeightCheckBox = new CheckBox({
            label: localValue.getConstant('Specify height')
        });
        this.rowHeightCheckBox.appendTo(rowHeightCheckBox);
        this.rowHeightType = new DropDownList({ width: '120px' });
        this.rowHeightType.appendTo(rowHeightType);
        this.allowRowBreak = new CheckBox({
            label: localValue.getConstant('Allow row to break across pages')
        });
        this.allowRowBreak.appendTo(allowRowBreak);
        this.repeatHeader = new CheckBox({
            label: localValue.getConstant('Repeat as header row at the top of each page')
        });
        this.repeatHeader.appendTo(repeatHeader);
    }
    setTableRowProperties() {
        let rowFormat = this.owner.selection.rowFormat;
        let enableRowHeight = (rowFormat.height > 0 || rowFormat.heightType === 'Exactly');
        //instance of table row values
        if (enableRowHeight) {
            this.rowHeightCheckBox.checked = true;
        }
        else {
            if (rowFormat.heightType === undefined) {
                this.rowHeightCheckBox.indeterminate = true;
                enableRowHeight = true;
            }
            else {
                this.rowHeightCheckBox.checked = false;
            }
        }
        this.rowHeightBox.enabled = enableRowHeight;
        this.rowHeightType.enabled = enableRowHeight;
        // let enabledHeader: boolean = this.enableRepeatHeader() ? false : true;
        let enabledHeader = true;
        if (isNullOrUndefined(this.owner.selection.rowFormat.isHeader)) {
            this.repeatHeader.indeterminate = true;
            this.repeatHeader.disabled = true;
        }
        else if (this.owner.selection.rowFormat.isHeader) {
            this.repeatHeader.checked = !enabledHeader;
            this.repeatHeader.indeterminate = enabledHeader;
            this.repeatHeader.disabled = enabledHeader;
        }
        else {
            this.repeatHeader.checked = false;
            this.repeatHeader.indeterminate = false;
            this.repeatHeader.disabled = enabledHeader;
        }
        if (isNullOrUndefined(rowFormat.allowBreakAcrossPages)) {
            this.allowRowBreak.indeterminate = true;
        }
        else {
            this.allowRowBreak.checked = rowFormat.allowBreakAcrossPages;
        }
        this.rowHeightBox.value = rowFormat.height;
        if (rowFormat.heightType === 'Auto' || rowFormat.heightType === 'AtLeast') {
            this.rowHeightType.index = 0;
        }
        else {
            this.rowHeightType.index = 1;
        }
    }
    /**
     * @private
     */
    onRowHeightChange() {
        this.rowHeightValue = this.rowHeightBox.value;
    }
    /**
     * @private
     */
    onRowHeightTypeChange() {
        this.rowFormat.heightType = this.rowHeightType.text;
    }
    /**
     * @private
     */
    onAllowBreakAcrossPage() {
        this.rowFormat.allowBreakAcrossPages = this.allowRowBreak.checked;
    }
    /**
     * @private
     */
    onRepeatHeader() {
        this.rowFormat.isHeader = this.repeatHeader.checked;
    }
    /**
     * @private
     */
    // public enableRepeatHeader(): boolean {
    //     let isFirstRow: number = 0;
    //     for (let i: number = 0; i < this.owner.selection.selectionRanges.length; i++) {
    //         let range: SelectionRange = this.owner.selection.selectionRanges.getRange(i);
    //         let table: WTable = range.start.paragraph.associatedCell.ownerTable;
    //         if (table.childNodes.indexOf(range.start.paragraph.associatedCell.ownerRow) === 0 ||
    //             table.childNodes.indexOf(range.start.paragraph.associatedCell.ownerRow) === 0) {
    //             isFirstRow++;
    //         }
    //     }
    //     return isFirstRow === this.owner.selection.selectionRanges.length;
    // }
    //#endregion
    //#region Cell Format
    /**
     * @private
     */
    initTableCellProperties(element, localValue) {
        let sizeDiv = createElement('div', { styles: 'width: 100%;' });
        let div = createElement('div', {
            innerHTML: localValue.getConstant('Size'), className: 'e-de-table-dialog-options-label',
            styles: 'width: 100%;padding-top: 20px;padding-bottom: 10px;',
        });
        let parentdiv = createElement('div', { styles: 'display: inline;width: 100%;' });
        let childdiv1 = createElement('div', {
            styles: 'display: inline;float: left;',
            className: 'e-de-table-cell-header-div'
        });
        let preferredCellWidthCheckBox = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: element.id + '_Prefer_Width_CheckBox_cell'
        });
        let childdiv2 = createElement('div', {
            styles: 'display: inline-block;',
            className: 'e-de-cell-width-top'
        });
        this.preferredCellWidth = createElement('input', {
            id: element.id + 'tablecell_Width_textBox', attrs: { 'type': 'text' }
        });
        let child2 = createElement('div', {
            styles: 'float: right;display: inline;width: auto;margin-top: 5px;'
        });
        let child3 = createElement('div', {
            styles: 'display: inline;',
            className: 'e-de-table-ppty-dlg-cell-tab-measure-label'
        });
        let child4 = createElement('div', {
            styles: 'display: inline;float: right;', className: 'e-de-table-cell-subheader-div'
        });
        let controlDiv = createElement('div');
        let cellWidthType = createElement('select', {
            innerHTML: '<option>' + localValue.getConstant('Points') + '</option><option>' +
                localValue.getConstant('Percent') + '</option>', 'id': element.id + '_measure_type_cell'
        });
        let labeltext = createElement('label', {
            innerHTML: localValue.getConstant('Measure in'),
            styles: 'font-size: 11px;font-weight: normal;'
        });
        sizeDiv.appendChild(div);
        element.appendChild(sizeDiv);
        childdiv1.appendChild(preferredCellWidthCheckBox);
        parentdiv.appendChild(childdiv1);
        childdiv2.appendChild(this.preferredCellWidth);
        parentdiv.appendChild(childdiv2);
        controlDiv.appendChild(cellWidthType);
        child3.appendChild(labeltext);
        child4.appendChild(controlDiv);
        child2.appendChild(child3);
        child2.appendChild(child4);
        parentdiv.appendChild(child2);
        element.appendChild(parentdiv);
        let alignmentDiv = createElement('div', {
            innerHTML: localValue.getConstant('Vertical alignment'),
            styles: 'width: 100%;margin: 0px;',
            className: 'e-de-table-dialog-options-label'
        });
        let classDivName = element.id + 'e-de-table-cell-alignment';
        let divAlignment = createElement('div', {
            styles: 'width: 100%;height: 100px;'
        });
        let divStyle = 'width:54px;height:54px;margin:2px;border-style:solid;border-width:1px';
        let topAlignDiv = createElement('div', { className: 'e-de-table-dia-align-div' });
        this.cellTopAlign = createElement('div', {
            styles: divStyle, id: element.id + '_cell_top-alignment',
            className: 'e-icons e-de-tablecell-alignment  e-de-tablecell-top-alignment ' + classDivName
        });
        topAlignDiv.appendChild(this.cellTopAlign);
        let centerAlignDiv = createElement('div', { className: 'e-de-table-dia-align-div' });
        this.cellCenterAlign = createElement('div', {
            styles: divStyle, id: element.id + '_cell_center-alignment',
            className: 'e-icons e-de-tablecell-alignment  e-de-tablecell-center-alignment ' + classDivName
        });
        centerAlignDiv.appendChild(this.cellCenterAlign);
        let bottomAlignDiv = createElement('div', { className: 'e-de-table-dia-align-div' });
        this.cellBottomAlign = createElement('div', {
            styles: divStyle, id: element.id + '_cell_bottom-alignment',
            className: 'e-icons e-de-tablecell-alignment e-de-tablecell-bottom-alignment  ' + classDivName
        });
        bottomAlignDiv.appendChild(this.cellBottomAlign);
        let topLabel = createElement('label', {
            innerHTML: localValue.getConstant('Top'), className: 'e-de-table-dia-align-label'
        });
        let centerLabel = createElement('label', {
            innerHTML: localValue.getConstant('Center'), className: 'e-de-table-dia-align-label'
        });
        let bottomLabel = createElement('label', {
            innerHTML: localValue.getConstant('Bottom'), className: 'e-de-table-dia-align-label'
        });
        this.cellOptionButton = createElement('button', {
            innerHTML: localValue.getConstant('Options'), id: element.id + '_table_cellmargin',
            className: 'e-de-tbl-dlg-op-btn e-control e-btn e-flat e-de-cell-options',
        });
        divAlignment.appendChild(topAlignDiv);
        divAlignment.appendChild(centerAlignDiv);
        divAlignment.appendChild(bottomAlignDiv);
        topAlignDiv.appendChild(topLabel);
        centerAlignDiv.appendChild(centerLabel);
        bottomAlignDiv.appendChild(bottomLabel);
        element.appendChild(alignmentDiv);
        element.appendChild(divAlignment);
        element.appendChild(this.cellOptionButton);
        this.cellOptionButton.addEventListener('click', this.showCellOptionsDialog);
        this.cellWidthBox = new NumericTextBox({
            value: 0, decimals: 2, min: 0, max: 1584, width: 120, enablePersistence: false
        });
        this.cellWidthBox.appendTo(this.preferredCellWidth);
        this.preferredCellWidthCheckBox = new CheckBox({ label: localValue.getConstant('Preferred Width') });
        this.preferredCellWidthCheckBox.appendTo(preferredCellWidthCheckBox);
        this.cellWidthType = new DropDownList({ width: '120px' });
        this.cellWidthType.appendTo(cellWidthType);
    }
    setTableCellProperties() {
        let cellFormat = this.owner.selection.cellFormat;
        //instance of table cell Values
        this.hasCellWidth = cellFormat.preferredWidth > 0;
        let preferredWidth = cellFormat.preferredWidth;
        if (isNullOrUndefined(cellFormat.preferredWidth)) {
            this.preferredCellWidthCheckBox.indeterminate = true;
            preferredWidth = this.owner.selection.start.paragraph.associatedCell.cellFormat.preferredWidth;
        }
        else {
            this.preferredCellWidthCheckBox.checked = this.hasCellWidth;
        }
        this.cellWidthBox.enabled = this.hasCellWidth;
        this.cellWidthType.enabled = this.hasCellWidth;
        if (cellFormat.preferredWidthType === 'Auto' || cellFormat.preferredWidthType === 'Point') {
            this.cellWidthType.index = 0;
        }
        else {
            this.cellWidthType.index = 1;
        }
        this.formatNumericTextBox(this.cellWidthBox, cellFormat.preferredWidthType, preferredWidth);
        classList(this.cellTopAlign, ['e-de-tablecell-alignment'], ['e-de-table-alignment-active']);
        classList(this.cellCenterAlign, ['e-de-tablecell-alignment'], ['e-de-table-alignment-active']);
        classList(this.cellBottomAlign, ['e-de-tablecell-alignment'], ['e-de-table-alignment-active']);
        if (cellFormat.verticalAlignment === 'Top') {
            this.cellTopAlign.classList.add('e-de-table-alignment-active');
        }
        else if (cellFormat.verticalAlignment === 'Center') {
            this.cellCenterAlign.classList.add('e-de-table-alignment-active');
        }
        else if (cellFormat.verticalAlignment === 'Bottom') {
            this.cellBottomAlign.classList.add('e-de-table-alignment-active');
        }
    }
    /**
     * @private
     */
    updateClassForCellAlignment(element) {
        let cellAlignments = element.getElementsByClassName(element.id + 'e-de-table-cell-alignment');
        for (let j = 0; j < cellAlignments.length; j++) {
            let cellAlignment = cellAlignments[j];
            if (cellAlignment.classList.contains('e-de-table-alignment-active')) {
                classList(cellAlignment, ['e-de-tablecell-alignment'], ['e-de-table-alignment-active']);
            }
        }
    }
    /**
     * @private
     */
    formatNumericTextBox(textBox, format, value) {
        if (format === 'Auto' || format === 'Point') {
            textBox.format = 'n2';
        }
        else {
            textBox.format = '#\'\%\'';
        }
        textBox.step = 1;
        textBox.decimals = 2;
        textBox.value = value;
    }
    /**
     * @private
     */
    getCellAlignment() {
        let id = this.cellTab.id;
        let groupButtons = this.cellTab.getElementsByClassName(id + 'e-de-table-cell-alignment');
        for (let j = 0; j < groupButtons.length; j++) {
            let groupButton = groupButtons[j];
            if (groupButton.classList.contains('e-de-table-alignment-active')) {
                if (j === 0) {
                    return 'Top';
                }
                else if (j === 1) {
                    return 'Center';
                }
                else {
                    return 'Bottom';
                }
            }
        }
        return this.owner.selection.cellFormat.verticalAlignment;
    }
    /**
     * @private
     */
    onCellWidthChange() {
        this.cellFormat.preferredWidth = this.cellWidthBox.value;
    }
    /**
     * @private
     */
    onCellWidthTypeChange() {
        let value;
        let table = this.owner.selection.start.paragraph.associatedCell.ownerTable;
        let containerWidth = table.getOwnerWidth(true);
        let tableWidth = table.getTableClientWidth(containerWidth);
        if (this.cellWidthType.text === 'Percent' && this.owner.selection.cellFormat.preferredWidthType !== 'Percent') {
            value = this.cellWidthBox.value / tableWidth * 100;
            this.formatNumericTextBox(this.cellWidthBox, 'Percent', value);
        }
        else if (this.cellWidthType.text === 'Points' && this.owner.selection.cellFormat.preferredWidthType !== 'Point') {
            value = tableWidth / 100 * this.cellWidthBox.value;
            this.formatNumericTextBox(this.cellWidthBox, 'Point', value);
        }
        else {
            if (this.cellWidthBox.format === '#\'\%\'') {
                if (this.cellWidthType.text === 'Points') {
                    value = tableWidth / 100 * this.cellWidthBox.value;
                }
                else {
                    value = this.cellWidthBox.value;
                }
            }
            else {
                if (this.cellWidthType.text === 'Percent') {
                    value = this.cellWidthBox.value / tableWidth * 100;
                }
                else {
                    value = this.cellWidthBox.value;
                }
            }
            // tslint:disable-next-line:max-line-length
            this.formatNumericTextBox(this.cellWidthBox, (this.cellWidthType.text === 'Points') ? 'Point' : this.cellWidthType.text, value);
        }
        this.cellFormat.preferredWidthType = (this.cellWidthType.text === 'Points') ? 'Point' : this.cellWidthType.text;
    }
    /**
     * @private
     */
    destroy() {
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (let s = 0; s < this.target.childNodes.length; s++) {
                this.target.removeChild(this.target.childNodes[s]);
                s--;
            }
            this.target = undefined;
        }
        this.dialog = undefined;
        this.target = undefined;
        this.cellAlignment = undefined;
        this.tableAlignment = undefined;
        this.owner = undefined;
        this.preferCheckBox = undefined;
        this.tableWidthType = undefined;
        this.preferredWidth = undefined;
        this.rowHeightType = undefined;
        this.rowHeightCheckBox = undefined;
        this.rowHeight = undefined;
        this.cellWidthType = undefined;
        this.preferredCellWidthCheckBox = undefined;
        this.preferredCellWidth = undefined;
        this.tableTab = undefined;
        this.rowTab = undefined;
        this.cellTab = undefined;
        this.left = undefined;
        this.center = undefined;
        this.right = undefined;
        this.leftIndent = undefined;
        this.allowRowBreak = undefined;
        this.repeatHeader = undefined;
        this.cellTopAlign = undefined;
        this.cellCenterAlign = undefined;
        this.cellBottomAlign = undefined;
        this.tableFormat.destroy();
        this.cellFormat.destroy();
        this.tableFormat = undefined;
        this.cellFormat = undefined;
    }
}

/**
 * The Borders and Shading dialog is used to modify borders and shading options for selected table or cells.
 */
class BordersAndShadingDialog {
    /**
     * @private
     */
    constructor(viewer) {
        this.cellFormat = new WCellFormat();
        this.tableFormat = new WTableFormat();
        this.applyBordersShadingsProperties = () => {
            let tablePropertiesDialog = this.owner.owner.tablePropertiesDialogModule;
            let selectedCell = this.owner.selection.start.paragraph.associatedCell;
            //Need to bind the properties with current cell and current table formats.
            let borders = undefined;
            if (this.checkClassName(this.previewDivTopTop) || this.checkClassName(this.previewDivTopBottom)
                || this.checkClassName(this.previewDivTopCenter) || this.checkClassName(this.previewDivBottomcenter)
                || this.checkClassName(this.previewDivBottomLeft) || this.checkClassName(this.previewDivBottomRight)
                || this.checkClassName(this.previewDivDiagonalRight) || this.checkClassName(this.previewDivLeftDiagonal)) {
                borders = new WBorders();
                if (this.checkClassName(this.previewDivTopTop)) {
                    borders.top = this.getBorder();
                }
                if (this.checkClassName(this.previewDivTopBottom)) {
                    borders.bottom = this.getBorder();
                }
                if (this.checkClassName(this.previewDivBottomLeft)) {
                    borders.left = this.getBorder();
                }
                if (this.checkClassName(this.previewDivBottomRight)) {
                    borders.right = this.getBorder();
                }
                if (this.checkClassName(this.previewDivTopCenter)) {
                    borders.horizontal = this.getBorder();
                }
                if (this.checkClassName(this.previewDivBottomcenter)) {
                    borders.vertical = this.getBorder();
                }
                if (this.checkClassName(this.previewDivLeftDiagonal)) {
                    borders.diagonalDown = this.getBorder();
                }
                if (this.checkClassName(this.previewDivDiagonalRight)) {
                    borders.diagonalUp = this.getBorder();
                }
            }
            let shading = new WShading();
            let editorModule = this.owner.owner.editorModule;
            shading.backgroundColor = this.shadingColorPicker.value;
            if (this.ulelementShading.index === 0) {
                this.applyTo = 0;
                if (tablePropertiesDialog) {
                    tablePropertiesDialog.isCellBordersAndShadingUpdated = true;
                }
                this.cellFormat.borders = new WBorders();
                if (!isNullOrUndefined(borders)) {
                    editorModule.applyBordersInternal(this.cellFormat.borders, borders);
                }
                else if (this.noneDiv.classList.contains('e-de-table-border-inside-setting-click')) {
                    editorModule.applyBordersInternal(this.cellFormat.borders, new WBorders());
                }
                // Once option has been added for texture and foreground, need to handle this similar to Shading Fill.
                if (!isNullOrUndefined(selectedCell.cellFormat.shading)) {
                    shading.foregroundColor = selectedCell.cellFormat.shading.foregroundColor;
                    shading.textureStyle = selectedCell.cellFormat.shading.textureStyle;
                }
                this.cellFormat.shading = new WShading();
                editorModule.applyShading(this.cellFormat.shading, shading);
            }
            else {
                if (tablePropertiesDialog) {
                    tablePropertiesDialog.isTableBordersAndShadingUpdated = true;
                }
                this.applyTo = 1;
                let currentTableFormat = this.owner.owner.selection.tableFormat.table.tableFormat;
                this.tableFormat.copyFormat(currentTableFormat);
                this.tableFormat.borders = new WBorders();
                if (!isNullOrUndefined(borders)) {
                    editorModule.applyBordersInternal(this.tableFormat.borders, borders);
                }
                else if (this.noneDiv.classList.contains('e-de-table-border-inside-setting-click')) {
                    editorModule.applyBordersInternal(this.tableFormat.borders, new WBorders());
                }
                // Once option has been added for texture and foreground, need to handle this similar to Shading Fill.
                if (!isNullOrUndefined(currentTableFormat.shading)) {
                    shading.foregroundColor = currentTableFormat.shading.foregroundColor;
                    shading.textureStyle = currentTableFormat.shading.textureStyle;
                }
                this.tableFormat.shading = new WShading();
                editorModule.applyShading(this.tableFormat.shading, shading);
            }
            this.applyFormat();
            this.closeDialog();
        };
        /**
         * @private
         */
        this.closeDialog = () => {
            this.owner.dialog.hide();
            this.closeBordersShadingsDialog();
        };
        this.closeBordersShadingsDialog = () => {
            this.owner.dialog2.element.style.pointerEvents = '';
            this.owner.updateFocus();
        };
        this.handleSettingCheckBoxAction = (event) => {
            let targetId = event.target.id;
            let tableBorderDialogId = this.target.id;
            if (targetId === tableBorderDialogId + '_None_Div' || targetId === tableBorderDialogId + '_None_Div_Container'
                || targetId === tableBorderDialogId + '_None_Div_Transparent') {
                this.updateClassForSettingDivElements();
                this.noneDiv.classList.add('e-de-table-border-inside-setting-click');
                this.setSettingPreviewDivElement('none');
            }
            else if (targetId === tableBorderDialogId + '_Box_Div' || targetId === tableBorderDialogId + '_Box_Div_Container'
                || targetId === tableBorderDialogId + '_Box_Div_Transparent') {
                this.updateClassForSettingDivElements();
                this.boxDiv.classList.add('e-de-table-border-inside-setting-click');
                this.setSettingPreviewDivElement('box');
            }
            else if (targetId === tableBorderDialogId + '_All_Div' || targetId === tableBorderDialogId + '_All_Div_Container'
                || targetId === tableBorderDialogId + '_All_Div_Transparent') {
                this.updateClassForSettingDivElements();
                this.allDiv.classList.add('e-de-table-border-inside-setting-click');
                this.setSettingPreviewDivElement('all');
            }
            else {
                this.updateClassForSettingDivElements();
                this.customDiv.classList.add('e-de-table-border-inside-setting-click');
                this.setSettingPreviewDivElement('customDiv');
            }
        };
        this.handlePreviewCheckBoxAction = (event) => {
            let target = event.target;
            let targetId = target.id;
            let tableBorderDialog = this.target;
            let tableBorderDialogId = this.target.id;
            let compareClass = 'e-de-table-border-inside-preview-click';
            this.customDiv.click();
            if (targetId === tableBorderDialogId + '_Preview_Div_TopTop_Container' || targetId === tableBorderDialogId + '_Preview_Div_TopTop'
                || targetId === tableBorderDialogId + '_previewDivTopTopTransParent') {
                this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, this.previewDivTopTop);
                this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div', '_Preview_Div_TopTop', 'TopTop');
            }
            else if (targetId === tableBorderDialogId + '_Preview_Div_TopCenter_Container'
                || targetId === tableBorderDialogId + '_Preview_Div_TopCenter'
                || targetId === tableBorderDialogId + '_previewDivTopCenterTransParent') {
                this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, this.previewDivTopCenter);
                // tslint:disable-next-line:max-line-length
                this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div_Horizontal', '_Preview_Div_TopCenter', 'TopCenter');
            }
            else if (targetId === tableBorderDialogId + '_Preview_Div_TopBottom_Container' || targetId === tableBorderDialogId + '_Preview_Div_TopBottom'
                || targetId === tableBorderDialogId + '_previewDivTopBottomTransParent') {
                this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, this.previewDivTopBottom);
                this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div', '_Preview_Div_TopBottom', 'TopBottom');
            }
            else if (targetId === tableBorderDialogId + '_Preview_Div_LeftDiagonal_Container'
                || targetId === tableBorderDialogId + '_Preview_Div_LeftDiagonal'
                || targetId === tableBorderDialogId + '_previewDivLeftDiagonalTransParent') {
                this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, this.previewDivLeftDiagonal);
                // tslint:disable-next-line:max-line-length
                this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div_Left_Diagonal', '_Preview_Div_LeftDiagonal', 'LeftDiagonal');
            }
            else if (targetId === tableBorderDialogId + '_Preview_Div_BottomLeft_Container' || targetId === tableBorderDialogId + '_Preview_Div_BottomLeft'
                || targetId === tableBorderDialogId + '_previewDivBottomLeftTransparent') {
                this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, this.previewDivBottomLeft);
                this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div', '_Preview_Div_BottomLeft', 'BottomLeft');
            }
            else if (targetId === tableBorderDialogId + '_Preview_Div_BottomCenter_Container'
                || targetId === tableBorderDialogId + '_Preview_Div_BottomCenter'
                || targetId === tableBorderDialogId + '_previewDivBottomcenterTransparent') {
                this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, this.previewDivBottomcenter);
                // tslint:disable-next-line:max-line-length
                this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div_Vertical', '_Preview_Div_BottomCenter', 'BottomCenter');
            }
            else if (targetId === tableBorderDialogId + '_Preview_Div_BottomRight_Container' || targetId === tableBorderDialogId + '_Preview_Div_BottomRight'
                || targetId === tableBorderDialogId + '_previewDivBottomRightTransparent') {
                this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, this.previewDivBottomRight);
                this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div', '_Preview_Div_BottomRight', 'BottomRight');
            }
            else if (targetId === tableBorderDialogId + '_Preview_Div_RightDiagonal_Container'
                || targetId === tableBorderDialogId + '_Preview_Div_RightDiagonal'
                || targetId === tableBorderDialogId + '_previewDivDiagonalRightTransparent') {
                this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, this.previewDivDiagonalRight);
                // tslint:disable-next-line:max-line-length
                this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div_Right_Diagonal', '_Preview_Div_RightDiagonal', 'RightDiagonal');
            }
        };
        this.applyTableCellPreviewBoxes = () => {
            this.customDiv.click();
            if (!isNullOrUndefined(this.ulelementShading)) {
                if (this.ulelementShading.index === 0) {
                    this.previewDivBottomcenterContainer.style.display = 'none';
                    this.previewDivTopCenterContainer.style.display = 'none';
                    this.previewVerticalDiv.style.display = 'none';
                    this.previewHorizontalDiv.style.display = 'none';
                    this.previewDivLeftDiagonal.style.display = '';
                    this.previewDivDiagonalRight.style.display = '';
                    this.previewDivBottomRightContainer.style.left = '80px';
                }
                else {
                    this.previewDivLeftDiagonal.style.display = 'none';
                    this.previewDivDiagonalRight.style.display = 'none';
                    this.previewDivBottomcenterContainer.style.display = '';
                    this.previewDivTopCenterContainer.style.display = '';
                    this.previewVerticalDiv.style.display = '';
                    this.previewHorizontalDiv.style.display = '';
                    this.previewDivBottomRightContainer.style.left = '110px';
                }
            }
        };
        this.applyPreviewTableBackgroundColor = (args) => {
            if (!isNullOrUndefined(args.currentValue)) {
                let color = args.currentValue.hex;
                this.previewDiv.style.backgroundColor = color;
            }
        };
        this.applyPreviewTableBorderColor = (args) => {
            if (!isNullOrUndefined(args.currentValue)) {
                let color = args.currentValue.hex;
                this.previewDiv.style.borderColor = color;
                this.previewRightDiagonalDiv.style.backgroundColor = color;
                this.previewLeftDiagonalDiv.style.backgroundColor = color;
                this.previewVerticalDiv.style.backgroundColor = color;
                this.previewHorizontalDiv.style.backgroundColor = color;
            }
        };
        this.owner = viewer;
    }
    getModuleName() {
        return 'BordersAndShadingDialog';
    }
    /**
     * @private
     */
    // tslint:disable-next-line:max-func-body-length
    initBordersAndShadingsDialog(localeValue) {
        let instance = this;
        this.target = createElement('div', {
            id: instance.owner.owner.containerId + '_table_border_shadings',
            className: 'e-de-table-border-shading-dlg'
        });
        this.owner.owner.element.appendChild(this.target);
        let displayText = createElement('div', {
            innerHTML: localeValue.getConstant('Borders'), styles: 'position: absolute;top: 65px;',
            id: this.target.id + '_border_label', className: 'e-de-table-border-heading'
        });
        let settingsContiner = createElement('div', {
            styles: 'display: inline-block;position: absolute;top: 105px;width: 100px;height: 235px;border-style: none;',
            id: this.target.id + '_border_settings'
        });
        let styleContainer = createElement('div', {
            // tslint:disable-next-line:max-line-length
            styles: 'display: inline-block;position: absolute;left: 125px;top: 125px;width: 150px;height: 235px;padding-left: 40px;border-style: none;padding-right: 40px;',
            id: this.target.id + '_border_style'
        });
        let previewContiner = createElement('div', {
            // tslint:disable-next-line:max-line-length
            styles: 'display: inline-block;position: absolute;left: 345px;top: 87px;width: 180px;height: 235px;padding: 0px;border-style: none;',
            id: this.target.id + '_border_preview'
        });
        let styleText = createElement('div', {
            innerHTML: localeValue.getConstant('Style'), styles: 'width: 100%;padding-bottom: 10px;',
            className: 'e-de-table-element-subheading'
        });
        let dropDownList = createElement('select', {
            id: this.target.id + '_border_style_dropDown'
        });
        dropDownList.innerHTML = '<option>' + localeValue.getConstant('None') + '</option><option>'
            + localeValue.getConstant('Single') + '</option><option>' + localeValue.getConstant('Dot') + '</option><option>'
            + localeValue.getConstant('DashSmallGap') + '</option><option>' + localeValue.getConstant('DashLargeGap') + '</option><option>'
            + localeValue.getConstant('DashDot') + '</option><option>' + localeValue.getConstant('DashDotDot') + '</option><option>'
            + localeValue.getConstant('Double') + '</option><option>' + localeValue.getConstant('Triple') + '</option><option>'
            + localeValue.getConstant('ThinThickSmallGap') + '</option><option>'
            + localeValue.getConstant('ThickThinSmallGap') + '</option><option>' + localeValue.getConstant('ThinThickThinSmallGap')
            + '</option><option>' + localeValue.getConstant('ThinThickMediumGap') + '</option><option>'
            + localeValue.getConstant('ThickThinMediumGap') + '</option><option>' + localeValue.getConstant('ThinThickThinMediumGap')
            + '</option><option>' + localeValue.getConstant('ThinThickLargeGap') + '</option><option>'
            + localeValue.getConstant('ThickThinLargeGap') + '</option><option>' + localeValue.getConstant('ThinThickThinLargeGap')
            + '</option><option>' + localeValue.getConstant('SingleWavy') + '</option><option>'
            + localeValue.getConstant('DoubleWavy') + '</option><option>' + localeValue.getConstant('DashDotStroked')
            + '</option><option>' + localeValue.getConstant('Emboss3D') + '</option><option>' + localeValue.getConstant('Engrave3D')
            + '</option><option>' + localeValue.getConstant('Outset') + '</option><option>'
            + localeValue.getConstant('Inset') + '</option><option>' + localeValue.getConstant('Thick') + '</option>';
        let widthText = createElement('div', {
            innerHTML: localeValue.getConstant('Width'), styles: 'width:100%;padding-top: 20px;padding-bottom: 10px;',
            className: 'e-de-table-element-subheading'
        });
        let widthNumeric = createElement('input', {
            id: this.target.id + '_width'
        });
        let colorText = createElement('div', {
            innerHTML: localeValue.getConstant('Color'), styles: 'padding-top: 25px;',
            className: 'e-de-table-setting-heading'
        });
        let borderColorPickerElement = createElement('input', {
            attrs: { 'type': 'color' },
            id: this.target.id + '_border_color',
            styles: 'width: 30px;position: absolute;left: 90px;',
            className: 'e-dlg-clr-pkr-top'
        });
        let settingText = createElement('div', {
            innerHTML: localeValue.getConstant('Setting'), styles: 'width: 100%;position: absolute;',
            className: 'e-de-table-setting-heading'
        });
        let noneDivContainer = createElement('div', {
            id: this.target.id + '_None_Div_Container', className: 'e-de-table-border-none'
        });
        this.noneDiv = createElement('div', {
            id: this.target.id + '_None_Div',
            className: 'e-de-table-border-inside-setting e-de-table-border-setting-genral'
        });
        let noneDivLabel = createElement('label', {
            innerHTML: localeValue.getConstant('None'), className: 'e-de-table-setting-labels-heading',
            styles: 'padding-left: 10px;top: 20px;position: absolute;',
            id: this.target.id + '_None_Div_Label'
        });
        let boxDivContainer = createElement('div', {
            id: this.target.id + '_Box_Div_Container', className: 'e-de-table-border-box'
        });
        this.boxDiv = createElement('div', {
            id: this.target.id + '_Box_Div',
            className: 'e-de-table-border-inside-setting e-de-table-border-setting-genral'
        });
        let boxDivLabel = createElement('label', {
            innerHTML: localeValue.getConstant('Box'), className: 'e-de-table-setting-labels-heading',
            styles: 'padding-left: 10px;top: 20px;position: absolute;',
            id: this.target.id + '_Box_Div_Label'
        });
        let allDivContainer = createElement('div', {
            id: this.target.id + '_All_Div_Container', className: 'e-de-table-border-all'
        });
        this.allDiv = createElement('div', {
            id: this.target.id + '_All_Div',
            className: 'e-de-table-border-inside-setting e-de-table-border-setting-genral'
        });
        let allDivLabel = createElement('label', {
            innerHTML: localeValue.getConstant('All'), className: 'e-de-table-setting-labels-heading',
            styles: 'padding-left: 10px;top: 25px;position: absolute;',
            id: this.target.id + '_All_Div_Label'
        });
        let customDivContainer = createElement('div', {
            id: this.target.id + '_Custom_Div_Container', className: 'e-de-table-border-custom'
        });
        this.customDiv = createElement('div', {
            id: this.target.id + '_Custom_Div',
            className: 'e-de-table-border-inside-setting e-de-table-border-setting-genral'
        });
        let customDivLabel = createElement('label', {
            innerHTML: localeValue.getConstant('Custom'), className: 'e-de-table-setting-labels-heading',
            styles: 'padding-left: 10px;top: 25px;position: absolute;',
            id: this.target.id + '_Custom_Div_Label'
        });
        this.noneDivTransparent = createElement('div', {
            id: this.target.id + '_None_Div_Transparent', className: 'e-icons e-de-table-border-setting e-de-table-border-none-setting'
        });
        this.boxDivTransparent = createElement('div', {
            id: this.target.id + '_Box_Div_Transparent', className: 'e-icons e-de-table-border-setting e-de-table-border-box-setting'
        });
        this.allDivTransparent = createElement('div', {
            id: this.target.id + '_All_Div_Transparent', className: 'e-icons e-de-table-border-setting e-de-table-border-all-setting'
        });
        this.customDivTransparent = createElement('div', {
            id: this.target.id + '_Custom_Div_Transparent', className: 'e-icons e-de-table-border-setting e-de-table-border-custom-setting'
        });
        let previewText = createElement('div', {
            innerHTML: localeValue.getConstant('Preview'), className: 'e-de-table-setting-heading',
            styles: 'position: absolute;top: 20px;left: 10px;'
        });
        this.previewDiv = createElement('div', {
            styles: 'width: 80px;height: 80px;position: absolute; left: 50px;top: 50px;',
            id: this.target.id + '_Preview_Div', className: 'e-de-border-dlg-preview-div'
        });
        this.previewRightDiagonalDiv = createElement('div', {
            styles: 'position: absolute;width:1px;height:113px;left: 90px;top: 34px;transform: rotate(135deg);',
            id: this.target.id + '_Preview_Div_Right_Diagonal',
            className: 'e-de-border-dlg-preview-inside-divs'
        });
        this.previewLeftDiagonalDiv = createElement('div', {
            styles: 'position: absolute;width: 1px;height: 113px;left: 90px;top: 34px;transform:rotate(45deg);',
            id: this.target.id + '_Preview_Div_Left_Diagonal',
            className: 'e-de-border-dlg-preview-inside-divs'
        });
        this.previewVerticalDiv = createElement('div', {
            styles: 'width: 1px;height: 81px;position: absolute;left: 90px;top: 50px;',
            id: this.target.id + '_Preview_Div_Vertical',
            className: 'e-de-border-dlg-preview-inside-divs'
        });
        this.previewHorizontalDiv = createElement('div', {
            styles: 'width: 81px;height: 1px;position: absolute;left: 50px;top: 90px;',
            id: this.target.id + '_Preview_Div_Horizontal',
            className: 'e-de-border-dlg-preview-inside-divs'
        });
        this.previewDivTopTopContainer = createElement('div', {
            styles: 'top: 50px;position: absolute;left: 10px;', id: this.target.id + '_Preview_Div_TopTop_Container'
        });
        this.previewDivTopTop = createElement('div', {
            id: this.target.id + '_Preview_Div_TopTop',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        this.previewDivTopCenterContainer = createElement('div', {
            styles: 'top: 80px;position: absolute;left: 10px;', id: this.target.id + '_Preview_Div_TopCenter_Container'
        });
        this.previewDivTopCenter = createElement('div', {
            id: this.target.id + '_Preview_Div_TopCenter',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        this.previewDivTopBottomContainer = createElement('div', {
            styles: 'top: 110px;position: absolute;left: 10px;', id: this.target.id + '_Preview_Div_TopBottom_Container'
        });
        this.previewDivTopBottom = createElement('div', {
            id: this.target.id + '_Preview_Div_TopBottom',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        this.previewDivLeftDiagonalContainer = createElement('div', {
            styles: 'top: 145px;position: absolute;left: 10px;', id: this.target.id + '_Preview_Div_LeftDiagonal_Container'
        });
        this.previewDivLeftDiagonal = createElement('div', {
            id: this.target.id + '_Preview_Div_LeftDiagonal',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        this.previewDivBottomLeftContainer = createElement('div', {
            styles: 'top: 145px;position: absolute;left: 50px', id: this.target.id + '_Preview_Div_BottomLeft_Container'
        });
        this.previewDivBottomLeft = createElement('div', {
            id: this.target.id + '_Preview_Div_BottomLeft',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        this.previewDivBottomcenterContainer = createElement('div', {
            styles: 'top: 145px;position: absolute;left: 80px;', id: this.target.id + '_Preview_Div_BottomCenter_Container'
        });
        this.previewDivBottomcenter = createElement('div', {
            id: this.target.id + '_Preview_Div_BottomCenter',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        this.previewDivBottomRightContainer = createElement('div', {
            styles: 'top: 145px;position: absolute;left: 110px;', id: this.target.id + '_Preview_Div_BottomRight_Container'
        });
        this.previewDivBottomRight = createElement('div', {
            id: this.target.id + '_Preview_Div_BottomRight',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        this.previewDivDiagonalRightContainer = createElement('div', {
            styles: 'top: 145px; position: absolute; left: 110px;', id: this.target.id + '_Preview_Div_RightDiagonal_Container'
        });
        this.previewDivDiagonalRight = createElement('div', {
            id: this.target.id + '_Preview_Div_RightDiagonal',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        this.previewDivTopTopTransParent = createElement('div', {
            id: this.target.id + '_previewDivTopTopTransParent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-toptop-alignment'
        });
        this.previewDivTopCenterTransParent = createElement('div', {
            id: this.target.id + '_previewDivTopCenterTransParent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-topcenter-alignment'
        });
        this.previewDivTopBottomTransParent = createElement('div', {
            id: this.target.id + '_previewDivTopBottomTransParent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-topbottom-alignment'
        });
        this.previewDivLeftDiagonalTransParent = createElement('div', {
            id: this.target.id + '_previewDivLeftDiagonalTransParent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-diagionalup-alignment'
        });
        this.previewDivBottomLeftTransparent = createElement('div', {
            id: this.target.id + '_previewDivBottomLeftTransparent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-bottomleft-alignment'
        });
        this.previewDivBottomcenterTransparent = createElement('div', {
            id: this.target.id + '_previewDivBottomcenterTransparent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-bottomcenter-alignment'
        });
        this.previewDivBottomRightTransparent = createElement('div', {
            id: this.target.id + '_previewDivBottomRightTransparent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-bottomright-alignment'
        });
        this.previewDivDiagonalRightTransparent = createElement('div', {
            id: this.target.id + '_previewDivDiagonalRightTransparent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-diagionaldown-alignment'
        });
        this.shadingContiner = createElement('div', {
            /* tslint:disable:max-line-length */
            styles: 'display:inline-block;position:absolute;left:17px;width:400px;height:100px;padding:0px;border-style: none;margin-left:10px;',
            id: this.target.id + '_shading_preview', className: 'e-de-table-shading-preview'
        });
        let shadingText = createElement('div', {
            innerHTML: localeValue.getConstant('Shading'), className: 'e-de-table-border-heading',
            styles: 'padding-top: 30px;left: 5px;'
        });
        let shadings = createElement('div', { styles: 'display:flex;' });
        let label = createElement('div', {
            innerHTML: localeValue.getConstant('Fill'), className: 'e-de-table-setting-heading e-de-table-border-fill',
            styles: 'top: 50px;left: 10px;'
        });
        let shadingColorPickerElement = createElement('input', {
            attrs: { 'type': 'color' },
            id: this.target.id + '_shading_color', styles: 'position: absolute;top: 75px;left: 40px;width: 30px;'
        });
        let shdApply = createElement('div', {
            styles: 'position:absolute;top:41px;left:150px;width:180px;'
        });
        let div = createElement('div', {
            styles: 'width:100px;padding-bottom: 10px;', innerHTML: localeValue.getConstant('Apply To'),
            className: 'e-de-table-element-subheading'
        });
        let divsion = createElement('div', { styles: 'width:100px;position:absolute;' });
        let ulelementShading = createElement('select', {
            innerHTML: '<option>' + localeValue.getConstant('Cell') + '</option>'
                + '<option>' + localeValue.getConstant('Table') + '</option>',
            id: this.target.id + '_shading'
        });
        divsion.appendChild(ulelementShading);
        this.noneDiv.appendChild(this.noneDivTransparent);
        this.boxDiv.appendChild(this.boxDivTransparent);
        this.allDiv.appendChild(this.allDivTransparent);
        this.customDiv.appendChild(this.customDivTransparent);
        noneDivContainer.appendChild(this.noneDiv);
        noneDivContainer.appendChild(noneDivLabel);
        boxDivContainer.appendChild(this.boxDiv);
        boxDivContainer.appendChild(boxDivLabel);
        allDivContainer.appendChild(this.allDiv);
        allDivContainer.appendChild(allDivLabel);
        customDivContainer.appendChild(this.customDiv);
        customDivContainer.appendChild(customDivLabel);
        settingsContiner.appendChild(settingText);
        settingsContiner.appendChild(noneDivContainer);
        settingsContiner.appendChild(boxDivContainer);
        settingsContiner.appendChild(allDivContainer);
        settingsContiner.appendChild(customDivContainer);
        this.previewDivBottomcenter.appendChild(this.previewDivBottomcenterTransparent);
        this.previewDivBottomRight.appendChild(this.previewDivBottomRightTransparent);
        this.previewDivBottomLeft.appendChild(this.previewDivBottomLeftTransparent);
        this.previewDivTopTop.appendChild(this.previewDivTopTopTransParent);
        this.previewDivTopCenter.appendChild(this.previewDivTopCenterTransParent);
        this.previewDivTopBottom.appendChild(this.previewDivTopBottomTransParent);
        this.previewDivDiagonalRight.appendChild(this.previewDivDiagonalRightTransparent);
        this.previewDivLeftDiagonal.appendChild(this.previewDivLeftDiagonalTransParent);
        this.previewDivBottomcenterContainer.appendChild(this.previewDivBottomcenter);
        this.previewDivBottomLeftContainer.appendChild(this.previewDivBottomLeft);
        this.previewDivBottomRightContainer.appendChild(this.previewDivBottomRight);
        this.previewDivDiagonalRightContainer.appendChild(this.previewDivDiagonalRight);
        this.previewDivLeftDiagonalContainer.appendChild(this.previewDivLeftDiagonal);
        this.previewDivTopBottomContainer.appendChild(this.previewDivTopBottom);
        this.previewDivTopCenterContainer.appendChild(this.previewDivTopCenter);
        this.previewDivTopTopContainer.appendChild(this.previewDivTopTop);
        previewContiner.appendChild(previewText);
        previewContiner.appendChild(this.previewDiv);
        previewContiner.appendChild(this.previewRightDiagonalDiv);
        previewContiner.appendChild(this.previewHorizontalDiv);
        previewContiner.appendChild(this.previewLeftDiagonalDiv);
        previewContiner.appendChild(this.previewVerticalDiv);
        previewContiner.appendChild(this.previewDivBottomcenterContainer);
        previewContiner.appendChild(this.previewDivBottomLeftContainer);
        previewContiner.appendChild(this.previewDivBottomRightContainer);
        previewContiner.appendChild(this.previewDivDiagonalRightContainer);
        previewContiner.appendChild(this.previewDivLeftDiagonalContainer);
        previewContiner.appendChild(this.previewDivTopBottomContainer);
        previewContiner.appendChild(this.previewDivTopCenterContainer);
        previewContiner.appendChild(this.previewDivTopTopContainer);
        shdApply.appendChild(div);
        shdApply.appendChild(divsion);
        shadings.appendChild(label);
        shadings.appendChild(shadingColorPickerElement);
        shadings.appendChild(shdApply);
        this.shadingContiner.appendChild(shadingText);
        this.shadingContiner.appendChild(shadings);
        styleContainer.appendChild(styleText);
        styleContainer.appendChild(dropDownList);
        styleContainer.appendChild(widthText);
        styleContainer.appendChild(widthNumeric);
        styleContainer.appendChild(colorText);
        styleContainer.appendChild(borderColorPickerElement);
        this.target.appendChild(displayText);
        this.target.appendChild(settingsContiner);
        this.target.appendChild(styleContainer);
        this.target.appendChild(previewContiner);
        this.target.appendChild(this.shadingContiner);
        // Handling Setting Container
        noneDivContainer.addEventListener('click', this.handleSettingCheckBoxAction);
        boxDivContainer.addEventListener('click', this.handleSettingCheckBoxAction);
        allDivContainer.addEventListener('click', this.handleSettingCheckBoxAction);
        customDivContainer.addEventListener('click', this.handleSettingCheckBoxAction);
        // Handling Preview Div Container
        this.previewDivBottomcenterContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        this.previewDivBottomLeftContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        this.previewDivBottomRightContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        this.previewDivTopTopContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        this.previewDivTopBottomContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        this.previewDivTopCenterContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        this.previewDivDiagonalRightContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        this.previewDivLeftDiagonalContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        // handling dropdown change
        this.borderWidth = new NumericTextBox({
            value: 0, min: 0, max: 6, decimals: 2,
            width: 150, enablePersistence: false
        });
        this.borderWidth.appendTo(widthNumeric);
        this.borderStyle = new DropDownList({
            width: '150px', popupHeight: '150px', index: 1
        });
        this.borderStyle.appendTo(dropDownList);
        this.ulelementShading = new DropDownList({
            width: '150px', change: this.applyTableCellPreviewBoxes, index: 1
        });
        this.ulelementShading.appendTo(ulelementShading);
        this.borderColorPicker = new ColorPicker({
            value: '#000000', change: this.applyPreviewTableBorderColor
        });
        this.borderColorPicker.appendTo(borderColorPickerElement);
        this.shadingColorPicker = new ColorPicker({
            value: '#000000', change: this.applyPreviewTableBackgroundColor
        });
        this.shadingColorPicker.appendTo(shadingColorPickerElement);
    }
    applyFormat() {
        let selection = this.owner.selection;
        let editorModule = this.owner.owner.editorModule;
        editorModule.initComplexHistory('BordersAndShading');
        editorModule.isBordersAndShadingDialog = true;
        if (this.applyTo === 0) {
            editorModule.onCellFormat(this.cellFormat);
        }
        else {
            editorModule.onTableFormat(this.tableFormat);
        }
        if (!isNullOrUndefined(this.owner.owner.editorHistory.currentHistoryInfo)) {
            this.owner.owner.editorHistory.updateComplexHistory();
        }
        editorModule.isBordersAndShadingDialog = false;
    }
    getBorder() {
        let border = new WBorder();
        border.color = this.borderColorPicker.value;
        border.lineStyle = this.borderStyle.text;
        border.lineWidth = this.borderWidth.value;
        return border;
    }
    checkClassName(element) {
        return element.classList.contains('e-de-table-border-inside-preview-click');
    }
    /**
     * @private
     */
    show() {
        let localeValue = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localeValue.setLocale(this.owner.owner.locale);
        setCulture(this.owner.owner.locale);
        if (!this.target) {
            this.initBordersAndShadingsDialog(localeValue);
        }
        this.loadBordersShadingsPropertiesDialog();
        this.owner.dialog.content = this.target;
        this.owner.dialog.header = localeValue.getConstant('Borders and Shading');
        this.owner.dialog.beforeOpen = this.owner.updateFocus;
        this.owner.dialog.close = this.closeBordersShadingsDialog;
        this.owner.dialog.position = { X: 'center', Y: 'top' };
        this.owner.dialog.width = 'auto';
        this.owner.dialog.height = 'auto';
        this.owner.dialog.buttons = [{
                click: this.applyBordersShadingsProperties,
                buttonModel: { content: localeValue.getConstant('Ok'), cssClass: 'e-flat e-table-border-shading-okay', isPrimary: true }
            },
            {
                click: this.closeDialog,
                buttonModel: { content: localeValue.getConstant('Cancel'), cssClass: 'e-flat e-table-border-shading-cancel' }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    }
    updateClassForSettingDivElements() {
        let settingDivs = this.target.getElementsByClassName('e-de-table-border-inside-setting');
        for (let j = 0; j < settingDivs.length; j++) {
            if (settingDivs[j].className.indexOf('e-de-table-border-inside-setting-click') !== -1) {
                let tempClassName = settingDivs[j].className;
                tempClassName = tempClassName.replace('e-de-table-border-inside-setting-click', '');
                settingDivs[j].className = tempClassName;
            }
        }
    }
    setSettingPreviewDivElement(position) {
        switch (position) {
            case 'none':
                this.previewDivTopTop.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivTopCenter.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivTopBottom.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivLeftDiagonal.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivDiagonalRight.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivBottomRight.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivBottomLeft.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivBottomcenter.classList.remove('e-de-table-border-inside-preview-click');
                this.isShowHidePreviewTableElements('none');
                break;
            case 'box':
                this.previewDivTopCenter.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivLeftDiagonal.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivDiagonalRight.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivBottomcenter.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivTopTop.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivTopBottom.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivBottomRight.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivBottomLeft.classList.add('e-de-table-border-inside-preview-click');
                this.isShowHidePreviewTableElements('box');
                break;
            case 'all':
                this.previewDivLeftDiagonal.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivDiagonalRight.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivBottomcenter.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivTopTop.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivTopBottom.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivBottomRight.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivBottomLeft.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivTopCenter.classList.add('e-de-table-border-inside-preview-click');
                this.isShowHidePreviewTableElements('all');
                break;
        }
    }
    isShowHidePreviewTableElements(settingDiv) {
        switch (settingDiv) {
            case 'none':
                this.previewDiv.style.border = 'none';
                this.previewRightDiagonalDiv.style.display = 'none';
                this.previewLeftDiagonalDiv.style.display = 'none';
                this.previewHorizontalDiv.style.display = 'none';
                this.previewVerticalDiv.style.display = 'none';
                break;
            case 'box':
                this.previewDiv.style.border = '1px solid rgba(0, 0, 0, .54)';
                this.previewRightDiagonalDiv.style.display = 'none';
                this.previewLeftDiagonalDiv.style.display = 'none';
                this.previewHorizontalDiv.style.display = 'none';
                this.previewVerticalDiv.style.display = 'none';
                break;
            case 'all':
                this.previewDiv.style.border = '1px solid rgba(0, 0, 0, .54)';
                this.previewRightDiagonalDiv.style.display = 'none';
                this.previewLeftDiagonalDiv.style.display = 'none';
                this.previewHorizontalDiv.style.display = 'block';
                this.previewVerticalDiv.style.display = 'block';
                break;
        }
    }
    handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, element) {
        if (element.classList.contains(compareClass)) {
            element.classList.remove(compareClass);
        }
        else {
            element.classList.add(compareClass);
        }
    }
    // tslint:disable-next-line:max-line-length
    showHidePreviewDivElements(tableBorderDialogId, compareClass, elementClass, compareElementClass, position) {
        let setElement = document.getElementById(tableBorderDialogId + elementClass);
        let compareElement = document.getElementById(tableBorderDialogId + compareElementClass);
        if (position === 'TopTop') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'border-top');
        }
        else if (position === 'TopCenter') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'display');
        }
        else if (position === 'TopBottom') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'border-bottom');
        }
        else if (position === 'LeftDiagonal') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'display');
        }
        else if (position === 'BottomLeft') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'border-left');
        }
        else if (position === 'BottomCenter') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'display');
        }
        else if (position === 'BottomRight') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'border-right');
        }
        else if (position === 'RightDiagonal') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'display');
        }
    }
    setPropertyPreviewDivElement(ele, compareElement, compareClass, property) {
        if (compareElement.classList.contains(compareClass) && property.split('-')[0] === 'border') {
            /* tslint:disable:no-any */
            ele.style[property] = '1px solid rgba(0, 0, 0, .54)';
        }
        else if (compareElement.classList.contains(compareClass) && property === 'display') {
            ele.style[property] = 'block';
        }
        else {
            ele.style[property] = 'none';
            /* tslint:enable:no-any */
        }
    }
    loadBordersShadingsPropertiesDialog() {
        let tableFormat = this.owner.selection.tableFormat.table.tableFormat;
        let lineStyle;
        let borderColor;
        let fillColor;
        let borderWidth;
        if (!isNullOrUndefined(tableFormat) && !isNullOrUndefined(tableFormat.borders)) {
            this.cloneBorders(tableFormat.borders);
            if (isNullOrUndefined(tableFormat.borders) || isNullOrUndefined(tableFormat.borders.top)) {
                lineStyle = 1;
                borderColor = '#000000';
                borderWidth = 0;
                fillColor = '#000000';
            }
            else {
                lineStyle = this.getLineStyle(tableFormat.borders.top.lineStyle);
                borderColor = tableFormat.borders.top.color;
                borderWidth = tableFormat.borders.top.getLineWidth();
                fillColor = tableFormat.shading.backgroundColor;
            }
        }
        this.borderColorPicker.value = borderColor;
        this.shadingColorPicker.value = fillColor;
        /* tslint:disable:no-any */
        let colorPickerEvent = {
            target: this.borderColorPicker, ctrlKey: false,
            shiftKey: false, which: 0
        };
        let fillColorEvent = {
            target: this.shadingColorPicker, ctrlKey: false,
            shiftKey: false, which: 0
        };
        /* tslint:enable:no-any */
        this.applyPreviewTableBackgroundColor(fillColorEvent);
        this.applyPreviewTableBorderColor(colorPickerEvent);
        this.ulelementShading.index = 1;
        this.previewDivLeftDiagonal.style.display = 'none';
        this.previewDivDiagonalRight.style.display = 'none';
        this.borderWidth.value = borderWidth;
        this.borderStyle.index = lineStyle;
    }
    // tslint:disable:max-func-body-length
    cloneBorders(borders) {
        let topBorder = false;
        let bottomBorder = false;
        let leftBorder = false;
        let rightBorder = false;
        let horizontalBorder = false;
        let verticalBorder = false;
        let diagonalDownBorder = false;
        let customBorder = false;
        let diagonalUpBorder = false;
        if (borders !== null) {
            if (borders.top && (borders.top.hasNoneStyle || borders.top.lineStyle !== 'None')) {
                topBorder = true;
            }
            if (borders.bottom && (borders.bottom.hasNoneStyle || borders.bottom.lineStyle !== 'None')) {
                bottomBorder = true;
            }
            if (borders.left && (borders.left.hasNoneStyle || borders.left.lineStyle !== 'None')) {
                leftBorder = true;
            }
            if (borders.right && (borders.right.hasNoneStyle || borders.right.lineStyle !== 'None')) {
                rightBorder = true;
            }
            if (borders.horizontal && (borders.horizontal.hasNoneStyle || borders.horizontal.lineStyle !== 'None')) {
                horizontalBorder = true;
            }
            if (borders.vertical && (borders.vertical.hasNoneStyle || borders.vertical.lineStyle !== 'None')) {
                verticalBorder = true;
            }
            if (borders.diagonalDown && (borders.diagonalDown.hasNoneStyle || borders.diagonalDown.lineStyle !== 'None')) {
                diagonalDownBorder = true;
            }
            if (borders.diagonalUp && (borders.diagonalUp.hasNoneStyle || borders.diagonalUp.lineStyle !== 'None')) {
                diagonalUpBorder = true;
            }
            if (!(!topBorder || !bottomBorder || !leftBorder || !rightBorder)) {
                if (!(!topBorder || !bottomBorder || !leftBorder || !rightBorder || !horizontalBorder
                    || !verticalBorder || diagonalUpBorder || diagonalDownBorder)) {
                    if ((topBorder && bottomBorder && leftBorder && rightBorder && horizontalBorder && verticalBorder
                        && !diagonalUpBorder && !diagonalDownBorder)) {
                        if (borders.top.hasNoneStyle && borders.bottom.hasNoneStyle && borders.left.hasNoneStyle
                            && borders.right.hasNoneStyle && borders.horizontal.hasNoneStyle && borders.vertical.hasNoneStyle) {
                            this.setSettingPreviewDivElement('none');
                            this.customDiv.classList.remove('e-de-table-border-inside-setting-click');
                            this.noneDiv.classList.add('e-de-table-border-inside-setting-click');
                            this.boxDiv.classList.remove('e-de-table-border-inside-setting-click');
                            this.allDiv.classList.remove('e-de-table-border-inside-setting-click');
                        }
                        else {
                            this.setSettingPreviewDivElement('all');
                            this.allDiv.classList.add('e-de-table-border-inside-setting-click');
                            this.customDiv.classList.remove('e-de-table-border-inside-setting-click');
                            this.noneDiv.classList.remove('e-de-table-border-inside-setting-click');
                            this.boxDiv.classList.remove('e-de-table-border-inside-setting-click');
                        }
                    }
                }
                else if ((leftBorder && bottomBorder && topBorder && rightBorder && !horizontalBorder && !verticalBorder)) {
                    if (borders.top.hasNoneStyle && borders.bottom.hasNoneStyle && borders.left.hasNoneStyle
                        && borders.right.hasNoneStyle && borders.horizontal.hasNoneStyle && borders.vertical.hasNoneStyle) {
                        this.setSettingPreviewDivElement('none');
                        this.boxDiv.classList.remove('e-de-table-border-inside-setting-click');
                        this.allDiv.classList.remove('e-de-table-border-inside-setting-click');
                        this.customDiv.classList.remove('e-de-table-border-inside-setting-click');
                        this.noneDiv.classList.add('e-de-table-border-inside-setting-click');
                    }
                    else {
                        this.setSettingPreviewDivElement('box');
                        this.customDiv.classList.remove('e-de-table-border-inside-setting-click');
                        this.noneDiv.classList.remove('e-de-table-border-inside-setting-click');
                        this.boxDiv.classList.add('e-de-table-border-inside-setting-click');
                        this.allDiv.classList.remove('e-de-table-border-inside-setting-click');
                    }
                }
                else {
                    customBorder = true;
                }
            }
            else {
                customBorder = true;
            }
            this.previewDivLeftDiagonal.classList.remove('e-de-table-border-inside-preview-click');
            this.previewDivDiagonalRight.classList.remove('e-de-table-border-inside-preview-click');
            if (customBorder) {
                this.customDiv.classList.add('e-de-table-border-inside-setting-click');
                this.noneDiv.classList.remove('e-de-table-border-inside-setting-click');
                this.boxDiv.classList.remove('e-de-table-border-inside-setting-click');
                this.allDiv.classList.remove('e-de-table-border-inside-setting-click');
                if (topBorder) {
                    this.previewDivTopTop.classList.add('e-de-table-border-inside-preview-click');
                }
                else {
                    this.previewDivTopTop.classList.remove('e-de-table-border-inside-preview-click');
                }
                if (bottomBorder) {
                    this.previewDivTopBottom.classList.add('e-de-table-border-inside-preview-click');
                }
                else {
                    this.previewDivTopBottom.classList.remove('e-de-table-border-inside-preview-click');
                }
                if (leftBorder) {
                    this.previewDivBottomLeft.classList.add('e-de-table-border-inside-preview-click');
                }
                else {
                    this.previewDivBottomLeft.classList.remove('e-de-table-border-inside-preview-click');
                }
                if (rightBorder) {
                    this.previewDivBottomRight.classList.add('e-de-table-border-inside-preview-click');
                }
                else {
                    this.previewDivBottomRight.classList.remove('e-de-table-border-inside-preview-click');
                }
                if (verticalBorder) {
                    this.previewDivBottomcenter.classList.add('e-de-table-border-inside-preview-click');
                }
                else {
                    this.previewDivBottomcenter.classList.remove('e-de-table-border-inside-preview-click');
                }
                if (horizontalBorder) {
                    this.previewDivTopCenter.classList.add('e-de-table-border-inside-preview-click');
                }
                else {
                    this.previewDivTopCenter.classList.remove('e-de-table-border-inside-preview-click');
                }
            }
        }
    }
    getLineStyle(lineStyle) {
        switch (lineStyle) {
            case 'Single': return 1;
            case 'Dot': return 2;
            case 'DashSmallGap': return 3;
            case 'DashLargeGap': return 4;
            case 'DashDot': return 5;
            case 'DashDotDot': return 6;
            case 'Double': return 7;
            case 'Triple': return 8;
            case 'ThinThickSmallGap': return 9;
            case 'ThickThinSmallGap': return 10;
            case 'ThinThickThinSmallGap': return 11;
            case 'ThinThickMediumGap': return 12;
            case 'ThickThinMediumGap': return 13;
            case 'ThinThickThinMediumGap': return 14;
            case 'ThinThickLargeGap': return 15;
            case 'ThickThinLargeGap': return 16;
            case 'ThinThickThinLargeGap': return 17;
            case 'SingleWavy': return 18;
            case 'DoubleWavy': return 19;
            case 'DashDotStroked': return 20;
            case 'Emboss3D': return 21;
            case 'Engrave3D': return 22;
            case 'Outset': return 23;
            case 'Inset': return 24;
            case 'Thick': return 25;
        }
        return 0;
    }
    /**
     * @private
     */
    destroy() {
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (let k = 0; k < this.target.childNodes.length; k++) {
                this.target.removeChild(this.target.childNodes[k]);
                k--;
            }
            this.target = undefined;
        }
        if (this.cellFormat) {
            this.cellFormat.destroy();
            this.cellFormat = undefined;
        }
        if (this.tableFormat) {
            this.tableFormat.destroy();
            this.tableFormat = undefined;
        }
        this.dialog = undefined;
        this.target = undefined;
        if (!isNullOrUndefined(this.borderStyle)) {
            this.borderStyle.destroy();
        }
        this.borderStyle = undefined;
        if (!isNullOrUndefined(this.borderColorPicker)) {
            this.borderColorPicker.destroy();
        }
        this.borderColorPicker = undefined;
        if (!isNullOrUndefined(this.shadingColorPicker)) {
            this.shadingColorPicker.destroy();
        }
        this.shadingColorPicker = undefined;
        if (!isNullOrUndefined(this.ulelementShading)) {
            this.ulelementShading.destroy();
        }
        this.ulelementShading = undefined;
        this.noneDivTransparent = undefined;
        this.boxDivTransparent = undefined;
        this.allDivTransparent = undefined;
        this.customDivTransparent = undefined;
        this.previewDiv = undefined;
        this.previewRightDiagonalDiv = undefined;
        this.previewLeftDiagonalDiv = undefined;
        this.previewVerticalDiv = undefined;
        this.previewHorizontalDiv = undefined;
        this.previewDivTopTopContainer = undefined;
        this.previewDivTopTop = undefined;
        this.previewDivTopCenterContainer = undefined;
        this.previewDivTopCenter = undefined;
        this.previewDivTopBottomContainer = undefined;
        this.previewDivTopBottom = undefined;
        this.previewDivLeftDiagonalContainer = undefined;
        this.previewDivLeftDiagonal = undefined;
        this.previewDivBottomLeftContainer = undefined;
        this.previewDivBottomLeft = undefined;
        this.previewDivBottomcenterContainer = undefined;
        this.previewDivBottomcenter = undefined;
        this.previewDivBottomRightContainer = undefined;
        this.previewDivBottomRight = undefined;
        this.previewDivDiagonalRightContainer = undefined;
        this.previewDivDiagonalRight = undefined;
        this.previewDivTopTopTransParent = undefined;
        this.previewDivTopCenterTransParent = undefined;
        this.previewDivTopBottomTransParent = undefined;
        this.previewDivLeftDiagonalTransParent = undefined;
        this.previewDivBottomLeftTransparent = undefined;
        this.previewDivBottomcenterTransparent = undefined;
        this.previewDivBottomRightTransparent = undefined;
        this.previewDivDiagonalRightTransparent = undefined;
        this.shadingContiner = undefined;
        this.noneDiv = undefined;
        this.customDiv = undefined;
        this.allDiv = undefined;
        this.boxDiv = undefined;
    }
}

/**
 * The Table options dialog is used to modify default cell margins and cell spacing of selected table.
 */
class TableOptionsDialog {
    /**
     * @private
     */
    constructor(viewer) {
        /**
         * @private
         */
        this.applyTableCellProperties = () => {
            let tableFormat = this.owner.selection.tableFormat;
            if (!isNullOrUndefined(this.bottomMarginBox.value || this.leftMarginBox.value
                || this.rightMarginBox.value || this.topMarginBox.value || this.cellSpaceTextBox.value)
                && (tableFormat.bottomMargin !== this.bottomMarginBox.value
                    || tableFormat.leftMargin !== this.leftMarginBox.value
                    || tableFormat.rightMargin !== this.rightMarginBox.value
                    || tableFormat.topMargin !== this.topMarginBox.value
                    || tableFormat.cellSpacing !== this.cellSpaceTextBox.value)) {
                this.owner.owner.tablePropertiesDialogModule.isTableOptionsUpdated = true;
                this.applyTableOptions(this.tableFormat);
                this.owner.owner.tablePropertiesDialogModule.applyTableSubProperties();
            }
            this.closeCellMarginsDialog();
        };
        /**
         * @private
         */
        this.closeCellMarginsDialog = () => {
            this.owner.dialog.hide();
            this.owner.dialog.element.style.pointerEvents = '';
            this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.changeAllowSpaceCheckBox = () => {
            if (this.allowSpaceCheckBox.checked) {
                this.cellSpaceTextBox.enabled = true;
            }
            else {
                this.cellSpaceTextBox.enabled = false;
            }
        };
        /**
         * @private
         */
        this.removeEvents = () => {
            this.owner.dialog2.element.style.pointerEvents = '';
            this.owner.updateFocus();
        };
        this.owner = viewer;
    }
    /**
     * @private
     */
    get tableFormat() {
        if (isNullOrUndefined(this.tableFormatIn)) {
            return this.tableFormatIn = new WTableFormat();
        }
        return this.tableFormatIn;
    }
    /**
     * @private
     */
    getModuleName() {
        return 'TableOptionsDialog';
    }
    /**
     * @private
     */
    initTableOptionsDialog(localValue) {
        let instance = this.owner;
        this.target = createElement('div', {
            id: this.owner.owner.containerId + '_insertCellMarginsDialog', className: 'e-de-table-options-dlg'
        });
        this.owner.owner.element.appendChild(this.target);
        let innerDiv = createElement('div', { styles: 'width: 475px;position: relative;height: 180px;' });
        let innerDivLabel = createElement('Label', {
            id: this.target.id + '_innerDivLabel', className: 'e-de-cell-dia-options-label',
            innerHTML: localValue.getConstant('Default cell margins')
        });
        innerDiv.appendChild(innerDivLabel);
        CellOptionsDialog.getCellMarginDialogElements(this, innerDiv, localValue);
        let div = createElement('div', { styles: 'width: 475px; position: relative;' });
        let cellSpaceLabel = createElement('Label', {
            className: 'e-de-cell-dia-options-label',
            id: this.target.id + '_cellSpaceLabel'
        });
        cellSpaceLabel.innerHTML = localValue.getConstant('Default cell spacing');
        div.appendChild(cellSpaceLabel);
        let table2 = createElement('TABLE', {
            styles: 'height: 30px;padding-bottom: 15px;'
        });
        let tr3 = createElement('tr');
        let td5 = createElement('td');
        let allowSpaceCheckBox = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_cellcheck'
        });
        let td6 = createElement('td', { styles: 'padding-left: 15px;', });
        this.cellspacingTextBox = createElement('input', {
            attrs: { 'type': 'text' }, id: this.target.id + '_cellspacing'
        });
        td5.appendChild(allowSpaceCheckBox);
        td6.appendChild(this.cellspacingTextBox);
        tr3.appendChild(td5);
        tr3.appendChild(td6);
        table2.appendChild(tr3);
        div.appendChild(table2);
        let divBtn = document.createElement('div');
        this.target.appendChild(div);
        this.target.appendChild(divBtn);
        this.cellSpaceTextBox = new NumericTextBox({
            value: 0, min: 0, max: 264.5, width: 150,
            decimals: 2, enablePersistence: false
        });
        this.cellSpaceTextBox.appendTo(this.cellspacingTextBox);
        this.allowSpaceCheckBox = new CheckBox({
            label: localValue.getConstant('Allow spacing between cells'),
            change: this.changeAllowSpaceCheckBox,
            cssClass: 'e-de-tbl-margin-sub-header',
        });
        this.allowSpaceCheckBox.appendTo(allowSpaceCheckBox);
    }
    /**
     * @private
     */
    loadCellMarginsDialog() {
        let tableFormat = this.owner.selection.tableFormat;
        this.cellSpaceTextBox.value = tableFormat.cellSpacing;
        this.bottomMarginBox.value = tableFormat.bottomMargin;
        this.topMarginBox.value = tableFormat.topMargin;
        this.rightMarginBox.value = tableFormat.rightMargin;
        this.leftMarginBox.value = tableFormat.leftMargin;
        if (tableFormat.cellSpacing > 0) {
            this.allowSpaceCheckBox.checked = true;
            this.cellSpaceTextBox.enabled = true;
        }
        else {
            this.allowSpaceCheckBox.checked = false;
            this.cellSpaceTextBox.enabled = false;
        }
    }
    /**
     * @private
     */
    applySubTableOptions(tableFormat) {
        this.owner.owner.editorHistory.initComplexHistory(this.owner.selection, 'TableMarginsSelection');
        this.applyTableOptionsHistory(tableFormat);
        if (!isNullOrUndefined(this.owner.owner.editorHistory.currentHistoryInfo)) {
            this.owner.owner.editorHistory.updateComplexHistory();
        }
    }
    /**
     * @private
     */
    applyTableOptionsHelper(tableFormat) {
        this.applySubTableOptionsHelper(tableFormat);
    }
    /**
     * @private
     */
    applyTableOptionsHistory(tableFormat) {
        this.owner.owner.editorModule.initHistory('TableOptions');
        this.applySubTableOptionsHelper(tableFormat);
    }
    /**
     * @private
     */
    applySubTableOptionsHelper(tableFormat) {
        let ownerTable = this.owner.selection.start.currentWidget.paragraph.associatedCell.ownerTable;
        ownerTable = ownerTable.combineWidget(this.owner);
        let currentTableFormat = ownerTable.tableFormat;
        if (!isNullOrUndefined(this.owner.owner.editorHistory.currentBaseHistoryInfo)) {
            this.owner.owner.editorHistory.currentBaseHistoryInfo.addModifiedTableOptions(currentTableFormat);
        }
        currentTableFormat.cellSpacing = tableFormat.cellSpacing;
        currentTableFormat.leftMargin = tableFormat.leftMargin;
        currentTableFormat.topMargin = tableFormat.topMargin;
        currentTableFormat.rightMargin = tableFormat.rightMargin;
        currentTableFormat.bottomMargin = tableFormat.bottomMargin;
        this.owner.owner.tablePropertiesDialogModule.calculateGridValue(ownerTable);
    }
    /**
     * @private
     */
    applyTableOptions(tableFormat) {
        tableFormat.leftMargin = this.leftMarginBox.value;
        tableFormat.topMargin = this.topMarginBox.value;
        tableFormat.bottomMargin = this.bottomMarginBox.value;
        tableFormat.rightMargin = this.rightMarginBox.value;
        if (this.allowSpaceCheckBox.checked) {
            tableFormat.cellSpacing = this.cellSpaceTextBox.value;
        }
    }
    /**
     * @private
     */
    show() {
        let documentLocale = new L10n('documenteditor', this.owner.owner.defaultLocale);
        documentLocale.setLocale(this.owner.owner.locale);
        setCulture(this.owner.owner.locale);
        if (!this.target) {
            this.initTableOptionsDialog(documentLocale);
        }
        this.loadCellMarginsDialog();
        this.owner.dialog.header = documentLocale.getConstant('Table Options');
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = undefined;
        this.owner.dialog.position = { X: 'center', Y: 'top' };
        //  this.owner.dialog.cssClass = 'e-de-table-margin-size';
        this.owner.dialog.height = 'auto';
        this.owner.dialog.width = 'auto';
        this.owner.dialog.open = undefined;
        this.owner.dialog.beforeOpen = this.owner.updateFocus;
        this.owner.dialog.close = this.removeEvents;
        this.owner.dialog.buttons = [{
                click: this.applyTableCellProperties,
                buttonModel: { content: documentLocale.getConstant('Ok'), cssClass: 'e-flat e-table-cell-okay', isPrimary: true }
            },
            {
                click: this.closeCellMarginsDialog,
                buttonModel: { content: documentLocale.getConstant('Cancel'), cssClass: 'e-flat e-table-cell-cancel' }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    }
    /**
     * @private
     */
    destroy() {
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (let p = 0; p < this.target.childNodes.length; p++) {
                this.target.removeChild(this.target.childNodes[p]);
                p--;
            }
            this.target = undefined;
        }
        this.dialog = undefined;
        this.target = undefined;
        this.owner = undefined;
        this.cellspacingTextBox = undefined;
        this.allowSpaceCheckBox = undefined;
    }
}

/**
 * The Cell options dialog is used to modify margins of selected cells.
 */
class CellOptionsDialog {
    /**
     * @private
     */
    constructor(viewer) {
        /**
         * @private
         */
        this.removeEvents = () => {
            this.owner.dialog2.element.style.pointerEvents = '';
            this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.changeSameAsTable = () => {
            if (this.sameAsTableCheckBox.checked) {
                this.leftMarginBox.enabled = false;
                this.rightMarginBox.enabled = false;
                this.bottomMarginBox.enabled = false;
                this.topMarginBox.enabled = false;
            }
            else {
                this.leftMarginBox.enabled = true;
                this.rightMarginBox.enabled = true;
                this.bottomMarginBox.enabled = true;
                this.topMarginBox.enabled = true;
            }
        };
        /**
         * @private
         */
        this.applyTableCellProperties = () => {
            let cellFormat = this.owner.selection.cellFormat;
            if (!isNullOrUndefined(this.bottomMarginBox.value || this.leftMarginBox.value
                || this.rightMarginBox.value || this.topMarginBox.value) &&
                (cellFormat.bottomMargin !== this.bottomMarginBox.value || cellFormat.leftMargin !== this.leftMarginBox.value
                    || cellFormat.rightMargin !== this.rightMarginBox.value || cellFormat.topMargin !== this.topMarginBox.value)) {
                this.owner.owner.tablePropertiesDialogModule.isCellOptionsUpdated = true;
                this.applyTableOptions(this.cellFormat);
                this.owner.owner.tablePropertiesDialogModule.applyTableSubProperties();
            }
            this.closeCellMarginsDialog();
        };
        /**
         * @private
         */
        this.closeCellMarginsDialog = () => {
            this.owner.dialog.hide();
            this.owner.dialog.element.style.pointerEvents = '';
        };
        this.owner = viewer;
    }
    /**
     * @private
     */
    get cellFormat() {
        if (isNullOrUndefined(this.cellFormatIn)) {
            return this.cellFormatIn = new WCellFormat();
        }
        return this.cellFormatIn;
    }
    /**
     * @private
     */
    getModuleName() {
        return 'CellOptionsDialog';
    }
    /**
     * @private
     */
    initCellMarginsDialog(localValue) {
        let instance = this.owner;
        this.target = createElement('div', {
            id: this.owner.owner.containerId + '_tableCellMarginsDialog', className: 'e-de-table-cell-margin-dlg'
        });
        this.owner.owner.element.appendChild(this.target);
        let innerDiv = createElement('div', { styles: 'width: 475px;position: relative;height: 165px;' });
        let innerDivLabel = createElement('Label', {
            className: 'e-de-cell-dia-options-label', id: this.target.id + '_innerDivLabel'
        });
        innerDivLabel.innerHTML = localValue.getConstant('Cell margins');
        innerDiv.appendChild(innerDivLabel);
        let table = createElement('TABLE', {
            styles: 'height: 40px;padding-bottom: 0px;', className: 'e-de-cell-margin-top'
        });
        let tr = createElement('tr');
        let td = createElement('td', { className: 'e-de-tbl-btn-seperator' });
        let sameAsTableCheckBox = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_sameAsCheckBox'
        });
        td.appendChild(sameAsTableCheckBox);
        tr.appendChild(td);
        table.appendChild(tr);
        innerDiv.appendChild(table);
        CellOptionsDialog.getCellMarginDialogElements(this, innerDiv, localValue);
        let divBtn = document.createElement('div');
        this.target.appendChild(divBtn);
        this.sameAsTableCheckBox = new CheckBox({
            label: localValue.getConstant('Same as the whole table'),
            change: this.changeSameAsTable
        });
        this.sameAsTableCheckBox.appendTo(sameAsTableCheckBox);
        this.sameAsTableCheckBox.addEventListener('change', this.changeSameAsTable);
    }
    /**
     * @private
     */
    show() {
        let localizeValue = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localizeValue.setLocale(this.owner.owner.locale);
        setCulture(this.owner.owner.locale);
        if (!this.target) {
            this.initCellMarginsDialog(localizeValue);
        }
        this.loadCellMarginsDialog();
        this.owner.dialog.header = localizeValue.getConstant('Cell Options');
        this.owner.dialog.position = { X: 'center', Y: 'top' };
        this.owner.dialog.height = 'auto';
        this.owner.dialog.width = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = undefined;
        this.owner.dialog.open = undefined;
        this.owner.dialog.close = this.removeEvents;
        this.owner.dialog.buttons = [{
                click: this.applyTableCellProperties,
                buttonModel: { content: localizeValue.getConstant('Ok'), cssClass: 'e-flat e-table-cell-margin-okay', isPrimary: true }
            },
            {
                click: this.closeCellMarginsDialog,
                buttonModel: { content: localizeValue.getConstant('Cancel'), cssClass: 'e-flat e-table-cell-margin-cancel' }
            }];
        this.owner.dialog.show();
    }
    /**
     * @private
     */
    loadCellMarginsDialog() {
        let cellFormat = this.owner.selection.cellFormat;
        this.sameAsTable = isNullOrUndefined(cellFormat.leftMargin || cellFormat.topMargin
            || cellFormat.rightMargin || cellFormat.bottomMargin);
        if (this.sameAsTable) {
            let tableFormat = this.owner.selection.tableFormat;
            this.loadCellProperties(tableFormat, false, true);
        }
        else {
            this.loadCellProperties(cellFormat, true, false);
        }
    }
    loadCellProperties(format, enableTextBox, enableCheckBox) {
        this.leftMarginBox.value = format.leftMargin;
        this.rightMarginBox.value = format.rightMargin;
        this.topMarginBox.value = format.topMargin;
        this.bottomMarginBox.value = format.bottomMargin;
        this.leftMarginBox.enabled = enableTextBox;
        this.rightMarginBox.enabled = enableTextBox;
        this.topMarginBox.enabled = enableTextBox;
        this.bottomMarginBox.enabled = enableTextBox;
        this.sameAsTableCheckBox.checked = enableCheckBox;
    }
    /**
     * @private
     */
    applySubCellOptions(cellFormat) {
        this.owner.owner.editorHistory.initComplexHistory(this.owner.selection, 'CellMarginsSelection');
        this.owner.owner.editorModule.initHistory('CellOptions');
        /* tslint:disable:max-line-length */
        let startTable = this.owner.selection.start.paragraph.associatedCell.ownerTable;
        startTable = startTable.combineWidget(this.owner);
        this.applyCellmarginsValue(this.owner.selection.start.paragraph.associatedCell.ownerRow.combineWidget(this.owner), this.owner.selection.start, this.owner.selection.end, cellFormat);
        this.owner.owner.editorModule.reLayout(this.owner.selection, false);
        if (!isNullOrUndefined(this.owner.owner.editorHistory.currentHistoryInfo)) {
            this.owner.owner.editorHistory.updateComplexHistory();
        }
    }
    /**
     * @private
     */
    applyCellmarginsValue(row, start, end, cellFormat) {
        this.applyCellMarginsInternal(row, cellFormat);
        if (end.paragraph.associatedCell.ownerRow === row) {
            return;
        }
        let newRow = row.nextWidget;
        if (!isNullOrUndefined(newRow)) {
            this.applyCellmarginsValue(newRow, start, end, cellFormat);
        }
    }
    applyCellMarginsInternal(row, cellFormat) {
        if (!isNullOrUndefined(this.owner.owner.editorHistory.currentBaseHistoryInfo)) {
            let currentFormat = row.childWidgets[0].cellFormat;
            /* tslint:disable:max-line-length */
            cellFormat = this.owner.owner.editorHistory.currentBaseHistoryInfo.addModifiedCellOptions(currentFormat, cellFormat, row.ownerTable);
        }
        if (!isNullOrUndefined(cellFormat)) {
            this.applyCellMarginsForCells(row, cellFormat);
        }
    }
    /**
     * @private
     */
    applyCellMarginsForCells(row, cellFormat) {
        let rowCells = row.childWidgets;
        this.iterateCells(rowCells, cellFormat);
    }
    /**
     * @private
     */
    iterateCells(cells, cellFormat) {
        for (let i = 0; i < cells.length; i++) {
            this.applySubCellMargins(cells[i].cellFormat, cellFormat);
        }
        this.owner.owner.tablePropertiesDialogModule.calculateGridValue(cells[0].ownerTable);
    }
    /**
     * @private
     */
    applySubCellMargins(sourceFormat, cellFormat) {
        sourceFormat.leftMargin = cellFormat.leftMargin;
        sourceFormat.topMargin = cellFormat.topMargin;
        sourceFormat.rightMargin = cellFormat.rightMargin;
        sourceFormat.bottomMargin = cellFormat.bottomMargin;
    }
    /**
     * @private
     */
    applyTableOptions(cellFormat) {
        if (!this.sameAsTableCheckBox.checked) {
            cellFormat.leftMargin = this.leftMarginBox.value;
            cellFormat.topMargin = this.topMarginBox.value;
            cellFormat.bottomMargin = this.bottomMarginBox.value;
            cellFormat.rightMargin = this.rightMarginBox.value;
        }
    }
    /**
     * @private
     */
    destroy() {
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (let y = 0; y < this.target.childNodes.length; y++) {
                this.target.removeChild(this.target.childNodes[y]);
                y--;
            }
            this.target = undefined;
        }
        this.dialog = undefined;
        this.target = undefined;
        this.owner = undefined;
        this.sameAsTableCheckBox = undefined;
    }
    /**
     * @private
     */
    static getCellMarginDialogElements(dialog, div, locale) {
        if (!isNullOrUndefined(dialog)) {
            let table = createElement('TABLE', { className: 'e-de-cell-margin-top' });
            let tr1 = createElement('tr', { styles: 'height: 50px;color:black;' });
            let td1 = createElement('td');
            let topLabel = createElement('label', {
                innerHTML: locale.getConstant('Top'), className: 'e-de-cell-dia-label-common',
                id: dialog.target.id + '_TopLabel'
            });
            let topTextBox = createElement('input', {
                attrs: { 'type': 'text' }, styles: 'width:100%', id: dialog.target.id + '_Top'
            });
            td1.appendChild(topLabel);
            td1.appendChild(topTextBox);
            let td2 = createElement('td', { className: 'e-de-tbl-btn-seperator' });
            let leftLabel = createElement('label', {
                innerHTML: locale.getConstant('Left'), className: 'e-de-cell-dia-label-common',
                id: dialog.target.id + '_leftLabel'
            });
            let leftTextBox = createElement('input', {
                attrs: { 'type': 'text' },
                styles: 'width:100%', id: dialog.target.id + '_left'
            });
            td2.appendChild(leftLabel);
            td2.appendChild(leftTextBox);
            tr1.appendChild(td1);
            tr1.appendChild(td2);
            let tr2 = createElement('tr', { styles: 'height: 50px;color:black;' });
            let td3 = createElement('td', { styles: 'width:40%;' });
            let bottomLabel = createElement('label', {
                innerHTML: locale.getConstant('Bottom'),
                className: 'e-de-cell-dia-label-common', id: dialog.target.id + '_bottomLabel'
            });
            let bottomTextBox = createElement('input', {
                attrs: { 'type': 'text' },
                styles: 'width:100%', id: dialog.target.id + '_bottom'
            });
            td3.appendChild(bottomLabel);
            td3.appendChild(bottomTextBox);
            let td4 = createElement('td', { styles: 'width:40%;' });
            let rightLabel = createElement('label', {
                innerHTML: locale.getConstant('Right'), id: dialog.target.id + '_rightLabel',
                className: 'e-de-cell-dia-label-common'
            });
            let rightTextBox = createElement('input', {
                attrs: { 'type': 'text' },
                styles: 'width:100%', id: dialog.target.id + '_right'
            });
            td4.appendChild(rightLabel);
            td4.appendChild(rightTextBox);
            tr2.appendChild(td3);
            tr2.appendChild(td4);
            table.appendChild(tr1);
            table.appendChild(tr2);
            div.appendChild(table);
            dialog.target.appendChild(div);
            dialog.topMarginBox = new NumericTextBox({
                value: 0, min: 0, max: 1584, width: 150, decimals: 2,
                enablePersistence: false
            });
            dialog.topMarginBox.appendTo(topTextBox);
            dialog.leftMarginBox = new NumericTextBox({
                value: 0, min: 0, max: 1584, width: 150,
                decimals: 2, enablePersistence: false
            });
            dialog.leftMarginBox.appendTo(leftTextBox);
            dialog.bottomMarginBox = new NumericTextBox({
                value: 0, min: 0, max: 1584, width: 150, decimals: 2,
                enablePersistence: false
            });
            dialog.bottomMarginBox.appendTo(bottomTextBox);
            dialog.rightMarginBox = new NumericTextBox({
                value: 0, min: 0, max: 1584, width: 150,
                decimals: 2, enablePersistence: false
            });
            dialog.rightMarginBox.appendTo(rightTextBox);
        }
    }
}

/**
 * The Styles dialog is used to create or modify styles.
 */
class StylesDialog {
    /**
     * @private
     */
    constructor(viewer) {
        this.updateStyleNames = () => {
            let collection = this.owner.owner.viewer.styles.getStyleNames('Paragraph');
            let defaultStyleNames = ['Normal', 'Heading 1', 'Heading 2', 'Heading 3', 'Heading 4', 'Heading 5', 'Heading 6'];
            let finalList = collection.concat(defaultStyleNames).filter((v, i, a) => a.indexOf(v) === i);
            return finalList;
        };
        this.modifyStyles = () => {
            this.owner.dialog.hide();
            this.owner.owner.styleDialogModule.show(this.styleName, this.localValue.getConstant('Modify Style'));
        };
        /* tslint:disable:no-any */
        this.selectHandler = (args) => {
            this.styleName = args.text;
        };
        this.addNewStyles = () => {
            this.owner.dialog.hide();
            this.owner.owner.styleDialogModule.show();
        };
        this.owner = viewer;
    }
    /**
     * @private
     */
    getModuleName() {
        return 'StylesDialog';
    }
    /**
     * @private
     */
    initStylesDialog(localValue, styles) {
        let id = this.owner.owner.containerId + '_insert_styles';
        this.target = createElement('div', { id: id, className: 'e-de-styles' });
        let headerValue = localValue.getConstant('Styles');
        let dlgFields = createElement('div', { innerHTML: headerValue, className: 'e-styles-dlgfields' });
        this.target.appendChild(dlgFields);
        let commonDiv = createElement('div', { className: 'e-styles-common' });
        this.target.appendChild(commonDiv);
        let searchDiv = createElement('div', { className: 'e-styles-list' });
        commonDiv.appendChild(searchDiv);
        let listviewDiv = createElement('div', { className: 'e-styles-listViewDiv', id: 'styles_listview' });
        searchDiv.appendChild(listviewDiv);
        this.listviewInstance = new ListView({
            dataSource: styles,
            cssClass: 'e-styles-listview',
        });
        this.listviewInstance.appendTo(listviewDiv);
        this.listviewInstance.addEventListener('select', this.selectHandler);
        let buttonDiv = createElement('div', { className: 'e-styles-button' });
        commonDiv.appendChild(buttonDiv);
        let newButtonDiv = createElement('div', { className: 'e-styles-addbutton' });
        buttonDiv.appendChild(newButtonDiv);
        let newButtonElement = createElement('button', { innerHTML: localValue.getConstant('New'), id: 'new' });
        newButtonDiv.appendChild(newButtonElement);
        let newbutton = new Button({ cssClass: 'e-button-custom' });
        newbutton.appendTo(newButtonElement);
        newButtonElement.addEventListener('click', this.addNewStyles);
        let modifybuttonDiv = createElement('div', { className: 'e-styles-addbutton' });
        buttonDiv.appendChild(modifybuttonDiv);
        let modifyButtonElement = createElement('button', { innerHTML: localValue.getConstant('Modify'), id: 'modify' });
        modifybuttonDiv.appendChild(modifyButtonElement);
        let addbutton = new Button({ cssClass: 'e-button-custom' });
        addbutton.appendTo(modifyButtonElement);
        modifyButtonElement.addEventListener('click', this.modifyStyles);
    }
    /**
     * @private
     */
    show() {
        let styles = this.updateStyleNames();
        let localValue = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localValue.setLocale(this.owner.owner.locale);
        setCulture(this.owner.owner.locale);
        this.localValue = localValue;
        this.initStylesDialog(localValue, styles);
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = this.owner.updateFocus;
        this.owner.dialog.close = this.owner.updateFocus;
        this.owner.dialog.header = 'Styles';
        this.owner.dialog.height = 'auto';
        this.owner.dialog.width = 'auto';
        this.owner.dialog.buttons = [{
                click: this.hideObjects.bind(this),
                buttonModel: { content: localValue.getConstant('Cancel'), cssClass: 'e-flat e-hyper-insert', isPrimary: true }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    }
    hideObjects() {
        this.owner.dialog.hide();
    }
    /**
     * @private
     */
    destroy() {
        if (this.listviewInstance) {
            this.listviewInstance.destroy();
            this.listviewInstance = undefined;
        }
    }
}

/**
 * Export dialogs
 */

/**
 * Document Editor implementation
 */

/**
 * export document editor
 */

/**
 * export document editor modules
 */

export { Dictionary, WUniqueFormat, WUniqueFormats, DocumentEditor, Print, ContextMenu$1 as ContextMenu, WSectionFormat, WStyle, WParagraphStyle, WCharacterStyle, WStyles, WCharacterFormat, WListFormat, WTabStop, WParagraphFormat, WTableFormat, WRowFormat, WCellFormat, WBorder, WBorders, WShading, WList, WAbstractList, WListLevel, WLevelOverride, LayoutViewer, PageLayoutViewer, Layout, Rect, Margin, Widget, BlockContainer, BodyWidget, HeaderFooterWidget, BlockWidget, ParagraphWidget, TableWidget, TableRowWidget, TableCellWidget, LineWidget, ElementBox, FieldElementBox, TextElementBox, FieldTextElementBox, TabElementBox, BookmarkElementBox, ImageElementBox, ListTextElementBox, Page, WTableHolder, WColumn, Renderer, SfdtReader, TextHelper, Zoom, Selection, SelectionCharacterFormat, SelectionParagraphFormat, SelectionSectionFormat, SelectionTableFormat, SelectionCellFormat, SelectionRowFormat, SelectionImageFormat, TextPosition, SelectionWidgetInfo, Hyperlink, ImageFormat, Search, OptionsPane, TextSearch, SearchWidgetInfo, TextSearchResult, TextSearchResults, Editor, ImageResizer, ImageResizingPoints, SelectedImageInfo, TableResizer, HelperMethods, Point, EditorHistory, BaseHistoryInfo, HistoryInfo, ModifiedLevel, ModifiedParagraphFormat, RowHistoryFormat, TableHistoryInfo, TableFormatHistoryInfo, RowFormatHistoryInfo, CellFormatHistoryInfo, CellHistoryFormat, WordExport, TextExport, SfdtExport, HtmlExport, HyperlinkDialog, TableDialog, BookmarkDialog, TableOfContentsDialog, PageSetupDialog, ParagraphDialog, ListDialog, StyleDialog, BulletsAndNumberingDialog, FontDialog, TablePropertiesDialog, BordersAndShadingDialog, TableOptionsDialog, CellOptionsDialog, StylesDialog };
//# sourceMappingURL=ej2-documenteditor.es2015.js.map
