import { WTableFormat, WRowFormat, WCellFormat } from '../format/index';
import { WidthType } from '../../base/types';
import { WListLevel } from '../list/list-level';
import { WParagraphFormat, WCharacterFormat, WSectionFormat, WBorder, WBorders } from '../format/index';
import { LayoutViewer } from './viewer';
import { Dictionary } from '../../base/dictionary';
import { ElementInfo, Point } from '../editor/editor-helper';
import { HeaderFooterType, TabLeader } from '../../base/types';
/**
 * @private
 */
export declare class Rect {
    /**
     * @private
     */
    width: number;
    /**
     * @private
     */
    height: number;
    /**
     * @private
     */
    x: number;
    /**
     * @private
     */
    y: number;
    /**
     * @private
     */
    readonly right: number;
    /**
     * @private
     */
    readonly bottom: number;
    constructor(x: number, y: number, width: number, height: number);
}
/**
 * @private
 */
export declare class Margin {
    /**
     * @private
     */
    left: number;
    /**
     * @private
     */
    top: number;
    /**
     * @private
     */
    right: number;
    /**
     * @private
     */
    bottom: number;
    constructor(leftMargin: number, topMargin: number, rightMargin: number, bottomMargin: number);
    /**
     * @private
     */
    clone(): Margin;
    /**
     * @private
     */
    destroy(): void;
}
/**
 * @private
 */
export interface IWidget {
}
/**
 * @private
 */
export declare abstract class Widget implements IWidget {
    /**
     * @private
     */
    childWidgets: IWidget[];
    /**
     * @private
     */
    x: number;
    /**
     * @private
     */
    y: number;
    /**
     * @private
     */
    width: number;
    /**
     * @private
     */
    height: number;
    /**
     * @private
     */
    margin: Margin;
    /**
     * @private
     */
    containerWidget: Widget;
    /**
     * @private
     */
    index: number;
    /**
     * @private
     */
    readonly indexInOwner: number;
    /**
     * @private
     */
    readonly firstChild: IWidget;
    /**
     * @private
     */
    readonly lastChild: IWidget;
    /**
     * @private
     */
    readonly previousWidget: Widget;
    /**
     * @private
     */
    readonly nextWidget: Widget;
    /**
     * @private
     */
    readonly previousRenderedWidget: Widget;
    /**
     * @private
     */
    readonly nextRenderedWidget: Widget;
    /**
     * @private
     */
    readonly previousSplitWidget: Widget;
    /**
     * @private
     */
    readonly nextSplitWidget: Widget;
    /**
     * @private
     */
    abstract equals(widget: Widget): boolean;
    /**
     * @private
     */
    abstract getTableCellWidget(point: Point): TableCellWidget;
    /**
     * @private
     */
    getPreviousSplitWidgets(): Widget[];
    /**
     * @private
     */
    getSplitWidgets(): Widget[];
    /**
     * @private
     */
    combineWidget(viewer: LayoutViewer): Widget;
    private combine(widget, viewer);
    /**
     * @private
     */
    addWidgets(childWidgets: IWidget[]): void;
    /**
     * @private
     */
    removeChild(index: number): void;
    /**
     * @private
     */
    abstract destroyInternal(viewer: LayoutViewer): void;
    /**
     * @private
     */
    destroy(): void;
}
/**
 * @private
 */
export declare abstract class BlockContainer extends Widget {
    /**
     * @private
     */
    page: Page;
    /**
     * @private
     */
    sectionFormatIn: WSectionFormat;
    /**
     * @private
     */
    /**
     * @private
     */
    sectionFormat: WSectionFormat;
    /**
     * @private
     */
    readonly sectionIndex: number;
    /**
     * @private
     */
    getHierarchicalIndex(hierarchicalIndex: string): string;
}
/**
 * @private
 */
export declare class BodyWidget extends BlockContainer {
    /**
     * Initialize the constructor of BodyWidget
     */
    constructor();
    /**
     * @private
     */
    equals(widget: Widget): boolean;
    /**
     * @private
     */
    getHierarchicalIndex(hierarchicalIndex: string): string;
    /**
     * @private
     */
    getTableCellWidget(touchPoint: Point): TableCellWidget;
    /**
     * @private
     */
    destroyInternal(viewer: LayoutViewer): void;
    /**
     * @private
     */
    destroy(): void;
}
/**
 * @private
 */
export interface HeaderFooters {
    [key: number]: HeaderFooterWidget;
}
/**
 * @private
 */
export declare class HeaderFooterWidget extends BlockContainer {
    /**
     * @private
     */
    headerFooterType: HeaderFooterType;
    constructor(type: HeaderFooterType);
    /**
     * @private
     */
    getTableCellWidget(point: Point): TableCellWidget;
    /**
     * @private
     */
    equals(widget: Widget): boolean;
    /**
     * @private
     */
    clone(): HeaderFooterWidget;
    /**
     * @private
     */
    destroyInternal(viewer: LayoutViewer): void;
}
/**
 * @private
 */
export declare abstract class BlockWidget extends Widget {
    /**
     * @private
     */
    leftBorderWidth: number;
    /**
     * @private
     */
    rightBorderWidth: number;
    /**
     * @private
     */
    topBorderWidth: number;
    /**
     * @private
     */
    bottomBorderWidth: number;
    /**
     * @private
     */
    readonly bodyWidget: BlockContainer;
    /**
     * @private
     */
    readonly leftIndent: number;
    /**
     * @private
     */
    readonly rightIndent: number;
    /**
     * @private
     */
    readonly isInsideTable: boolean;
    /**
     * @private
     */
    readonly isInHeaderFooter: boolean;
    /**
     * @private
     */
    readonly associatedCell: TableCellWidget;
    /**
     * Check whether the paragraph contains only page break.
     * @private
     */
    isPageBreak(): boolean;
    /**
     * @private
     */
    getHierarchicalIndex(hierarchicalIndex: string): string;
    /**
     * @private
     */
    abstract clone(): BlockWidget;
    /**
     * @private
     */
    getIndex(): number;
    /**
     * @private
     */
    getContainerWidth(): number;
}
/**
 * @private
 */
export declare class ParagraphWidget extends BlockWidget {
    /**
     * @private
     */
    paragraphFormat: WParagraphFormat;
    /**
     * @private
     */
    characterFormat: WCharacterFormat;
    /**
     * @private
     */
    readonly isEndsWithPageBreak: boolean;
    /**
     * Initialize the constructor of ParagraphWidget
     */
    constructor();
    /**
     * @private
     */
    equals(widget: Widget): boolean;
    /**
     * @private
     */
    isEmpty(): boolean;
    /**
     * @private
     */
    getInline(offset: number, indexInInline: number): ElementInfo;
    /**
     * @private
     */
    getLength(): number;
    /**
     * @private
     */
    getTableCellWidget(point: Point): TableCellWidget;
    /**
     * @private
     */
    clone(): ParagraphWidget;
    /**
     * @private
     */
    destroyInternal(viewer: LayoutViewer): void;
    /**
     * @private
     */
    destroy(): void;
}
/**
 * @private
 */
export declare class TableWidget extends BlockWidget {
    private flags;
    /**
     * @private
     */
    leftMargin: number;
    /**
     * @private
     */
    topMargin: number;
    /**
     * @private
     */
    rightMargin: number;
    /**
     * @private
     */
    bottomMargin: number;
    /**
     * @private
     */
    tableFormat: WTableFormat;
    /**
     * @private
     */
    spannedRowCollection: Dictionary<number, number>;
    /**
     * @private
     */
    tableGrids: number[];
    /**
     * @private
     */
    tableHolder: WTableHolder;
    /**
     * @private
     */
    headerHeight: number;
    /**
     * @private
     */
    description: string;
    /**
     * @private
     */
    title: string;
    /**
     * @private
     */
    tableCellInfo: Dictionary<number, Dictionary<number, number>>;
    /**
     * @private
     */
    /**
     * @private
     */
    isGridUpdated: boolean;
    /**
     * @private
     */
    /**
     * @private
     */
    continueHeader: boolean;
    /**
     * @private
     */
    /**
     * @private
     */
    header: boolean;
    constructor();
    /**
     * @private
     */
    equals(widget: Widget): boolean;
    /**
     * @private
     */
    combineRows(viewer: LayoutViewer): void;
    /**
     * @private
     */
    contains(tableCell: TableCellWidget): boolean;
    /**
     * @private
     */
    getOwnerWidth(isBasedOnViewer: boolean): number;
    private getTableWidth();
    /**
     * @private
     */
    getTableClientWidth(clientWidth: number): number;
    /**
     * @private
     */
    getCellWidth(preferredWidth: number, preferredWidthType: WidthType, containerWidth: number, cell: TableCellWidget): number;
    /**
     * @private
     */
    fitCellsToClientArea(clientWidth: number): void;
    /**
     * @private
     */
    getTableCellWidget(point: Point): TableCellWidget;
    /**
     * @private
     */
    calculateGrid(): void;
    private updateColumnSpans(tempGrid, containerWidth);
    /**
     * @private
     */
    buildTableColumns(): void;
    /**
     * @private
     */
    setWidthToCells(tableWidth: number, isAutoWidth: boolean): void;
    /**
     * @private
     */
    getMaxRowWidth(clientWidth: number): number;
    /**
     * @private
     */
    updateWidth(dragValue: number): void;
    /**
     * @private
     */
    convertPointToPercent(tablePreferredWidth: number, ownerWidth: number): number;
    /**
     * @private
     */
    clone(): TableWidget;
    /**
     * @private
     */
    static getTableOf(node: WBorders): TableWidget;
    /**
     * @private
     */
    fitChildToClientArea(): void;
    /**
     * @private
     */
    getColumnCellsForSelection(startCell: TableCellWidget, endCell: TableCellWidget): TableCellWidget[];
    /**
     * Splits width equally for all the cells.
     * @param tableClientWidth
     * @private
     */
    splitWidthToTableCells(tableClientWidth: number): void;
    /**
     * @private
     */
    insertTableRowsInternal(tableRows: TableRowWidget[], startIndex: number): void;
    /**
     * @private
     */
    updateRowIndex(startIndex: number): void;
    /**
     * @private
     */
    getCellStartOffset(cell: TableCellWidget): number;
    /**
     * @private
     */
    destroyInternal(viewer: LayoutViewer): void;
    /**
     * @private
     */
    destroy(): void;
}
/**
 * @private
 */
export declare class TableRowWidget extends BlockWidget {
    /**
     * @private
     */
    topBorderWidth: number;
    /**
     * @private
     */
    bottomBorderWidth: number;
    /**
     * @private
     */
    rowFormat: WRowFormat;
    /**
     * @private
     */
    spannedRowCollection: TableRowWidget[];
    /**
     * @private
     */
    readonly rowIndex: number;
    /**
     * @private
     */
    readonly ownerTable: TableWidget;
    /**
     * @private
     */
    readonly nextRow: TableRowWidget;
    constructor();
    /**
     * @private
     */
    equals(widget: Widget): boolean;
    /**
     * @private
     */
    combineCells(viewer: LayoutViewer): void;
    /**
     * @private
     */
    static getRowOf(node: WBorders): TableRowWidget;
    /**
     * @private
     */
    getCell(rowIndex: number, cellIndex: number): TableCellWidget;
    /**
     * @private
     */
    splitWidthToRowCells(tableClientWidth: number): void;
    /**
     * @private
     */
    getGridCount(tableGrid: number[], cell: TableCellWidget, index: number, containerWidth: number): number;
    private getOffsetIndex(tableGrid, offset);
    private getCellOffset(index, containerWidth);
    /**
     * @private
     */
    updateRowBySpannedCells(): void;
    /**
     * @private
     */
    getPreviousRowSpannedCells(include?: boolean): TableCellWidget[];
    /**
     * @private
     */
    getTableCellWidget(point: Point): TableCellWidget;
    /**
     * @private
     */
    destroyInternal(viewer: LayoutViewer): void;
    /**
     * @private
     */
    clone(): TableRowWidget;
    /**
     * @private
     */
    destroy(): void;
}
/**
 * @private
 */
export declare class TableCellWidget extends BlockWidget {
    /**
     * @private
     */
    rowIndex: number;
    /**
     * @private
     */
    cellFormat: WCellFormat;
    /**
     * @private
     */
    columnIndex: number;
    /**
     * @private
     */
    readonly ownerColumn: WColumn;
    /**
     * @private
     */
    readonly leftMargin: number;
    /**
     * @private
     */
    readonly topMargin: number;
    /**
     * @private
     */
    readonly rightMargin: number;
    /**
     * @private
     */
    readonly bottomMargin: number;
    /**
     * @private
     */
    readonly cellIndex: number;
    /**
     * @private
     */
    readonly ownerTable: TableWidget;
    /**
     * @private
     */
    readonly ownerRow: TableRowWidget;
    constructor();
    /**
     * @private
     */
    equals(widget: Widget): boolean;
    /**
     * @private
     */
    getContainerTable(): TableWidget;
    /**
     * @private
     */
    getPreviousSplitWidget(): TableCellWidget;
    /**
     * @private
     */
    getNextSplitWidget(): TableCellWidget;
    /**
     * @private
     */
    getTableCellWidget(point: Point): TableCellWidget;
    /**
     * @private
     */
    updateWidth(preferredWidth: number): void;
    /**
     * @private
     */
    convertPointToPercent(cellPreferredWidth: number): number;
    /**
     * @private
     */
    static getCellLeftBorder(tableCell: TableCellWidget): WBorder;
    /**
     * @private
     */
    getLeftBorderWidth(): number;
    /**
     * @private
     */
    getRightBorderWidth(): number;
    /**
     * @private
     */
    getCellSpacing(): number;
    /**
     * @private
     */
    getMinimumPreferredWidth(): number;
    /**
     * @private
     */
    getPreviousCellLeftBorder(leftBorder: WBorder, previousCell: TableCellWidget): WBorder;
    /**
     * @private
     */
    getBorderBasedOnPriority(border: WBorder, adjacentBorder: WBorder): WBorder;
    /**
     * @private
     */
    getLeftBorderToRenderByHierarchy(leftBorder: WBorder, rowBorders: WBorders, tableBorders: WBorders): WBorder;
    /**
     * @private
     */
    static getCellRightBorder(tableCell: TableCellWidget): WBorder;
    /**
     * @private
     */
    getAdjacentCellRightBorder(rightBorder: WBorder, nextCell: TableCellWidget): WBorder;
    /**
     * @private
     */
    getRightBorderToRenderByHierarchy(rightBorder: WBorder, rowBorders: WBorders, tableBorders: WBorders): WBorder;
    /**
     * @private
     */
    static getCellTopBorder(tableCell: TableCellWidget): WBorder;
    /**
     * @private
     */
    getPreviousCellTopBorder(topBorder: WBorder, previousTopCell: TableCellWidget): WBorder;
    /**
     * @private
     */
    getTopBorderToRenderByHierarchy(topBorder: WBorder, rowBorders: WBorders, tableBorders: WBorders): WBorder;
    /**
     * @private
     */
    static getCellBottomBorder(tableCell: TableCellWidget): WBorder;
    /**
     * @private
     */
    getAdjacentCellBottomBorder(bottomBorder: WBorder, nextBottomCell: TableCellWidget): WBorder;
    /**
     * @private
     */
    getBottomBorderToRenderByHierarchy(bottomBorder: WBorder, rowBorders: WBorders, tableBorders: WBorders): WBorder;
    private convertHexToRGB(colorCode);
    /**
     * @private
     */
    static getCellOf(node: WBorders): TableCellWidget;
    /**
     * @private
     */
    destroyInternal(viewer: LayoutViewer): void;
    /**
     * @private
     */
    clone(): TableCellWidget;
    /**
     * @private
     */
    destroy(): void;
}
/**
 * @private
 */
export declare class LineWidget implements IWidget {
    /**
     * @private
     */
    children: ElementBox[];
    /**
     * @private
     */
    paragraph: ParagraphWidget;
    /**
     * @private
     */
    x: number;
    /**
     * @private
     */
    y: number;
    /**
     * @private
     */
    width: number;
    /**
     * @private
     */
    height: number;
    /**
     * @private
     */
    readonly indexInOwner: number;
    /**
     * @private
     */
    readonly nextLine: LineWidget;
    /**
     * @private
     */
    readonly previousLine: LineWidget;
    /**
     * @private
     */
    readonly isEndsWithPageBreak: boolean;
    /**
     * Initialize the constructor of LineWidget
     */
    constructor(paragraphWidget: ParagraphWidget);
    /**
     * @private
     */
    isFirstLine(): boolean;
    /**
     * @private
     */
    isLastLine(): boolean;
    /**
     * @private
     */
    getOffset(inline: ElementBox, index: number): number;
    /**
     * @private
     */
    getEndOffset(): number;
    /**
     * @private
     */
    getInline(offset: number, indexInInline: number): ElementInfo;
    /**
     * @private
     */
    getHierarchicalIndex(hierarchicalIndex: string): string;
    /**
     * @private
     */
    clone(): LineWidget;
    /**
     * @private
     */
    destroy(): void;
}
/**
 * @private
 */
export declare abstract class ElementBox {
    /**
     * @private
     */
    x: number;
    /**
     * @private
     */
    y: number;
    /**
     * @private
     */
    width: number;
    /**
     * @private
     */
    height: number;
    /**
     * @private
     */
    margin: Margin;
    /**
     * @private
     */
    line: LineWidget;
    /**
     * @private
     */
    characterFormat: WCharacterFormat;
    /**
     * @private
     */
    static objectCharacter: string;
    /**
     * @private
     */
    readonly isPageBreak: boolean;
    /**
     * @private
     */
    linkFieldCharacter(viewer: LayoutViewer): void;
    /**
     * @private
     */
    linkFieldTraversingBackward(line: LineWidget, fieldEnd: FieldElementBox, previousNode: ElementBox): boolean;
    /**
     * @private
     */
    linkFieldTraversingForward(line: LineWidget, fieldBegin: FieldElementBox, previousNode: ElementBox): boolean;
    /**
     * @private
     */
    linkFieldTraversingBackwardSeparator(line: LineWidget, fieldSeparator: FieldElementBox, previousNode: ElementBox): boolean;
    /**
     * @private
     */
    readonly length: number;
    /**
     * @private
     */
    readonly indexInOwner: number;
    /**
     * @private
     */
    readonly previousElement: ElementBox;
    /**
     * @private
     */
    readonly nextElement: ElementBox;
    /**
     * @private
     */
    readonly nextNode: ElementBox;
    /**
     * @private
     */
    readonly previousNode: ElementBox;
    /**
     * @private
     */
    readonly paragraph: ParagraphWidget;
    /**
     * Initialize the constructor of ElementBox
     */
    constructor();
    /**
     * @private
     */
    abstract getLength(): number;
    /**
     * @private
     */
    abstract clone(): ElementBox;
    /**
     * @private
     */
    destroy(): void;
}
/**
 * @private
 */
export declare class FieldElementBox extends ElementBox {
    /**
     * @private
     */
    fieldType: number;
    /**
     * @private
     */
    hasFieldEnd: boolean;
    private fieldBeginInternal;
    private fieldSeparatorInternal;
    private fieldEndInternal;
    fieldBegin: FieldElementBox;
    fieldSeparator: FieldElementBox;
    fieldEnd: FieldElementBox;
    constructor(type: number);
    /**
     * @private
     */
    getLength(): number;
    /**
     * @private
     */
    clone(): FieldElementBox;
    /**
     * @private
     */
    destroy(): void;
}
/**
 * @private
 */
export declare class TextElementBox extends ElementBox {
    /**
     * @private
     */
    baselineOffset: number;
    /**
     * @private
     */
    text: string;
    constructor();
    /**
     * @private
     */
    getLength(): number;
    /**
     * @private
     */
    clone(): TextElementBox;
    /**
     * @private
     */
    destroy(): void;
}
/**
 * @private
 */
export declare class FieldTextElementBox extends TextElementBox {
    /**
     * @private
     */
    fieldBegin: FieldElementBox;
    private fieldText;
    text: string;
    constructor();
    /**
     * @private
     */
    clone(): FieldTextElementBox;
}
/**
 * @private
 */
export declare class TabElementBox extends TextElementBox {
    /**
     * @private
     */
    tabText: string;
    /**
     * @private
     */
    tabLeader: TabLeader;
    /**
     * @private
     */
    destroy(): void;
    constructor();
    /**
     * @private
     */
    clone(): TabElementBox;
}
/**
 * @private
 */
export declare class BookmarkElementBox extends ElementBox {
    private bookmarkTypeIn;
    private refereneceIn;
    private nameIn;
    /**
     * @private
     */
    readonly bookmarkType: number;
    /**
     * @private
     */
    /**
     * @private
     */
    name: string;
    /**
     * @private
     */
    /**
     * @private
     */
    reference: BookmarkElementBox;
    constructor(type: number);
    /**
     * @private
     */
    getLength(): number;
    /**
     * @private
     */
    destroy(): void;
    /**
     * Clones the bookmark element box.
     * @param element - book mark element
     */
    /**
     * @private
     */
    clone(): BookmarkElementBox;
}
/**
 * @private
 */
export declare class ImageElementBox extends ElementBox {
    private imageStr;
    private imgElement;
    private isInlineImageIn;
    /**
     * @private
     */
    isMetaFile: boolean;
    /**
     * @private
     */
    readonly isInlineImage: boolean;
    /**
     * @private
     */
    readonly element: HTMLImageElement;
    /**
     * @private
     */
    readonly length: number;
    /**
     * @private
     */
    /**
     * @private
     */
    imageString: string;
    constructor(isInlineImage?: boolean);
    /**
     * @private
     */
    getLength(): number;
    /**
     * @private
     */
    clone(): ImageElementBox;
    /**
     * @private
     */
    destroy(): void;
}
/**
 * @private
 */
export declare class ListTextElementBox extends ElementBox {
    /**
     * @private
     */
    baselineOffset: number;
    /**
     * @private
     */
    text: string;
    /**
     * @private
     */
    listLevel: WListLevel;
    /**
     * @private
     */
    isFollowCharacter: boolean;
    constructor(listLevel: WListLevel, isListFollowCharacter: boolean);
    /**
     * @private
     */
    getLength(): number;
    /**
     * @private
     */
    clone(): ListTextElementBox;
    /**
     * @private
     */
    destroy(): void;
}
/**
 * @private
 */
export declare class Page {
    /**
     * Specifies the Viewer
     * @private
     */
    viewer: LayoutViewer;
    /**
     * Specifies the Bonding Rectangle
     * @private
     */
    boundingRectangle: Rect;
    /**
     * @private
     */
    repeatHeaderRowTableWidget: boolean;
    /**
     * Specifies the bodyWidgets
     * @default []
     * @private
     */
    bodyWidgets: BodyWidget[];
    /**
     * @private
     */
    headerWidget: HeaderFooterWidget;
    /**
     * @private
     */
    footerWidget: HeaderFooterWidget;
    /**
     * @private
     */
    readonly index: number;
    /**
     * @private
     */
    readonly previousPage: Page;
    /**
     * @private
     */
    readonly nextPage: Page;
    /**
     * @private
     */
    readonly sectionIndex: number;
    /**
     * Initialize the constructor of Page
     */
    constructor();
    destroy(): void;
}
/**
 * @private
 */
export declare class WTableHolder {
    private tableColumns;
    /**
     * @private
     */
    tableWidth: number;
    readonly columns: WColumn[];
    /**
     * @private
     */
    resetColumns(): void;
    /**
     * @private
     */
    getPreviousSpannedCellWidth(previousColumnIndex: number, curColumnIndex: number): number;
    /**
     * @private
     */
    addColumns(currentColumnIndex: number, columnSpan: number, width: number, minWidth: number, offset: number): void;
    /**
     * @private
     */
    getTotalWidth(): number;
    /**
     * @private
     */
    isFitColumns(containerWidth: number, preferredTableWidth: number, isAutoWidth: boolean): boolean;
    /**
     * @private
     */
    fitColumns(containerWidth: number, preferredTableWidth: number, isAutoWidth: boolean): void;
    /**
     * @private
     */
    getCellWidth(columnIndex: number, columnSpan: number, preferredTableWidth: number, isAutoWidth: boolean): number;
    /**
     * @private
     */
    validateColumnWidths(): void;
    /**
     * @private
     */
    clone(): WTableHolder;
    /**
     * @private
     */
    destroy(): void;
}
/**
 * @private
 */
export declare class WColumn {
    /**
     * @private
     */
    preferredWidth: number;
    /**
     * @private
     */
    minWidth: number;
    /**
     * @private
     */
    maxWidth: number;
    /**
     * @private
     */
    endOffset: number;
    /**
     * @private
     */
    clone(): WColumn;
    /**
     * @private
     */
    destroy(): void;
}
