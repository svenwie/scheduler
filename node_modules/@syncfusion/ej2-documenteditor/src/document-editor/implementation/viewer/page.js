var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { WTableFormat, WRowFormat, WCellFormat } from '../format/index';
import { WParagraphFormat, WCharacterFormat, WBorder, WBorders } from '../format/index';
import { isNullOrUndefined } from '@syncfusion/ej2-base';
import { Dictionary } from '../../base/dictionary';
import { HelperMethods } from '../editor/editor-helper';
/**
 * @private
 */
var Rect = /** @class */ (function () {
    function Rect(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    Object.defineProperty(Rect.prototype, "right", {
        /**
         * @private
         */
        get: function () {
            return this.x + this.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rect.prototype, "bottom", {
        /**
         * @private
         */
        get: function () {
            return this.y + this.height;
        },
        enumerable: true,
        configurable: true
    });
    return Rect;
}());
export { Rect };
/**
 * @private
 */
var Margin = /** @class */ (function () {
    function Margin(leftMargin, topMargin, rightMargin, bottomMargin) {
        this.left = leftMargin;
        this.top = topMargin;
        this.right = rightMargin;
        this.bottom = bottomMargin;
    }
    /**
     * @private
     */
    Margin.prototype.clone = function () {
        return new Margin(this.left, this.top, this.right, this.bottom);
    };
    /**
     * @private
     */
    Margin.prototype.destroy = function () {
        this.left = undefined;
        this.right = undefined;
        this.top = undefined;
        this.bottom = undefined;
    };
    return Margin;
}());
export { Margin };
/**
 * @private
 */
var Widget = /** @class */ (function () {
    function Widget() {
        /**
         * @private
         */
        this.childWidgets = [];
        /**
         * @private
         */
        this.x = 0;
        /**
         * @private
         */
        this.y = 0;
        /**
         * @private
         */
        this.width = 0;
        /**
         * @private
         */
        this.height = 0;
        /**
         * @private
         */
        this.index = 0;
    }
    Object.defineProperty(Widget.prototype, "indexInOwner", {
        /**
         * @private
         */
        get: function () {
            if (this instanceof BodyWidget && this.page) {
                return this.page.bodyWidgets.indexOf(this);
            }
            else if (this.containerWidget && this.containerWidget.childWidgets) {
                return this.containerWidget.childWidgets.indexOf(this);
            }
            return -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "firstChild", {
        /**
         * @private
         */
        get: function () {
            return this.childWidgets.length > 0 ? this.childWidgets[0] : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "lastChild", {
        /**
         * @private
         */
        get: function () {
            if (this.childWidgets) {
                return this.childWidgets.length > 0 ?
                    this.childWidgets[this.childWidgets.length - 1] : undefined;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "previousWidget", {
        /**
         * @private
         */
        get: function () {
            var widget = this;
            var index = this.indexInOwner;
            if (widget instanceof BodyWidget) {
                widget = index > 0 ? widget.page.bodyWidgets[index - 1] : undefined;
            }
            else {
                widget = index > 0 ? widget.containerWidget.childWidgets[index - 1] : undefined;
            }
            return widget;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "nextWidget", {
        /**
         * @private
         */
        get: function () {
            var widget = this;
            var index = this.indexInOwner;
            if (index === -1) {
                return undefined;
            }
            if (widget instanceof BodyWidget) {
                widget = index < widget.page.bodyWidgets.length - 1 ?
                    widget.page.bodyWidgets[index + 1] : undefined;
            }
            else {
                widget = index < widget.containerWidget.childWidgets.length - 1 ?
                    widget.containerWidget.childWidgets[index + 1] : undefined;
            }
            return widget;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "previousRenderedWidget", {
        /**
         * @private
         */
        get: function () {
            var widget = this;
            var index = this.indexInOwner;
            if (index < 0) {
                return undefined;
            }
            if (widget instanceof BodyWidget) {
                if (index > 0) {
                    widget = widget.page.bodyWidgets[index - 1];
                }
                else {
                    var page = widget.page.previousPage;
                    widget = page && page.bodyWidgets.length > 0 ? page.bodyWidgets[page.bodyWidgets.length - 1] : undefined;
                }
            }
            else {
                if (index > 0) {
                    widget = widget.containerWidget.childWidgets[index - 1];
                }
                else {
                    var previousContainer = undefined;
                    if (widget.containerWidget instanceof TableCellWidget) {
                        previousContainer = widget.containerWidget.getPreviousSplitWidget();
                    }
                    else if (!(widget.containerWidget instanceof TableRowWidget
                        || widget.containerWidget instanceof HeaderFooterWidget)) {
                        // Since cells are lay outed left to right, we should not navigate to previous row.
                        previousContainer = widget.containerWidget.previousRenderedWidget;
                    }
                    while (previousContainer && previousContainer.childWidgets.length === 0) {
                        previousContainer = previousContainer.previousRenderedWidget;
                        if (isNullOrUndefined(previousContainer)) {
                            break;
                        }
                    }
                    widget = previousContainer && previousContainer.constructor === widget.containerWidget.constructor ?
                        previousContainer.lastChild : undefined;
                }
            }
            return widget;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "nextRenderedWidget", {
        /**
         * @private
         */
        get: function () {
            var widget = this;
            var index = this.indexInOwner;
            if (index < 0) {
                return undefined;
            }
            if (widget instanceof BodyWidget) {
                if (index < widget.page.bodyWidgets.length - 1) {
                    widget = widget.page.bodyWidgets[index + 1];
                }
                else {
                    var page = widget.page.nextPage;
                    widget = page && page.bodyWidgets.length > 0 ? page.bodyWidgets[0] : undefined;
                }
            }
            else {
                if (index < widget.containerWidget.childWidgets.length - 1) {
                    widget = widget.containerWidget.childWidgets[index + 1];
                }
                else {
                    var nextContainer = undefined;
                    if (widget.containerWidget instanceof TableCellWidget) {
                        nextContainer = widget.containerWidget.getNextSplitWidget();
                    }
                    else if (!(widget.containerWidget instanceof TableRowWidget
                        || widget.containerWidget instanceof HeaderFooterWidget)) {
                        // Since cells are lay outed left to right, we should not navigate to next row.
                        nextContainer = widget.containerWidget.nextRenderedWidget;
                    }
                    while (nextContainer && nextContainer.childWidgets.length === 0 && !(nextContainer instanceof TableCellWidget)) {
                        nextContainer = nextContainer.nextRenderedWidget;
                        if (isNullOrUndefined(nextContainer)) {
                            break;
                        }
                    }
                    widget = nextContainer && nextContainer.constructor === widget.containerWidget.constructor ?
                        nextContainer.firstChild : undefined;
                }
            }
            return widget;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "previousSplitWidget", {
        /**
         * @private
         */
        get: function () {
            var widget = this;
            if (widget instanceof TableCellWidget) {
                return widget.getPreviousSplitWidget();
            }
            else {
                var previous = widget.previousRenderedWidget;
                if (widget instanceof BodyWidget && previous instanceof BodyWidget && widget.equals(previous)) {
                    return previous;
                }
                else if (previous instanceof BlockWidget && widget.index === previous.index && widget.equals(previous)) {
                    return previous;
                }
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "nextSplitWidget", {
        /**
         * @private
         */
        get: function () {
            var widget = this;
            if (widget instanceof TableCellWidget) {
                return widget.getNextSplitWidget();
            }
            else {
                var next = widget.nextRenderedWidget;
                if (widget instanceof BodyWidget && next instanceof BodyWidget && widget.equals(next)) {
                    return next;
                }
                else if (next instanceof BlockWidget && widget.index === next.index && widget.equals(next)) {
                    return next;
                }
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    Widget.prototype.getPreviousSplitWidgets = function () {
        var widgets = [];
        var widget = this.previousSplitWidget;
        while (widget) {
            widgets.unshift(widget);
            widget = widget.previousSplitWidget;
        }
        return widgets;
    };
    /**
     * @private
     */
    Widget.prototype.getSplitWidgets = function () {
        var widgets = this.getPreviousSplitWidgets();
        var widget = this;
        while (widget) {
            widgets.push(widget);
            widget = widget.nextSplitWidget;
        }
        return widgets;
    };
    /**
     * @private
     */
    Widget.prototype.combineWidget = function (viewer) {
        var root = this;
        var widgets = this.getSplitWidgets();
        if (widgets.length > 1) {
            root = widgets.shift();
            while (widgets.length > 0) {
                var splitWidget = widgets.shift();
                root.combine(splitWidget, viewer);
            }
        }
        if (root instanceof TableWidget) {
            root.combineRows(viewer);
        }
        return root;
    };
    Widget.prototype.combine = function (widget, viewer) {
        if (widget.childWidgets.length > 0) {
            var lastChild = this.lastChild;
            if (lastChild instanceof TableWidget) {
                lastChild.combineWidget(viewer);
            }
            else {
                var firstChild = widget.firstChild;
                if (!(widget instanceof TableWidget) && lastChild instanceof Widget && firstChild instanceof Widget &&
                    lastChild.index === firstChild.index) {
                    lastChild.combine(widget.childWidgets.shift(), viewer);
                }
            }
            this.addWidgets(widget.childWidgets);
            widget.childWidgets = [];
        }
        widget.destroyInternal(viewer);
    };
    /**
     * @private
     */
    Widget.prototype.addWidgets = function (childWidgets) {
        while (childWidgets.length > 0) {
            var widget = childWidgets.shift();
            if (widget instanceof LineWidget && this instanceof ParagraphWidget) {
                widget.paragraph = this;
                this.height += widget.height;
            }
            else if (widget instanceof Widget) {
                var lastChild = this.lastChild;
                widget.containerWidget = this;
                widget.y = lastChild instanceof Widget ? lastChild.y + lastChild.height : this.y;
                this.height += widget.height;
            }
            this.childWidgets.push(widget);
        }
    };
    /**
     * @private
     */
    Widget.prototype.removeChild = function (index) {
        if (index > -1 && index < this.childWidgets.length) {
            this.childWidgets.splice(index, 1);
        }
    };
    /**
     * @private
     */
    Widget.prototype.destroy = function () {
        if (this.childWidgets) {
            while (this.childWidgets.length > 0) {
                var child = this.childWidgets.pop();
                if (child instanceof LineWidget || child instanceof Widget) {
                    child.destroy();
                }
            }
        }
        this.childWidgets = undefined;
        if (this.containerWidget) {
            this.containerWidget.removeChild(this.indexInOwner);
        }
        this.containerWidget = undefined;
        // if (this.margin) {
        //     this.margin.destroy();
        // }
        this.margin = undefined;
        this.x = undefined;
        this.y = undefined;
        this.width = undefined;
        this.height = undefined;
        this.index = undefined;
    };
    return Widget;
}());
export { Widget };
/**
 * @private
 */
var BlockContainer = /** @class */ (function (_super) {
    __extends(BlockContainer, _super);
    function BlockContainer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * @private
         */
        _this.sectionFormatIn = undefined;
        return _this;
    }
    Object.defineProperty(BlockContainer.prototype, "sectionFormat", {
        /**
         * @private
         */
        get: function () {
            var container = this;
            if (container instanceof BodyWidget) {
                return container.sectionFormatIn;
            }
            else if (container.page) {
                return container.page.bodyWidgets[0].sectionFormat;
            }
            return undefined;
        },
        /**
         * @private
         */
        set: function (value) {
            if (this instanceof BodyWidget) {
                this.sectionFormatIn = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BlockContainer.prototype, "sectionIndex", {
        /**
         * @private
         */
        get: function () {
            var container = this;
            var index = 0;
            if (container instanceof BodyWidget) {
                index = container.index;
            }
            else if (container.page) {
                index = container.page.bodyWidgets[0].index;
            }
            return index;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    BlockContainer.prototype.getHierarchicalIndex = function (hierarchicalIndex) {
        var viewer = undefined;
        var node = this;
        if (node instanceof BodyWidget) {
            hierarchicalIndex = node.index + ';' + hierarchicalIndex;
        }
        else {
            if (node.headerFooterType.indexOf('Header') !== -1) {
                hierarchicalIndex = 'H' + ';' + hierarchicalIndex;
            }
            else {
                hierarchicalIndex = 'F' + ';' + hierarchicalIndex;
            }
        }
        if (!isNullOrUndefined(node.page)) {
            viewer = this.page.viewer;
            var pageIndex = viewer.pages.indexOf(this.page);
            return pageIndex + ';' + hierarchicalIndex;
        }
        return hierarchicalIndex;
    };
    return BlockContainer;
}(Widget));
export { BlockContainer };
/**
 * @private
 */
var BodyWidget = /** @class */ (function (_super) {
    __extends(BodyWidget, _super);
    /**
     * Initialize the constructor of BodyWidget
     */
    function BodyWidget() {
        return _super.call(this) || this;
    }
    /**
     * @private
     */
    BodyWidget.prototype.equals = function (widget) {
        return widget instanceof BodyWidget && widget.sectionFormat === this.sectionFormat;
    };
    /**
     * @private
     */
    BodyWidget.prototype.getHierarchicalIndex = function (hierarchicalIndex) {
        var viewer = undefined;
        var node = this;
        hierarchicalIndex = node.index + ';' + hierarchicalIndex;
        if (!isNullOrUndefined(node.page)) {
            viewer = this.page.viewer;
            var pageIndex = viewer.pages.indexOf(this.page);
            return pageIndex + ';' + hierarchicalIndex;
        }
        return hierarchicalIndex;
    };
    /**
     * @private
     */
    BodyWidget.prototype.getTableCellWidget = function (touchPoint) {
        for (var i = 0; i < this.childWidgets.length; i++) {
            if (this.childWidgets[i].y <= touchPoint.y
                && (this.childWidgets[i].y + this.childWidgets[i].height) >= touchPoint.y) {
                return this.childWidgets[i].getTableCellWidget(touchPoint);
            }
        }
        var tableCellWidget = undefined;
        if (this.childWidgets.length > 0) {
            if (this.childWidgets[0].y <= touchPoint.y) {
                tableCellWidget = this.childWidgets[this.childWidgets.length - 1].getTableCellWidget(touchPoint);
            }
            else {
                tableCellWidget = this.childWidgets[0].getTableCellWidget(touchPoint);
            }
        }
        return tableCellWidget;
    };
    /**
     * @private
     */
    BodyWidget.prototype.destroyInternal = function (viewer) {
        var height = this.height;
        if (!isNullOrUndefined(this.childWidgets)) {
            for (var n = 0; n < this.childWidgets.length; n++) {
                var chilgWidget = this.childWidgets[n];
                if (chilgWidget instanceof ParagraphWidget) {
                    chilgWidget.destroyInternal(viewer);
                }
                else {
                    chilgWidget.destroyInternal(viewer);
                }
                if (isNullOrUndefined(this.childWidgets)) {
                    break;
                }
                n--;
            }
            this.childWidgets = undefined;
        }
        // if (this instanceof HeaderFooterWidget && ((this as HeaderFooterWidget).currentNode ))) {
        //     if (((this as HeaderFooterWidget).currentNode as WHeaderFooter).layoutedWidgets )) {
        //         let index: number = ((this as HeaderFooterWidget).currentNode as WHeaderFooter).layoutedWidgets.indexOf(this);
        //         ((this as HeaderFooterWidget).currentNode as WHeaderFooter).layoutedWidgets.splice(index, 1);
        //     }
        //     this.currentNode = undefined;
        /* tslint:disable: one-line */
        if (!isNullOrUndefined(this.page)) {
            var index = this.indexInOwner;
            if (this.indexInOwner > -1) {
                this.page.bodyWidgets.splice(index, 1);
                if (this.page.bodyWidgets.length === 0) {
                    this.page.destroy();
                    // }
                }
                else if ((this instanceof HeaderFooterWidget)
                    && this.page.headerWidget === this) {
                    this.page.headerWidget = undefined;
                }
                else if ((this instanceof HeaderFooterWidget)
                    && this.page.footerWidget === this) {
                    this.page.footerWidget = undefined;
                }
                this.page = undefined;
            }
        }
        this.destroy();
    };
    /**
     * @private
     */
    BodyWidget.prototype.destroy = function () {
        // if (this.sectionFormat) {
        //     this.sectionFormat.destroy();
        // }
        this.sectionFormat = undefined;
        this.page = undefined;
        _super.prototype.destroy.call(this);
    };
    return BodyWidget;
}(BlockContainer));
export { BodyWidget };
/**
 * @private
 */
var HeaderFooterWidget = /** @class */ (function (_super) {
    __extends(HeaderFooterWidget, _super);
    function HeaderFooterWidget(type) {
        var _this = _super.call(this) || this;
        _this.headerFooterType = type;
        return _this;
    }
    /**
     * @private
     */
    HeaderFooterWidget.prototype.getTableCellWidget = function (point) {
        return undefined;
    };
    /**
     * @private
     */
    HeaderFooterWidget.prototype.equals = function (widget) {
        // Todo: Need to work
        return widget instanceof HeaderFooterWidget
            && widget.containerWidget === this.containerWidget;
    };
    /**
     * @private
     */
    HeaderFooterWidget.prototype.clone = function () {
        var headerFooter = new HeaderFooterWidget(this.headerFooterType);
        for (var i = 0; i < this.childWidgets.length; i++) {
            var block = this.childWidgets[i].clone();
            headerFooter.childWidgets.push(block);
            block.index = i;
            block.containerWidget = headerFooter;
        }
        headerFooter.x = this.x;
        headerFooter.y = this.y;
        headerFooter.height = 0;
        headerFooter.width = 0;
        return headerFooter;
    };
    /**
     * @private
     */
    HeaderFooterWidget.prototype.destroyInternal = function (viewer) {
        this.page = undefined;
        _super.prototype.destroy.call(this);
    };
    return HeaderFooterWidget;
}(BlockContainer));
export { HeaderFooterWidget };
/**
 * @private
 */
var BlockWidget = /** @class */ (function (_super) {
    __extends(BlockWidget, _super);
    function BlockWidget() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(BlockWidget.prototype, "bodyWidget", {
        /**
         * @private
         */
        get: function () {
            var widget = this;
            while (widget.containerWidget) {
                if (widget.containerWidget instanceof BlockContainer) {
                    return widget.containerWidget;
                }
                widget = widget.containerWidget;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BlockWidget.prototype, "leftIndent", {
        /**
         * @private
         */
        get: function () {
            var blockAdv = this;
            if (blockAdv instanceof ParagraphWidget && blockAdv.paragraphFormat instanceof WParagraphFormat) {
                return blockAdv.paragraphFormat.leftIndent;
            }
            else if (blockAdv instanceof TableWidget && blockAdv.tableFormat instanceof WTableFormat) {
                return blockAdv.tableFormat.leftIndent;
            }
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BlockWidget.prototype, "rightIndent", {
        /**
         * @private
         */
        get: function () {
            var blockAdv = this;
            if (blockAdv instanceof ParagraphWidget && blockAdv.paragraphFormat instanceof WParagraphFormat) {
                return blockAdv.paragraphFormat.rightIndent;
            }
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BlockWidget.prototype, "isInsideTable", {
        /**
         * @private
         */
        get: function () {
            return this.containerWidget instanceof TableCellWidget;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BlockWidget.prototype, "isInHeaderFooter", {
        /**
         * @private
         */
        get: function () {
            return this.bodyWidget instanceof HeaderFooterWidget;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BlockWidget.prototype, "associatedCell", {
        /**
         * @private
         */
        get: function () {
            if (this.containerWidget instanceof TableCellWidget) {
                return this.containerWidget;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Check whether the paragraph contains only page break.
     * @private
     */
    BlockWidget.prototype.isPageBreak = function () {
        var isPageBreak = false;
        if (this instanceof ParagraphWidget) {
            var paragraph = this;
            if (paragraph != null && paragraph.childWidgets.length === 1 &&
                paragraph.firstChild.children.length === 1) {
                var pageBreak = paragraph.firstChild.children[0];
                isPageBreak = pageBreak.isPageBreak;
            }
        }
        return isPageBreak;
    };
    /**
     * @private
     */
    BlockWidget.prototype.getHierarchicalIndex = function (hierarchicalIndex) {
        var node = this;
        hierarchicalIndex = node.containerWidget.childWidgets.indexOf(node) + ';' + hierarchicalIndex;
        if (!isNullOrUndefined(node.containerWidget)) {
            if (node.containerWidget instanceof BlockWidget) {
                return node.containerWidget.getHierarchicalIndex(hierarchicalIndex);
            }
            else if (node.containerWidget instanceof BlockContainer) {
                hierarchicalIndex = node.containerWidget.getHierarchicalIndex(hierarchicalIndex);
            }
        }
        return hierarchicalIndex;
    };
    /**
     * @private
     */
    BlockWidget.prototype.getIndex = function () {
        if (this instanceof ParagraphWidget || this instanceof TableWidget) {
            return this.containerWidget.childWidgets.indexOf(this);
        }
        else if (this instanceof TableRowWidget) {
            return this.ownerTable.childWidgets.indexOf(this);
        }
        else if (this instanceof TableCellWidget) {
            return this.ownerRow.childWidgets.indexOf(this);
        }
        return 0;
    };
    /**
     * @private
     */
    BlockWidget.prototype.getContainerWidth = function () {
        if (this.isInsideTable) {
            return this.associatedCell.cellFormat.cellWidth - (this.associatedCell.margin.left + this.associatedCell.margin.right);
        }
        else {
            var bodyWidget = this.bodyWidget;
            var sectionFormat = bodyWidget.sectionFormat;
            return sectionFormat.pageWidth - (sectionFormat.leftMargin + sectionFormat.rightMargin);
        }
    };
    return BlockWidget;
}(Widget));
export { BlockWidget };
/**
 * @private
 */
var ParagraphWidget = /** @class */ (function (_super) {
    __extends(ParagraphWidget, _super);
    /**
     * Initialize the constructor of ParagraphWidget
     */
    function ParagraphWidget() {
        var _this = _super.call(this) || this;
        _this.paragraphFormat = new WParagraphFormat(_this);
        _this.characterFormat = new WCharacterFormat(_this);
        return _this;
    }
    Object.defineProperty(ParagraphWidget.prototype, "isEndsWithPageBreak", {
        /**
         * @private
         */
        get: function () {
            if (this.childWidgets.length > 0) {
                return this.lastChild.isEndsWithPageBreak;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ParagraphWidget.prototype.equals = function (widget) {
        return widget instanceof ParagraphWidget && widget.paragraphFormat === this.paragraphFormat;
    };
    /**
     * @private
     */
    ParagraphWidget.prototype.isEmpty = function () {
        if (isNullOrUndefined(this.childWidgets) || this.childWidgets.length === 0) {
            return true;
        }
        for (var j = 0; j < this.childWidgets.length; j++) {
            var inlineElement = this.childWidgets[j];
            for (var i = 0; i < inlineElement.children.length; i++) {
                var inline = inlineElement.children[i];
                if (inline.length === 0) {
                    continue;
                }
                if (inline instanceof TextElementBox || inline instanceof ImageElementBox || inline instanceof BookmarkElementBox
                    || (inline instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(inline))) {
                    return false;
                }
            }
        }
        return true;
    };
    /**
     * @private
     */
    ParagraphWidget.prototype.getInline = function (offset, indexInInline) {
        var inline = undefined;
        var count = 0;
        var isStarted = false;
        var splittedWidget = this.getSplitWidgets();
        for (var k = 0; k < splittedWidget.length; k++) {
            var widget = splittedWidget[k];
            for (var j = 0; j < widget.childWidgets.length; j++) {
                var line = widget.childWidgets[j];
                for (var i = 0; i < line.children.length; i++) {
                    inline = line.children[i];
                    if (inline instanceof ListTextElementBox) {
                        continue;
                    }
                    if (!isStarted && (inline instanceof TextElementBox || inline instanceof ImageElementBox
                        || inline instanceof BookmarkElementBox || inline instanceof FieldElementBox
                        && HelperMethods.isLinkedFieldCharacter(inline))) {
                        isStarted = true;
                    }
                    if (isStarted && offset <= count + inline.length) {
                        indexInInline = (offset - count);
                        return { 'element': inline, 'index': indexInInline };
                    }
                    count += inline.length;
                }
            }
        }
        if (offset > count) {
            indexInInline = isNullOrUndefined(inline) ? offset : inline.length;
        }
        return { 'element': inline, 'index': indexInInline };
    };
    /**
     * @private
     */
    ParagraphWidget.prototype.getLength = function () {
        var length = 0;
        for (var j = 0; j < this.childWidgets.length; j++) {
            var line = this.childWidgets[j];
            for (var i = 0; i < line.children.length; i++) {
                var element = line.children[i];
                if (element instanceof ListTextElementBox) {
                    continue;
                }
                length += element.length;
            }
        }
        return length;
    };
    /**
     * @private
     */
    ParagraphWidget.prototype.getTableCellWidget = function (point) {
        return undefined;
    };
    /**
     * @private
     */
    ParagraphWidget.prototype.clone = function () {
        var paragraph = new ParagraphWidget();
        paragraph.paragraphFormat.copyFormat(this.paragraphFormat);
        paragraph.characterFormat.copyFormat(this.characterFormat);
        for (var i = 0; i < this.childWidgets.length; i++) {
            var line = this.childWidgets[i];
            var cloneLine = line.clone();
            paragraph.childWidgets.push(cloneLine);
            cloneLine.paragraph = paragraph;
        }
        paragraph.x = this.x;
        paragraph.y = this.y;
        paragraph.height = this.height;
        paragraph.width = this.width;
        return paragraph;
    };
    /**
     * @private
     */
    ParagraphWidget.prototype.destroyInternal = function (viewer) {
        var height = this.height;
        if (!isNullOrUndefined(this.childWidgets)) {
            for (var i = 0; i < this.childWidgets.length; i++) {
                var widget = this.childWidgets[i];
                widget.destroy();
                if (this.childWidgets.length === 1 && isNullOrUndefined(this.childWidgets[0].children)) {
                    this.childWidgets = undefined;
                }
                if (isNullOrUndefined(this.childWidgets)) {
                    break;
                }
                i--;
            }
            this.childWidgets = undefined;
        }
        if (!isNullOrUndefined(this.containerWidget) && !isNullOrUndefined(this.containerWidget.childWidgets)
            && this.containerWidget.childWidgets.indexOf(this) !== -1) {
            this.containerWidget.childWidgets.splice(this.containerWidget.childWidgets.indexOf(this), 1);
            this.containerWidget.height -= height;
            // if ((isNullOrUndefined(this.containerWidget.childWidgets) || this.containerWidget.childWidgets.length === 0)
            //     && this.containerWidget instanceof BodyWidget) {
            //     // (this.containerWidget as BodyWidget).destroyInternal(viewer);
            // }
            this.containerWidget = undefined;
        }
        this.destroy();
    };
    /**
     * @private
     */
    ParagraphWidget.prototype.destroy = function () {
        // if (this.paragraphFormat) {
        //     this.paragraphFormat.destroy();
        // }
        this.paragraphFormat = undefined;
        // if (this.characterFormat) {
        //     this.characterFormat.destroy();
        // }
        this.characterFormat = undefined;
        _super.prototype.destroy.call(this);
    };
    return ParagraphWidget;
}(BlockWidget));
export { ParagraphWidget };
/**
 * @private
 */
var TableWidget = /** @class */ (function (_super) {
    __extends(TableWidget, _super);
    function TableWidget() {
        var _this = _super.call(this) || this;
        _this.flags = 0;
        /**
         * @private
         */
        _this.leftMargin = 0;
        /**
         * @private
         */
        _this.topMargin = 0;
        /**
         * @private
         */
        _this.rightMargin = 0;
        /**
         * @private
         */
        _this.bottomMargin = 0;
        _this.margin = new Margin(_this.leftMargin, _this.topMargin, _this.rightMargin, _this.bottomMargin);
        _this.leftBorderWidth = 0;
        _this.rightBorderWidth = 0;
        _this.topBorderWidth = 0;
        _this.bottomBorderWidth = 0;
        _this.tableFormat = new WTableFormat(_this);
        _this.tableHolder = new WTableHolder();
        _this.spannedRowCollection = new Dictionary();
        return _this;
    }
    Object.defineProperty(TableWidget.prototype, "isGridUpdated", {
        /**
         * @private
         */
        get: function () {
            return ((this.flags & 0x4) >> 2) !== 0;
        },
        /**
         * @private
         */
        set: function (value) {
            this.flags = ((this.flags & 0xFB) | ((value ? 1 : 0) << 2));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableWidget.prototype, "continueHeader", {
        /**
         * @private
         */
        get: function () {
            return ((this.flags & 0x2) >> 1) !== 0;
        },
        /**
         * @private
         */
        set: function (value) {
            this.flags = ((this.flags & 0xFD) | ((value ? 1 : 0) << 1));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableWidget.prototype, "header", {
        /**
         * @private
         */
        get: function () {
            return (this.flags & 0x1) !== 0;
        },
        /**
         * @private
         */
        set: function (value) {
            this.flags = ((this.flags & 0xFE) | (value ? 1 : 0));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    TableWidget.prototype.equals = function (widget) {
        return widget instanceof TableWidget && widget.tableFormat === this.tableFormat;
    };
    /**
     * @private
     */
    TableWidget.prototype.combineRows = function (viewer) {
        for (var i = 0; i < this.childWidgets.length; i++) {
            var row = this.childWidgets[i];
            if (row.childWidgets.length === 0) {
                row.destroy();
                i--;
            }
            else {
                row.combineCells(viewer);
            }
        }
    };
    /**
     * @private
     */
    TableWidget.prototype.contains = function (tableCell) {
        if (this.equals(tableCell.ownerTable)) {
            return true;
        }
        while (tableCell.ownerTable.isInsideTable) {
            if (this.equals(tableCell.ownerTable)) {
                return true;
            }
            tableCell = tableCell.ownerTable.associatedCell;
        }
        return this.equals(tableCell.ownerTable);
    };
    /**
     * @private
     */
    TableWidget.prototype.getOwnerWidth = function (isBasedOnViewer) {
        var width = this.getContainerWidth();
        // Left and right indents should be neglected.
        width = width - this.leftIndent - this.rightIndent;
        return width >= 0 ? width : 0;
    };
    TableWidget.prototype.getTableWidth = function () {
        var width = 0;
        for (var i = 0; i < this.childWidgets.length; i++) {
            var rowWidth = 0;
            var row = this.childWidgets[i];
            for (var j = 0; j < row.childWidgets.length; j++) {
                rowWidth += row.childWidgets[j].cellFormat.cellWidth;
            }
            if (width < rowWidth) {
                width = rowWidth;
            }
        }
        return width;
    };
    /**
     * @private
     */
    TableWidget.prototype.getTableClientWidth = function (clientWidth) {
        var tableWidth = clientWidth;
        if (this.tableFormat.preferredWidthType === 'Point'
            && this.tableFormat.preferredWidth > 0) {
            tableWidth = this.tableFormat.preferredWidth;
        }
        else {
            if (this.tableFormat.preferredWidthType === 'Percent'
                && this.tableFormat.preferredWidth > 0) {
                tableWidth = tableWidth * this.tableFormat.preferredWidth / 100;
            }
            else {
                //By default, if Table preferred widthType is auto , width is set based on ClientWidth and type is set as 'Point'
                this.tableFormat.preferredWidthType = 'Point';
                this.tableFormat.preferredWidth = tableWidth;
            }
        }
        return tableWidth;
    };
    /**
     * @private
     */
    TableWidget.prototype.getCellWidth = function (preferredWidth, preferredWidthType, containerWidth, cell) {
        var cellWidth = preferredWidth;
        if (preferredWidthType === 'Percent') {
            cellWidth = (preferredWidth * containerWidth) / 100;
        }
        else if (preferredWidthType === 'Point') {
            cellWidth = preferredWidth;
        }
        else if (!isNullOrUndefined(cell)) {
            cellWidth = cell.getMinimumPreferredWidth();
        }
        return cellWidth;
    };
    /**
     * @private
     */
    TableWidget.prototype.fitCellsToClientArea = function (clientWidth) {
        var tableWidth = this.getTableWidth();
        var factor = clientWidth / tableWidth;
        for (var i = 0; i < this.childWidgets.length; i++) {
            var row = this.childWidgets[i];
            row.rowFormat.gridAfterWidth *= factor;
            row.rowFormat.gridBeforeWidth *= factor;
            for (var j = 0; j < row.childWidgets.length; j++) {
                row.childWidgets[j].cellFormat.cellWidth *= factor;
            }
        }
    };
    /**
     * @private
     */
    TableWidget.prototype.getTableCellWidget = function (point) {
        var tableCellWidget = undefined;
        for (var i = 0; i < this.childWidgets.length; i++) {
            if (this.childWidgets[i].y <= point.y
                && (this.childWidgets[i].y + this.childWidgets[i].height) >= point.y) {
                tableCellWidget = this.childWidgets[i].getTableCellWidget(point);
                break;
            }
        }
        return tableCellWidget;
    };
    /**
     * @private
     */
    //tslint:disable: max-func-body-length
    TableWidget.prototype.calculateGrid = function () {
        var tempGrid = [];
        var spannedCells = [];
        var containerWidth = this.getOwnerWidth(true);
        var tableWidth = this.getTableClientWidth(containerWidth);
        this.tableCellInfo = new Dictionary();
        for (var i = 0; i < this.childWidgets.length; i++) {
            var row = this.childWidgets[i];
            var rowCellInfo = new Dictionary();
            var rowFormat = row.rowFormat;
            var cellWidth = 0;
            var columnSpan = row.rowFormat.gridBefore;
            var currOffset = 0;
            if (tempGrid.indexOf(currOffset) < 0) {
                tempGrid.push(currOffset);
            }
            //Converts the row grid before width from point to twips point by 15 factor.
            cellWidth = this.getCellWidth(rowFormat.gridBeforeWidth, rowFormat.gridBeforeWidthType, tableWidth, null);
            currOffset += cellWidth;
            var startOffset = Math.round(currOffset);
            if (tempGrid.indexOf(startOffset) < 0) {
                tempGrid.push(startOffset);
            }
            for (var j = 0; j < row.childWidgets.length; j++) {
                var cell = row.childWidgets[j];
                for (var k = 0; k < spannedCells.length; k++) {
                    if (spannedCells[k].columnIndex < columnSpan) {
                        continue;
                    }
                    var rowSpan = spannedCells[k].cellFormat.rowSpan;
                    var removeSpannedCell = true;
                    if (spannedCells[k].columnIndex > columnSpan) {
                        {
                            removeSpannedCell = false;
                            // If the cell is the last cell in the row and the row has grid after value..
                            if (j === row.childWidgets.length - 1 && row.rowFormat.gridAfter > 0) {
                                // tslint:disable-next-line:max-line-length
                                cellWidth = this.getCellWidth(spannedCells[k].cellFormat.preferredWidth, spannedCells[k].cellFormat.preferredWidthType, tableWidth, null);
                                currOffset += cellWidth;
                            }
                        }
                    }
                    else {
                        // If the table gird alone calculted then column index of the rowspanned cell will be directly taken. 
                        // If the gird calculation is done from the UI level opearations such as resizing then table holder 
                        // will have the columns at that time we can get the column index from the table holder.
                        //Converts the cell width from point to twips point by 15 factor.
                        // tslint:disable-next-line:max-line-length
                        cellWidth = this.getCellWidth(spannedCells[k].cellFormat.preferredWidth, spannedCells[k].cellFormat.preferredWidthType, tableWidth, null);
                        currOffset += cellWidth;
                        columnSpan = spannedCells[k].columnIndex + spannedCells[k].cellFormat.columnSpan;
                    }
                    if (!removeSpannedCell && j === row.childWidgets.length - 1) {
                        removeSpannedCell = true;
                    }
                    if (removeSpannedCell && i - spannedCells[k].ownerRow.rowIndex === rowSpan - 1) {
                        spannedCells.splice(k, 1);
                        k--;
                    }
                }
                // At the start of each row, we will process the row spanned cells to get the start column index.
                // To calculate grid properly, we need the items in the spanned cells collection in the order of their column index
                if (cell.cellFormat.rowSpan > 1) {
                    if (spannedCells.length === 0 || spannedCells[spannedCells.length - 1].columnIndex <= columnSpan) {
                        spannedCells.push(cell);
                    }
                    else {
                        for (var m = spannedCells.length; m > 0; m--) {
                            if (spannedCells[m - 1].columnIndex > columnSpan) {
                                spannedCells.splice(m - 1, 0, cell);
                            }
                        }
                    }
                }
                // Add start offset of each cell based on its index
                if (!rowCellInfo.containsKey(cell.cellIndex)) {
                    rowCellInfo.add(cell.cellIndex, Math.round(currOffset - startOffset));
                }
                columnSpan += cell.cellFormat.columnSpan;
                //Converts the cell width from pixel to twips point by 15 factor.
                cellWidth = this.getCellWidth(cell.cellFormat.preferredWidth, cell.cellFormat.preferredWidthType, tableWidth, null);
                currOffset += cellWidth;
                var offset = Math.round(currOffset);
                if (tempGrid.indexOf(offset) < 0) {
                    tempGrid.push(offset);
                }
                if (j === row.childWidgets.length - 1 && rowFormat.gridAfter > 0) {
                    cellWidth = this.getCellWidth(rowFormat.gridAfterWidth, 'Point', tableWidth, null);
                    currOffset += cellWidth;
                    if (tempGrid.indexOf(Math.round(currOffset)) < 0) {
                        tempGrid.push(Math.round(currOffset));
                    }
                    columnSpan += rowFormat.gridAfter;
                }
                // Add rowindex and its cells info for each row
                if (!this.tableCellInfo.containsKey(row.rowIndex)) {
                    this.tableCellInfo.add(row.rowIndex, rowCellInfo);
                }
            }
        }
        tempGrid.sort(function (a, b) { return a - b; });
        if (tempGrid.length - 1 !== this.tableHolder.columns.length) {
            this.updateColumnSpans(tempGrid, tableWidth);
        }
        this.tableCellInfo.clear();
        this.tableCellInfo = undefined;
    };
    TableWidget.prototype.updateColumnSpans = function (tempGrid, containerWidth) {
        for (var i = 0; i < this.childWidgets.length; i++) {
            var row = this.childWidgets[i];
            if (row.rowFormat.gridBeforeWidth >= 0) {
                row.rowFormat.gridBefore = row.getGridCount(tempGrid, undefined, -1, containerWidth);
            }
            for (var j = 0; j < row.childWidgets.length; j++) {
                var cell = row.childWidgets[j];
                var columnSpan = row.getGridCount(tempGrid, cell, cell.getIndex(), containerWidth);
                if (columnSpan > 0 && cell.cellFormat.columnSpan !== columnSpan) {
                    cell.cellFormat.columnSpan = columnSpan;
                }
            }
            if (row.rowFormat.gridAfterWidth >= 0) {
                row.rowFormat.gridAfter = row.getGridCount(tempGrid, undefined, row.childWidgets.length, containerWidth);
            }
        }
    };
    /**
     * @private
     */
    TableWidget.prototype.buildTableColumns = function () {
        if (this.isGridUpdated) {
            return;
        }
        // Clear existing columns in order to start creating columns freshly.
        this.tableHolder.resetColumns();
        var containerWidth = 0;
        var tableWidth = 0;
        var rowSpannedCells = [];
        var isAutoWidth = this.tableFormat.preferredWidthType === 'Auto';
        // For continuous layout, window width should be considered. 
        // If preferred width exceeds this limit, it can take upto maximum of 2112 pixels (1584 points will be assigned by Microsoft Word).
        containerWidth = this.getOwnerWidth(true);
        tableWidth = this.getTableClientWidth(containerWidth);
        for (var i = 0; i < this.childWidgets.length; i++) {
            var row = this.childWidgets[i];
            var rowFormat = row.rowFormat;
            var columnSpan = 0;
            var cellWidth = 0;
            var offset = 0;
            if (rowFormat.gridBefore > 0) {
                cellWidth = this.getCellWidth(rowFormat.gridBeforeWidth, row.rowFormat.gridAfterWidthType, tableWidth, null);
                this.tableHolder.addColumns(columnSpan, columnSpan = rowFormat.gridBefore, cellWidth, cellWidth, offset = cellWidth);
            }
            for (var j = 0; j < row.childWidgets.length; j++) {
                var cell = row.childWidgets[j];
                if (rowSpannedCells.length === 0) {
                    cell.columnIndex = columnSpan;
                }
                for (var k = 0; k < rowSpannedCells.length; k++) {
                    var rowSpannedCell = rowSpannedCells[k];
                    if (rowSpannedCell.columnIndex < columnSpan) {
                        cell.columnIndex = columnSpan;
                        continue;
                    }
                    var rowSpan = 1;
                    var removeSpannedCell = true;
                    rowSpan = rowSpannedCell.cellFormat.rowSpan;
                    if (rowSpannedCell.columnIndex > columnSpan) {
                        cell.columnIndex = columnSpan;
                        removeSpannedCell = false;
                    }
                    else {
                        // tslint:disable-next-line:max-line-length
                        cellWidth = this.getCellWidth(rowSpannedCell.cellFormat.preferredWidth, rowSpannedCell.cellFormat.preferredWidthType, tableWidth, rowSpannedCell);
                        var minWidth_1 = rowSpannedCell.getMinimumPreferredWidth();
                        // If the table gird alone calculted then column index of the rowspanned cell will be directly taken. 
                        // tslint:disable-next-line:max-line-length
                        // If the gird calculation is done from the UI level opearations such as resizing then table holder will have the columns at that time we can get the column index from the table holder.
                        // tslint:disable-next-line:max-line-length
                        if (this.tableHolder.columns.length > 0) {
                            this.tableHolder.addColumns(columnSpan, columnSpan = this.tableHolder.columns.indexOf(rowSpannedCell.ownerColumn) + rowSpannedCell.cellFormat.columnSpan, cellWidth, minWidth_1, offset += cellWidth);
                            cell.columnIndex = columnSpan;
                        }
                        else {
                            // tslint:disable-next-line:max-line-length
                            this.tableHolder.addColumns(columnSpan, columnSpan = rowSpannedCell.columnIndex + rowSpannedCell.cellFormat.columnSpan, cellWidth, minWidth_1, offset += cellWidth);
                            cell.columnIndex = columnSpan;
                        }
                    }
                    if (!removeSpannedCell && j === row.childWidgets.length - 1) {
                        removeSpannedCell = true;
                    }
                    if (removeSpannedCell && i - rowSpannedCell.ownerRow.rowIndex === rowSpan - 1) {
                        rowSpannedCells.splice(k, 1);
                        k--;
                    }
                }
                // At the start of each row, we will process the row spanned cells to get the start column index.
                // To calculate grid properly, we need the items in the spanned cells collection in the order of their column index
                if (cell.cellFormat.rowSpan > 1) {
                    if (rowSpannedCells.length === 0 || rowSpannedCells[rowSpannedCells.length - 1].columnIndex <= columnSpan) {
                        rowSpannedCells.push(cell);
                    }
                    else {
                        for (var m = rowSpannedCells.length; m > 0; m--) {
                            if (rowSpannedCells[m - 1].columnIndex > columnSpan) {
                                rowSpannedCells.splice(m - 1, 0, cell);
                            }
                        }
                    }
                }
                cellWidth = this.getCellWidth(cell.cellFormat.preferredWidth, cell.cellFormat.preferredWidthType, tableWidth, cell);
                var minWidth = cell.getMinimumPreferredWidth();
                this.tableHolder.addColumns(columnSpan, columnSpan += cell.cellFormat.columnSpan, cellWidth, minWidth, offset += cellWidth);
                if (j === row.childWidgets.length - 1 && rowFormat.gridAfterWidth > 0) {
                    cellWidth = this.getCellWidth(rowFormat.gridAfterWidth, 'Point', tableWidth, null);
                    this.tableHolder.addColumns(columnSpan, columnSpan += rowFormat.gridAfter, cellWidth, cellWidth, offset += cellWidth);
                }
            }
        }
        this.tableHolder.validateColumnWidths();
        // Fits the column width based on preferred width. i.e. Fixed layout.
        this.tableHolder.fitColumns(containerWidth, tableWidth, isAutoWidth);
        //Sets the width to cells
        this.setWidthToCells(tableWidth, isAutoWidth);
    };
    /**
     * @private
     */
    TableWidget.prototype.setWidthToCells = function (tableWidth, isAutoWidth) {
        for (var i = 0; i < this.childWidgets.length; i++) {
            var rw = this.childWidgets[i];
            var rowFormat = rw.rowFormat;
            if (rowFormat.gridBefore > 0) {
                rowFormat.beforeWidth = this.tableHolder.getCellWidth(0, rowFormat.gridBefore, tableWidth, isAutoWidth);
            }
            for (var j = 0; j < rw.childWidgets.length; j++) {
                var cell = rw.childWidgets[j];
                // tslint:disable-next-line:max-line-length
                cell.cellFormat.cellWidth = this.tableHolder.getCellWidth(cell.columnIndex, cell.cellFormat.columnSpan, tableWidth, isAutoWidth);
                //By default, if cell preferred widthType is auto , width set based on table width and type is changed to 'Point'
                if (cell.cellFormat.preferredWidthType !== 'Percent') {
                    cell.cellFormat.preferredWidth = cell.cellFormat.cellWidth;
                    cell.cellFormat.preferredWidthType = 'Point';
                }
            }
            if (rowFormat.gridAfter > 0) {
                rowFormat.afterWidth = this.tableHolder.getCellWidth(0, rowFormat.gridAfter, tableWidth, isAutoWidth);
            }
        }
    };
    /**
     * @private
     */
    TableWidget.prototype.getMaxRowWidth = function (clientWidth) {
        var width = 0;
        for (var i = 0; i < this.childWidgets.length; i++) {
            var row = this.childWidgets[i];
            var rowWidth = 0;
            for (var j = 0; j < row.childWidgets.length; j++) {
                var cell = row.childWidgets[j];
                rowWidth += this.getCellWidth(cell.cellFormat.preferredWidth, cell.cellFormat.preferredWidthType, clientWidth, cell);
            }
            if (width < rowWidth) {
                width = rowWidth;
            }
        }
        return width;
    };
    /**
     * @private
     */
    TableWidget.prototype.updateWidth = function (dragValue) {
        var totalPreferredWidth = this.tableHolder.getTotalWidth();
        var containerWidth = this.getTableClientWidth(this.getOwnerWidth(true));
        if (containerWidth <= totalPreferredWidth) {
            if (this.tableFormat.preferredWidthType === 'Auto') {
                this.tableFormat.preferredWidthType = 'Point';
            }
        }
        if (this.tableFormat.preferredWidthType !== 'Auto') {
            if (this.tableFormat.preferredWidthType === 'Point') {
                this.tableFormat.preferredWidth = this.getMaxRowWidth(containerWidth);
            }
            // else
            // {   //ToDo:Need to anzlyze more the Percentage calculation for table width.
            //     let value:number = ConvertPixelToPercent(GetMaxRowWidth(containerWidth));
            //     this.tableFormat.preferredWidth = value;
            // }
        }
    };
    /**
     * @private
     */
    TableWidget.prototype.convertPointToPercent = function (tablePreferredWidth, ownerWidth) {
        var value = 0;
        value = (tablePreferredWidth / ownerWidth) * 100;
        value = Math.round(value);
        return value < 100 ? value : 100; // The value should be lesser than or equal to 100%;
    };
    /**
     * @private
     */
    TableWidget.prototype.clone = function () {
        var table = new TableWidget();
        table.tableHolder = this.tableHolder.clone();
        table.tableFormat.copyFormat(this.tableFormat);
        for (var i = 0; i < this.childWidgets.length; i++) {
            var row = this.childWidgets[i].clone();
            table.childWidgets.push(row);
            row.containerWidget = table;
            row.index = i;
        }
        table.x = this.x;
        table.y = this.y;
        table.height = this.height;
        table.width = this.width;
        table.containerWidget = this.containerWidget;
        return table;
    };
    /**
     * @private
     */
    TableWidget.getTableOf = function (node) {
        if (node instanceof WBorders) {
            var row = TableRowWidget.getRowOf(node);
            if (!isNullOrUndefined(row)) {
                return row.ownerTable;
            }
            else if (node.ownerBase instanceof WTableFormat && node.ownerBase.ownerBase instanceof TableWidget) {
                return node.ownerBase.ownerBase;
            }
            else {
                return undefined;
            }
        }
        return undefined;
    };
    /**
     * @private
     */
    TableWidget.prototype.fitChildToClientArea = function () {
        var clientWidth = this.getContainerWidth();
        if (Math.round(clientWidth) < Math.round(this.getTableWidth())) {
            this.fitCellsToClientArea(clientWidth);
        }
        for (var i = 0; i < this.childWidgets.length; i++) {
            var row = this.childWidgets[i];
            for (var j = 0; j < row.childWidgets.length; j++) {
                var cell = row.childWidgets[j];
                for (var k = 0; k < cell.childWidgets.length; k++) {
                    if (cell.childWidgets[k] instanceof TableWidget) {
                        cell.childWidgets[k].fitChildToClientArea();
                    }
                }
            }
        }
    };
    /**
     * @private
     */
    TableWidget.prototype.getColumnCellsForSelection = function (startCell, endCell) {
        var cells = [];
        var start = startCell.columnIndex;
        var end = endCell.columnIndex + endCell.cellFormat.columnSpan;
        for (var i = 0; i < this.childWidgets.length; i++) {
            var row = this.childWidgets[i];
            for (var j = 0; j < row.childWidgets.length; j++) {
                var cell = row.childWidgets[j];
                var columnIndex = cell.columnIndex;
                var columnSpan = cell.cellFormat.columnSpan;
                if ((columnIndex + columnSpan > start && columnIndex + columnSpan < end) || (columnIndex > start && columnIndex < end)) {
                    if (cells.indexOf(cell) < 0) {
                        cells.push(cell);
                    }
                }
                else if ((columnIndex > start && columnIndex < end && columnIndex + columnSpan < end)
                    || (columnIndex < start && columnIndex + columnSpan > end)) {
                    if (cells.indexOf(cell) < 0) {
                        cells.push(cell);
                    }
                }
                else if (columnIndex === start || columnIndex + columnSpan === end) {
                    if (cells.indexOf(cell) < 0) {
                        cells.push(cell);
                    }
                }
            }
        }
        return cells;
    };
    /**
     * Splits width equally for all the cells.
     * @param tableClientWidth
     * @private
     */
    TableWidget.prototype.splitWidthToTableCells = function (tableClientWidth) {
        for (var row = 0; row < this.childWidgets.length; row++) {
            this.childWidgets[row].splitWidthToRowCells(tableClientWidth);
        }
    };
    /**
     * @private
     */
    TableWidget.prototype.insertTableRowsInternal = function (tableRows, startIndex) {
        for (var i = 0; i < tableRows.length; i++) {
            var row = tableRows.splice(i, 1)[0];
            row.containerWidget = this;
            this.childWidgets.splice(startIndex, 0, row);
            i--;
        }
        this.updateRowIndex(startIndex);
        this.isGridUpdated = false;
        this.buildTableColumns();
        this.isGridUpdated = true;
    };
    /**
     * @private
     */
    TableWidget.prototype.updateRowIndex = function (startIndex) {
        for (var i = startIndex; i < this.childWidgets.length; i++) {
            var row = this.childWidgets[i];
            row.index = i;
            for (var j = 0; j < row.childWidgets.length; j++) {
                row.childWidgets[j].index = j;
                row.childWidgets[j].rowIndex = row.rowIndex;
            }
            startIndex++;
        }
    };
    /**
     * @private
     */
    TableWidget.prototype.getCellStartOffset = function (cell) {
        var offset = 0;
        if (cell && this.tableCellInfo) {
            if (this.tableCellInfo.containsKey(cell.ownerRow.rowIndex)) {
                var rowCellInfo = this.tableCellInfo.get(cell.ownerRow.rowIndex);
                if (rowCellInfo.containsKey(cell.cellIndex)) {
                    offset = rowCellInfo.get(cell.cellIndex);
                }
            }
        }
        return offset;
    };
    /**
     * @private
     */
    TableWidget.prototype.destroyInternal = function (viewer) {
        var height = this.height;
        if (!isNullOrUndefined(this.childWidgets)) {
            for (var j = 0; j < this.childWidgets.length; j++) {
                var widget = undefined;
                var childWidget = this.childWidgets[j];
                widget = childWidget;
                if (!isNullOrUndefined(widget)) {
                    widget.destroyInternal(viewer);
                }
                if (isNullOrUndefined(this.childWidgets)) {
                    break;
                }
                j--;
            }
            this.childWidgets = undefined;
        }
        if (!isNullOrUndefined(this.containerWidget)) {
            if (!isNullOrUndefined(this.containerWidget.childWidgets)) {
                if (this.containerWidget.childWidgets.indexOf(this) !== -1) {
                    this.containerWidget.childWidgets.splice(this.containerWidget.childWidgets.indexOf(this), 1);
                }
                this.containerWidget.height -= height;
                // if ((isNullOrUndefined(this.containerWidget.childWidgets) || this.containerWidget.childWidgets.length === 0)
                //     && this.containerWidget instanceof BodyWidget) {
                //     // (this.containerWidget as BodyWidget).destroyInternal(viewer);
                // }
            }
            this.containerWidget = undefined;
        }
        this.destroy();
    };
    /**
     * @private
     */
    TableWidget.prototype.destroy = function () {
        // if (this.tableFormat) {
        //     this.tableFormat.destroy();
        // }
        this.tableFormat = undefined;
        // if (this.spannedRowCollection) {
        //     this.spannedRowCollection.destroy();
        // }
        this.spannedRowCollection = undefined;
        this.tableGrids = [];
        this.tableGrids = undefined;
        // if (this.tableHolder) {
        //     this.tableHolder.destroy();
        // }
        this.tableHolder = undefined;
        this.flags = undefined;
        this.leftMargin = undefined;
        this.topMargin = undefined;
        this.rightMargin = undefined;
        this.bottomMargin = undefined;
        this.headerHeight = undefined;
        this.description = undefined;
        this.title = undefined;
        _super.prototype.destroy.call(this);
    };
    return TableWidget;
}(BlockWidget));
export { TableWidget };
/**
 * @private
 */
var TableRowWidget = /** @class */ (function (_super) {
    __extends(TableRowWidget, _super);
    function TableRowWidget() {
        var _this = _super.call(this) || this;
        /**
         * @private
         */
        _this.spannedRowCollection = [];
        _this.topBorderWidth = 0;
        _this.bottomBorderWidth = 0;
        _this.rowFormat = new WRowFormat(_this);
        return _this;
    }
    Object.defineProperty(TableRowWidget.prototype, "rowIndex", {
        /**
         * @private
         */
        get: function () {
            if (this.containerWidget) {
                return this.containerWidget.childWidgets.indexOf(this);
            }
            return -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableRowWidget.prototype, "ownerTable", {
        /**
         * @private
         */
        get: function () {
            if (this.containerWidget instanceof TableWidget) {
                return this.containerWidget;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableRowWidget.prototype, "nextRow", {
        /**
         * @private
         */
        get: function () {
            var index = this.indexInOwner;
            if (index > -1 && index < this.ownerTable.childWidgets.length - 1) {
                return this.ownerTable.childWidgets[index + 1];
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    TableRowWidget.prototype.equals = function (widget) {
        return widget instanceof TableRowWidget && widget.rowFormat === this.rowFormat;
    };
    /**
     * @private
     */
    TableRowWidget.prototype.combineCells = function (viewer) {
        for (var i = 0; i < this.childWidgets.length; i++) {
            var cell = this.childWidgets[i];
            cell.combineWidget(viewer);
            if (cell.cellFormat.rowSpan === 1) {
                var cellHeight = cell.height + cell.margin.top + cell.margin.bottom;
                if ((this.height - this.ownerTable.tableFormat.cellSpacing) < cell.height) {
                    this.height = this.ownerTable.tableFormat.cellSpacing + cell.height;
                }
            }
        }
    };
    /**
     * @private
     */
    TableRowWidget.getRowOf = function (node) {
        if (node instanceof WBorders) {
            var cell = TableCellWidget.getCellOf(node);
            if (!isNullOrUndefined(cell)) {
                return cell.ownerRow;
            }
            else if (node.ownerBase instanceof WRowFormat && node.ownerBase.ownerBase instanceof TableRowWidget) {
                return node.ownerBase.ownerBase;
            }
            else {
                return undefined;
            }
        }
        return undefined;
    };
    /**
     * @private
     */
    TableRowWidget.prototype.getCell = function (rowIndex, cellIndex) {
        for (var i = 0; i < this.childWidgets.length; i++) {
            var cell = this.childWidgets[i];
            if (cell.rowIndex === rowIndex && cell.index === cellIndex) {
                return cell;
            }
        }
        return undefined;
    };
    /**
     * @private
     */
    TableRowWidget.prototype.splitWidthToRowCells = function (tableClientWidth) {
        var cells = this.childWidgets;
        var cellWidth = tableClientWidth / cells.length;
        for (var cell = 0; cell < cells.length; cell++) {
            cells[cell].cellFormat.preferredWidth = cellWidth;
        }
    };
    /**
     * @private
     */
    TableRowWidget.prototype.getGridCount = function (tableGrid, cell, index, containerWidth) {
        var prevOffset = 0;
        var width = 0;
        var ownerTable = this.ownerTable;
        var rowFormat = this.rowFormat;
        if (index === -1) {
            width = ownerTable.getCellWidth(rowFormat.gridBeforeWidth, rowFormat.gridBeforeWidthType, containerWidth, null);
        }
        else {
            prevOffset += ownerTable.getCellWidth(rowFormat.gridBeforeWidth, rowFormat.gridBeforeWidthType, containerWidth, null);
            if (index >= 0) {
                prevOffset += ownerTable.getCellStartOffset(cell);
            }
            if (index < this.childWidgets.length) {
                width = ownerTable.getCellWidth(cell.cellFormat.preferredWidth, cell.cellFormat.preferredWidthType, containerWidth, null);
            }
            else {
                width = ownerTable.getCellWidth(rowFormat.gridAfterWidth, rowFormat.gridAfterWidthType, containerWidth, null);
            }
        }
        var gridStartIndex = this.getOffsetIndex(tableGrid, prevOffset);
        var gridEndIndex = this.getOffsetIndex(tableGrid, prevOffset + width);
        return gridEndIndex - gridStartIndex;
    };
    TableRowWidget.prototype.getOffsetIndex = function (tableGrid, offset) {
        offset = Math.round(offset);
        var index = 0;
        if (tableGrid.indexOf(offset) >= 0) {
            index = tableGrid.indexOf(offset);
        }
        else {
            for (var i = 0; i < tableGrid.length; i++) {
                if (tableGrid[i] > offset) {
                    return i;
                }
            }
            index = tableGrid.length - 1;
        }
        return index;
    };
    TableRowWidget.prototype.getCellOffset = function (index, containerWidth) {
        var prevOffset = 0;
        var ownerTable = this.ownerTable;
        for (var i = 0; i < this.childWidgets.length; i++) {
            var cellFormat = this.childWidgets[i].cellFormat;
            if (i === index) {
                break;
            }
            prevOffset += ownerTable.getCellWidth(cellFormat.preferredWidth, cellFormat.preferredWidthType, containerWidth, null);
        }
        return prevOffset;
    };
    /**
     * @private
     */
    TableRowWidget.prototype.updateRowBySpannedCells = function () {
        var rowSpannedCells = this.getPreviousRowSpannedCells();
        var currentRowIndex = this.rowIndex;
        for (var i = 0; i < rowSpannedCells.length; i++) {
            var spannedCell = rowSpannedCells[i];
            var rowSpanEnd = spannedCell.ownerRow.rowIndex + spannedCell.cellFormat.rowSpan - 1;
            // If current row is row span end or includes spanned cells. then, decrease the rowspan
            if (rowSpanEnd >= currentRowIndex) {
                spannedCell.cellFormat.rowSpan -= 1;
            }
        }
    };
    /**
     * @private
     */
    TableRowWidget.prototype.getPreviousRowSpannedCells = function (include) {
        var rowSpannedCells = [];
        var row = include ? this : this.previousWidget;
        while (!isNullOrUndefined(row)) {
            for (var i = 0; i < row.childWidgets.length; i++) {
                var cell = row.childWidgets[i];
                if (cell.cellFormat.rowSpan > 1) {
                    rowSpannedCells.splice(0, 0, cell);
                }
            }
            row = row.previousWidget;
        }
        return rowSpannedCells;
    };
    /**
     * @private
     */
    TableRowWidget.prototype.getTableCellWidget = function (point) {
        for (var i = 0; i < this.childWidgets.length; i++) {
            var x = Math.round(this.childWidgets[i].x);
            if (x - this.childWidgets[i].margin.left - 1 <= point.x
                && (x + this.childWidgets[i].width) >= point.x) {
                return this.childWidgets[i];
            }
            else if (i === this.childWidgets.length - 1
                && (this.childWidgets[i].x + this.childWidgets[i].width) + 1 <= point.x) {
                return this.childWidgets[i];
            }
        }
        var cellWidget = undefined;
        if (this.childWidgets.length > 0) {
            if (this.childWidgets[0].x <= point.x) {
                cellWidget = this.childWidgets[this.childWidgets.length - 1].getTableCellWidget(point);
            }
            else {
                cellWidget = this.childWidgets[0].getTableCellWidget(point);
            }
        }
        return cellWidget;
    };
    /**
     * @private
     */
    TableRowWidget.prototype.destroyInternal = function (viewer) {
        var height = this.height;
        if (!isNullOrUndefined(this.childWidgets)) {
            for (var i = 0; i < this.childWidgets.length; i++) {
                var widget = this.childWidgets[i];
                widget.destroyInternal(viewer);
                if (isNullOrUndefined(this.childWidgets)) {
                    break;
                }
                i--;
            }
            this.childWidgets = undefined;
        }
        if (!isNullOrUndefined(this.containerWidget)) {
            if (!isNullOrUndefined(this.containerWidget.childWidgets)) {
                this.containerWidget.childWidgets.splice(this.containerWidget.childWidgets.indexOf(this), 1);
                if ((isNullOrUndefined(this.containerWidget.childWidgets) || this.containerWidget.childWidgets.length === 0)
                    && this.containerWidget instanceof TableWidget) {
                    this.containerWidget.destroyInternal(viewer);
                }
                else if (this.containerWidget.containerWidget instanceof BodyWidget) {
                    this.containerWidget.containerWidget.height -= height;
                }
                this.containerWidget.height -= height;
            }
        }
        this.destroy();
    };
    /**
     * @private
     */
    TableRowWidget.prototype.clone = function () {
        var row = new TableRowWidget();
        row.rowFormat.copyFormat(this.rowFormat);
        row.topBorderWidth = this.topBorderWidth;
        row.bottomBorderWidth = this.bottomBorderWidth;
        for (var i = 0; i < this.childWidgets.length; i++) {
            var cell = this.childWidgets[i].clone();
            row.childWidgets.push(cell);
            cell.containerWidget = row;
            cell.index = i;
            cell.rowIndex = this.rowIndex;
        }
        row.x = this.x;
        row.y = this.y;
        row.height = this.height;
        row.width = this.width;
        return row;
    };
    /**
     * @private
     */
    TableRowWidget.prototype.destroy = function () {
        // if (this.rowFormat) {
        //     this.rowFormat.destroy();
        // }
        this.rowFormat = undefined;
        this.rowFormat = undefined;
        this.spannedRowCollection = [];
        this.spannedRowCollection = undefined;
        this.topBorderWidth = undefined;
        this.bottomBorderWidth = undefined;
        _super.prototype.destroy.call(this);
    };
    return TableRowWidget;
}(BlockWidget));
export { TableRowWidget };
/**
 * @private
 */
var TableCellWidget = /** @class */ (function (_super) {
    __extends(TableCellWidget, _super);
    function TableCellWidget() {
        var _this = _super.call(this) || this;
        /**
         * @private
         */
        _this.rowIndex = -1;
        _this.margin = new Margin(_this.leftMargin, _this.topMargin, _this.rightMargin, _this.bottomMargin);
        _this.leftBorderWidth = 0;
        _this.rightBorderWidth = 0;
        _this.cellFormat = new WCellFormat(_this);
        return _this;
    }
    Object.defineProperty(TableCellWidget.prototype, "ownerColumn", {
        /**
         * @private
         */
        get: function () {
            return this.ownerTable.tableHolder.columns[this.columnIndex];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableCellWidget.prototype, "leftMargin", {
        /**
         * @private
         */
        get: function () {
            if (this.cellFormat && this.cellFormat.containsMargins()) {
                return this.cellFormat.leftMargin;
            }
            else if (!isNullOrUndefined(this.ownerTable) && !isNullOrUndefined(this.ownerTable.tableFormat)) {
                return this.ownerTable.tableFormat.leftMargin;
            }
            else {
                return 0;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableCellWidget.prototype, "topMargin", {
        /**
         * @private
         */
        get: function () {
            if (this.cellFormat && this.cellFormat.containsMargins()) {
                return this.cellFormat.topMargin;
            }
            else if (!isNullOrUndefined(this.ownerTable) && !isNullOrUndefined(this.ownerTable.tableFormat)) {
                return this.ownerTable.tableFormat.topMargin;
            }
            else {
                return 0;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableCellWidget.prototype, "rightMargin", {
        /**
         * @private
         */
        get: function () {
            if (this.cellFormat && this.cellFormat.containsMargins()) {
                return this.cellFormat.rightMargin;
            }
            else if (!isNullOrUndefined(this.ownerTable) && !isNullOrUndefined(this.ownerTable.tableFormat)) {
                return this.ownerTable.tableFormat.rightMargin;
            }
            else {
                return 0;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableCellWidget.prototype, "bottomMargin", {
        /**
         * @private
         */
        get: function () {
            if (this.cellFormat && this.cellFormat.containsMargins()) {
                return this.cellFormat.bottomMargin;
            }
            else if (!isNullOrUndefined(this.ownerTable) && !isNullOrUndefined(this.ownerTable.tableFormat)) {
                return this.ownerTable.tableFormat.bottomMargin;
            }
            else {
                return 0;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableCellWidget.prototype, "cellIndex", {
        /**
         * @private
         */
        get: function () {
            if (this.ownerRow) {
                return this.ownerRow.childWidgets.indexOf(this);
            }
            return -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableCellWidget.prototype, "ownerTable", {
        /**
         * @private
         */
        get: function () {
            if (this.containerWidget instanceof TableRowWidget) {
                return this.containerWidget.ownerTable;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableCellWidget.prototype, "ownerRow", {
        /**
         * @private
         */
        get: function () {
            return this.containerWidget;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    TableCellWidget.prototype.equals = function (widget) {
        return widget instanceof TableCellWidget && widget.cellFormat === this.cellFormat;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getContainerTable = function () {
        var table = this.ownerTable;
        while (table instanceof TableWidget && table.associatedCell instanceof TableCellWidget) {
            table = table.associatedCell.getContainerTable();
        }
        return table;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getPreviousSplitWidget = function () {
        if (this.containerWidget instanceof TableRowWidget) {
            var row = this.containerWidget;
            do {
                row = row.previousRenderedWidget;
                if (isNullOrUndefined(row) || row.index < this.rowIndex) {
                    break;
                }
                var previousCell = row.getCell(this.rowIndex, this.index);
                if (previousCell && this.equals(previousCell)) {
                    return previousCell;
                }
            } while (row);
        }
        return undefined;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getNextSplitWidget = function () {
        var rowSpan = this.cellFormat.rowSpan;
        if (this.containerWidget instanceof TableRowWidget) {
            var row = this.containerWidget;
            do {
                row = row.nextRenderedWidget;
                if (isNullOrUndefined(row) || row.index > this.rowIndex + rowSpan) {
                    break;
                }
                var nextCell = row.getCell(this.rowIndex, this.index);
                if (nextCell && this.equals(nextCell)) {
                    return nextCell;
                }
            } while (row);
        }
        return undefined;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getTableCellWidget = function (point) {
        for (var i = 0; i < this.childWidgets.length; i++) {
            if (this.childWidgets[i].y <= point.y
                && (this.childWidgets[i].y + this.childWidgets[i].height) >= point.y) {
                return this.childWidgets[i].getTableCellWidget(point);
            }
        }
        var tableCellWidget = undefined;
        if (this.childWidgets.length > 0) {
            if (this.childWidgets[0].y <= point.y) {
                tableCellWidget = this.childWidgets[this.childWidgets.length - 1].getTableCellWidget(point);
            }
            else {
                tableCellWidget = this.childWidgets[0].getTableCellWidget(point);
            }
        }
        return tableCellWidget;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.updateWidth = function (preferredWidth) {
        if (this.cellFormat.preferredWidthType === 'Auto') {
            this.cellFormat.preferredWidth = preferredWidth;
            this.cellFormat.preferredWidthType = 'Point';
        }
        else if (this.cellFormat.preferredWidthType === 'Point') {
            this.cellFormat.preferredWidth = preferredWidth;
        }
        else if (this.cellFormat.preferredWidthType === 'Percent') {
            this.cellFormat.preferredWidth = this.convertPointToPercent(preferredWidth);
        }
        this.cellFormat.cellWidth = preferredWidth;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.convertPointToPercent = function (cellPreferredWidth) {
        var value = 0;
        var clientWidth = this.ownerTable.getOwnerWidth(true);
        var tableWidth = this.ownerTable.getTableClientWidth(clientWidth);
        value = (cellPreferredWidth / tableWidth) * 100;
        value = Math.round(value);
        return value < 100 ? value : 100; // The value should be lesser than or equal to 100%;
    };
    /**
     * @private
     */
    TableCellWidget.getCellLeftBorder = function (tableCell) {
        var leftBorder = undefined;
        var cellBorder = tableCell.cellFormat.borders;
        var rowBorders = !isNullOrUndefined(tableCell.ownerRow) ? tableCell.ownerRow.rowFormat.borders : undefined;
        var tableBorders = !isNullOrUndefined(tableCell.ownerTable) ? tableCell.ownerTable.tableFormat.borders : undefined;
        if (!isNullOrUndefined(cellBorder.left)) {
            leftBorder = cellBorder.left;
        }
        if (isNullOrUndefined(leftBorder)) {
            leftBorder = tableCell.getLeftBorderToRenderByHierarchy(leftBorder, rowBorders, tableBorders);
        }
        if (tableCell.ownerTable.tableFormat.cellSpacing > 0) {
            leftBorder = tableCell.getLeftBorderToRenderByHierarchy(leftBorder, rowBorders, tableBorders);
        }
        else {
            var prevCell = undefined;
            if (!isNullOrUndefined(tableCell.previousWidget)) {
                // if the border is shared then choose the border based on Conflict Resolution algorithm.
                prevCell = tableCell.previousWidget;
            }
            else if ((tableCell.cellFormat.columnSpan > 1 || tableCell.columnIndex > 1) && tableCell.ownerRow.rowIndex > 0) {
                var previousRow = tableCell.ownerRow.previousWidget;
                while (!isNullOrUndefined(previousRow) && previousRow.childWidgets.length > 0) {
                    for (var i = 0; i < previousRow.childWidgets.length; i++) {
                        var prevRowCell = previousRow.childWidgets[i];
                        if (prevRowCell.columnIndex + prevRowCell.cellFormat.columnSpan === tableCell.columnIndex) {
                            prevCell = previousRow.childWidgets[i];
                            break;
                        }
                    }
                    if (!isNullOrUndefined(prevCell)) {
                        break;
                    }
                    previousRow = previousRow.previousWidget;
                }
            }
            leftBorder = tableCell.getPreviousCellLeftBorder(leftBorder, prevCell);
        }
        if (isNullOrUndefined(leftBorder)) {
            leftBorder = new WBorder(tableCell.cellFormat.borders);
        }
        return leftBorder;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getLeftBorderWidth = function () {
        var borderWidth = 0;
        //let ownerTable = this.ownerTable;
        //Added null condition check for asynchronous loading.
        // if (this.cellFormat !== null && this.cellFormat.borders !== null) {
        // update the margins values respect to layouting of borders.
        //For normal table cells only left border is rendred. for last cell left and right border is rendred.
        // this border widths are not included in margins.
        //     boderWidth = this.cellFormat.borders.GetRightBorderToRender(this).GetLineWidth();
        //need to render rightBorder specifically for all the cells when the cellSpacing is greater than zero or for last cell of each row.
        // }
        return borderWidth;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getRightBorderWidth = function () {
        var borderWidth = 0;
        var ownerTable = this.ownerTable;
        //Added null condition check for asynchronous loading.
        // if (this.cellFormat !== null && this.cellFormat.borders !== null) {
        ///need to render right border specifically for all the cells when the cell spacing is 
        //greater than zero or for last cell of each row.
        //     let isLastCell: boolean = false;
        //     isLastCell = this.cellIndex === 0;
        //     if (ownerTable.tableFormat.cellSpacing > 0 || isLastCell) {
        //         boderWidth = this.cellFormat.borders.getLeftBorderToRender(this).GetLineWidth();
        //     }
        // }
        return borderWidth;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getCellSpacing = function () {
        var actualCellSpacing = this.ownerTable && this.ownerTable.tableFormat ? this.ownerTable.tableFormat.cellSpacing : 0;
        var cellSpacingToLayout = actualCellSpacing;
        // Considers the left, right margins and border widths(only available for Layouted table) for Minimum width.
        if (this.ownerRow.childWidgets.length === 1) {
            cellSpacingToLayout = actualCellSpacing * 2;
        }
        else if (this.cellIndex === 0 || this.cellIndex === this.ownerRow.childWidgets.length - 1) {
            cellSpacingToLayout = actualCellSpacing + (actualCellSpacing / 2);
        }
        else {
            cellSpacingToLayout = actualCellSpacing;
        }
        return cellSpacingToLayout;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getMinimumPreferredWidth = function () {
        var defaultWidth = 0;
        defaultWidth = this.leftMargin + this.rightMargin + this.getLeftBorderWidth() + this.getRightBorderWidth() + this.getCellSpacing();
        return defaultWidth;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getPreviousCellLeftBorder = function (leftBorder, previousCell) {
        // tslint:disable-next-line:max-line-length
        if ((isNullOrUndefined(previousCell) || (!isNullOrUndefined(leftBorder) && (leftBorder.lineStyle === 'None' && !leftBorder.hasNoneStyle)))) {
            if (!isNullOrUndefined(leftBorder) && !(leftBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getLeftBorderToRenderByHierarchy(leftBorder, TableRowWidget.getRowOf(leftBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(leftBorder.ownerBase).tableFormat.borders);
            }
        }
        else {
            var prevCellRightBorder = undefined;
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(previousCell.cellFormat.borders) && !isNullOrUndefined(previousCell.cellFormat.borders.right) && previousCell.cellFormat.borders.right.lineStyle !== 'None') {
                prevCellRightBorder = previousCell.cellFormat.borders.right;
            }
            if (!isNullOrUndefined(prevCellRightBorder) && prevCellRightBorder.lineStyle !== 'None') {
                return this.getBorderBasedOnPriority(prevCellRightBorder, leftBorder);
            }
            else if (!isNullOrUndefined(leftBorder) && !(leftBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getLeftBorderToRenderByHierarchy(leftBorder, TableRowWidget.getRowOf(leftBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(leftBorder.ownerBase).tableFormat.borders);
            }
        }
        return leftBorder;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getBorderBasedOnPriority = function (border, adjacentBorder) {
        // If the cell and its adjacent cell defined different borders then based on this algorithm the border choose to render.
        // Reference link :https://msdn.microsoft.com/en-us/library/office/documentformat.openxml.wordprocessing.tablecellborders.aspx
        if (isNullOrUndefined(border)) {
            return adjacentBorder;
        }
        else if (isNullOrUndefined(adjacentBorder)) {
            return border;
        }
        var borderWeight = border.getBorderWeight();
        var adjacentBorderWeight = adjacentBorder.getBorderWeight();
        //the border with higher wight  shall be displayed.
        if (borderWeight === adjacentBorderWeight) {
            //if the border is equal weight the based on the priority the border will be choosen to render.
            var borderPriority = border.getPrecedence();
            var adjacentBorderPriority = adjacentBorder.getPrecedence();
            if (borderPriority === adjacentBorderPriority) {
                //The color with the smaller brightness value shall be displayed.
                var borderColInRGB = this.convertHexToRGB(border.color);
                var R1 = borderColInRGB.r;
                var G1 = borderColInRGB.g;
                var B1 = borderColInRGB.b;
                var adjacentBorderColInRGB = this.convertHexToRGB(adjacentBorder.color);
                var R2 = adjacentBorderColInRGB.r;
                var G2 = adjacentBorderColInRGB.g;
                var B2 = adjacentBorderColInRGB.b;
                var borderBrightness = (R1 + B1 + (2 * G1));
                var adjacentBorderBrightness = (R2 + B2 + (2 * G2));
                if (borderBrightness === adjacentBorderBrightness) {
                    borderBrightness = (B1 + (2 * G1));
                    adjacentBorderBrightness = (B2 + (2 * G2));
                    if (borderBrightness === adjacentBorderBrightness) {
                        if (G1 === G2) {
                            return border;
                        }
                        else if (G1 > G2) {
                            return adjacentBorder;
                        }
                        else {
                            return border;
                        }
                    }
                    else if (borderBrightness > adjacentBorderBrightness) {
                        return adjacentBorder;
                    }
                    else {
                        return border;
                    }
                }
                else if (borderBrightness > adjacentBorderBrightness) {
                    return adjacentBorder;
                }
                else {
                    return border;
                }
            }
            else if (borderPriority > adjacentBorderPriority) {
                return border;
            }
            else {
                return adjacentBorder;
            }
        }
        else if (borderWeight > adjacentBorderWeight) {
            return border;
        }
        else {
            return adjacentBorder;
        }
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getLeftBorderToRenderByHierarchy = function (leftBorder, rowBorders, tableBorders) {
        if (!isNullOrUndefined(leftBorder) && (leftBorder.lineStyle !== 'None' || (leftBorder.hasNoneStyle &&
            //If border defined with default values then border drawn based on hierarchy. 
            !(leftBorder.lineStyle === 'None' && leftBorder.lineWidth === 0 && leftBorder.color === '#000000')))) {
            return leftBorder;
            // tslint:disable-next-line:max-line-length
        }
        else if (!isNullOrUndefined(leftBorder) && (leftBorder.ownerBase instanceof WBorders) && TableCellWidget.getCellOf(leftBorder.ownerBase).columnIndex === 0) {
            if (!isNullOrUndefined(tableBorders) && !isNullOrUndefined(tableBorders.left)) {
                leftBorder = tableBorders.left;
            }
            return leftBorder;
        }
        else if (!isNullOrUndefined(rowBorders)
            && !isNullOrUndefined(rowBorders.vertical) && rowBorders.vertical.lineStyle !== 'None') {
            return leftBorder = rowBorders.vertical;
        }
        else if (!isNullOrUndefined(tableBorders)
            && !isNullOrUndefined(tableBorders.vertical) && tableBorders.vertical.lineStyle !== 'None') {
            return leftBorder = tableBorders.vertical;
        }
        else {
            return leftBorder;
        }
    };
    /**
     * @private
     */
    TableCellWidget.getCellRightBorder = function (tableCell) {
        var rightBorder = undefined;
        var cellBorder = tableCell.cellFormat.borders;
        var rowBorders = !isNullOrUndefined(tableCell.ownerRow) ? tableCell.ownerRow.rowFormat.borders : undefined;
        var tableBorders = !isNullOrUndefined(tableCell.ownerTable) ? tableCell.ownerTable.tableFormat.borders : undefined;
        if (!isNullOrUndefined(cellBorder.right)) {
            rightBorder = cellBorder.right;
        }
        if (isNullOrUndefined(rightBorder)) {
            rightBorder = tableCell.getRightBorderToRenderByHierarchy(rightBorder, rowBorders, tableBorders);
        }
        if (tableCell.ownerTable.tableFormat.cellSpacing > 0) {
            rightBorder = tableCell.getRightBorderToRenderByHierarchy(rightBorder, rowBorders, tableBorders);
        }
        else {
            var nextCell = undefined;
            if (!isNullOrUndefined(tableCell.nextWidget)) {
                nextCell = tableCell.nextWidget;
            }
            // if the border is shared then choose the border based on Conflict Resolution algorithm.
            rightBorder = tableCell.getAdjacentCellRightBorder(rightBorder, nextCell);
        }
        if (isNullOrUndefined(rightBorder)) {
            rightBorder = new WBorder(tableCell.cellFormat.borders);
        }
        return rightBorder;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getAdjacentCellRightBorder = function (rightBorder, nextCell) {
        // tslint:disable-next-line:max-line-length
        if (isNullOrUndefined(nextCell) || (!isNullOrUndefined(rightBorder) && (rightBorder.lineStyle === 'None' && !rightBorder.hasNoneStyle))) {
            if (!isNullOrUndefined(rightBorder) && !(rightBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getRightBorderToRenderByHierarchy(rightBorder, TableRowWidget.getRowOf(rightBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(rightBorder.ownerBase).tableFormat.borders);
            }
        }
        else {
            var nextCellLeftBorder = undefined;
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(nextCell.cellFormat.borders) && !isNullOrUndefined(nextCell.cellFormat.borders.left) && nextCell.cellFormat.borders.left.lineStyle !== 'None') {
                nextCellLeftBorder = nextCell.cellFormat.borders.left;
            }
            if (!isNullOrUndefined(nextCellLeftBorder) && nextCellLeftBorder.lineStyle !== 'None') {
                return this.getBorderBasedOnPriority(rightBorder, nextCellLeftBorder);
            }
            else if (!isNullOrUndefined(rightBorder) && !(rightBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getRightBorderToRenderByHierarchy(rightBorder, TableRowWidget.getRowOf(rightBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(rightBorder.ownerBase).tableFormat.borders);
            }
        }
        return rightBorder;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getRightBorderToRenderByHierarchy = function (rightBorder, rowBorders, tableBorders) {
        if (!isNullOrUndefined(rightBorder) && (rightBorder.lineStyle !== 'None' || (rightBorder.hasNoneStyle &&
            //If border defined with default values then border drawn based on hierarchy. 
            !(rightBorder.lineStyle === 'None' && rightBorder.lineWidth === 0 && rightBorder.color === '#000000')))) {
            return rightBorder;
            // tslint:disable-next-line:max-line-length
        }
        else if (!isNullOrUndefined(rightBorder) && (rightBorder.ownerBase instanceof WBorders) && TableCellWidget.getCellOf(rightBorder.ownerBase).columnIndex === TableCellWidget.getCellOf(rightBorder.ownerBase).ownerRow.childWidgets.length - 1) {
            if (!isNullOrUndefined(tableBorders) && !isNullOrUndefined(tableBorders.right)) {
                rightBorder = tableBorders.right;
            }
            return rightBorder;
        }
        else if (!isNullOrUndefined(rowBorders)
            && !isNullOrUndefined(rowBorders.vertical) && rowBorders.vertical.lineStyle !== 'None') {
            return rightBorder = rowBorders.vertical;
        }
        else if (!isNullOrUndefined(tableBorders)
            && !isNullOrUndefined(tableBorders.vertical) && tableBorders.vertical.lineStyle !== 'None') {
            return rightBorder = tableBorders.vertical;
        }
        else {
            return rightBorder;
        }
    };
    /**
     * @private
     */
    TableCellWidget.getCellTopBorder = function (tableCell) {
        var topBorder = undefined;
        var cellBorder = tableCell.cellFormat.borders;
        var rowBorders = !isNullOrUndefined(tableCell.ownerRow) ? tableCell.ownerRow.rowFormat.borders : undefined;
        var tableBorders = !isNullOrUndefined(tableCell.ownerTable) ? tableCell.ownerTable.tableFormat.borders : undefined;
        if (!isNullOrUndefined(cellBorder.top)) {
            topBorder = cellBorder.top;
        }
        if (isNullOrUndefined(topBorder)) {
            topBorder = tableCell.getTopBorderToRenderByHierarchy(topBorder, rowBorders, tableBorders);
        }
        if (tableCell.ownerTable.tableFormat.cellSpacing > 0) {
            topBorder = tableCell.getTopBorderToRenderByHierarchy(topBorder, rowBorders, tableBorders);
        }
        else {
            var prevTopCell = undefined;
            //ToDo: Need to analyze more to get the previous cell.
            var prevRow = tableCell.ownerRow.previousWidget;
            while (!isNullOrUndefined(prevRow) && prevRow.childWidgets.length > 0) {
                for (var i = 0; i < prevRow.childWidgets.length; i++) {
                    var prevRowCell = prevRow.childWidgets[i];
                    if (prevRowCell.columnIndex + prevRowCell.cellFormat.columnSpan - 1 >= tableCell.columnIndex) {
                        prevTopCell = prevRow.childWidgets[i];
                        break;
                    }
                }
                if (!isNullOrUndefined(prevTopCell)) {
                    break;
                }
                prevRow = prevRow.previousWidget;
                //If all the previous rows checked and the previous top cell is null
                // then TableCell previus row matched column index cell is taken for border calculation.
                if (isNullOrUndefined(prevRow) && isNullOrUndefined(prevTopCell)) {
                    prevRow = tableCell.ownerRow.previousWidget;
                    if (tableCell.columnIndex < prevRow.childWidgets.length) {
                        for (var i = 0; i < prevRow.childWidgets.length; i++) {
                            var prevRowCell = prevRow.childWidgets[i];
                            if (prevRowCell.columnIndex === tableCell.columnIndex) {
                                prevTopCell = prevRow.childWidgets[i];
                                break;
                            }
                        }
                        //If table cell Column index is greater than previous row cells count then last cell is taken as previous top cell.
                    }
                    else {
                        // tslint:disable-next-line:max-line-length
                        prevTopCell = tableCell.ownerRow.previousWidget.childWidgets[tableCell.ownerRow.previousWidget.childWidgets.length - 1];
                    }
                }
            }
            //If the border is shared then choose the border based on Conflict Resolution algorithm.
            topBorder = tableCell.getPreviousCellTopBorder(topBorder, prevTopCell);
        }
        if (isNullOrUndefined(topBorder)) {
            topBorder = new WBorder(tableCell.cellFormat.borders);
        }
        return topBorder;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getPreviousCellTopBorder = function (topBorder, previousTopCell) {
        // tslint:disable-next-line:max-line-length
        if (isNullOrUndefined(previousTopCell) || (!isNullOrUndefined(topBorder) && (topBorder.lineStyle === 'None' && !topBorder.hasNoneStyle))) {
            if (!isNullOrUndefined(topBorder) && !(topBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getTopBorderToRenderByHierarchy(topBorder, TableRowWidget.getRowOf(topBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(topBorder.ownerBase).tableFormat.borders);
            }
        }
        else {
            var prevTopCellBottomBorder = undefined;
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(previousTopCell.cellFormat.borders) && !isNullOrUndefined(previousTopCell.cellFormat.borders.bottom) && previousTopCell.cellFormat.borders.bottom.lineStyle !== 'None') {
                prevTopCellBottomBorder = previousTopCell.cellFormat.borders.bottom;
            }
            if (!isNullOrUndefined(prevTopCellBottomBorder) && prevTopCellBottomBorder.lineStyle !== 'None') {
                return this.getBorderBasedOnPriority(topBorder, prevTopCellBottomBorder);
            }
            else if (!isNullOrUndefined(topBorder) && !(topBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getTopBorderToRenderByHierarchy(topBorder, TableRowWidget.getRowOf(topBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(topBorder.ownerBase).tableFormat.borders);
            }
        }
        return topBorder;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getTopBorderToRenderByHierarchy = function (topBorder, rowBorders, tableBorders) {
        if (!isNullOrUndefined(topBorder) && (topBorder.lineStyle !== 'None' || (topBorder.hasNoneStyle &&
            //If border defined with default values then border drawn based on hierarchy. 
            !(topBorder.lineStyle === 'None' && topBorder.lineWidth === 0 && topBorder.color === '#000000')))) {
            return topBorder;
            // tslint:disable-next-line:max-line-length
        }
        else if (!isNullOrUndefined(topBorder) && (topBorder.ownerBase instanceof WBorders) && TableCellWidget.getCellOf(topBorder.ownerBase).ownerRow.rowIndex === 0) {
            if (!isNullOrUndefined(tableBorders) && !isNullOrUndefined(tableBorders.top)) {
                topBorder = tableBorders.top;
            }
            return topBorder;
        }
        else if (!isNullOrUndefined(rowBorders)
            && !isNullOrUndefined(rowBorders.horizontal) && rowBorders.horizontal.lineStyle !== 'None') {
            return topBorder = rowBorders.horizontal;
        }
        else if (!isNullOrUndefined(tableBorders)
            && !isNullOrUndefined(tableBorders.horizontal) && tableBorders.horizontal.lineStyle !== 'None') {
            return topBorder = tableBorders.horizontal;
        }
        else {
            return topBorder;
        }
    };
    /**
     * @private
     */
    TableCellWidget.getCellBottomBorder = function (tableCell) {
        var bottomBorder = undefined;
        var cellBorder = tableCell.cellFormat.borders;
        var rowBorders = !isNullOrUndefined(tableCell.ownerRow) ? tableCell.ownerRow.rowFormat.borders : undefined;
        var tableBorders = !isNullOrUndefined(tableCell.ownerTable) ? tableCell.ownerTable.tableFormat.borders : undefined;
        if (!isNullOrUndefined(cellBorder.bottom)) {
            bottomBorder = cellBorder.bottom;
        }
        if (isNullOrUndefined(bottomBorder)) {
            // tslint:disable-next-line:max-line-length
            bottomBorder = tableCell.getBottomBorderToRenderByHierarchy(bottomBorder, rowBorders, tableBorders); // select the left border based on heirarchy.
        }
        if (tableCell.ownerTable.tableFormat.cellSpacing > 0) {
            bottomBorder = tableCell.getBottomBorderToRenderByHierarchy(bottomBorder, rowBorders, tableBorders);
        }
        else {
            var nextBottomCell = undefined;
            var nextRow = tableCell.ownerRow.nextWidget;
            if (!isNullOrUndefined(nextRow) && tableCell.columnIndex < nextRow.childWidgets.length) {
                nextBottomCell = nextRow.childWidgets[tableCell.columnIndex];
            }
            //If the border is shared then choose the border based on Conflict Resolution algorithm.
            bottomBorder = tableCell.getAdjacentCellBottomBorder(bottomBorder, nextBottomCell);
        }
        if (isNullOrUndefined(bottomBorder)) {
            bottomBorder = new WBorder(tableCell.cellFormat.borders);
        }
        return bottomBorder;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getAdjacentCellBottomBorder = function (bottomBorder, nextBottomCell) {
        // tslint:disable-next-line:max-line-length
        if (isNullOrUndefined(nextBottomCell) || (!isNullOrUndefined(bottomBorder) && (bottomBorder.lineStyle === 'None' && !bottomBorder.hasNoneStyle))) {
            if (!isNullOrUndefined(bottomBorder) && !(bottomBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getBottomBorderToRenderByHierarchy(bottomBorder, TableRowWidget.getRowOf(bottomBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(bottomBorder.ownerBase).tableFormat.borders);
            }
        }
        else {
            var prevBottomCellTopBorder = undefined;
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(nextBottomCell.cellFormat.borders) && !isNullOrUndefined(nextBottomCell.cellFormat.borders.top) && nextBottomCell.cellFormat.borders.top.lineStyle !== 'None') {
                prevBottomCellTopBorder = nextBottomCell.cellFormat.borders.top;
            }
            if (!isNullOrUndefined(prevBottomCellTopBorder) && prevBottomCellTopBorder.lineStyle !== 'None') {
                return this.getBorderBasedOnPriority(bottomBorder, prevBottomCellTopBorder);
            }
            else if (!isNullOrUndefined(bottomBorder) && !(bottomBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getBottomBorderToRenderByHierarchy(bottomBorder, TableRowWidget.getRowOf(bottomBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(bottomBorder.ownerBase).tableFormat.borders);
            }
        }
        return bottomBorder;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getBottomBorderToRenderByHierarchy = function (bottomBorder, rowBorders, tableBorders) {
        if (!isNullOrUndefined(bottomBorder) && (bottomBorder.lineStyle !== 'None' || (bottomBorder.hasNoneStyle &&
            //If border defined with default values then border drawn based on hierarchy. 
            !(bottomBorder.lineStyle === 'None' && bottomBorder.lineWidth === 0 && bottomBorder.color === '#000000')))) {
            return bottomBorder;
            // tslint:disable-next-line:max-line-length
        }
        else if (!isNullOrUndefined(bottomBorder) && (bottomBorder.ownerBase instanceof WBorders) && TableCellWidget.getCellOf(bottomBorder.ownerBase).ownerRow.rowIndex + TableCellWidget.getCellOf(bottomBorder.ownerBase).cellFormat.rowSpan === TableCellWidget.getCellOf(bottomBorder.ownerBase).ownerTable.childWidgets.length) {
            if (!isNullOrUndefined(tableBorders) && !isNullOrUndefined(tableBorders.bottom)) {
                bottomBorder = tableBorders.bottom;
            }
            return bottomBorder;
        }
        else if (!isNullOrUndefined(rowBorders)
            && !isNullOrUndefined(rowBorders.horizontal) && rowBorders.horizontal.lineStyle !== 'None') {
            return bottomBorder = rowBorders.horizontal;
        }
        else if (!isNullOrUndefined(tableBorders)
            && !isNullOrUndefined(tableBorders.horizontal) && tableBorders.horizontal.lineStyle !== 'None') {
            return bottomBorder = tableBorders.horizontal;
        }
        else {
            return bottomBorder;
        }
    };
    TableCellWidget.prototype.convertHexToRGB = function (colorCode) {
        if (colorCode) {
            colorCode = colorCode.replace(/[^0-9A-F]/gi, ''); // To remove # from color code string.
            var colCodeNo = parseInt(colorCode, 16);
            var r = (colCodeNo >> 16) & 255;
            var g = (colCodeNo >> 8) & 255;
            var b = colCodeNo & 255;
            return { 'r': r, 'g': g, 'b': b };
        }
        return undefined;
    };
    /**
     * @private
     */
    TableCellWidget.getCellOf = function (node) {
        if (node instanceof WBorders) {
            if (node.ownerBase instanceof WCellFormat && node.ownerBase.ownerBase instanceof TableCellWidget) {
                return node.ownerBase.ownerBase;
            }
            else {
                return undefined;
            }
        }
        return undefined;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.destroyInternal = function (viewer) {
        // let viewer: LayoutViewer = undefined;
        // let page: Page = this.getPage();
        // if (!isNullOrUndefined(page ))
        //     viewer = page.viewer;
        if (!isNullOrUndefined(this.childWidgets)) {
            for (var i = 0; i < this.childWidgets.length; i++) {
                var widget = this.childWidgets[i];
                if (widget instanceof ParagraphWidget) {
                    widget.destroyInternal(viewer);
                }
                else {
                    widget.destroyInternal(viewer);
                }
                i--;
            }
            this.childWidgets = undefined;
        }
        this.destroy();
    };
    /**
     * @private
     */
    TableCellWidget.prototype.clone = function () {
        var cell = new TableCellWidget();
        cell.cellFormat.copyFormat(this.cellFormat);
        for (var i = 0; i < this.childWidgets.length; i++) {
            var block = this.childWidgets[i].clone();
            cell.childWidgets.push(block);
            block.containerWidget = cell;
            block.index = i;
        }
        cell.leftBorderWidth = this.leftBorderWidth;
        cell.rightBorderWidth = this.rightBorderWidth;
        if (this.margin) {
            cell.margin = this.margin.clone();
        }
        cell.columnIndex = this.columnIndex;
        cell.x = this.x;
        cell.y = this.y;
        cell.height = this.height;
        cell.width = this.width;
        return cell;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.destroy = function () {
        // if (this.cellFormat) {
        //     this.cellFormat.destroy();
        // }
        this.cellFormat = undefined;
        this.rowIndex = undefined;
        this.columnIndex = undefined;
        _super.prototype.destroy.call(this);
    };
    return TableCellWidget;
}(BlockWidget));
export { TableCellWidget };
/**
 * @private
 */
var LineWidget = /** @class */ (function () {
    /**
     * Initialize the constructor of LineWidget
     */
    function LineWidget(paragraphWidget) {
        /**
         * @private
         */
        this.children = [];
        /**
         * @private
         */
        this.x = 0;
        /**
         * @private
         */
        this.y = 0;
        /**
         * @private
         */
        this.width = 0;
        /**
         * @private
         */
        this.height = 0;
        this.paragraph = paragraphWidget;
    }
    Object.defineProperty(LineWidget.prototype, "indexInOwner", {
        /**
         * @private
         */
        get: function () {
            if (this.paragraph && this.paragraph.childWidgets) {
                return this.paragraph.childWidgets.indexOf(this);
            }
            return -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineWidget.prototype, "nextLine", {
        /**
         * @private
         */
        get: function () {
            var paragraph = this.paragraph;
            var lineIndex = this.indexInOwner;
            if (lineIndex <= paragraph.childWidgets.length - 2) {
                return paragraph.childWidgets[lineIndex + 1];
            }
            else if (paragraph.nextSplitWidget) {
                var line = paragraph.nextSplitWidget.firstChild;
                if (line instanceof LineWidget && line.paragraph.equals(this.paragraph)) {
                    return line;
                }
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineWidget.prototype, "previousLine", {
        /**
         * @private
         */
        get: function () {
            var paragraph = this.paragraph;
            var lineIndex = this.indexInOwner;
            var splitParagraph = paragraph.previousSplitWidget;
            if (lineIndex > 0) {
                return paragraph.childWidgets[lineIndex - 1];
            }
            else if (splitParagraph instanceof ParagraphWidget) {
                var line = splitParagraph.lastChild;
                if (line instanceof LineWidget && line.paragraph.equals(this.paragraph)) {
                    return line;
                }
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineWidget.prototype, "isEndsWithPageBreak", {
        /**
         * @private
         */
        get: function () {
            if (this.children.length > 0) {
                var lastElement = this.children[this.children.length - 1];
                if (lastElement instanceof TextElementBox) {
                    return lastElement.isPageBreak;
                }
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    LineWidget.prototype.isFirstLine = function () {
        var index = this.indexInOwner;
        if (index > -1 && this.paragraph.previousSplitWidget === undefined) {
            return index === 0;
        }
        return false;
    };
    /**
     * @private
     */
    LineWidget.prototype.isLastLine = function () {
        var index = this.indexInOwner;
        if (index > -1 && this.paragraph.nextSplitWidget === undefined) {
            return index === this.paragraph.childWidgets.length - 1;
        }
        return false;
    };
    /**
     * @private
     */
    LineWidget.prototype.getOffset = function (inline, index) {
        if (isNullOrUndefined(inline)) {
            return index;
        }
        var textIndex = index;
        var line = inline.line;
        var lineIndex = inline.line.paragraph.childWidgets.indexOf(inline.line);
        for (var i = 0; i < line.children.length; i++) {
            var inlineElement = line.children[i];
            if (inline === inlineElement) {
                break;
            }
            if (inlineElement instanceof ListTextElementBox) {
                continue;
            }
            textIndex += inlineElement.length;
        }
        return textIndex;
    };
    /**
     * @private
     */
    LineWidget.prototype.getEndOffset = function () {
        var startOffset = 0;
        var count = 0;
        for (var i = 0; i < this.children.length; i++) {
            var inlineElement = this.children[i];
            if (inlineElement.length === 0) {
                continue;
            }
            if (inlineElement instanceof ListTextElementBox) {
                continue;
            }
            if (inlineElement instanceof TextElementBox || inlineElement instanceof ImageElementBox
                || inlineElement instanceof BookmarkElementBox || (inlineElement instanceof FieldElementBox
                && HelperMethods.isLinkedFieldCharacter(inlineElement))) {
                startOffset = count + inlineElement.length;
            }
            count += inlineElement.length;
        }
        return startOffset;
    };
    /**
     * @private
     */
    LineWidget.prototype.getInline = function (offset, indexInInline) {
        var inlineElement = undefined;
        var count = 0;
        var isStarted = false;
        if (this.children.length === 0) {
            if (this.previousLine) {
                var elementBox = this.previousLine.children[this.previousLine.children.length - 1];
                if (elementBox instanceof TextElementBox && elementBox.text === '\v') {
                    inlineElement = this.previousLine.children[this.previousLine.children.length - 1];
                    indexInInline = 1;
                    return { 'element': inlineElement, 'index': indexInInline };
                }
            }
        }
        for (var i = 0; i < this.children.length; i++) {
            inlineElement = this.children[i];
            if (inlineElement instanceof ListTextElementBox) {
                continue;
            }
            if (!isStarted && (inlineElement instanceof TextElementBox || inlineElement instanceof ImageElementBox
                || inlineElement instanceof BookmarkElementBox
                || inlineElement instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(inlineElement))) {
                isStarted = true;
            }
            if (isStarted && offset <= count + inlineElement.length) {
                indexInInline = (offset - count);
                return { 'element': inlineElement, 'index': indexInInline };
            }
            count += inlineElement.length;
        }
        if (offset > count) {
            indexInInline = isNullOrUndefined(inlineElement) ? offset : inlineElement.length;
        }
        return { 'element': inlineElement, 'index': indexInInline };
    };
    /**
     * @private
     */
    LineWidget.prototype.getHierarchicalIndex = function (hierarchicalIndex) {
        var node = this;
        hierarchicalIndex = node.paragraph.childWidgets.indexOf(node) + ';' + hierarchicalIndex;
        if (node.paragraph instanceof BlockWidget) {
            return node.paragraph.getHierarchicalIndex(hierarchicalIndex);
        }
        return hierarchicalIndex;
    };
    /**
     * @private
     */
    LineWidget.prototype.clone = function () {
        var line = new LineWidget(undefined);
        for (var j = 0; j < this.children.length; j++) {
            var element = this.children[j];
            var clone = element.clone();
            line.children.push(clone);
            clone.line = line;
        }
        line.width = this.width;
        line.height = this.height;
        return line;
    };
    /**
     * @private
     */
    LineWidget.prototype.destroy = function () {
        if (!isNullOrUndefined(this.children)) {
            for (var i = 0; i < this.children.length; i++) {
                this.children[i].destroy();
            }
            this.children = [];
        }
        this.children = undefined;
        if (this.paragraph) {
            this.paragraph.removeChild(this.indexInOwner);
        }
        this.paragraph = undefined;
        this.x = undefined;
        this.y = undefined;
        this.width = undefined;
        this.height = undefined;
    };
    return LineWidget;
}());
export { LineWidget };
/**
 * @private
 */
var ElementBox = /** @class */ (function () {
    /**
     * Initialize the constructor of ElementBox
     */
    function ElementBox() {
        /**
         * @private
         */
        this.x = 0;
        /**
         * @private
         */
        this.y = 0;
        /**
         * @private
         */
        this.width = 0;
        /**
         * @private
         */
        this.height = 0;
        /**
         * @private
         */
        this.margin = new Margin(0, 0, 0, 0);
        /**
         * @private
         */
        this.characterFormat = undefined;
        this.characterFormat = new WCharacterFormat(this);
        this.margin = new Margin(0, 0, 0, 0);
    }
    Object.defineProperty(ElementBox.prototype, "isPageBreak", {
        /**
         * @private
         */
        get: function () {
            if (this instanceof TextElementBox) {
                return this.text === '\f';
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ElementBox.prototype.linkFieldCharacter = function (viewer) {
        if (!(this instanceof FieldElementBox)) {
            return;
        }
        if (this.fieldType === 0) {
            var fieldBegin = this;
            if (isNullOrUndefined(fieldBegin.fieldEnd)) {
                this.linkFieldTraversingForward(this.line, fieldBegin, fieldBegin);
                if (viewer.fields.indexOf(fieldBegin) === -1) {
                    viewer.fields.push(fieldBegin);
                }
            }
        }
        else if (this.fieldType === 2) {
            var fieldSeparator = this;
            //Links the field begin for the current separator.
            if (isNullOrUndefined(fieldSeparator.fieldBegin)) {
                this.linkFieldTraversingBackwardSeparator(this.line, fieldSeparator, fieldSeparator);
            }
            fieldSeparator.fieldBegin.fieldSeparator = fieldSeparator;
            if (!isNullOrUndefined(fieldSeparator.fieldBegin)) {
                //Links to field end traversing from field separator.
                var isFieldEnd = this.linkFieldTraversingForward(this.line, fieldSeparator.fieldBegin, fieldSeparator);
                if (isNullOrUndefined(fieldSeparator.fieldEnd) && isFieldEnd) {
                    fieldSeparator.fieldEnd = fieldSeparator.fieldBegin.fieldEnd;
                }
                if (fieldSeparator.fieldEnd) {
                    fieldSeparator.fieldEnd.fieldSeparator = fieldSeparator;
                }
            }
        }
        else {
            var fieldEnd = this;
            //Links the field begin and separator for the current end.
            if (isNullOrUndefined(fieldEnd.fieldBegin)) {
                this.linkFieldTraversingBackward(this.line, fieldEnd, fieldEnd);
            }
        }
    };
    /**
     * @private
     */
    ElementBox.prototype.linkFieldTraversingBackward = function (line, fieldEnd, previousNode) {
        var k = line.children.length - 1;
        if (line.children.indexOf(previousNode) > -1) {
            k = line.children.indexOf(previousNode) - 1;
        }
        for (var j = k; j >= 0; j--) {
            var childNode = line.children[j];
            if (childNode instanceof FieldElementBox) {
                if (childNode.fieldType === 0) {
                    if (isNullOrUndefined(childNode.fieldEnd)) {
                        fieldEnd.fieldBegin = childNode;
                        if (isNullOrUndefined(childNode.fieldEnd)) {
                            childNode.fieldEnd = fieldEnd;
                        }
                        if (fieldEnd.fieldSeparator && isNullOrUndefined(fieldEnd.fieldSeparator.fieldBegin)) {
                            fieldEnd.fieldSeparator.fieldBegin = childNode;
                            if (isNullOrUndefined(childNode.fieldSeparator)) {
                                childNode.fieldSeparator = fieldEnd.fieldSeparator;
                            }
                        }
                    }
                    return !isNullOrUndefined(fieldEnd.fieldBegin);
                }
                else if (childNode.fieldType === 2 && isNullOrUndefined(childNode.fieldEnd)) {
                    fieldEnd.fieldSeparator = childNode;
                    childNode.fieldEnd = fieldEnd;
                    if (!isNullOrUndefined(childNode.fieldBegin)) {
                        fieldEnd.fieldBegin = childNode.fieldBegin;
                    }
                }
            }
        }
        if (line.previousLine) {
            this.linkFieldTraversingBackward(line.previousLine, fieldEnd, this);
        }
        else if (line.paragraph.previousRenderedWidget instanceof ParagraphWidget) {
            var prevParagraph = line.paragraph.previousRenderedWidget;
            // tslint:disable-next-line:max-line-length
            this.linkFieldTraversingBackward(prevParagraph.childWidgets[prevParagraph.childWidgets.length - 1], fieldEnd, this);
        }
        return true;
    };
    /**
     * @private
     */
    ElementBox.prototype.linkFieldTraversingForward = function (line, fieldBegin, previousNode) {
        var i = 0;
        if (line.children.indexOf(previousNode) > -1) {
            i = line.children.indexOf(previousNode) + 1;
        }
        for (var j = i; j < line.children.length; j++) {
            var node = line.children[j];
            if (node instanceof FieldElementBox) {
                if (node.fieldType === 1) {
                    if (isNullOrUndefined(node.fieldBegin)) {
                        fieldBegin.fieldEnd = node;
                    }
                    if (fieldBegin.fieldEnd && isNullOrUndefined(fieldBegin.fieldEnd.fieldBegin)) {
                        fieldBegin.fieldEnd.fieldBegin = fieldBegin;
                    }
                    return true;
                }
                else if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
                    if (node.fieldType === 2 && isNullOrUndefined(node.fieldBegin)) {
                        fieldBegin.fieldSeparator = node;
                        if (!isNullOrUndefined(node.fieldEnd)) {
                            fieldBegin.fieldEnd = node.fieldEnd;
                            return true;
                        }
                    }
                    else {
                        return false;
                    }
                }
            }
        }
        if (line.nextLine) {
            this.linkFieldTraversingForward(line.nextLine, fieldBegin, this);
        }
        else if (line.paragraph.nextRenderedWidget instanceof ParagraphWidget) {
            this.linkFieldTraversingForward(line.paragraph.nextRenderedWidget.childWidgets[0], fieldBegin, this);
        }
        return true;
    };
    /**
     * @private
     */
    ElementBox.prototype.linkFieldTraversingBackwardSeparator = function (line, fieldSeparator, previousNode) {
        var index = line.children.length - 1;
        if (line.children.indexOf(previousNode) > -1) {
            index = line.children.indexOf(previousNode) - 1;
        }
        for (var i = index; i >= 0; i--) {
            var childElement = line.children[i];
            if (childElement instanceof FieldElementBox) {
                if (childElement instanceof FieldElementBox && childElement.fieldType === 0) {
                    if (isNullOrUndefined(childElement.fieldSeparator)) {
                        fieldSeparator.fieldBegin = childElement;
                    }
                    return !isNullOrUndefined(fieldSeparator.fieldBegin);
                }
            }
        }
        if (line.previousLine) {
            this.linkFieldTraversingBackwardSeparator(line.previousLine, fieldSeparator, this);
        }
        else if (line.paragraph.nextRenderedWidget instanceof ParagraphWidget) {
            // tslint:disable-next-line:max-line-length
            line = line.paragraph.previousRenderedWidget.childWidgets[line.paragraph.previousRenderedWidget.childWidgets.length - 1];
            this.linkFieldTraversingBackwardSeparator(line, fieldSeparator, this);
        }
        else {
            return true;
        }
        return true;
    };
    Object.defineProperty(ElementBox.prototype, "length", {
        /**
         * @private
         */
        get: function () {
            return this.getLength();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementBox.prototype, "indexInOwner", {
        /**
         * @private
         */
        get: function () {
            return this.line instanceof LineWidget && this.line.children ? this.line.children.indexOf(this) : -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementBox.prototype, "previousElement", {
        /**
         * @private
         */
        get: function () {
            var index = this.indexInOwner;
            if (index > 0 && index < this.line.children.length) {
                return this.line.children[index - 1];
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementBox.prototype, "nextElement", {
        /**
         * @private
         */
        get: function () {
            var index = this.indexInOwner;
            if (index > -1 && index < this.line.children.length - 1) {
                return this.line.children[index + 1];
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementBox.prototype, "nextNode", {
        /**
         * @private
         */
        get: function () {
            var index = this.line.children.indexOf(this);
            var lineIndex = this.line.paragraph.childWidgets.indexOf(this.line);
            if (index < this.line.children.length - 1) {
                return this.line.children[index + 1];
            }
            else if (lineIndex < this.line.paragraph.childWidgets.length - 1) {
                return this.line.paragraph.childWidgets[lineIndex + 1].children[0];
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementBox.prototype, "previousNode", {
        /**
         * @private
         */
        get: function () {
            var index = this.line.children.indexOf(this);
            var lineIndex = this.line.paragraph.childWidgets.indexOf(this.line);
            if (index > 0) {
                return this.line.children[index - 1];
            }
            else if (lineIndex > 0) {
                var lineWidget = this.line.paragraph.childWidgets[lineIndex - 1];
                return lineWidget.children[lineWidget.children.length - 1];
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementBox.prototype, "paragraph", {
        /**
         * @private
         */
        get: function () {
            if (this.line) {
                return this.line.paragraph;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ElementBox.prototype.destroy = function () {
        if (!isNullOrUndefined(this.line) && this.line.children && this.line.children.indexOf(this) > -1) {
            var index = this.line.children.indexOf(this);
            this.line.children.splice(index, 1);
        }
        this.line = undefined;
        if (this.characterFormat) {
            this.characterFormat.destroy();
        }
        this.characterFormat = undefined;
        if (this.margin) {
            this.margin.destroy();
        }
        this.margin = undefined;
        this.x = undefined;
        this.y = undefined;
        this.width = undefined;
        this.height = undefined;
    };
    /**
     * @private
     */
    ElementBox.objectCharacter = String.fromCharCode(65532);
    return ElementBox;
}());
export { ElementBox };
/**
 * @private
 */
var FieldElementBox = /** @class */ (function (_super) {
    __extends(FieldElementBox, _super);
    function FieldElementBox(type) {
        var _this = _super.call(this) || this;
        /**
         * @private
         */
        _this.fieldType = 0;
        /**
         * @private
         */
        _this.hasFieldEnd = false;
        _this.fieldBeginInternal = undefined;
        _this.fieldSeparatorInternal = undefined;
        _this.fieldEndInternal = undefined;
        _this.fieldType = type;
        return _this;
    }
    Object.defineProperty(FieldElementBox.prototype, "fieldBegin", {
        get: function () {
            return this.fieldBeginInternal;
        },
        set: function (field) {
            this.fieldBeginInternal = field;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FieldElementBox.prototype, "fieldSeparator", {
        get: function () {
            return this.fieldSeparatorInternal;
        },
        set: function (field) {
            this.fieldSeparatorInternal = field;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FieldElementBox.prototype, "fieldEnd", {
        get: function () {
            return this.fieldEndInternal;
        },
        set: function (field) {
            this.fieldEndInternal = field;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    FieldElementBox.prototype.getLength = function () {
        return 1;
    };
    /**
     * @private
     */
    FieldElementBox.prototype.clone = function () {
        var field = new FieldElementBox(this.fieldType);
        field.characterFormat.copyFormat(this.characterFormat);
        if (this.margin) {
            field.margin = this.margin.clone();
        }
        field.width = this.width;
        field.height = this.height;
        return field;
    };
    /**
     * @private
     */
    FieldElementBox.prototype.destroy = function () {
        this.fieldType = undefined;
        this.hasFieldEnd = undefined;
        this.fieldBeginInternal = undefined;
        this.fieldEndInternal = undefined;
        this.fieldSeparatorInternal = undefined;
        _super.prototype.destroy.call(this);
    };
    return FieldElementBox;
}(ElementBox));
export { FieldElementBox };
/**
 * @private
 */
var TextElementBox = /** @class */ (function (_super) {
    __extends(TextElementBox, _super);
    function TextElementBox() {
        var _this = _super.call(this) || this;
        /**
         * @private
         */
        _this.baselineOffset = 0;
        /**
         * @private
         */
        _this.text = '';
        return _this;
    }
    /**
     * @private
     */
    TextElementBox.prototype.getLength = function () {
        return this.text ? this.text.length : 0;
    };
    /**
     * @private
     */
    TextElementBox.prototype.clone = function () {
        var span = new TextElementBox();
        span.characterFormat.copyFormat(this.characterFormat);
        span.text = this.text;
        if (this.margin) {
            span.margin = this.margin.clone();
        }
        span.width = this.width;
        span.height = this.height;
        return span;
    };
    /**
     * @private
     */
    TextElementBox.prototype.destroy = function () {
        this.text = undefined;
        _super.prototype.destroy.call(this);
    };
    return TextElementBox;
}(ElementBox));
export { TextElementBox };
/**
 * @private
 */
var FieldTextElementBox = /** @class */ (function (_super) {
    __extends(FieldTextElementBox, _super);
    function FieldTextElementBox() {
        var _this = _super.call(this) || this;
        _this.fieldText = '';
        return _this;
    }
    Object.defineProperty(FieldTextElementBox.prototype, "text", {
        get: function () {
            return this.fieldText;
        },
        set: function (value) {
            this.fieldText = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    FieldTextElementBox.prototype.clone = function () {
        var span = new FieldTextElementBox();
        span.characterFormat.copyFormat(this.characterFormat);
        span.fieldBegin = this.fieldBegin;
        span.text = this.text;
        if (this.margin) {
            span.margin = this.margin.clone();
        }
        span.width = this.width;
        span.height = this.height;
        return span;
    };
    return FieldTextElementBox;
}(TextElementBox));
export { FieldTextElementBox };
/**
 * @private
 */
var TabElementBox = /** @class */ (function (_super) {
    __extends(TabElementBox, _super);
    function TabElementBox() {
        var _this = _super.call(this) || this;
        /**
         * @private
         */
        _this.tabText = '';
        /**
         * @private
         */
        _this.tabLeader = 'None';
        return _this;
    }
    /**
     * @private
     */
    TabElementBox.prototype.destroy = function () {
        this.tabText = undefined;
        this.tabLeader = undefined;
    };
    /**
     * @private
     */
    TabElementBox.prototype.clone = function () {
        var span = new TabElementBox();
        span.characterFormat.copyFormat(this.characterFormat);
        span.tabText = this.tabText;
        span.tabLeader = this.tabLeader;
        span.text = this.text;
        if (this.margin) {
            span.margin = this.margin.clone();
        }
        span.width = this.width;
        span.height = this.height;
        return span;
    };
    return TabElementBox;
}(TextElementBox));
export { TabElementBox };
/**
 * @private
 */
var BookmarkElementBox = /** @class */ (function (_super) {
    __extends(BookmarkElementBox, _super);
    function BookmarkElementBox(type) {
        var _this = _super.call(this) || this;
        _this.bookmarkTypeIn = 0;
        _this.refereneceIn = undefined;
        _this.nameIn = '';
        _this.bookmarkTypeIn = type;
        return _this;
    }
    Object.defineProperty(BookmarkElementBox.prototype, "bookmarkType", {
        /**
         * @private
         */
        get: function () {
            return this.bookmarkTypeIn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BookmarkElementBox.prototype, "name", {
        /**
         * @private
         */
        get: function () {
            return this.nameIn;
        },
        /**
         * @private
         */
        set: function (name) {
            this.nameIn = name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BookmarkElementBox.prototype, "reference", {
        /**
         * @private
         */
        get: function () {
            return this.refereneceIn;
        },
        /**
         * @private
         */
        set: function (reference) {
            this.refereneceIn = reference;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    BookmarkElementBox.prototype.getLength = function () {
        return 1;
    };
    /**
     * @private
     */
    BookmarkElementBox.prototype.destroy = function () {
        this.name = undefined;
        this.reference = undefined;
        this.bookmarkTypeIn = undefined;
    };
    /**
     * Clones the bookmark element box.
     * @param element - book mark element
     */
    /**
     * @private
     */
    BookmarkElementBox.prototype.clone = function () {
        var span = new BookmarkElementBox(this.bookmarkType);
        span.name = this.name;
        span.reference = this.reference;
        if (this.margin) {
            span.margin = this.margin.clone();
        }
        span.width = this.width;
        span.height = this.height;
        return span;
    };
    return BookmarkElementBox;
}(ElementBox));
export { BookmarkElementBox };
/**
 * @private
 */
var ImageElementBox = /** @class */ (function (_super) {
    __extends(ImageElementBox, _super);
    function ImageElementBox(isInlineImage) {
        var _this = _super.call(this) || this;
        _this.imageStr = '';
        _this.imgElement = undefined;
        _this.isInlineImageIn = true;
        /**
         * @private
         */
        _this.isMetaFile = false;
        _this.isInlineImageIn = isInlineImage;
        return _this;
    }
    Object.defineProperty(ImageElementBox.prototype, "isInlineImage", {
        /**
         * @private
         */
        get: function () {
            return this.isInlineImageIn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageElementBox.prototype, "element", {
        /**
         * @private
         */
        get: function () {
            if (isNullOrUndefined(this.imgElement)) {
                this.imgElement = document.createElement('img');
            }
            return this.imgElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageElementBox.prototype, "length", {
        /**
         * @private
         */
        get: function () {
            return 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageElementBox.prototype, "imageString", {
        /**
         * @private
         */
        get: function () {
            return this.imageStr;
        },
        /**
         * @private
         */
        set: function (value) {
            this.imageStr = value;
            if (!isNullOrUndefined(value)) {
                this.element.src = this.imageStr;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ImageElementBox.prototype.getLength = function () {
        return 1;
    };
    /**
     * @private
     */
    ImageElementBox.prototype.clone = function () {
        var image = new ImageElementBox(this.isInlineImage);
        image.characterFormat.copyFormat(this.characterFormat);
        image.imageString = this.imageString;
        image.isMetaFile = this.isMetaFile;
        image.width = this.width;
        image.height = this.height;
        if (this.margin) {
            image.margin = this.margin.clone();
        }
        return image;
    };
    /**
     * @private
     */
    ImageElementBox.prototype.destroy = function () {
        this.imgElement = undefined;
        this.imageString = undefined;
        this.isInlineImageIn = undefined;
        _super.prototype.destroy.call(this);
    };
    return ImageElementBox;
}(ElementBox));
export { ImageElementBox };
/**
 * @private
 */
var ListTextElementBox = /** @class */ (function (_super) {
    __extends(ListTextElementBox, _super);
    function ListTextElementBox(listLevel, isListFollowCharacter) {
        var _this = _super.call(this) || this;
        /**
         * @private
         */
        _this.baselineOffset = 0;
        /**
         * @private
         */
        _this.isFollowCharacter = false;
        _this.listLevel = listLevel;
        _this.isFollowCharacter = isListFollowCharacter;
        return _this;
    }
    /**
     * @private
     */
    ListTextElementBox.prototype.getLength = function () {
        return this.text ? this.text.length : 0;
    };
    /**
     * @private
     */
    ListTextElementBox.prototype.clone = function () {
        var list = new ListTextElementBox(this.listLevel, this.isFollowCharacter);
        list.text = this.text;
        list.baselineOffset = this.baselineOffset;
        if (this.margin) {
            list.margin = this.margin.clone();
        }
        list.width = this.width;
        list.height = this.height;
        return list;
    };
    /**
     * @private
     */
    ListTextElementBox.prototype.destroy = function () {
        this.text = undefined;
        _super.prototype.destroy.call(this);
    };
    return ListTextElementBox;
}(ElementBox));
export { ListTextElementBox };
/**
 * @private
 */
var Page = /** @class */ (function () {
    /**
     * Initialize the constructor of Page
     */
    function Page() {
        /**
         * Specifies the Bonding Rectangle
         * @private
         */
        this.boundingRectangle = new Rect(96, 96, 816, 1056);
        /**
         * @private
         */
        this.repeatHeaderRowTableWidget = false;
        /**
         * Specifies the bodyWidgets
         * @default []
         * @private
         */
        this.bodyWidgets = [];
        /**
         * @private
         */
        this.headerWidget = undefined;
        /**
         * @private
         */
        this.footerWidget = undefined;
        // let text: string = 'DocumentEditor';
    }
    Object.defineProperty(Page.prototype, "index", {
        /**
         * @private
         */
        get: function () {
            if (this.viewer) {
                return this.viewer.pages.indexOf(this);
            }
            return -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Page.prototype, "previousPage", {
        /**
         * @private
         */
        get: function () {
            var index = this.index;
            if (index > 0) {
                return this.viewer.pages[index - 1];
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Page.prototype, "nextPage", {
        /**
         * @private
         */
        get: function () {
            var index = this.index;
            if (index < this.viewer.pages.length - 1) {
                return this.viewer.pages[index + 1];
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Page.prototype, "sectionIndex", {
        /**
         * @private
         */
        get: function () {
            if (this.bodyWidgets.length > 0) {
                return this.bodyWidgets[0].index;
            }
            return -1;
        },
        enumerable: true,
        configurable: true
    });
    Page.prototype.destroy = function () {
        if (this.headerWidget) {
            if (this.viewer && this.viewer.owner.editor) {
                this.viewer.owner.editor.removeFieldInWidget(this.headerWidget);
            }
            this.headerWidget.destroy();
        }
        this.headerWidget = undefined;
        if (this.footerWidget) {
            if (this.viewer && this.viewer.owner.editor) {
                this.viewer.owner.editor.removeFieldInWidget(this.footerWidget);
            }
            this.footerWidget.destroy();
        }
        this.footerWidget = undefined;
        this.bodyWidgets = [];
        this.bodyWidgets = undefined;
        if (!isNullOrUndefined(this.viewer)) {
            if (!isNullOrUndefined(this.viewer.pages)) {
                this.viewer.removePage(this);
            }
        }
        this.viewer = undefined;
    };
    return Page;
}());
export { Page };
/**
 * @private
 */
var WTableHolder = /** @class */ (function () {
    function WTableHolder() {
        this.tableColumns = [];
        /**
         * @private
         */
        this.tableWidth = 0;
    }
    Object.defineProperty(WTableHolder.prototype, "columns", {
        get: function () {
            return this.tableColumns;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    WTableHolder.prototype.resetColumns = function () {
        for (var i = 0; i < this.tableColumns.length; i++) {
            this.tableColumns[i].destroy();
        }
        this.tableColumns = [];
    };
    /**
     * @private
     */
    WTableHolder.prototype.getPreviousSpannedCellWidth = function (previousColumnIndex, curColumnIndex) {
        var width = 0;
        for (var i = previousColumnIndex; i < curColumnIndex; i++) {
            width += this.tableColumns[i].preferredWidth;
        }
        return width;
    };
    /**
     * @private
     */
    WTableHolder.prototype.addColumns = function (currentColumnIndex, columnSpan, width, minWidth, offset) {
        for (var i = this.columns.length; i < columnSpan; i++) {
            this.columns.push(new WColumn());
        }
        var availableWidth = 0;
        for (var j = currentColumnIndex; j < columnSpan; j++) {
            availableWidth += this.columns[j].preferredWidth;
        }
        // If width to add is greater than preferred width, then preferred width will be increased.
        // In case of Gridspan > 1, only last grid column width will be updated.
        var gridSpan = columnSpan - currentColumnIndex;
        if (!(gridSpan > 1) && availableWidth < width) {
            this.columns[columnSpan - 1].preferredWidth += (width - availableWidth);
        }
        if (minWidth > this.columns[columnSpan - 1].minWidth) {
            this.columns[columnSpan - 1].minWidth = minWidth;
        }
        if (offset > this.columns[columnSpan - 1].endOffset) {
            this.columns[columnSpan - 1].endOffset = offset;
        }
    };
    /**
     * @private
     */
    WTableHolder.prototype.getTotalWidth = function () {
        var width = 0;
        for (var i = 0; i < this.columns.length; i++) {
            var column = this.columns[i];
            width += column.preferredWidth;
        }
        return width;
    };
    /**
     * @private
     */
    WTableHolder.prototype.isFitColumns = function (containerWidth, preferredTableWidth, isAutoWidth) {
        // Gets total preferred width.
        var totalColumnWidth = this.getTotalWidth();
        // If auto table width, based on total column widths, minimum value will be updated.
        if (isAutoWidth) {
            this.tableWidth = preferredTableWidth > totalColumnWidth ? totalColumnWidth : preferredTableWidth;
        }
        else {
            this.tableWidth = preferredTableWidth;
        }
        // If total columns width doesn't match table width, then all grid column widths will be updated by even factor.
        // If totalColumnWidth < TableWidth, all grid columns are enlarged. Otherwise shrinked.
        if (totalColumnWidth !== this.tableWidth) {
            var factor = this.tableWidth / totalColumnWidth;
            factor = isNaN(factor) ? 1 : factor;
            for (var i = 0; i < this.columns.length; i++) {
                var column = this.columns[i];
                //column.PreferredWidth = factor * column.PreferredWidth;
                if (factor * column.preferredWidth < column.minWidth) {
                    return false;
                }
            }
            return true;
        }
        else {
            return true;
        }
    };
    /**
     * @private
     */
    WTableHolder.prototype.fitColumns = function (containerWidth, preferredTableWidth, isAutoWidth) {
        // Gets total preferred width.
        var totalColumnWidth = this.getTotalWidth();
        // If auto table width, based on total column widths, minimum value will be updated.
        if (isAutoWidth) {
            this.tableWidth = preferredTableWidth > totalColumnWidth ? totalColumnWidth : preferredTableWidth;
        }
        else {
            this.tableWidth = preferredTableWidth;
        }
        // If total columns width doesn't match table width, then all grid column widths will be updated by even factor.
        // If totalColumnWidth < TableWidth, all grid columns are enlarged. Otherwise shrinked.
        if (totalColumnWidth !== this.tableWidth) {
            var factor = this.tableWidth / totalColumnWidth;
            for (var i = 0; i < this.columns.length; i++) {
                var column = this.columns[i];
                column.preferredWidth = factor * column.preferredWidth;
            }
        }
    };
    /**
     * @private
     */
    WTableHolder.prototype.getCellWidth = function (columnIndex, columnSpan, preferredTableWidth, isAutoWidth) {
        var width = 0;
        for (var i = 0; i < columnSpan; i++) {
            width += this.tableColumns[i + columnIndex].preferredWidth;
        }
        return width;
    };
    /**
     * @private
     */
    WTableHolder.prototype.validateColumnWidths = function () {
        for (var i = 0; i < this.columns.length; i++) {
            if (i === 0) {
                if (this.columns[i].preferredWidth !== this.columns[i].endOffset) {
                    this.columns[i].preferredWidth = this.columns[i].endOffset;
                }
            }
            else {
                // If Previous column offset + current column preferred width is less than current column offset, 
                // Then current column preferred width is set to current column offset - previous column offset.
                if (this.columns[i - 1].endOffset + this.columns[i].preferredWidth < this.columns[i].endOffset) {
                    this.columns[i].preferredWidth = this.columns[i].endOffset - this.columns[i - 1].endOffset;
                }
            }
        }
    };
    /**
     * @private
     */
    WTableHolder.prototype.clone = function () {
        var tableHolder = new WTableHolder();
        tableHolder.tableWidth = this.tableWidth;
        for (var i = 0; i < this.columns.length; i++) {
            tableHolder.columns.push(this.columns[i].clone());
        }
        return tableHolder;
    };
    /**
     * @private
     */
    WTableHolder.prototype.destroy = function () {
        if (!isNullOrUndefined(this.tableColumns)) {
            for (var i = 0; i < this.tableColumns.length; i++) {
                var column = this.tableColumns[i];
                column.destroy();
            }
        }
        this.tableColumns = [];
        this.tableColumns = undefined;
        this.tableWidth = undefined;
    };
    return WTableHolder;
}());
export { WTableHolder };
/**
 * @private
 */
var WColumn = /** @class */ (function () {
    function WColumn() {
        /**
         * @private
         */
        this.preferredWidth = 0;
        /**
         * @private
         */
        this.minWidth = 0;
        /**
         * @private
         */
        this.maxWidth = 0;
        /**
         * @private
         */
        this.endOffset = 0;
    }
    /**
     * @private
     */
    WColumn.prototype.clone = function () {
        var column = new WColumn();
        column.preferredWidth = this.preferredWidth;
        column.minWidth = this.minWidth;
        column.maxWidth = this.maxWidth;
        return column;
    };
    /**
     * @private
     */
    WColumn.prototype.destroy = function () {
        this.preferredWidth = undefined;
        this.minWidth = undefined;
        this.maxWidth = undefined;
    };
    return WColumn;
}());
export { WColumn };
