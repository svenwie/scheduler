import { LayoutViewer } from '../index';
import { Selection } from '../index';
import { TextPosition } from '../selection/selection-helper';
import { ParagraphWidget, LineWidget, ElementBox, Page, ImageElementBox, BlockWidget, TableWidget, TableCellWidget, Widget, BookmarkElementBox, HeaderFooterWidget, FieldTextElementBox } from '../viewer/page';
import { WCharacterFormat } from '../format/character-format';
import { ElementInfo, ParagraphInfo, LineInfo, IndexInfo, BlockInfo } from './editor-helper';
import { WParagraphFormat, WTableFormat, WRowFormat, WCellFormat, WBorder, WBorders, WShading } from '../index';
import { WList } from '../list/list';
import { WListLevel } from '../list/list-level';
import { WLevelOverride } from '../list/level-override';
import { FieldElementBox } from '../viewer/page';
import { HighlightColor, BaselineAlignment, Strikethrough, Underline, TextAlignment, ListLevelPattern } from '../../base/index';
import { Action } from '../../index';
import { TableResizer } from './table-resizer';
import { CellVerticalAlignment, BorderType, LineStyle, TabLeader } from '../../base/types';
/**
 * Editor module
 */
export declare class Editor {
    /**
     * @private
     */
    viewer: LayoutViewer;
    private nodes;
    private editHyperlinkInternal;
    private startOffset;
    private startParagraph;
    private endOffset;
    private endParagraph;
    /**
     * @private
     */
    isHandledComplex: boolean;
    /**
     * @private
     */
    tableResize: TableResizer;
    /**
     * @private
     */
    tocStyles: TocLevelSettings;
    private refListNumber;
    private incrementListNumber;
    private removedBookmarkElements;
    /**
     * @private
     */
    tocBookmarkId: number;
    /**
     * @private
     */
    copiedData: string;
    private animationTimer;
    private pageRefFields;
    /**
     * @private
     */
    isInsertingTOC: boolean;
    /**
     * Initialize the editor module
     * @param  {LayoutViewer} viewer
     * @private
     */
    constructor(viewer: LayoutViewer);
    private readonly editorHistory;
    /**
     * @private
     */
    isBordersAndShadingDialog: boolean;
    private readonly selection;
    private readonly owner;
    private getModuleName();
    insertField(code: string, result?: string): void;
    /**
     * To update style for paragraph
     * @param style - style name
     * @param clearDirectFormatting - Removes manual formatting (formatting not applied using a style)
     * from the selected text, to match the formatting of the applied style. Default value is false.
     */
    applyStyle(style: string, clearDirectFormatting?: boolean): void;
    /**
     * Moves the selected content in the document editor control to clipboard.
     */
    cut(): void;
    /**
     * Notify content change event
     * @private
     */
    fireContentChange(): void;
    /**
     * Update physical location for text position
     * @private
     */
    updateSelectionTextPosition(isSelectionChanged: boolean): void;
    /**
     * @private
     */
    onTextInputInternal: (event: KeyboardEvent) => void;
    /**
     * Predict text
     * @private
     */
    predictText(): void;
    /**
     * Gets prefix and suffix.
     * @private
     */
    getPrefixAndSuffix(): void;
    /**
     * Fired on paste.
     * @param {ClipboardEvent} event
     * @private
     */
    onPaste: (event: ClipboardEvent) => void;
    /**
     * key action
     * @private
     */
    onKeyDownInternal(event: KeyboardEvent, ctrl: boolean, shift: boolean, alt: boolean): void;
    /**
     * @private
     */
    handleShiftEnter(): void;
    /**
     * Handles back key.
     * @private
     */
    handleBackKey(): void;
    /**
     * Handles delete
     * @private
     */
    handleDelete(): void;
    /**
     * Handles enter key.
     * @private
     */
    handleEnterKey(): void;
    /**
     * @private
     */
    handleTextInput(text: string): void;
    /**
     * Copies to format.
     * @param  {WCharacterFormat} format
     * @private
     */
    copyInsertFormat(format: WCharacterFormat, copy: boolean): WCharacterFormat;
    /**
     * Inserts the specified text at cursor position
     * @param  {string} text
     * @param  {boolean} isReplace
     * @private
     */
    insertText(text: string, isReplace: boolean): void;
    /**
     * Insert Section break at cursor position
     */
    insertSectionBreak(): void;
    /**
     * @private
     */
    insertSection(selection: Selection, selectFirstBlock: boolean): BlockWidget;
    private splitBodyWidget(bodyWidget, sectionFormat, startBlock);
    private insertRemoveHeaderFooter(sectionIndex, insert);
    private updateBlockIndex(blockIndex, block);
    private updateSectionIndex(sectionFormat, startBodyWidget, increaseIndex);
    private checkAndConvertList(selection, isTab);
    private getListLevelPattern(value);
    private autoConvertList(selection, listLevel);
    private checkNumberFormat(numberFormat, isBullet, text);
    private checkLeadingZero(text);
    private getPageFromBlockWidget(block);
    /**
     * @private
     */
    insertTextInline(element: ElementBox, selection: Selection, text: string, index: number): void;
    private insertFieldBeginText(fieldBegin, selection, text, index);
    private insertBookMarkText(element, selection, text, index);
    private insertFieldSeparatorText(fieldSeparator, selection, text, index);
    private insertFieldEndText(fieldEnd, selection, text, index);
    private insertImageText(image, selection, text, index);
    /**
     * @private
     */
    private isListTextSelected();
    private checkAndConvertToHyperlink(selection, isEnter, paragraph?);
    private autoFormatHyperlink(selection, url, startPosition, endPosition);
    private appylingHyperlinkFormat(selection);
    private createHyperlinkElement(url, startPosition, endPosition, format);
    private insertHyperlinkfield(selection, format, url, isBookmark?);
    private unLinkFieldCharacter(inline);
    private getCharacterFormat(selection);
    /**
     * Insert Hyperlink
     * @param  {string} url
     * @param  {string} displayText
     * @param  {boolean} remove
     * @private
     */
    insertHyperlink(url: string, displayText: string, remove: boolean, isBookmark?: boolean): void;
    private insertHyperlinkInternal(selection, url, displayText, isBookmark?);
    private insertHyperlinkByFormat(selection, url, displayText, format, isBookmark?);
    private initInsertInline(element, insertHyperlink?);
    /**
     * @private
     */
    insertElementInCurrentLine(selection: Selection, inline: ElementBox, isReLayout: boolean): void;
    /**
     * Edit Hyperlink
     * @param  {Selection} selection
     * @param  {string} url
     * @param  {string} displayText
     * @private
     */
    editHyperlink(selection: Selection, url: string, displayText: string, isBookmark?: boolean): boolean;
    private insertClonedFieldResult(selection, nodes, fieldSeparator);
    private getClonedFieldResultWithSel(paragraph, selection, fieldSeparator);
    private getClonedFieldResult(curParagraph, fieldSeparator);
    /**
     * Removes the hyperlink if selection is within hyperlink.
     */
    removeHyperlink(): void;
    /**
     * Paste copied clipboard content on Paste event
     * @param  {ClipboardEvent} event
     * @param  {any} pasteWindow?
     * @private
     */
    pasteInternal(event: ClipboardEvent, pasteWindow?: any): void;
    /**
     * Pastes the data present in local clipboard if any.
     */
    pasteLocal(): void;
    private getBlocks(pasteContent);
    private pasteContents(content);
    private pasteContentsInternal(widgets);
    private pasteContent(widgets);
    private pasteCopiedData(widgets);
    /**
     * Insert Table on undo
     * @param  {WTable} table
     * @param  {WTable} newTable
     * @param  {boolean} moveRows
     * @private
     */
    insertTableInternal(table: TableWidget, newTable: TableWidget, moveRows: boolean): void;
    /**
     * Insert Table on undo
     * @param  {Selection} selection
     * @param  {WBlock} block
     * @param  {WTable} table
     * @private
     */
    insertBlockTable(selection: Selection, block: BlockWidget, table: TableWidget): void;
    /**
     * On cut handle selected content remove and relayout
     * @param  {Selection} selection
     * @param  {TextPosition} startPosition
     * @param  {TextPosition} endPosition
     * @private
     */
    handleCut(selection: Selection): void;
    private insertInlineInternal(element);
    private insertElement(element);
    private insertElementInternal(element, newElement, index, relayout?);
    /**
     * Insert Block on undo
     * @param  {Selection} selection
     * @param  {WBlock} block
     * @private
     */
    insertBlock(block: BlockWidget): void;
    /**
     * Insert new Block on specific index
     * @param  {Selection} selection
     * @param  {BlockWidget} block
     * @private
     */
    insertBlockInternal(block: BlockWidget): void;
    /**
     * Inserts the image with specified size at cursor position in the document editor.
     * @param {string} imageString  Base64 string, web URL or file URL.
     * @param {number} width? Image width
     * @param {number} height? Image height
     */
    insertImage(imageString: string, width?: number, height?: number): void;
    /**
     * Inserts a table of specified size at cursor position
     *  in the document editor.
     * @param {number} rows Default value of ‘rows’ parameter is 1.
     * @param {number} columns Default value of ‘columns’ parameter is 1.
     */
    insertTable(rows?: number, columns?: number): void;
    /**
     * Inserts the specified number of rows to the table above or below to the row at cursor position.
     * @param {boolean} above The above parameter is optional and if omitted,
     * it takes the value as false and inserts below the row at cursor position.
     * @param {number} count The count parameter is optional and if omitted, it takes the value as 1.
     */
    insertRow(above?: boolean, count?: number): void;
    private updateCellFormatForInsertedRow(newRow, cellFormats);
    private updateRowspan(row, startCell, rowPlacement);
    private insertTableRows(table, prevBlock);
    /**
     * Inserts the specified number of columns to the table left or right to the column at cursor position.
     * @param {number} left The left parameter is optional and if omitted, it takes the value as false and
     * inserts to the right of column at cursor position.
     * @param {number} count The count parameter is optional and if omitted, it takes the value as 1.
     */
    insertColumn(left?: boolean, count?: number): void;
    /**
     * Creates table with specified rows and columns.
     * @private
     */
    createTable(rows: number, columns: number): TableWidget;
    private createRowAndColumn(columns, rowIndex);
    private createColumn(paragraph);
    private getColumnCountToInsert();
    private getRowCountToInsert();
    private getOwnerCell(isStart);
    private getOwnerRow(isStart);
    private getOwnerTable(isStart);
    /**
     * Merge Selected cells
     * @private
     */
    mergeSelectedCellsInTable(): void;
    private mergeSelectedCells(table, startCell, endCell);
    private mergeBorders(mergedCell, tableCell);
    private updateBlockIndexAfterMerge(cell);
    /**
     * Determines whether merge cell operation can be done.
     */
    canMergeCells(): boolean;
    private canMergeSelectedCellsInTable(table, startCell, endCell);
    private checkCellWidth(cell);
    private checkCellWithInSelection(startLeft, endLeft, cellStart);
    private checkPrevOrNextCellIsWithinSel(startLeft, endLeft, cell, isPrev);
    private checkCurrentCell(rowSpannedCells, cell, isPrevCellWithInSel, isNextCellWithinSel);
    private checkRowSpannedCells(rowSpannedCells, cell);
    /**
     * @private
     */
    insertNewParagraphWidget(newParagraph: ParagraphWidget, insertAfter: boolean): void;
    private insertParagraph(newParagraph, insertAfter);
    private moveInlines(currentParagraph, newParagraph, insertIndex, startOffset, startLine, endOffset, endLine);
    /**
     * @private
     */
    moveContent(lineWidget: LineWidget, startOffset: number, endOffset: number, insertIndex: number, paragraph: ParagraphWidget): number;
    /**
     * update complex changes when history is not preserved
     * @param  {number} action?
     * @param  {string} start?
     * @param  {string} end?
     * @private
     */
    updateComplexWithoutHistory(action?: number, start?: string, end?: string): void;
    /**
     * reLayout
     * @param selection
     * @param isSelectionChanged
     * @private
     */
    reLayout(selection: Selection, isSelectionChanged?: boolean): void;
    /**
     * @private
     */
    updateHeaderFooterWidget(): void;
    /**
     * @private
     */
    updateHeaderFooterWidgetToPage(node: HeaderFooterWidget): void;
    /**
     * @private
     */
    updateHeaderFooterWidgetToPageInternal(page: Page, widget: HeaderFooterWidget, isHeader: boolean): void;
    /**
     * @private
     */
    removeFieldInWidget(widget: Widget): void;
    /**
     * @private
     */
    removeFieldInBlock(block: BlockWidget): void;
    /**
     * @private
     */
    removeFieldTable(table: TableWidget): void;
    /**
     * @private
     */
    shiftPageContent(headerFooter: HeaderFooterWidget): void;
    /**
     * @private
     */
    checkAndShiftFromBottom(page: Page, footerWidget: HeaderFooterWidget): void;
    /**
     * Change HighlightColor
     * @param  {HighlightColor} highlightColor
     * Applies character format for selection.
     * @param {string} property
     * @param {Object} value
     * @param {boolean} update
     * @private
     */
    onApplyCharacterFormat(property: string, value: Object, update?: boolean): void;
    /**
     * @private
     */
    applyCharacterFormatForListText(selection: Selection, property: string, values: Object, update: boolean): void;
    private applyListCharacterFormatByValue(selection, format, property, value);
    /**
     * @private
     */
    updateListCharacterFormat(selection: Selection, property: string, value: Object): void;
    private updateListTextSelRange(selection, property, value, update);
    /**
     * @private
     */
    getListLevel(paragraph: ParagraphWidget): WListLevel;
    private updateInsertPosition();
    /**
     * preserve paragraph and offset value for selection
     * @private
     */
    setOffsetValue(selection: Selection): void;
    /**
     * Toggles the highlight color property of selected contents.
     * @param {HighlightColor} highlightColor Default value of ‘underline’ parameter is Yellow.
     */
    toggleHighlightColor(highlightColor?: HighlightColor): void;
    /**
     * Toggles the subscript formatting of selected contents.
     */
    toggleSubscript(): void;
    /**
     * Toggles the superscript formatting of selected contents.
     */
    toggleSuperscript(): void;
    /**
     * Toggles the text alignment property of selected contents.
     * @param {TextAlignment} textAlignment Default value of ‘textAlignment parameter is TextAlignment.Left.
     */
    /**
     * Increases the left indent of selected paragraphs to a factor of 36 points.
     */
    increaseIndent(): void;
    /**
     * Decreases the left indent of selected paragraphs to a factor of 36 points.
     */
    decreaseIndent(): void;
    /**
     * Clears the list format for selected paragraphs.
     */
    clearList(): void;
    /**
     * Applies the bullet list to selected paragraphs.
     * @param {string} bullet Bullet character
     * @param {string} fontFamily Bullet font family
     */
    applyBullet(bullet: string, fontFamily: string): void;
    /**
     * Applies the numbering list to selected paragraphs.
     * @param numberFormat  “%n” representations in ‘numberFormat’ parameter will be replaced by respective list level’s value.
     * `“%1)” will be displayed as “1)” `
     * @param listLevelPattern  Default value of ‘listLevelPattern’ parameter is ListLevelPattern.Arabic
     */
    applyNumbering(numberFormat: string, listLevelPattern?: ListLevelPattern): void;
    /**
     * Toggles the baseline alignment property of selected contents.
     * @param  {Selection} selection
     * @param  {BaselineAlignment} baseAlignment
     */
    toggleBaselineAlignment(baseAlignment: BaselineAlignment): void;
    /**
     * Clears the formatting.
     */
    clearFormatting(): void;
    /**
     * Toggles the specified property. If property is assigned already. Then property will be changed
     * @param  {Selection} selection
     * @param  {number} type
     * @param  {Object} value
     * @private
     */
    updateProperty(type: number, value: Object): void;
    private getCompleteStyles();
    /**
     * Initialize default styles
     * @private
     */
    intializeDefaultStyles(): void;
    /**
     * Creates a new instance of Style.
     */
    createStyle(styleString: string): void;
    /**
     * Create a Style.
     * @private
     */
    createStyleIn(styleString: string): Object;
    /**
     * @private
     */
    getUniqueStyleName(name: string): string;
    private getUniqueName(name);
    /**
     * Update Character format for selection
     * @private
     */
    updateSelectionCharacterFormatting(property: string, values: Object, update: boolean): void;
    /**
     * Update character format for selection range
     * @param  {SelectionRange} selectionRange
     * @param  {string} property
     * @param  {Object} value
     * @returns void
     * @private
     */
    updateCharacterFormat(property: string, value: Object): void;
    private updateCharacterFormatWithUpdate(selection, property, value, update);
    private applyCharFormatSelectedContent(paragraph, selection, start, end, property, value, update);
    private applyCharFormatForSelectedPara(paragraph, selection, property, value, update);
    private splittedLastParagraph(paragraph);
    private getNextParagraphForCharacterFormatting(block, start, end, property, value, update);
    private applyCharFormat(paragraph, selection, start, end, property, value, update);
    /**
     * Toggles the bold property of selected contents.
     */
    toggleBold(): void;
    /**
     * Toggles the bold property of selected contents.
     */
    toggleItalic(): void;
    private getCurrentSelectionValue(property);
    /**
     * Toggles the underline property of selected contents.
     * @param underline Default value of ‘underline’ parameter is Single.
     */
    toggleUnderline(underline?: Underline): void;
    /**
     * Toggles the strike through property of selected contents.
     * @param {Strikethrough} strikethrough Default value of strikethrough parameter is SingleStrike.
     */
    toggleStrikethrough(strikethrough?: Strikethrough): void;
    private updateFontSize(format, value);
    private applyCharFormatInline(inline, selection, startIndex, endIndex, property, value, update);
    private formatInline(inline, selection, startIndex, endIndex, property, value, update);
    private applyCharFormatCell(cell, selection, start, end, property, value, update);
    private applyCharFormatForSelectedCell(cell, selection, property, value, update);
    private applyCharFormatRow(row, selection, start, end, property, value, update);
    private applyCharFormatForTable(index, table, selection, start, end, property, value, update);
    private applyCharFormatForSelTable(tableWidget, selection, property, value, update);
    private applyCharFormatForTableCell(table, selection, startCell, endCell, property, value, update);
    private updateSelectedCellsInTable(start, end, endCellLeft, endCellRight);
    private getCharacterFormatValueOfCell(cell, selection, value, property);
    /**
     * Apply Character format for selection
     * @private
     */
    applyCharFormatValueInternal(selection: Selection, format: WCharacterFormat, property: string, value: Object): void;
    private copyInlineCharacterFormat(sourceFormat, destFormat);
    private applyCharFormatValue(format, property, value, update);
    /**
     * @private
     */
    onImageFormat(elementBox: ImageElementBox, width: number, height: number): void;
    /**
     * Toggles the text alignment of selected paragraphs.
     * @param  {TextAlignment} textAlignment
     */
    toggleTextAlignment(textAlignment: TextAlignment): void;
    /**
     * Applies paragraph format for the selection ranges.
     * @param {string} property
     * @param {Object} value
     * @param {boolean} update
     * @param {boolean} isSelectionChanged
     * @private
     */
    onApplyParagraphFormat(property: string, value: Object, update: boolean, isSelectionChanged: boolean): void;
    /**
     * Update the list level
     * @param  {boolean} increaseLevel
     * @private
     */
    updateListLevel(increaseLevel: boolean): void;
    /**
     * Applies list
     * @param  {WList} list
     * @param  {number} listLevelNumber
     * @private
     */
    onApplyListInternal(list: WList, listLevelNumber: number): void;
    /**
     * Apply paragraph format to selection range
     * @private
     */
    updateSelectionParagraphFormatting(property: string, value: Object, update: boolean): void;
    private getIndentIncrementValue(currentParagraph, incrementFactor);
    private getIndentIncrementValueInternal(position, incrementFactor);
    private updateParagraphFormatInternal(property, value, update);
    /**
     * Update paragraph format on undo
     * @param  {SelectionRange} selectionRange
     * @param  {string} property
     * @param  {Object} value
     * @param  {boolean} update
     * @private
     */
    updateParagraphFormat(property: string, value: Object, update: boolean): void;
    private applyParaFormatSelectedContent(start, end, property, value, update);
    /**
     * Apply Paragraph format
     * @private
     */
    applyParaFormatProperty(paragraph: ParagraphWidget, property: string, value: Object, update: boolean): void;
    private copyParagraphFormat(sourceFormat, destFormat);
    private onListFormatChange(paragraph, listFormat, paraFormat);
    private updateListParagraphFormat(paragraph, listFormat);
    /**
     * Copies list level paragraph format
     * @param  {WParagraphFormat} oldFormat
     * @param  {WParagraphFormat} newFormat
     * @private
     */
    copyFromListLevelParagraphFormat(oldFormat: WParagraphFormat, newFormat: WParagraphFormat): void;
    /**
     * @private
     */
    applyContinueNumbering(selection: Selection): void;
    /**
     * @private
     */
    applyContinueNumberingInternal(selection: Selection): void;
    /**
     * @private
     */
    getContinueNumberingInfo(paragraph: ParagraphWidget): ContinueNumberingInfo;
    /**
     * @private
     */
    revertContinueNumbering(selection: Selection, format: WParagraphFormat): void;
    private changeListId(list, block, format, levelNum, listType);
    private getParagraphFormat(paragraph, levelNumber, listType);
    private checkNumberArabic(listType, levelPattern);
    /**
     * @private
     */
    applyRestartNumbering(selection: Selection): void;
    /**
     * @private
     */
    restartListAt(selection: Selection): void;
    /**
     * @private
     */
    restartListAtInternal(selection: Selection, listId: number): void;
    private changeRestartNumbering(list, block, listId);
    private createListLevels(abstractList, currentListLevel, list);
    private applyParaFormat(paragraph, start, end, property, value, update);
    private applyCharacterStyle(paragraph, start, end, property, value, update);
    private applyParaFormatInCell(cell, start, end, property, value, update);
    private applyParaFormatCellInternal(cell, property, value, update);
    private getParaFormatValueInCell(cell, property, value);
    private applyParagraphFormatRow(wRow, start, end, property, value, update);
    private applyParaFormatTableCell(table, startCell, endCell, property, value, update);
    private applyParaFormatTable(table, start, end, property, value, update);
    private getNextParagraphForFormatting(block, start, end, property, value, update);
    private applyParagraphFormatTableInternal(table, property, value, update);
    /**
     * Apply section format selection changes
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    onApplySectionFormat(property: string, value: Object): void;
    /**
     * Update section format
     * @param  {string} property
     * @param  {Object} value
     * @returns TextPosition
     * @private
     */
    updateSectionFormat(property: string, value: Object): void;
    /**
     * Apply table format property changes
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    onApplyTableFormat(property: string, value: Object): void;
    private getTableFormatAction(property);
    /**
     * Apply table row format property changes
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    onApplyTableRowFormat(property: string, value: Object): void;
    private getRowAction(property);
    /**
     * Apply table cell property changes
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    onApplyTableCellFormat(property: string, value: Object): void;
    private getTableCellAction(property);
    private applyPropertyValueForSection(sectionFormat, property, value, update);
    /**
     * @private
     */
    layoutWholeDocument(): void;
    private combineSection();
    private combineSectionChild(bodyWidget, sections);
    private updateSelectionTableFormat(selection, action, value);
    /**
     * Update Table Format on undo
     * @param  {Selection} selection
     * @param  {SelectionRange} selectionRange
     * @param  {string} property
     * @param  {object} value
     * @private
     */
    updateTableFormat(selection: Selection, property: string, value: object): void;
    /**
     * update cell format on undo
     * @param  {Selection} selection
     * @param  {SelectionRange} selectionRange
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    updateCellFormat(selection: Selection, property: string, value: Object): void;
    /**
     * update row format on undo
     * @param  {Selection} selection
     * @param  {SelectionRange} selectionRange
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    updateRowFormat(selection: Selection, property: string, value: Object): void;
    private initHistoryPosition(selection, position?);
    private startSelectionReLayouting(paragraph, selection, start, end);
    private reLayoutSelectionOfTable(table, selection, start, end);
    private reLayoutSelection(paragraph, selection, start, end);
    private reLayoutSelectionOfBlock(block, selection, start, end);
    /**
     * @private
     */
    layoutItemBlock(block: BlockWidget, shiftNextWidget: boolean): void;
    /**
     * @private
     */
    removeSelectedContents(selection: Selection): boolean;
    private removeSelectedContentInternal(selection, startPosition, endPosition);
    private removeSelectedContent(paragraph, selection, start, end);
    private deleteSelectedContent(paragraph, selection, start, end, editAction);
    /**
     * Merge the selected cells.
     */
    mergeCells(): void;
    /**
     * Deletes the entire table at selection.
     */
    deleteTable(): void;
    /**
     * Deletes the selected column(s).
     */
    deleteColumn(): void;
    /**
     * Deletes the selected row(s).
     */
    deleteRow(): void;
    private removeRow(row);
    private updateTable(table);
    private getParagraphForSelection(table);
    private deletePara(paragraph, start, end, editAction);
    private deleteSection(selection, section, nextSection, editAction);
    private combineSectionInternal(selection, section, nextSection);
    /**
     * @private
     */
    checkAndInsertBlock(block: BlockWidget, start: TextPosition, end: TextPosition, editAction: number, previousParagraph: BlockWidget): ParagraphWidget;
    private splitParagraph(paragraphAdv, startLine, startOffset, endLine, endOffset, removeBlock);
    /**
     * @private
     */
    removeBlock(block: BlockWidget): void;
    private removeField(block);
    private addRemovedNodes(node);
    private deleteBlock(block, selection, start, end, editAction);
    private deleteTableCell(cellAdv, selection, start, end, editAction);
    private deleteCellsInTable(table, selection, start, end, editAction);
    private deleteCell(cell, selection, editAction, copyChildToClipboard);
    private deleteContainer(cell, selection, start, end, editAction);
    private deleteTableBlock(table, selection, start, end, editAction);
    private splitTable(table, splitEndRow);
    private updateEditPosition(cell, selection);
    /**
     * @private
     */
    deleteContent(table: TableWidget, selection: Selection, editAction: number): void;
    private setActionInternal(selection, action);
    private checkClearCells(selection);
    private isEndInAdjacentTable(paragraph, endParagraph);
    private cloneTableToHistoryInfo(table);
    private insertParagraphPaste(paragraph, currentParagraph, start, end, isCombineNextParagraph, editAction);
    private removeInlines(paragraph, startLine, startOffset, endLine, endOffset, editAction);
    /**
     * @private
     */
    removeContent(lineWidget: LineWidget, startOffset: number, endOffset: number): void;
    /**
     * @private
     */
    removeEmptyLine(paragraph: ParagraphWidget): void;
    /**
     * clone the list level
     * @param  {WListLevel} source
     * @private
     */
    cloneListLevel(source: WListLevel): WListLevel;
    /**
     * Copies the list level
     * @param  {WListLevel} destination
     * @param  {WListLevel} listLevel
     * @private
     */
    copyListLevel(destination: WListLevel, listLevel: WListLevel): void;
    /**
     * Clone level override
     * @param  {WLevelOverride} source
     * @private
     */
    cloneLevelOverride(source: WLevelOverride): WLevelOverride;
    /**
     * Update List Paragraph
     * @private
     */
    updateListParagraphs(): void;
    /**
     * @private
     */
    updateListParagraphsInBlock(block: BlockWidget): void;
    /**
     * Applies list format
     * @param  {WList} list
     * @private
     */
    onApplyList(list: WList): void;
    /**
     * Applies bullets or numbering list
     * @param  {string} format
     * @param  {ListLevelPattern} listLevelPattern
     * @param  {string} fontFamily
     * @private
     */
    applyBulletOrNumbering(format: string, listLevelPattern: ListLevelPattern, fontFamily: string): void;
    private addListLevels(abstractListAdv, listName, selection);
    /**
     * Insert page break at cursor position
     */
    insertPageBreak(): void;
    /**
     * @private
     */
    onEnter(isInsertPageBreak?: boolean): void;
    private splitParagraphInternal(selection, paragraphAdv, currentLine, offset);
    /**
     * @private
     */
    updateNextBlocksIndex(block: BlockWidget, increaseIndex: boolean): void;
    private updateIndex(widget, increment);
    private updateEndPosition();
    /**
     * @private
     */
    onBackSpace(): void;
    /**
     * @private
     */
    insertRemoveBookMarkElements(): boolean;
    /**
     * @private
     */
    deleteSelectedContents(selection: Selection, isBackSpace: boolean): boolean;
    /**
     * @private
     */
    singleBackspace(selection: Selection, isRedoing: boolean): void;
    private setPositionForHistory(editPosition?);
    private removeAtOffset(lineWidget, selection, offset);
    /**
     * @private
     */
    onDelete(): void;
    /**
     * Remove single character on right of cursor position
     * @param  {Selection} selection
     * @param  {boolean} isRedoing
     * @private
     */
    singleDelete(selection: Selection, isRedoing: boolean): void;
    private singleDeleteInternal(selection, isRedoing, paragraph);
    private deleteParagraphMark(paragraph, selection, editAction);
    private updateEditPositionOnMerge(currentParagraph, nextParagraph);
    private checkEndPosition(selection?);
    private checkInsertPosition(selection?);
    private checkIsNotRedoing();
    private deleteSelectedContentInternal(selection, isBackSpace, startPosition, endPosition);
    /**
     * Init EditorHistory
     * @private
     */
    initHistory(action: Action): void;
    /**
     * Init Complex EditorHistory
     * @private
     */
    initComplexHistory(action: Action): void;
    /**
     * Insert image
     * @param  {string} base64String
     * @param  {number} width
     * @param  {number} height
     * @private
     */
    insertPicture(base64String: string, width: number, height: number): void;
    private insertPictureInternal(imageElementBox);
    private fitImageToPage(selection, imageElementBox);
    /**
     * @private
     */
    insertInlineInSelection(selection: Selection, elementBox: ElementBox): void;
    /**
     * @private
     */
    onPortrait(): void;
    /**
     * @private
     */
    onLandscape(): void;
    private copyValues();
    /**
     * @private
     */
    changeMarginValue(property: string): void;
    /**
     * @private
     */
    onPaperSize(property: string): void;
    /**
     * @private
     */
    updateListItemsTillEnd(blockAdv: BlockWidget, updateNextBlockList: boolean): void;
    /**
     * @private
     */
    updateWholeListItems(block: BlockWidget): void;
    private updateListItems(blockAdv, block);
    private updateListItemsForTable(table, block);
    private updateListItemsForRow(row, block);
    private updateListItemsForCell(cell, block);
    /**
     * @private
     */
    updateRenderedListItems(block: BlockWidget): void;
    private updateRenderedListItemsForTable(table);
    private updateRenderedListItemsForRow(row);
    private updateRenderedListItemsForCell(cell);
    private updateListItemsForPara(paragraph, block);
    private updateRenderedListItemsForPara(paragraph);
    /**
     * Get logical offset of paragraph.
     * @private
     */
    getParagraphInfo(position: TextPosition): ParagraphInfo;
    /**
     * @private
     */
    getParagraphInfoInternal(line: LineWidget, lineOffset: number): ParagraphInfo;
    /**
     * Get offset value to update in selection
     * @private
     */
    getOffsetValue(selection: Selection): void;
    /**
     * Get offset value to update in selection
     * @private
     */
    getLineInfo(paragraph: ParagraphWidget, offset: number): LineInfo;
    /**
     * @private
     */
    setPositionParagraph(paragraph: ParagraphWidget, offset: number, skipSelectionChange: boolean): void;
    /**
     * @private
     */
    setPositionForCurrentIndex(textPosition: TextPosition, editPosition: string): void;
    /**
     * @private
     */
    insertPageNumber(numberFormat?: string): void;
    /**
     * @private
     */
    insertPageCount(numberFormat?: string): void;
    private createFields(fieldCode);
    /**
     * @private
     */
    insertBookmark(name: string): void;
    /**
     * @private
     */
    deleteBookmark(bookmarkName: string): void;
    /**
     * @private
     */
    deleteBookmarkInternal(bookmark: BookmarkElementBox): void;
    /**
     * @private
     */
    getSelectionInfo(): SelectionInfo;
    /**
     * @private
     */
    insertElements(endElements: ElementBox[], startElements?: ElementBox[]): void;
    /**
     * @private
     */
    insertElementsInternal(position: TextPosition, elements: ElementBox[]): void;
    /**
     * @private
     */
    getHierarchicalIndex(block: Widget, offset: string): string;
    /**
     * @private
     */
    getBlock(position: IndexInfo): BlockInfo;
    /**
     * Return Block relative to position
     * @private
     */
    getBlockInternal(widget: Widget, position: IndexInfo): BlockInfo;
    /**
     * @private
     */
    getParagraph(position: IndexInfo): ParagraphInfo;
    /**
     * Get paragraph relative to position
     * @private
     */
    private getParagraphInternal(container, position);
    private getBodyWidget(position);
    private getHeaderFooterWidget(position);
    private getBodyWidgetInternal(sectionIndex, blockIndex);
    /**
     * @private
     */
    getBlockByIndex(container: Widget, blockIndex: number): Widget;
    /**
     * @private
     */
    updateHistoryPosition(position: TextPosition | string, isInsertPosition: boolean): void;
    /**
     * Applies the borders based on given settings.
     * @param {BorderSettings} settings
     */
    applyBorders(settings: BorderSettings): void;
    private applyAllBorders(border, borderType);
    private applyInsideBorders(border, borderType, table);
    /**
     * @private
     */
    getTopBorderCellsOnSelection(): TableCellWidget[];
    /**
     * @private
     */
    getLeftBorderCellsOnSelection(): TableCellWidget[];
    /**
     * @private
     */
    getRightBorderCellsOnSelection(): TableCellWidget[];
    /**
     * @private
     */
    getBottomBorderCellsOnSelection(): TableCellWidget[];
    /**
     * @private
     */
    clearAllBorderValues(borders: WBorders): void;
    private clearBorder();
    /**
     * @private
     */
    getAdjacentCellToApplyBottomBorder(): TableCellWidget[];
    private getAdjacentBottomBorderOnEmptyCells(nextRow, cell, isSingleCell?);
    /**
     * @private
     */
    getAdjacentCellToApplyRightBorder(): TableCellWidget[];
    private getSelectedCellsNextWidgets(selectedCell, table);
    /**
     * @private
     */
    getBorder(borderColor: string, lineWidth: number, borderStyle: LineStyle): WBorder;
    /**
     * Applies borders
     * @param  {WBorders} sourceBorders
     * @param  {WBorders} applyBorders
     * @private
     */
    applyBordersInternal(sourceBorders: WBorders, applyBorders: WBorders): void;
    /**
     * Apply shading to table
     * @param  {WShading} sourceShading
     * @param  {WShading} applyShading
     * @private
     */
    applyShading(sourceShading: WShading, applyShading: WShading): void;
    private applyBorder(sourceBorder, applyBorder);
    /**
     * Apply Table Format changes
     * @param  {Selection} selection
     * @param  {WTableFormat} format
     * @private
     */
    onTableFormat(format: WTableFormat): void;
    /**
     * @private
     */
    applyTableFormat(table: TableWidget, property: string, value: object): void;
    private applyTablePropertyValue(selection, property, value, table);
    private handleTableFormat(tableFormat, applyFormat);
    private updateGridForTableDialog(table, shiftNextItem);
    /**
     * Applies Row Format Changes
     * @param  {Selection} selection
     * @param  {WRowFormat} format
     * @param  {WRow} row
     * @private
     */
    onRowFormat(format: WRowFormat): void;
    private applyRowFormat(row, start, end, property, value);
    private applyRowPropertyValue(selection, property, value, row);
    private handleRowFormat(format, applyFormat);
    /**
     * Applies Cell Format changes
     * @param  {Selection} selection
     * @param  {WCellFormat} format
     * @param  {WCell} cell
     * @private
     */
    onCellFormat(format: WCellFormat): void;
    /**
     * @private
     */
    updateCellMargins(selection: Selection, value: WCellFormat): void;
    /**
     * @private
     */
    updateFormatForCell(selection: Selection, property: string, value: Object): void;
    /**
     * @private
     */
    getSelectedCellInColumn(table: TableWidget, rowStartIndex: number, columnIndex: number, rowEndIndex: number): TableCellWidget[];
    private getColumnCells(table, columnIndex, isLeftSideCollection);
    /**
     * @private
     */
    getTableWidth(table: TableWidget): number;
    private applyCellPropertyValue(selection, property, value, applyFormat);
    private handleCellFormat(cellFormat, applyFormat);
    /**
     * @private
     */
    destroy(): void;
    private isTocField(element);
    /**
     * Updates the table of contents.
     * @private
     */
    updateToc(tocField?: FieldElementBox): void;
    private getTocSettings(code, tocField);
    private decodeTSwitch(tocSettings, tSwitch);
    /**
     * Inserts, modifies or updates the table of contents based on given settings.
     * @param {TableOfContentsSettings} tableOfContentsSettings
     */
    insertTableOfContents(tableOfContentsSettings?: TableOfContentsSettings): void;
    private appendEmptyPara(widgets);
    private constructTocFieldCode(tocSettings);
    private constructTSwitch(tocSettings);
    /**
     * Appends the end filed to the given line.
     */
    private appendEndField(fieldBegin, lineWidget);
    private validateTocSettings(tocSettings);
    /**
     * Builds the TOC
     * @private
     */
    buildToc(tocSettings: TableOfContentsSettings, fieldCode: string, isFirstPara: boolean, isStartParagraph?: boolean): ParagraphWidget[];
    private createOutlineLevels(settings);
    /**
     * Creates TOC heading styles
     * @param start - lower heading level
     * @param end - higher heading level
     */
    private createHeadingLevels(settings);
    /**
     * Checks the current style is heading style.
     */
    private isHeadingStyle(para);
    private isOutlineLevelStyle(para);
    /**
     * Creates TOC field element.
     */
    private createTocFieldElement(lineWidget, fieldCode);
    /**
     * Updates TOC para
     */
    private createTOCWidgets(widget, widgets, fieldCode, bookmarkName, tocSettings, isFirstPara?, isStartParagraph?);
    /**
     * Inserts toc hyperlink.
     */
    private insertTocHyperlink(lineWidget, bookmarkName, text);
    /**
     * Inserts toc page number.
     */
    private insertTocPageNumber(bookMarkname, lineWidget, isRightAlign, widget);
    private updatePageRef();
    /**
     * Inserts toc bookmark.
     */
    private insertTocBookmark(widget);
    /**
     * Generates bookmark id.
     */
    private generateBookmarkName();
    /**
     * Change cell content alignment
     * @private
     */
    onCellContentAlignment(verticalAlignment: CellVerticalAlignment, textAlignment: TextAlignment): void;
}
/**
 * @private
 */
export interface SelectionInfo {
    start: TextPosition;
    end: TextPosition;
    startElementInfo: ElementInfo;
    endElementInfo: ElementInfo;
    isEmpty: boolean;
}
/**
 * @private
 */
export interface ContinueNumberingInfo {
    currentList: WList;
    listLevelNumber: number;
    listPattern: ListLevelPattern;
}
/**
 * Specifies the settings for border.
 */
export interface BorderSettings {
    /**
     * Specifies the border type.
     */
    type: BorderType;
    /**
     * Specifies the border color.
     */
    borderColor?: string;
    /**
     * Specifies the line width.
     */
    lineWidth?: number;
    /**
     * Specifies the border style.
     */
    borderStyle?: LineStyle;
}
/**
 * @private
 */
export interface TocLevelSettings {
    [key: string]: number;
}
/**
 * @private
 */
export interface PageRefFields {
    [key: string]: FieldTextElementBox;
}
/**
 * Specifies the settings for table of contents.
 */
export interface TableOfContentsSettings {
    /**
     * Specifies the start level.
     */
    startLevel?: number;
    /**
     * Specifies the end level.
     */
    endLevel?: number;
    /**
     * Specifies whether hyperlink can be included.
     */
    includeHyperlink?: boolean;
    /**
     * Specifies whether page number can be included.
     */
    includePageNumber?: boolean;
    /**
     * Specifies whether the page number can be right aligned.
     */
    rightAlign?: boolean;
    /**
     * Specifies the tab leader.
     */
    tabLeader?: TabLeader;
    /**
     * @private
     */
    levelSettings?: TocLevelSettings;
    /**
     * Specifies whether outline levels can be included.
     */
    includeOutlineLevels?: boolean;
}
