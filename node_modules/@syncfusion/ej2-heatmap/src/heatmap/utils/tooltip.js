/**
 * HeatMap tool tip file
 */
import { createElement, isNullOrUndefined } from '@syncfusion/ej2-base';
import { Tooltip as tool } from '@syncfusion/ej2-svg-base';
/**
 *
 * The `Tooltip` module is used to render the tooltip for heatmap series.
 */
var Tooltip = /** @class */ (function () {
    function Tooltip(heatMap) {
        /* private */
        this.isFirst = true;
        /* private */
        this.isFadeout = false;
        this.heatMap = heatMap;
    }
    /**
     * Get module name
     */
    Tooltip.prototype.getModuleName = function () {
        return 'Tooltip';
    };
    /**
     * To show/hide Tooltip.
     * @private
     */
    Tooltip.prototype.showHideTooltip = function (isShow, isFadeout) {
        var ele = document.getElementById(this.heatMap.element.id + 'Celltooltipcontainer');
        if (!isShow) {
            if (ele && ele.style.visibility !== 'hidden') {
                if (this.tooltipObject && isFadeout) {
                    this.tooltipObject.fadeOut();
                }
                else {
                    if (this.tooltipObject && this.tooltipObject.element) {
                        var tooltipElement = this.tooltipObject.element.firstChild;
                        tooltipElement.setAttribute('opacity', '0');
                    }
                }
                ele.style.visibility = 'hidden';
            }
            this.isFadeout = true;
        }
        else {
            ele.style.visibility = 'visible';
        }
    };
    /**
     * To destroy the Tooltip.
     * @return {void}
     * @private
     */
    Tooltip.prototype.destroy = function (heatMap) {
        /**
         * Destroy method performed here
         */
    };
    ;
    /**
     * To add Tooltip to the rect cell.
     * @return {void}
     * @private
     */
    Tooltip.prototype.createTooltip = function (x, y, tempTooltipText) {
        var offset = null;
        if (this.heatMap.cellSettings.showLabel && this.heatMap.heatMapSeries.checkLabelXDisplay &&
            this.heatMap.heatMapSeries.checkLabelYDisplay) {
            offset = parseInt(this.heatMap.cellSettings.textStyle.size, 10) / 2;
        }
        this.tooltipObject = new tool({
            enableAnimation: false,
            offset: offset,
            location: { x: x, y: y },
            theme: this.heatMap.theme,
            content: tempTooltipText,
            areaBounds: {
                height: this.heatMap.initialClipRect.height + this.heatMap.initialClipRect.y,
                width: this.heatMap.initialClipRect.width, x: this.heatMap.initialClipRect.x
            }
        }, '#' + this.heatMap.element.id + 'Celltooltipcontainer');
    };
    /**
     * To create div container for tooltip.
     * @return {void}
     * @private
     */
    Tooltip.prototype.createTooltipDiv = function (heatMap) {
        var element2 = createElement('div', {
            id: this.heatMap.element.id + 'Celltooltipcontainer',
            styles: 'position:absolute'
        });
        this.heatMap.element.appendChild(createElement('div', {
            id: this.heatMap.element.id + 'Celltooltipparent',
            styles: 'position:relative'
        })
            .appendChild(element2));
    };
    /**
     * To get default tooltip content.
     * @private
     */
    Tooltip.prototype.getTooltipContent = function (currentRect, hetmapSeries) {
        var value;
        var content;
        var heatMap = this.heatMap;
        var adaptData = this.heatMap.dataSource;
        if (heatMap.bubbleSizeWithColor) {
            var xAxis = heatMap.xAxis.title && heatMap.xAxis.title.text !== '' ? heatMap.xAxis.title.text : 'X-Axis';
            var yAxis = heatMap.yAxis.title && heatMap.yAxis.title.text !== '' ? heatMap.yAxis.title.text : 'Y-Axis';
            var value1 = adaptData.isJsonData && adaptData.adaptorType === 'Cell' ?
                heatMap.dataSource.bubbleDataMapping.size : 'Value 1';
            var value2 = adaptData.isJsonData && adaptData.adaptorType === 'Cell' ?
                heatMap.dataSource.bubbleDataMapping.color : 'Value 2';
            value = hetmapSeries.getFormatedText(currentRect.value[0].bubbleData, this.heatMap.cellSettings.format);
            content = [xAxis + ' : ' + hetmapSeries.hoverXAxisLabel + '<br/>'
                    + yAxis + ' : ' + hetmapSeries.hoverYAxisLabel + '<br/>'
                    + value1 + ' : ' + value + '<br/>'
                    + value2 + ' : '
                    + hetmapSeries.getFormatedText(currentRect.value[1].bubbleData, this.heatMap.cellSettings.format)];
        }
        else {
            value = currentRect.value;
            content = [hetmapSeries.hoverXAxisLabel + ' | ' + hetmapSeries.hoverYAxisLabel + ' : ' +
                    hetmapSeries.getFormatedText(value, this.heatMap.cellSettings.format)];
        }
        return content;
    };
    /**
     * To render tooltip.
     * @private
     */
    Tooltip.prototype.renderTooltip = function (currentRect) {
        var hetmapSeries = this.heatMap.heatMapSeries;
        var tempTooltipText = [''];
        var showTooltip = this.heatMap.bubbleSizeWithColor ?
            !isNullOrUndefined(currentRect.value) && !isNullOrUndefined(currentRect.value[0].bubbleData)
                && currentRect.value[0].bubbleData.toString() !== '' ? true : false
            : isNullOrUndefined(currentRect.value) || (!isNullOrUndefined(currentRect.value) &&
                currentRect.value.toString() === '') ? false : true;
        if (!showTooltip) {
            this.showHideTooltip(false, false);
        }
        else {
            if (!isNullOrUndefined(this.heatMap.tooltipRender)) {
                // this.tooltipObject.header = '';
                // this.tooltipObject.content = this.getTemplateText(
                //     currentRect, this.heatMap.tooltipTemplate, hetmapSeries.hoverXAxisLabel,
                //     hetmapSeries.hoverYAxisLabel);
                var content = this.getTooltipContent(currentRect, hetmapSeries);
                var argData = {
                    heatmap: this.heatMap,
                    cancel: false,
                    name: 'tooltipRender',
                    value: currentRect.value,
                    xValue: this.heatMap.heatMapSeries.hoverXAxisValue,
                    yValue: this.heatMap.heatMapSeries.hoverYAxisValue,
                    xLabel: this.heatMap.heatMapSeries.hoverXAxisLabel ?
                        this.heatMap.heatMapSeries.hoverXAxisLabel.toString() : null,
                    yLabel: this.heatMap.heatMapSeries.hoverYAxisLabel ?
                        this.heatMap.heatMapSeries.hoverYAxisLabel.toString() : null,
                    content: content
                };
                this.heatMap.trigger('tooltipRender', argData);
                if (!argData.cancel) {
                    tempTooltipText = argData.content;
                }
                else {
                    if (this.tooltipObject) {
                        this.showHideTooltip(false);
                    }
                    return;
                }
            }
            else {
                //  this.tooltipObject.header = hetmapSeries.hoverYAxisLabel.toString();
                tempTooltipText = this.getTooltipContent(currentRect, hetmapSeries);
            }
            if (!this.tooltipObject) {
                this.createTooltip(currentRect.x + (currentRect.width / 2), currentRect.y + (currentRect.height / 2), tempTooltipText);
            }
            else {
                this.tooltipObject.content = tempTooltipText;
            }
            this.showHideTooltip(true);
            this.tooltipObject.enableAnimation = (this.isFirst || this.isFadeout) ? false : true;
            this.isFirst = (this.isFirst) ? false : this.isFirst;
            this.isFadeout = (this.isFadeout) ? false : this.isFadeout;
            this.tooltipObject.location.x = currentRect.x + (currentRect.width / 2);
            this.tooltipObject.location.y = currentRect.y + (currentRect.height / 2);
        }
    };
    return Tooltip;
}());
export { Tooltip };
