/**
 * Heat Map Component
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Component, Property, NotifyPropertyChanges, Internationalization, Complex } from '@syncfusion/ej2-base';
import { remove, Event, EventHandler } from '@syncfusion/ej2-base';
import { SvgRenderer, CanvasRenderer, Browser } from '@syncfusion/ej2-base';
import { Size, stringToNumber, RectOption, Rect, TextBasic, measureText } from './utils/helper';
import { DrawSvgCanvas, TextOption, titlePositionX, getTitle, showTooltip, getElement } from './utils/helper';
import { removeElement, CanvasTooltip, getTooltipText } from './utils/helper';
import { Margin, Title } from './model/base';
import { Theme, getThemeColor } from './model/theme';
import { Axis } from './axis/axis';
import { AxisHelper } from './axis/axis-helpers';
import { Series, CellSettings } from './series/series';
import { PaletteSettings, CellColor } from './utils/colorMapping';
import { TwoDimensional } from './datasource/twodimensional';
import { LegendSettings } from '../heatmap/legend/legend';
var HeatMap = /** @class */ (function (_super) {
    __extends(HeatMap, _super);
    function HeatMap() {
        /**
         * The width of the heatmap as a string accepts input as both like '100px' or '100%'.
         * If specified as '100%, heatmap renders to the full width of its parent element.
         * @default null
         */
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** @private */
        _this.enableCanvasRendering = false;
        /** @private */
        _this.horizontalGradient = _this.legendSettings.position === 'Bottom' || _this.legendSettings.position === 'Top';
        /**
         * @private
         */
        _this.tooltipCollection = [];
        /**
         * @private
         */
        _this.isCellData = false;
        return _this;
    }
    HeatMap.prototype.preRender = function () {
        this.initPrivateVariable();
        this.unWireEvents();
        this.wireEvents();
    };
    HeatMap.prototype.initPrivateVariable = function () {
        this.renderer = new SvgRenderer(this.element.id);
        this.canvasRenderer = new CanvasRenderer(this.element.id);
        this.heatMapAxis = new AxisHelper(this);
        this.heatMapSeries = new Series(this);
        this.drawSvgCanvas = new DrawSvgCanvas(this);
        this.twoDimensional = new TwoDimensional(this);
        this.cellColor = new CellColor(this);
        this.tempRectHoverClass = '';
        this.tempTooltipRectId = '';
        this.setCulture();
    };
    /**
     * Method to set culture for heatmap
     */
    HeatMap.prototype.setCulture = function () {
        this.intl = new Internationalization();
    };
    HeatMap.prototype.render = function () {
        this.updateBubbleHelperProperty();
        this.trigger('load', { heatmap: this });
        this.processInitData();
        this.setTheme();
        this.initAxis();
        this.calculateMaxLength();
        this.heatMapAxis.calculateVisibleLabels();
        this.twoDimensional.processDataSource(this.completeAdaptDataSource);
        this.createSvg();
        this.cellColor.getColorCollection();
        this.calculateBounds();
        this.renderElements();
        this.element.appendChild(this.svgObject);
        if (this.tooltipModule) {
            this.tooltipModule.showHideTooltip(false);
        }
        this.trigger('created', { heatmap: this });
    };
    /**
     * To re-calculate the datasource while changing datasource property dynamically.
     * @private
     */
    HeatMap.prototype.reRenderDatasource = function () {
        this.dataSourceMinValue = null;
        this.dataSourceMaxValue = null;
        this.processInitData();
        this.calculateMaxLength();
        this.heatMapAxis.calculateVisibleLabels();
        this.twoDimensional.processDataSource(this.completeAdaptDataSource);
        this.cellColor.getColorCollection();
        this.calculateBounds();
    };
    /**
     * To process datasource property.
     * @private
     */
    HeatMap.prototype.processInitData = function () {
        if (this.adaptorModule) {
            this.adaptorModule.constructDatasource(this.dataSource);
        }
        else {
            this.completeAdaptDataSource = this.dataSource;
        }
    };
    /**
     * To set render mode of heatmap as SVG or Canvas.
     * @private
     */
    HeatMap.prototype.setRenderMode = function () {
        if (this.renderingMode === 'Canvas') {
            this.enableCanvasRendering = true;
        }
        else if (this.renderingMode === 'Auto' &&
            (this.axisCollections[0].axisLabelSize * this.axisCollections[1].axisLabelSize) >= 10000) {
            this.enableCanvasRendering = true;
        }
        else {
            this.enableCanvasRendering = false;
        }
    };
    /**
     * To set bubble helper private property.
     * @private
     */
    HeatMap.prototype.updateBubbleHelperProperty = function () {
        if (this.cellSettings.tileType === 'Bubble' &&
            (this.cellSettings.bubbleType === 'Size' || this.cellSettings.bubbleType === 'Sector')) {
            this.legendVisibilityByCellType = false;
        }
        else if (this.legendModule && this.legendSettings.visible) {
            this.legendVisibilityByCellType = true;
        }
        if (this.cellSettings.tileType === 'Bubble' && this.cellSettings.bubbleType === 'SizeAndColor') {
            this.bubbleSizeWithColor = true;
        }
        else {
            this.bubbleSizeWithColor = false;
        }
    };
    HeatMap.prototype.renderElements = function () {
        this.renderSecondaryElement();
        this.renderBorder();
        this.renderTitle();
        this.heatMapAxis.renderAxes();
        if (this.tooltipModule && this.showTooltip) {
            this.tooltipModule.tooltipObject = null;
            this.tooltipModule.createTooltipDiv(this);
        }
        this.heatMapSeries.renderRectSeries();
        if (this.legendModule && this.legendSettings.visible
            && this.legendVisibilityByCellType) {
            this.legendModule.renderLegendItems();
            if (this.paletteSettings.type === 'Fixed' && this.legendSettings.enableSmartLegend &&
                this.legendSettings.labelDisplayType === 'None') {
                this.legendModule.createTooltipDiv(this);
            }
        }
    };
    /**
     * Get component name
     */
    HeatMap.prototype.getModuleName = function () {
        return 'heatmap';
    };
    /**
     * Get the properties to be maintained in the persisted state.
     * @private
     */
    HeatMap.prototype.getPersistData = function () {
        return '';
    };
    HeatMap.prototype.onPropertyChanged = function (newProp, oldProp) {
        var renderer = false;
        var refreshBounds = false;
        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
            var prop = _a[_i];
            switch (prop) {
                case 'renderingMode':
                    renderer = true;
                    break;
                case 'cellSettings':
                    this.updateBubbleHelperProperty();
                    this.reRenderDatasource();
                    refreshBounds = true;
                    break;
                case 'showTooltip':
                    refreshBounds = true;
                    break;
                case 'dataSource':
                    this.isCellData = false;
                    this.updateBubbleHelperProperty();
                    this.reRenderDatasource();
                    renderer = true;
                    break;
                case 'titleSettings':
                case 'width':
                case 'height':
                case 'margin':
                case 'legendSettings':
                    refreshBounds = true;
                    break;
                case 'yAxis':
                case 'xAxis':
                    this.reRenderDatasource();
                    refreshBounds = true;
                    break;
                case 'paletteSettings':
                    this.cellColor.getColorCollection();
                    this.calculateBounds();
                    renderer = true;
                    break;
                case 'theme':
                    this.setTheme();
                    renderer = true;
                    break;
            }
        }
        if (!refreshBounds && renderer) {
            this.createSvg();
            this.renderElements();
            this.element.appendChild(this.svgObject);
            this.trigger('created', { heatmap: this });
        }
        else if (refreshBounds) {
            this.createSvg();
            this.refreshBound();
            this.element.appendChild(this.svgObject);
            this.trigger('created', { heatmap: this });
        }
    };
    HeatMap.prototype.createSvg = function () {
        this.removeSvg();
        this.setRenderMode();
        this.calculateSize();
        if (!this.enableCanvasRendering) {
            this.svgObject = this.renderer.createSvg({
                id: this.element.id + '_svg',
                width: this.availableSize.width,
                height: this.availableSize.height
            });
            if (this.cellSettings.border.width.toString() === '0' && this.cellSettings.tileType === 'Rect') {
                this.svgObject.setAttribute('shape-rendering', 'crispEdges');
            }
        }
        else {
            this.svgObject = this.canvasRenderer.createCanvas({
                id: this.element.id + '_canvas',
                width: this.availableSize.width,
                height: this.availableSize.height
            });
        }
    };
    /**
     *  To Remove the SVG.
     */
    HeatMap.prototype.removeSvg = function () {
        if (document.getElementById(this.element.id + '_Secondary_Element')) {
            remove(document.getElementById(this.element.id + '_Secondary_Element'));
        }
        if (document.getElementById(this.element.id + 'Celltooltipcontainer')) {
            remove(document.getElementById(this.element.id + 'Celltooltipcontainer'));
        }
        if (document.getElementById(this.element.id + 'legendLabelTooltipContainer')) {
            remove(document.getElementById(this.element.id + 'legendLabelTooltipContainer'));
        }
        if (this.svgObject) {
            var svgElement = document.getElementById(this.svgObject.id);
            if (svgElement) {
                while (this.svgObject.childNodes.length) {
                    this.svgObject.removeChild(this.svgObject.firstChild);
                }
                remove(this.svgObject);
            }
        }
    };
    HeatMap.prototype.renderSecondaryElement = function () {
        var tooltipDiv = this.createElement('div');
        tooltipDiv.id = this.element.id + '_Secondary_Element';
        tooltipDiv.setAttribute('style', 'position: relative');
        this.element.appendChild(tooltipDiv);
    };
    /**
     * To provide the array of modules needed for control rendering
     * @return{ModuleDeclaration[]}
     * @private
     */
    HeatMap.prototype.requiredModules = function () {
        var modules = [];
        if (this.showTooltip) {
            modules.push({
                member: 'Tooltip',
                args: [this]
            });
        }
        if (this.legendSettings) {
            modules.push({
                member: 'Legend',
                args: [this]
            });
        }
        if (this.dataSource) {
            modules.push({
                member: 'Adaptor',
                args: [this]
            });
        }
        return modules;
    };
    /**
     * To destroy the widget
     * @method destroy
     * @return {void}.
     * @member of Heatmap
     */
    HeatMap.prototype.destroy = function () {
        this.unWireEvents();
        _super.prototype.destroy.call(this);
        this.element.innerHTML = '';
        this.element.classList.remove('e-heatmap');
    };
    HeatMap.prototype.renderBorder = function () {
        this.border = {
            width: 0
        };
        var width = 0;
        var rect = new RectOption(this.element.id + '_HeatmapBorder', this.themeStyle.background, this.border, 1, new Rect(width / 2, width / 2, this.availableSize.width - width, this.availableSize.height - width));
        this.drawSvgCanvas.drawRectangle(rect, this.svgObject);
    };
    HeatMap.prototype.calculateSize = function () {
        var width = stringToNumber(this.width, this.element.offsetWidth) || this.element.offsetWidth || 600;
        var height = stringToNumber(this.height, this.element.offsetHeight) || this.element.offsetHeight || 450;
        this.availableSize = new Size(width, height);
    };
    HeatMap.prototype.renderTitle = function () {
        if (this.titleSettings.text) {
            var titleStyle = this.titleSettings.textStyle;
            var anchor = titleStyle.textAlignment === 'Near' ? 'start' :
                titleStyle.textAlignment === 'Far' ? 'end' : 'middle';
            this.elementSize = measureText(this.titleCollection[0], titleStyle);
            var options = new TextOption(this.element.id + '_HeatmapTitle', new TextBasic(titlePositionX(this.availableSize.width - this.margin.left - this.margin.right, this.margin.left, this.margin.right, titleStyle), this.margin.top + ((this.elementSize.height) * 3 / 4), anchor, this.titleCollection), titleStyle, titleStyle.color || this.themeStyle.heatMapTitle);
            if (this.titleCollection.length > 1) {
                this.drawSvgCanvas.createWrapText(options, titleStyle, this.svgObject);
            }
            else {
                this.drawSvgCanvas.createText(options, this.svgObject, this.titleCollection[0]);
                if (this.titleCollection[0].indexOf('...') !== -1 && this.enableCanvasRendering) {
                    this.tooltipCollection.push(new CanvasTooltip(this.titleSettings.text, new Rect(this.margin.left, this.margin.top, this.elementSize.width, this.elementSize.height)));
                }
            }
        }
    };
    HeatMap.prototype.titleTooltip = function (event, x, y, isTouch) {
        var targetId = event.target.id;
        if ((targetId === (this.element.id + '_HeatmapTitle')) && (event.target.textContent.indexOf('...') > -1)) {
            showTooltip(this.titleSettings.text, x, y, this.element.offsetWidth, this.element.id + '_Title_Tooltip', getElement(this.element.id + '_Secondary_Element'), isTouch);
        }
        else {
            removeElement(this.element.id + '_Title_Tooltip');
        }
    };
    HeatMap.prototype.axisTooltip = function (event, x, y, isTouch) {
        var targetId = event.target.id;
        if ((targetId.indexOf(this.element.id + '_XAxis_Label') !== -1) && (event.target.textContent.indexOf('...') > -1)) {
            var index = parseInt(targetId.replace(this.element.id + '_XAxis_Label', ''), 10);
            showTooltip(this.axisCollections[0].axisLabels[index], x, y, this.element.offsetWidth, this.element.id + '_axis_Tooltip', getElement(this.element.id + '_Secondary_Element'), isTouch);
        }
        else {
            removeElement(this.element.id + '_axis_Tooltip');
        }
    };
    HeatMap.prototype.isHeatmapRect = function (x, y) {
        var firstRectDetails = [];
        var lastRectDetails = [];
        var isRect;
        firstRectDetails.push(this.heatMapSeries.rectPositionCollection[0][0]);
        lastRectDetails.push(this.heatMapSeries.rectPositionCollection[this.yLength - 1][this.xLength - 1]);
        isRect = (x >= firstRectDetails[0].x && y >= firstRectDetails[0].y &&
            x <= (lastRectDetails[0].x + lastRectDetails[0].width) &&
            y <= (lastRectDetails[0].y + lastRectDetails[0].height)) ? true : false;
        return isRect;
    };
    HeatMap.prototype.setTheme = function () {
        /*! Set theme */
        this.themeStyle = getThemeColor(this.theme);
    };
    HeatMap.prototype.calculateBounds = function () {
        var margin = this.margin;
        // Title Height;
        var titleHeight = 0;
        var padding = (this.legendModule && this.legendSettings.position === 'Top'
            && this.legendVisibilityByCellType) ? 0 : 16; // title padding
        var left = margin.left;
        var width = this.availableSize.width - left - margin.right;
        if (this.titleSettings.text) {
            this.titleCollection = getTitle(this.titleSettings.text, this.titleSettings.textStyle, width);
            titleHeight = (measureText(this.titleSettings.text, this.titleSettings.textStyle).height * this.titleCollection.length) +
                padding;
        }
        var top = margin.top + titleHeight;
        var height = this.availableSize.height - top - margin.bottom;
        this.initialClipRect = new Rect(left, top, width, height);
        var legendTop = this.initialClipRect.y;
        if (this.legendModule && this.legendSettings.visible && this.legendVisibilityByCellType) {
            this.legendModule.calculateLegendBounds(this.initialClipRect);
        }
        this.heatMapAxis.measureAxis(this.initialClipRect);
        if (this.legendModule && this.legendSettings.visible && this.legendVisibilityByCellType) {
            this.legendModule.calculateLegendSize(this.initialClipRect, legendTop);
        }
        this.heatMapAxis.calculateAxisSize(this.initialClipRect);
    };
    HeatMap.prototype.refreshBound = function () {
        this.updateBubbleHelperProperty();
        this.calculateBounds();
        this.renderElements();
    };
    HeatMap.prototype.initAxis = function () {
        var axis;
        var axes = [this.xAxis, this.yAxis];
        this.axisCollections = [];
        for (var i = 0, len = axes.length; i < len; i++) {
            axis = axes[i];
            axis.orientation = (i === 0) ? 'Horizontal' : 'Vertical';
            this.axisCollections.push(axis);
        }
    };
    /**
     * Method to bind events for HeatMap
     */
    HeatMap.prototype.wireEvents = function () {
        /*! Find the Events type */
        var isIE11Pointer = Browser.isPointer;
        var start = Browser.touchStartEvent;
        var stop = Browser.touchEndEvent;
        var move = Browser.touchMoveEvent;
        var cancel = isIE11Pointer ? 'pointerleave' : 'mouseleave';
        EventHandler.add(this.element, Browser.isDevice ? start : 'click', this.heatMapMouseClick, this);
        EventHandler.add(this.element, start, this.heatMapMouseMove, this);
        EventHandler.add(this.element, stop, this.heatMapMouseLeave, this);
        EventHandler.add(this.element, move, this.heatMapMouseMove, this);
        EventHandler.add(this.element, cancel, this.heatMapMouseLeave, this);
        window.addEventListener((Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.heatMapResize.bind(this));
        this.setStyle(this.element);
    };
    /**
     * Applying styles for heatmap element
     */
    HeatMap.prototype.setStyle = function (element) {
        element.style.touchAction = 'element';
        element.style.msTouchAction = 'element';
        element.style.msContentZooming = 'none';
        element.style.msUserSelect = 'none';
        element.style.webkitUserSelect = 'none';
        element.style.position = 'relative';
        element.style.display = 'block';
    };
    /**
     * Method to unbind events for HeatMap
     */
    HeatMap.prototype.unWireEvents = function () {
        /*! Find the Events type */
        var isIE11Pointer = Browser.isPointer;
        var start = Browser.touchStartEvent;
        var stop = Browser.touchEndEvent;
        var move = Browser.touchMoveEvent;
        var cancel = isIE11Pointer ? 'pointerleave' : 'mouseleave';
        EventHandler.remove(this.element, Browser.isDevice ? start : 'click', this.heatMapMouseClick);
        EventHandler.remove(this.element, start, this.heatMapMouseMove);
        EventHandler.remove(this.element, move, this.heatMapMouseLeave);
        EventHandler.remove(this.element, move, this.heatMapMouseMove);
        EventHandler.remove(this.element, cancel, this.heatMapMouseLeave);
        window.removeEventListener((Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.heatMapResize);
    };
    /**
     * Handles the heatmap resize.
     * @return {boolean}
     * @private
     */
    HeatMap.prototype.heatMapResize = function (e) {
        var _this = this;
        if (this.resizeTimer) {
            clearTimeout(this.resizeTimer);
        }
        this.resizeTimer = setTimeout(function () {
            if (_this.isDestroyed) {
                clearTimeout(_this.resizeTimer);
                return;
            }
            _this.createSvg();
            _this.refreshBound();
            _this.element.appendChild(_this.svgObject);
        }, 500);
        return false;
    };
    /**
     * Get the maximum length of data source for both horizontal and vertical
     * @private
     */
    HeatMap.prototype.calculateMaxLength = function () {
        var dataSource = this.completeAdaptDataSource;
        if (dataSource && dataSource.length > 0) {
            var xAxisMax = dataSource.length - 1;
            var yAxisMax = 0;
            for (var i = 0; i <= xAxisMax; i++) {
                var length_1 = dataSource[i].length;
                yAxisMax = yAxisMax > length_1 ? yAxisMax : length_1;
            }
            this.axisCollections[0].maxLength = xAxisMax;
            this.axisCollections[1].maxLength = yAxisMax - 1;
        }
        else {
            this.axisCollections[0].maxLength = 0;
            this.axisCollections[1].maxLength = 0;
        }
    };
    /**
     * To find mouse x, y for aligned heatmap element svg position
     */
    HeatMap.prototype.setMouseXY = function (pageX, pageY) {
        var rect = this.element.getBoundingClientRect();
        var svgCanvasRect;
        if (this.enableCanvasRendering) {
            svgCanvasRect = document.getElementById(this.element.id + '_canvas').getBoundingClientRect();
        }
        else {
            svgCanvasRect = document.getElementById(this.element.id + '_svg').getBoundingClientRect();
        }
        this.mouseX = (pageX - rect.left) - Math.max(svgCanvasRect.left - rect.left, 0);
        this.mouseY = (pageY - rect.top) - Math.max(svgCanvasRect.top - rect.top, 0);
    };
    HeatMap.prototype.heatMapMouseClick = function (e) {
        var pageX;
        var pageY;
        var tooltipText;
        var touchArg;
        var elementRect = this.element.getBoundingClientRect();
        if (e.type === 'touchstart') {
            this.isTouch = true;
            touchArg = e;
            pageY = touchArg.changedTouches[0].clientY;
            pageX = touchArg.changedTouches[0].clientX;
        }
        else {
            this.isTouch = false;
            pageY = e.clientY;
            pageX = e.clientX;
        }
        pageX -= elementRect.left;
        pageY -= elementRect.top;
        var isheatmapRect = this.isHeatmapRect(pageX, pageY);
        if (isheatmapRect) {
            var currentRect = this.heatMapSeries.getCurrentRect(pageX, pageY);
            this.trigger('cellClick', {
                heatmap: this,
                value: currentRect.value,
                x: currentRect.x,
                y: currentRect.y,
                xLabel: this.heatMapSeries.hoverXAxisLabel,
                yLabel: this.heatMapSeries.hoverYAxisLabel,
                xValue: this.heatMapSeries.hoverXAxisValue,
                yValue: this.heatMapSeries.hoverYAxisValue,
                cellElement: this.enableCanvasRendering ? null : document.getElementById(currentRect.id)
            });
        }
        this.notify('click', e);
        if (this.paletteSettings.type !== 'Gradient' && this.legendModule
            && this.legendSettings.visible && this.legendVisibilityByCellType) {
            var page = this.legendModule.navigationCollections;
            if (page.length && pageX > page[0].x && pageX < page[0].x + page[0].width &&
                pageY > page[0].y && pageY < page[0].y + page[0].height) {
                this.legendModule.translatePage(this, this.legendModule.currentPage, true);
            }
            else if (page.length && pageX > page[1].x && pageX < page[1].x + page[1].width &&
                pageY > page[1].y && pageY < page[1].y + page[1].height) {
                this.legendModule.translatePage(this, this.legendModule.currentPage, false);
            }
        }
        return false;
    };
    /**
     * Handles the mouse Move.
     * @return {boolean}
     * @private
     */
    HeatMap.prototype.heatMapMouseMove = function (e) {
        var _this = this;
        var pageX;
        var pageY;
        var tooltipText;
        var touchArg;
        var elementRect = this.element.getBoundingClientRect();
        if (e.type === 'touchmove' || e.type === 'touchstart') {
            this.isTouch = true;
            touchArg = e;
            pageX = touchArg.changedTouches[0].clientX;
            pageY = touchArg.changedTouches[0].clientY;
        }
        else {
            this.isTouch = false;
            pageX = e.clientX;
            pageY = e.clientY;
        }
        pageX -= elementRect.left;
        pageY -= elementRect.top;
        this.setMouseXY(pageX, pageY);
        if (e.target && e.target.id) {
            var isheatmapRect = this.isHeatmapRect(pageX, pageY);
            if (this.legendModule) {
                if (isheatmapRect) {
                    if (this.paletteSettings.type === 'Gradient' &&
                        this.legendSettings.showGradientPointer && this.legendSettings.visible && this.legendVisibilityByCellType) {
                        this.legendModule.renderGradientPointer(e, pageX, pageY);
                    }
                }
                else {
                    this.legendModule.removeGradientPointer();
                }
            }
            var isshowTooltip = void 0;
            isshowTooltip = this.showTooltip && this.tooltipModule ? this.isHeatmapRect(pageX, pageY) : false;
            if (isshowTooltip) {
                var currentRect = void 0;
                currentRect = this.heatMapSeries.getCurrentRect(pageX, pageY);
                if (this.tempTooltipRectId !== currentRect.id) {
                    if (this.showTooltip) {
                        if ((this.cellSettings.enableCellHighlighting || (this.tooltipModule && this.showTooltip))
                            && !this.enableCanvasRendering) {
                            this.heatMapSeries.highlightSvgRect(currentRect.id);
                        }
                        this.tooltipModule.renderTooltip(currentRect);
                        if (this.isTouch) {
                            if (this.tooltipTimer) {
                                window.clearTimeout(this.tooltipTimer);
                            }
                            this.tooltipTimer = setTimeout(function () {
                                _this.tooltipModule.tooltipObject.fadeOut();
                                _this.tooltipModule.isFadeout = true;
                            }, 1500);
                            if (e.type === 'touchmove') {
                                e.preventDefault();
                            }
                        }
                    }
                    this.tempTooltipRectId = currentRect.id;
                }
            }
            else {
                if (e.target.id.indexOf('Celltooltip') === -1) {
                    if ((this.cellSettings.enableCellHighlighting || this.showTooltip) && !this.enableCanvasRendering) {
                        this.heatMapSeries.highlightSvgRect(e.target.id);
                    }
                    if (this.tooltipModule && this.showTooltip) {
                        this.tooltipModule.showHideTooltip(false, true);
                    }
                }
                this.tempTooltipRectId = '';
            }
            if (this.legendModule && this.legendSettings.visible && this.paletteSettings.type === 'Fixed' &&
                this.legendSettings.enableSmartLegend && this.legendSettings.labelDisplayType === 'None') {
                this.legendModule.createTooltip(pageX, pageY);
            }
            if (!this.enableCanvasRendering) {
                if (this.titleSettings.text && this.titleSettings.textStyle.textOverflow === 'Trim') {
                    this.titleTooltip(e, pageX, pageY, this.isTouch);
                }
                this.axisTooltip(e, pageX, pageY, this.isTouch);
                if (this.legendModule && this.legendSettings.visible && this.legendSettings.showLabel && this.legendVisibilityByCellType) {
                    this.legendModule.renderLegendLabelTooltip(e);
                }
            }
            else {
                elementRect = this.element.getBoundingClientRect();
                var tooltipRect = (this.paletteSettings.type === 'Fixed' && this.legendSettings.enableSmartLegend &&
                    this.legendSettings.labelDisplayType === 'None') ? false : true;
                tooltipText = getTooltipText(this.tooltipCollection, pageX, pageY) ||
                    (this.legendModule && tooltipRect && getTooltipText(this.legendModule.legendLabelTooltip, pageX, pageY));
                if (tooltipText) {
                    showTooltip(tooltipText, this.mouseX, this.mouseY, this.element.offsetWidth, this.element.id + '_canvas_Tooltip', getElement(this.element.id + '_Secondary_Element'), this.isTouch);
                }
                else {
                    removeElement(this.element.id + '_canvas_Tooltip');
                }
            }
        }
        return true;
    };
    /**
     * Handles the mouse end.
     * @return {boolean}
     * @private
     */
    HeatMap.prototype.heatMapMouseLeave = function (e) {
        var _this = this;
        if (e.target && e.target.id &&
            (this.cellSettings.enableCellHighlighting || (this.tooltipModule && this.showTooltip))
            && !this.enableCanvasRendering) {
            this.heatMapSeries.highlightSvgRect(this.tempTooltipRectId);
        }
        if (this.tooltipModule && this.showTooltip && e.type === 'mouseleave') {
            this.tooltipModule.showHideTooltip(false);
        }
        this.tempTooltipRectId = '';
        if (this.legendModule && this.legendSettings.visible && this.legendModule.tooltipObject &&
            this.legendModule.tooltipObject.element) {
            var tooltipElement_1 = this.legendModule.tooltipObject.element.firstChild;
            if (e.type === 'mouseleave') {
                tooltipElement_1.setAttribute('opacity', '0');
            }
            else {
                if (this.legendTooltipTimer) {
                    window.clearTimeout(this.legendTooltipTimer);
                }
                this.legendTooltipTimer = setTimeout(function () {
                    tooltipElement_1.setAttribute('opacity', '0');
                }, 1500);
            }
        }
        if (this.paletteSettings.type === 'Gradient' && this.legendModule && this.legendSettings.showGradientPointer &&
            this.legendSettings.visible && this.legendVisibilityByCellType) {
            if (e.type === 'mouseleave') {
                this.legendModule.removeGradientPointer();
            }
            else {
                if (this.gradientTimer) {
                    window.clearTimeout(this.gradientTimer);
                }
                this.gradientTimer = setTimeout(function () { _this.legendModule.removeGradientPointer(); }, 1500);
            }
        }
        if (this.enableCanvasRendering) {
            var main = document.getElementById(this.element.id + '_hoverRect_canvas');
            if (main) {
                main.style.visibility = 'hidden';
                this.tempRectHoverClass = '';
            }
        }
        if (this.titleSettings.text && this.titleCollection[0].indexOf('...') !== -1) {
            if (!this.enableCanvasRendering) {
                removeElement(this.element.id + '_Title_Tooltip');
            }
            else {
                removeElement(this.element.id + '_canvas_Tooltip');
            }
        }
        return true;
    };
    __decorate([
        Property(null)
    ], HeatMap.prototype, "width", void 0);
    __decorate([
        Property(null)
    ], HeatMap.prototype, "height", void 0);
    __decorate([
        Property(true)
    ], HeatMap.prototype, "showTooltip", void 0);
    __decorate([
        Event()
    ], HeatMap.prototype, "tooltipRender", void 0);
    __decorate([
        Property('SVG')
    ], HeatMap.prototype, "renderingMode", void 0);
    __decorate([
        Property(null)
    ], HeatMap.prototype, "dataSource", void 0);
    __decorate([
        Property('Material')
    ], HeatMap.prototype, "theme", void 0);
    __decorate([
        Complex({}, Margin)
    ], HeatMap.prototype, "margin", void 0);
    __decorate([
        Complex({ text: '', textStyle: Theme.heatMapTitleFont }, Title)
    ], HeatMap.prototype, "titleSettings", void 0);
    __decorate([
        Complex({}, Axis)
    ], HeatMap.prototype, "xAxis", void 0);
    __decorate([
        Complex({}, LegendSettings)
    ], HeatMap.prototype, "legendSettings", void 0);
    __decorate([
        Complex({}, PaletteSettings)
    ], HeatMap.prototype, "paletteSettings", void 0);
    __decorate([
        Complex({}, Axis)
    ], HeatMap.prototype, "yAxis", void 0);
    __decorate([
        Complex({}, CellSettings)
    ], HeatMap.prototype, "cellSettings", void 0);
    __decorate([
        Event()
    ], HeatMap.prototype, "created", void 0);
    __decorate([
        Event()
    ], HeatMap.prototype, "load", void 0);
    __decorate([
        Event()
    ], HeatMap.prototype, "cellClick", void 0);
    HeatMap = __decorate([
        NotifyPropertyChanges
    ], HeatMap);
    return HeatMap;
}(Component));
export { HeatMap };
