import { findChildren, Location, Rect, Size, measureText, TextOption, PathOption, RectOption, drawSymbol, orderByArea } from '../utils/helper';
import { Browser, isNullOrUndefined, EventHandler } from '@syncfusion/ej2-base';
import { renderTextElement, textTrim } from '../utils/helper';
import { legendItemRendering } from '../model/constants';
/**
 * Legend module class
 */
var TreeMapLegend = /** @class */ (function () {
    function TreeMapLegend(treemap) {
        this.page = 0;
        this.legendBorderRect = new Rect(0, 0, 0, 0);
        this.currentPage = 0;
        this.heightIncrement = 0;
        this.widthIncrement = 0;
        this.textMaxWidth = 0;
        this.legendItemRect = new Rect(0, 0, 0, 0);
        this.treemap = treemap;
        this.addEventListener();
    }
    /**
     * method for legend
     */
    TreeMapLegend.prototype.renderLegend = function () {
        this.legendRenderingCollections = [];
        this.legendCollections = [];
        this.legendNames = [];
        this.totalPages = [];
        this.gradientCount = 1;
        this.defsElement = this.treemap.renderer.createDefs();
        this.treemap.svgObject.appendChild(this.defsElement);
        this.calculateLegendBounds();
        this.drawLegend();
    };
    /* tslint:disable:no-string-literal */
    /* tslint:disable-next-line:max-func-body-length */
    TreeMapLegend.prototype.calculateLegendBounds = function () {
        var _this = this;
        var treemap = this.treemap;
        var legend = treemap.legendSettings;
        this.findColorMappingLegendItems(treemap.levelsOfData[0]);
        if (this.treemap.palette.length > 0 && this.legendCollections.length === 0) {
            this.findPaletteLegendItems(this.treemap.levelsOfData[0], 'Parent');
        }
        if (this.legendCollections.length > 0) {
            var defaultSize = 25;
            var textPadding = 10;
            var position = legend.position;
            var legendTitle = legend.title.text;
            var titleTextStyle = legend.titleStyle;
            var legendMode = legend.mode;
            var shapeX = 0;
            var shapeY = 0;
            var textX = 0;
            var textY = 0;
            var shapeHeight = legend.shapeHeight;
            var shapeWidth = legend.shapeWidth;
            var shapeLocation = [];
            var textLocation = [];
            var orientation_1 = (legend.orientation === 'None') ? ((position === 'Top' || position === 'Bottom')
                ? 'Horizontal' : 'Vertical') : legend.orientation;
            var leftPadding = 10;
            var topPadding = 10;
            var spacing = 10;
            var legendWidth = (legend.width.length > 1) ? (legend.width.indexOf('%') > -1) ? (treemap.availableSize.width / 100)
                * parseFloat(legend.width) : parseFloat(legend.width) : null;
            var legendHeight = (legend.height.length > 1) ? (legend.height.indexOf('%') > -1) ?
                (treemap.availableSize.height / 100) * parseFloat(legend.height) : parseFloat(legend.height) : null;
            var legendTitleSize = measureText(legendTitle, titleTextStyle);
            var startX_1 = 0;
            var startY_1 = 0;
            var shapePadding = legend.shapePadding;
            var rectWidth = void 0;
            var rectHeight = void 0;
            var itemTextStyle = legend.textStyle;
            var legendLength = this.legendCollections.length;
            if (legendMode === 'Default') {
                legendWidth = (isNullOrUndefined(legendWidth)) ? treemap.areaRect.width : legendWidth;
                legendHeight = (isNullOrUndefined(legendHeight)) ? treemap.areaRect.height : legendHeight;
                var j = 0;
                for (var i = 0; i < this.legendCollections.length; i++) {
                    var legendItem = this.legendCollections[i];
                    if (isNullOrUndefined(this.totalPages[this.page])) {
                        this.totalPages[this.page] = { Page: (this.page + 1), Collection: [] };
                    }
                    var legendTextSize = measureText(legendItem['legendName'], legend.textStyle);
                    this.textMaxWidth = Math.max(this.textMaxWidth, legendTextSize.width);
                    if (i === 0) {
                        startX_1 = shapeX = (leftPadding + (shapeWidth / 2));
                        startY_1 = shapeY = topPadding + legendTitleSize.height + (shapeHeight > legendTextSize.height ? shapeHeight / 2
                            : (legendTextSize.height / 4));
                    }
                    else {
                        var maxSize = (legendTextSize.height > shapeHeight) ? legendTextSize.height : shapeHeight;
                        if (orientation_1 === 'Horizontal') {
                            var prvePositionX = (textLocation[j - 1].x + textLocation[j - 1].width) + textPadding + shapeWidth;
                            if ((prvePositionX + shapePadding + legendTextSize.width) > legendWidth) {
                                var nextPositionY = (textLocation[j - 1].y > (shapeLocation[j - 1].y + (shapeHeight / 2)) ?
                                    textLocation[j - 1].y : (shapeLocation[j - 1].y + (shapeHeight / 2))) + topPadding;
                                if ((nextPositionY + maxSize) > legendHeight) {
                                    this.getPageChanged();
                                    j = 0;
                                    shapeLocation = [];
                                    textLocation = [];
                                    shapeX = startX_1;
                                    shapeY = startY_1;
                                }
                                else {
                                    shapeX = (shapeLocation[0].x);
                                    shapeY = (nextPositionY + (maxSize / 2));
                                }
                            }
                            else {
                                shapeX = (prvePositionX - (shapeWidth / 2));
                                shapeY = (shapeLocation[j - 1]).y;
                            }
                        }
                        else {
                            var prevPositionY = textLocation[j - 1].y > shapeLocation[j - 1].y + (shapeHeight / 2) ?
                                textLocation[j - 1].y : shapeLocation[j - 1].y + (shapeHeight / 2);
                            if ((prevPositionY + topPadding + maxSize) > legendHeight) {
                                var nextPositionX = (textLocation[j - 1].x + this.textMaxWidth + textPadding);
                                if ((nextPositionX + shapePadding + legendTextSize.width) > legendWidth) {
                                    shapeX = startX_1;
                                    shapeY = startY_1;
                                    textLocation = [];
                                    shapeLocation = [];
                                    this.getPageChanged();
                                    j = 0;
                                }
                                else {
                                    shapeX = nextPositionX + (shapeWidth / 2);
                                    shapeY = (shapeLocation[0].y);
                                }
                            }
                            else {
                                shapeX = shapeLocation[j - 1].x;
                                shapeY = prevPositionY + topPadding + (shapeHeight / 2);
                            }
                        }
                    }
                    textX = shapeX + (shapeWidth / 2) + shapePadding;
                    textY = shapeY + (legendTextSize.height / 4);
                    shapeLocation.push({ x: shapeX, y: shapeY });
                    textLocation.push({ x: textX, y: textY, width: legendTextSize.width, height: (legendTextSize.height / 2) });
                    this.totalPages[this.page]['Collection'].push({
                        DisplayText: legendItem['legendName'],
                        Shape: { x: shapeX, y: shapeY },
                        Text: { x: textX, y: textY },
                        Fill: legendItem['legendFill'],
                        Data: legendItem['legendData'],
                        Rect: {
                            x: shapeLocation[j].x - (shapeWidth / 2),
                            y: (shapeLocation[j].y - (shapeHeight / 2)) < (textY - legendTextSize.height) ?
                                (shapeLocation[j].y - (shapeHeight / 2)) : (textY - legendTextSize.height),
                            width: Math.abs((shapeLocation[j].x - (shapeWidth / 2)) - (textX + legendTextSize.width)),
                            height: ((shapeHeight > legendTextSize.height) ? shapeHeight : legendTextSize.height)
                        }
                    });
                    j++;
                }
                var collection = this.totalPages[0]['Collection'];
                collection.forEach(function (legendObj, index) {
                    var legendRect = new Rect(legendObj['Rect']['x'], legendObj['Rect']['y'], legendObj['Rect']['width'], legendObj['Rect']['height']);
                    if (index === 0) {
                        startX_1 = legendRect.x;
                        startY_1 = legendRect.y;
                    }
                    _this.widthIncrement = Math.max(_this.widthIncrement, Math.abs(startX_1 - (legendRect.x + legendRect.width)));
                    _this.heightIncrement = Math.max(_this.heightIncrement, Math.abs(startY_1 - (legendRect.y + legendRect.height)));
                });
                legendWidth = ((this.widthIncrement < legendWidth) ? this.widthIncrement : legendWidth);
                legendHeight = ((this.heightIncrement < legendHeight) ? this.heightIncrement : legendHeight);
                this.legendItemRect = {
                    x: collection[0]['Rect']['x'], y: collection[0]['Rect']['y'],
                    width: legendWidth, height: legendHeight
                };
            }
            else {
                var itemTextStyle_1 = legend.textStyle;
                var rectWidth_1;
                var rectHeight_1;
                var legendLength_1 = this.legendCollections.length;
                rectWidth_1 = (orientation_1 === 'Horizontal') ? (isNullOrUndefined(legendWidth)) ? (treemap.areaRect.width / legendLength_1) :
                    (legendWidth / legendLength_1) : (isNullOrUndefined(legendWidth)) ? defaultSize : legendWidth;
                rectHeight_1 = (orientation_1 === 'Horizontal') ? (isNullOrUndefined(legendHeight)) ? defaultSize : legendHeight :
                    (isNullOrUndefined(legendHeight)) ? (treemap.areaRect.height / legendLength_1) : (legendHeight / legendLength_1);
                startX_1 = 0;
                startY_1 = legendTitleSize.height + spacing;
                var textPadding_1 = 10;
                var placement = legend.labelPosition;
                var itemStartX = 0;
                var itemStartY = 0;
                var labelAction = legend.labelDisplayMode;
                var maxTextHeight = 0;
                var maxTextWidth = 0;
                for (var i = 0; i < this.legendCollections.length; i++) {
                    startX_1 = (orientation_1 === 'Horizontal') ? (startX_1 + rectWidth_1) : startX_1;
                    startY_1 = (orientation_1 === 'Horizontal') ? startY_1 : (startY_1 + rectHeight_1);
                    var legendText = this.legendCollections[i]['legendName'];
                    var itemTextSize = new Size(0, 0);
                    if (labelAction === 'None') {
                        itemTextSize = measureText(legendText, itemTextStyle_1);
                    }
                    else if (labelAction === 'Trim') {
                        legendText = textTrim((orientation_1 === 'Horizontal' ? rectWidth_1 : rectHeight_1), legendText, itemTextStyle_1);
                        itemTextSize = measureText(legendText, itemTextStyle_1);
                    }
                    else {
                        legendText = '';
                    }
                    maxTextHeight = Math.max(maxTextHeight, itemTextSize.height);
                    maxTextWidth = Math.max(maxTextWidth, itemTextSize.width);
                    if (itemTextSize.width > 0 && itemTextSize.height > 0) {
                        if (orientation_1 === 'Horizontal') {
                            textX = startX_1 + (rectWidth_1 / 2);
                            textY = (placement === 'After') ? (startY_1 + rectHeight_1 + (itemTextSize.height / 2)) + textPadding_1 :
                                (startY_1 - textPadding_1);
                        }
                        else {
                            textX = (placement === 'After') ? startX_1 - (itemTextSize.width / 2) - textPadding_1
                                : (startX_1 + rectWidth_1 + itemTextSize.width / 2) + textPadding_1;
                            textY = startY_1 + (rectHeight_1 / 2) + (itemTextSize.height / 4);
                        }
                    }
                    if (i === 0) {
                        itemStartX = (orientation_1 === 'Horizontal') ? startX_1 : (placement === 'After') ?
                            textX - (itemTextSize.width / 2) : startX_1;
                        itemStartY = (orientation_1 === 'Horizontal') ? (placement === 'After') ? startY_1 :
                            textY - (itemTextSize.height / 2) : startY_1;
                    }
                    if (i === legendLength_1 - 1) {
                        legendWidth = (orientation_1 === 'Horizontal') ? Math.abs((startX_1 + rectWidth_1) - itemStartX) :
                            (rectWidth_1 + maxTextWidth + textPadding_1);
                        legendHeight = (orientation_1 === 'Horizontal') ? (rectHeight_1 + (maxTextHeight / 2) + textPadding_1) :
                            Math.abs((startY_1 + rectHeight_1) - itemStartY);
                    }
                    this.legendRenderingCollections.push({
                        fill: this.legendCollections[i]['legendFill'], x: startX_1, y: startY_1,
                        width: rectWidth_1, height: rectHeight_1, element: this.legendCollections[i]['gradientElement'],
                        text: legendText, textX: textX, textY: textY,
                        textWidth: itemTextSize.width, textHeight: itemTextSize.height,
                        data: this.legendCollections[i]['legendData']
                    });
                }
                this.legendItemRect = { x: itemStartX, y: itemStartY, width: legendWidth, height: legendHeight };
            }
        }
    };
    TreeMapLegend.prototype.getPageChanged = function () {
        this.page++;
        if (isNullOrUndefined(this.totalPages[this.page])) {
            this.totalPages[this.page] = { Page: (this.page + 1), Collection: [] };
        }
    };
    TreeMapLegend.prototype.findColorMappingLegendItems = function (data) {
        var child = findChildren(data)['values'];
        if (child && child.length > 0) {
            this.calculateLegendItems(child);
            if (this.treemap.levels.length > 0) {
                for (var i = 0; i < child.length; i++) {
                    this.findColorMappingLegendItems(child[i]);
                }
            }
        }
    };
    TreeMapLegend.prototype.findPaletteLegendItems = function (data, type) {
        var child = findChildren(data)['values'];
        if (child && child.length > 0) {
            for (var i = 0; i < child.length; i++) {
                this.legendCollections.push({
                    legendName: child[i]['name'],
                    legendFill: this.treemap.palette[i % this.treemap.palette.length],
                    legendData: [],
                    itemArea: child[i]['weight']
                });
            }
            this.legendCollections.sort(orderByArea);
            for (var j = 0; j < this.legendCollections.length; j++) {
                this.legendCollections[j]['legendFill'] = this.treemap.palette[j % this.treemap.palette.length];
            }
        }
    };
    TreeMapLegend.prototype.calculateLegendItems = function (data) {
        var isAddData;
        var fill;
        var rangeValue;
        var currentData;
        var legendText;
        var itemValue;
        var isLeafItem;
        var colorMapProcess = false;
        var colorMapping;
        var groupIndex;
        var leaf = this.treemap.leafItemSettings;
        var levels = this.treemap.levels;
        var equalValue;
        var position = this.treemap.legendSettings.position;
        var gradientElement;
        var x2;
        var y2;
        for (var i = 0; i < data.length; i++) {
            currentData = data[i]['data'];
            groupIndex = data[i]['groupIndex'];
            isLeafItem = (this.treemap.levels.length === 0 || groupIndex === this.treemap.levels.length);
            colorMapping = isLeafItem ? leaf.colorMapping : levels[groupIndex].colorMapping;
            for (var _i = 0, colorMapping_1 = colorMapping; _i < colorMapping_1.length; _i++) {
                var colorMap = colorMapping_1[_i];
                rangeValue = Number(currentData[this.treemap.rangeColorValuePath]);
                equalValue = currentData[this.treemap.equalColorValuePath];
                colorMap.value = !isNullOrUndefined(colorMap.value) ? colorMap.value.toString() : colorMap.value;
                if (!isNullOrUndefined(colorMap.from) && !isNullOrUndefined(colorMap.to) &&
                    rangeValue >= colorMap.from && rangeValue <= colorMap.to) {
                    colorMapProcess = true;
                    legendText = !isNullOrUndefined(colorMap.label) ? colorMap.label : colorMap.from + ' - ' + colorMap.to;
                    fill = isNullOrUndefined(colorMap.color) ? fill : colorMap.color;
                    isAddData = this.isAddNewLegendData(legendText);
                }
                else if (!isNullOrUndefined(colorMap.value) && equalValue === colorMap.value) {
                    colorMapProcess = true;
                    legendText = !isNullOrUndefined(colorMap.label) ? colorMap.label : colorMap.value.toString();
                    fill = isNullOrUndefined(colorMap.color) ? fill : colorMap.color;
                    isAddData = this.isAddNewLegendData(legendText);
                }
                if (colorMapProcess && colorMap.maxOpacity && colorMap.minOpacity && this.treemap.legendSettings.mode === 'Interactive') {
                    var colors = [];
                    var gradient = void 0;
                    var stop1Color = { colorStop: '0%', color: fill };
                    var stop2Color = { colorStop: '100%', color: fill };
                    x2 = position === 'Top' || position === 'Bottom' ? '100%' : '0%';
                    y2 = position === 'Top' || position === 'Bottom' ? '0%' : '100%';
                    colors.push(stop1Color);
                    colors.push(stop2Color);
                    gradient = {
                        id: 'groupIndex_' + groupIndex + '_colorIndex_' + this.gradientCount, x1: '0%', y1: '0%', x2: x2, y2: y2
                    };
                    gradientElement = this.treemap.renderer.drawGradient('linearGradient', gradient, colors).childNodes[0];
                    gradientElement.childNodes[0].setAttribute('stop-opacity', colorMap.minOpacity.toString());
                    gradientElement.childNodes[1].setAttribute('stop-opacity', colorMap.maxOpacity.toString());
                    this.defsElement.appendChild(gradientElement);
                    this.gradientCount++;
                }
                if (isAddData && isAddData['process'] && colorMapProcess) {
                    colorMapProcess = false;
                    this.legendCollections.push({
                        legendName: legendText, legendFill: fill, legendData: [], gradientElement: gradientElement
                    });
                    this.legendCollections[this.legendCollections.length - 1]['legendData'].push(data[i]);
                }
                else if (colorMapProcess) {
                    colorMapProcess = false;
                    this.legendCollections[isAddData['value']]['legendData'].push(data[i]);
                }
            }
        }
    };
    TreeMapLegend.prototype.isAddNewLegendData = function (legendText) {
        var newDataProcess;
        var itemValue;
        if (this.legendCollections.length === 0) {
            newDataProcess = true;
        }
        else {
            for (var j = 0; j < this.legendCollections.length; j++) {
                if (legendText === this.legendCollections[j]['legendName']) {
                    newDataProcess = false;
                    itemValue = j;
                    break;
                }
                else if (j === this.legendCollections.length - 1) {
                    newDataProcess = true;
                }
            }
        }
        return { process: newDataProcess, value: itemValue };
    };
    /**
     * To draw the legend
     */
    TreeMapLegend.prototype.drawLegend = function () {
        var treemap = this.treemap;
        var legend = treemap.legendSettings;
        var render = treemap.renderer;
        var fill;
        var textOptions;
        var gradientElement;
        var textFont = legend.textStyle;
        this.legendGroup = render.createGroup({ id: treemap.element.id + '_Legend_Group' });
        this.renderLegendBorder();
        this.renderLegendTitle();
        if (legend.mode === 'Default') {
            this.drawLegendItem(this.currentPage);
        }
        else {
            for (var i = 0; i < this.legendRenderingCollections.length; i++) {
                var itemId = treemap.element.id + '_Legend_Index_' + i;
                var textId = treemap.element.id + '_Legend_Index_' + i + '_Text';
                var item = this.legendRenderingCollections[i];
                gradientElement = item['element'];
                fill = gradientElement ? 'url(#' + gradientElement.id + ')' : item['fill'];
                var bounds = new Rect(item['x'], item['y'], item['width'], item['height']);
                var textLocation = new Location(item['textX'], item['textY']);
                var rectOptions = new RectOption(itemId, fill, legend.shapeBorder, 1, bounds);
                textOptions = new TextOption(textId, textLocation.x, textLocation.y, 'middle', item['text'], '', '');
                renderTextElement(textOptions, textFont, textFont.color, this.legendGroup);
                this.legendGroup.appendChild(render.drawRectangle(rectOptions));
            }
        }
    };
    TreeMapLegend.prototype.drawLegendItem = function (page) {
        var treemap = this.treemap;
        var legend = treemap.legendSettings;
        var spacing = 10;
        var shapeSize = new Size(legend.shapeWidth, legend.shapeHeight);
        var textOptions;
        var renderOptions;
        var render = treemap.renderer;
        var shapeBorder = legend.shapeBorder;
        var eventArgs;
        if (page >= 0 && page < this.totalPages.length) {
            if (document.getElementById(this.legendGroup.id)) {
                document.getElementById(this.legendGroup.id).remove();
            }
            var isLineShape = (legend.shape === 'HorizontalLine' || legend.shape === 'VerticalLine' || legend.shape === 'Cross');
            var strokeColor = isLineShape ? isNullOrUndefined(legend.fill) ? '#000000' : legend.fill : shapeBorder.color;
            var strokeWidth = isLineShape ? (shapeBorder.width === 0) ? 1 : shapeBorder.width : shapeBorder.width;
            for (var i = 0; i < this.totalPages[page]['Collection'].length; i++) {
                var collection = this.totalPages[page]['Collection'][i];
                var legendElement = render.createGroup({ id: treemap.element.id + '_Legend_Index_' + i });
                var legendText = collection['DisplayText'];
                var shapeId = treemap.element.id + '_Legend_Shape_Index_' + i;
                var textId = treemap.element.id + '_Legend_Text_Index_' + i;
                var shapeLocation = collection['Shape'];
                var textLocation = collection['Text'];
                eventArgs = {
                    cancel: false, name: legendItemRendering, treemap: treemap, fill: collection['Fill'],
                    shape: legend.shape, imageUrl: legend.imageUrl
                };
                var renderOptions_1 = new PathOption(shapeId, eventArgs.fill, strokeWidth, isLineShape ? collection['Fill'] : strokeColor, 1, '');
                legendElement.appendChild(drawSymbol(shapeLocation, eventArgs.shape, shapeSize, eventArgs.imageUrl, renderOptions_1, legendText));
                textOptions = new TextOption(textId, textLocation.x, textLocation.y, 'start', legendText, '', '');
                renderTextElement(textOptions, legend.textStyle, legend.textStyle.color, legendElement);
                this.legendGroup.appendChild(legendElement);
            }
            var pagingGroup = void 0;
            var width = spacing;
            var height = (spacing / 2);
            if (this.page !== 0) {
                var pagingText = (page + 1) + '/' + this.totalPages.length;
                var pagingFont = legend.textStyle;
                var pagingTextSize = measureText(pagingText, pagingFont);
                var leftPageX = (this.legendItemRect.x + this.legendItemRect.width) - pagingTextSize.width -
                    (width * 2) - spacing;
                var rightPageX = (this.legendItemRect.x + this.legendItemRect.width);
                var locY = (this.legendItemRect.y + this.legendItemRect.height) + (height / 2) + spacing;
                var pageTextX = rightPageX - width - (pagingTextSize.width / 2) - (spacing / 2);
                pagingGroup = render.createGroup({ id: treemap.element.id + '_Legend_Paging_Group' });
                var leftPageElement = render.createGroup({ id: treemap.element.id + '_Legend_Left_Paging_Group' });
                var rightPageElement = render.createGroup({ id: treemap.element.id + '_Legend_Right_Paging_Group' });
                var rightPath = ' M ' + rightPageX + ' ' + locY + ' L ' + (rightPageX - width) + ' ' + (locY - height) +
                    ' L ' + (rightPageX - width) + ' ' + (locY + height) + ' z ';
                var leftPath = ' M ' + leftPageX + ' ' + locY + ' L ' + (leftPageX + width) + ' ' + (locY - height) +
                    ' L ' + (leftPageX + width) + ' ' + (locY + height) + ' z ';
                var leftPageOptions = new PathOption(treemap.element.id + '_Left_Page', '#a6a6a6', 0, '#a6a6a6', 1, '', leftPath);
                leftPageElement.appendChild(render.drawPath(leftPageOptions));
                var leftRectPageOptions = new RectOption(treemap.element.id + '_Left_Page_Rect', 'transparent', {}, 1, new Rect(leftPageX - (width / 2), (locY - (height * 2)), width * 2, spacing * 2), '');
                leftPageElement.appendChild(render.drawRectangle(leftRectPageOptions));
                this.wireEvents(leftPageElement);
                var rightPageOptions = new PathOption(treemap.element.id + '_Right_Page', '#a6a6a6', 0, '#a6a6a6', 1, '', rightPath);
                rightPageElement.appendChild(render.drawPath(rightPageOptions));
                var rightRectPageOptions = new RectOption(treemap.element.id + '_Right_Page_Rect', 'transparent', {}, 1, new Rect((rightPageX - width), (locY - height), width, spacing), '');
                rightPageElement.appendChild(render.drawRectangle(rightRectPageOptions));
                this.wireEvents(rightPageElement);
                pagingGroup.appendChild(leftPageElement);
                pagingGroup.appendChild(rightPageElement);
                var pageTextOptions = {
                    'id': treemap.element.id + '_Paging_Text',
                    'x': pageTextX,
                    'y': locY + (pagingTextSize.height / 4),
                    'fill': '#a6a6a6',
                    'font-size': '14px',
                    'font-style': pagingFont.fontStyle,
                    'font-family': pagingFont.fontFamily,
                    'font-weight': pagingFont.fontWeight,
                    'text-anchor': 'middle',
                    'transform': '',
                    'opacity': 1,
                    'dominant-baseline': ''
                };
                pagingGroup.appendChild(render.createText(pageTextOptions, pagingText));
                this.legendGroup.appendChild(pagingGroup);
            }
        }
    };
    TreeMapLegend.prototype.renderLegendBorder = function () {
        var treemap = this.treemap;
        var legend = treemap.legendSettings;
        var legendTitle = legend.title.text;
        var spacing = 10;
        var textStyle = legend.titleStyle;
        var textOptions;
        var title = textTrim((this.legendItemRect.width + (spacing * 2)), legendTitle, textStyle);
        var textSize = measureText(title, textStyle);
        this.legendBorderRect = new Rect((this.legendItemRect.x - spacing), (this.legendItemRect.y - spacing - textSize.height), (this.legendItemRect.width) + (spacing * 2), (this.legendItemRect.height) + (spacing * 2) + textSize.height +
            (legend.mode === 'Interactive' ? 0 : (this.page !== 0) ? spacing : 0));
        var renderOptions = new RectOption(treemap.element.id + '_Legend_Border', legend.background, legend.border, 1, this.legendBorderRect, '');
        var legendBorder = treemap.renderer.drawRectangle(renderOptions);
        legendBorder.style.pointerEvents = 'none';
        this.legendGroup.appendChild(legendBorder);
        this.getLegendAlignment(treemap, this.legendBorderRect.width, this.legendBorderRect.height, legend);
        this.legendGroup.setAttribute('transform', 'translate( ' + (this.translate.x + (-(this.legendBorderRect.x))) + ' ' +
            (this.translate.y + (-(this.legendBorderRect.y))) + ' )');
        treemap.svgObject.appendChild(this.legendGroup);
    };
    TreeMapLegend.prototype.renderLegendTitle = function () {
        var treemap = this.treemap;
        var legend = treemap.legendSettings;
        var textStyle = legend.titleStyle;
        var legendTitle = legend.title.text;
        var textOptions;
        var spacing = 10;
        var trimTitle = textTrim((this.legendItemRect.width + (spacing * 2)), legendTitle, textStyle);
        var textSize = measureText(trimTitle, textStyle);
        if (legendTitle) {
            textOptions = new TextOption(treemap.element.id + '_LegendTitle', (this.legendItemRect.x) + (this.legendItemRect.width / 2), this.legendItemRect.y - (textSize.height / 2), 'middle', trimTitle, '');
            renderTextElement(textOptions, textStyle, textStyle.color, this.legendGroup);
        }
    };
    /**
     * To rendered the interactive pointer
     */
    TreeMapLegend.prototype.renderInteractivePointer = function (e) {
        var treemap = this.treemap;
        var target = e.target;
        var interactiveId = treemap.element.id + '_Interactive_Legend';
        target = !(e.type.indexOf('touch') > -1) ? target :
            document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
        var targetItem;
        var legend = treemap.legendSettings;
        if (target.id.indexOf('_Item_Index') > -1 && legend.visible && this.legendRenderingCollections.length > 0) {
            var currentData = void 0;
            var legendRect = void 0;
            var rect = void 0;
            var data = void 0;
            var fill = void 0;
            var stroke = void 0;
            var strokeWidth = void 0;
            var legendElement = void 0;
            targetItem = treemap.layout.renderItems[parseFloat(target.id.split('_')[6])];
            var svgRect = treemap.svgObject.getBoundingClientRect();
            for (var i = 0; i < this.legendCollections.length; i++) {
                currentData = this.legendCollections[i];
                legendElement = document.getElementById(treemap.element.id + '_Legend_Index_' + i);
                legendRect = legendElement.getBoundingClientRect();
                var rect_1 = new Rect(Math.abs(legendRect.left - svgRect.left), Math.abs(legendRect.top - svgRect.top), legendRect.width, legendRect.height);
                fill = legendElement.getAttribute('fill');
                stroke = legend.shapeBorder.color;
                strokeWidth = legend.shapeBorder.width;
                if (!isNullOrUndefined(currentData['legendData'])) {
                    data = currentData['legendData'];
                    for (var j = 0; j < data.length; j++) {
                        if (data[j]['levelOrderName'] === targetItem['levelOrderName']) {
                            this.drawInteractivePointer(legend, fill, stroke, interactiveId, strokeWidth, rect_1);
                            break;
                        }
                    }
                }
            }
        }
        else {
            this.removeInteractivePointer();
        }
    };
    TreeMapLegend.prototype.drawInteractivePointer = function (legend, fill, stroke, id, strokeWidth, rect) {
        var path;
        var pathOptions;
        var locX;
        var locY;
        var height = 10;
        var width = 10;
        var direction = (legend.orientation === 'None') ? (legend.position === 'Top' || legend.position === 'Bottom')
            ? 'Horizontal' : 'Vertical' : legend.orientation;
        if (direction === 'Horizontal') {
            if (!legend.invertedPointer) {
                locX = rect.x + (rect.width / 2);
                locY = rect.y;
                path = ' M ' + locX + ' ' + locY + ' L ' + (locX - width) + ' ' + (locY - height) +
                    ' L ' + (locX + width) + ' ' + (locY - height) + ' Z ';
            }
            else {
                locX = rect.x + (rect.width / 2);
                locY = rect.y + (rect.height);
                path = ' M ' + locX + ' ' + locY + ' L ' + (locX - width) + ' ' + (locY + height) +
                    ' L ' + (locX + width) + ' ' + (locY + height) + ' Z ';
            }
        }
        else {
            if (!legend.invertedPointer) {
                locX = rect.x + (rect.width);
                locY = rect.y + (rect.height / 2);
                path = ' M ' + locX + ' ' + locY + ' L ' + (locX + width) + ' ' + (locY - height) +
                    ' L ' + (locX + width) + ' ' + (locY + height) + ' z ';
            }
            else {
                locX = rect.x;
                locY = rect.y + (rect.height / 2);
                path = ' M ' + locX + ' ' + locY + ' L ' + (locX - width) + ' ' + (locY - height) +
                    ' L ' + (locX - width) + ' ' + (locY + height) + ' z ';
            }
        }
        pathOptions = new PathOption(id, fill, strokeWidth, stroke, 1, '', path);
        this.treemap.svgObject.appendChild(this.treemap.renderer.drawPath(pathOptions));
    };
    TreeMapLegend.prototype.getLegendAlignment = function (treemap, width, height, legend) {
        var x;
        var y;
        var spacing = 10;
        var areaX = treemap.areaRect.x;
        var areaY = treemap.areaRect.y;
        var areaHeight = treemap.areaRect.height;
        var areaWidth = treemap.areaRect.width;
        var totalWidth = treemap.availableSize.width;
        var totalHeight = treemap.availableSize.height;
        if (legend.position === 'Float') {
            this.translate = legend.location;
        }
        else {
            switch (legend.position) {
                case 'Top':
                case 'Bottom':
                    treemap.areaRect.height = (areaHeight - height);
                    x = (totalWidth / 2) - (width / 2);
                    y = (legend.position === 'Top') ? areaY : (areaY + treemap.areaRect.height);
                    treemap.areaRect.y = (legend.position === 'Top') ? areaY + height + spacing : areaY;
                    break;
                case 'Left':
                case 'Right':
                    treemap.areaRect.width = (areaWidth - width);
                    x = (legend.position === 'Left') ? areaX : areaX + treemap.areaRect.width;
                    y = (totalHeight / 2) - (height / 2);
                    treemap.areaRect.x = (legend.position === 'Left') ? areaX + width : areaX;
                    break;
            }
            switch (legend.alignment) {
                case 'Near':
                    if (legend.position === 'Top' || legend.position === 'Bottom') {
                        x = treemap.areaRect.x;
                    }
                    else {
                        y = treemap.areaRect.y;
                    }
                    break;
                case 'Far':
                    if (legend.position === 'Top' || legend.position === 'Bottom') {
                        x = totalWidth - width;
                    }
                    else {
                        y = totalHeight - height;
                    }
                    break;
            }
            this.translate = new Location(x, y);
        }
    };
    TreeMapLegend.prototype.mouseUpHandler = function (e) {
        this.renderInteractivePointer(e);
        clearTimeout(this.clearTimeout);
        this.clearTimeout = setTimeout(this.removeInteractivePointer.bind(this), 3000);
    };
    /**
     * To remove the interactive pointer
     */
    TreeMapLegend.prototype.removeInteractivePointer = function () {
        if (document.getElementById(this.treemap.element.id + '_Interactive_Legend')) {
            document.getElementById(this.treemap.element.id + '_Interactive_Legend').remove();
        }
    };
    /**
     * To change the next page
     */
    TreeMapLegend.prototype.changeNextPage = function (e) {
        this.currentPage = (e.target.id.indexOf('_Left_Page_') > -1) ? (this.currentPage - 1) :
            (this.currentPage + 1);
        this.drawLegend();
    };
    /**
     * Wire events for event handler
     */
    TreeMapLegend.prototype.wireEvents = function (element) {
        EventHandler.add(element, Browser.touchStartEvent, this.changeNextPage, this);
    };
    /**
     * To add the event listener
     */
    TreeMapLegend.prototype.addEventListener = function () {
        if (this.treemap.isDestroyed) {
            return;
        }
        this.treemap.on(Browser.touchMoveEvent, this.renderInteractivePointer, this);
        this.treemap.on(Browser.touchEndEvent, this.mouseUpHandler, this);
    };
    /**
     * To remove the event listener
     */
    TreeMapLegend.prototype.removeEventListener = function () {
        if (this.treemap.isDestroyed) {
            return;
        }
        this.treemap.off(Browser.touchMoveEvent, this.renderInteractivePointer);
        this.treemap.off(Browser.touchEndEvent, this.mouseUpHandler);
    };
    /**
     * Get module name.
     */
    TreeMapLegend.prototype.getModuleName = function () {
        return 'treeMapLegend';
    };
    /**
     * To destroy the legend.
     * @return {void}
     * @private
     */
    TreeMapLegend.prototype.destroy = function (treemap) {
        /**
         * Destroy method performed here
         */
        this.removeEventListener();
    };
    return TreeMapLegend;
}());
export { TreeMapLegend };
