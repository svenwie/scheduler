/**
 * Tree Map Component
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Component, NotifyPropertyChanges, Property, extend, Ajax } from '@syncfusion/ej2-base';
import { Complex, Collection } from '@syncfusion/ej2-base';
import { Event, Internationalization } from '@syncfusion/ej2-base';
import { SvgRenderer, isNullOrUndefined, createElement, EventHandler, Browser, remove } from '@syncfusion/ej2-base';
import { Border, Margin, TitleSettings, LegendSettings, InitialDrillSettings } from './model/base';
import { SelectionSettings, TooltipSettings, LevelSettings, LeafItemSettings, HighlightSettings, } from './model/base';
import { Size, stringToNumber, RectOption, Rect, textTrim, measureText, findChildren, removeClassNames } from '../treemap/utils/helper';
import { findPosition, TextOption, renderTextElement, isContainsData, TreeMapAjax } from '../treemap/utils/helper';
import { load, loaded, drillStart, drillEnd } from '../treemap/model/constants';
import { itemClick, itemMove, click, mouseMove, resize } from '../treemap/model/constants';
import { LayoutPanel } from './layout/render-panel';
import { ExportUtils } from '../treemap/utils/export';
import { DataManager, Query } from '@syncfusion/ej2-data';
/**
 * Represents the TreeMap control.
 * ```html
 * <div id="container"/>
 * <script>
 *   var treemap = new TreeMap();
 *   treemap.appendTo("#container");
 * </script>
 * ```
 */
var TreeMap = /** @class */ (function (_super) {
    __extends(TreeMap, _super);
    /**s
     * Constructor for TreeMap component.
     */
    function TreeMap(options, element) {
        var _this = _super.call(this, options, element) || this;
        /** @private */
        _this.orientation = 'Horizontal';
        /** @private */
        _this.drilledItems = [];
        /** @private */
        _this.isHierarchicalData = false;
        return _this;
    }
    TreeMap.prototype.preRender = function () {
        this.trigger(load, { treemap: this });
        this.initPrivateVariable();
        this.unWireEVents();
        this.createSvg();
        this.wireEVents();
        this.setCulture();
    };
    TreeMap.prototype.render = function () {
        this.themeEffect();
        this.createSecondaryElement();
        this.addTabIndex();
        this.renderBorder();
        this.renderTitle(this.titleSettings, 'title', null, null);
        this.processDataManager();
    };
    /* tslint:disable:no-string-literal */
    /* tslint:disable:no-eval */
    TreeMap.prototype.processDataManager = function () {
        var _this = this;
        var dataModule;
        var queryModule;
        var ajaxModule;
        var localAjax;
        if (this.dataSource instanceof DataManager) {
            dataModule = this.dataSource;
            queryModule = this.query instanceof Query ? this.query : new Query();
            var dataManager = dataModule.executeQuery(queryModule);
            dataManager.then(function (e) {
                _this.dataSource = e['result'];
                _this.renderTreeMapElements();
            });
        }
        else if (this.dataSource instanceof TreeMapAjax) {
            localAjax = this.dataSource;
            ajaxModule = new Ajax(localAjax.dataOptions, localAjax.type, localAjax.async, localAjax.contentType);
            ajaxModule.onSuccess = function (args) {
                _this.dataSource = JSON.parse('[' + args + ']')[0];
                _this.renderTreeMapElements();
            };
            ajaxModule.send(localAjax.sendData);
        }
        else {
            this.renderTreeMapElements();
        }
    };
    TreeMap.prototype.renderTreeMapElements = function () {
        this.processingData();
        if (this.treeMapLegendModule && this.legendSettings.visible) {
            this.treeMapLegendModule.renderLegend();
        }
        this.layout.processLayoutPanel();
        this.element.appendChild(this.svgObject);
        this.elementChange();
        this.trigger(loaded, { treemap: this });
    };
    TreeMap.prototype.createSvg = function () {
        if (this.svgObject) {
            while (this.svgObject.childNodes.length > 0) {
                this.svgObject.removeChild(this.svgObject.firstChild);
            }
            if (!this.svgObject.hasChildNodes() && this.svgObject.parentNode) {
                remove(this.svgObject);
            }
        }
        var containerWidth = this.element.clientWidth;
        var containerHeight = this.element.clientHeight;
        this.availableSize = new Size(stringToNumber(this.width, containerWidth) || containerWidth || 600, stringToNumber(this.height, containerHeight) || containerHeight || 450);
        this.svgObject = this.renderer.createSvg({
            id: this.element.id + '_svg',
            width: this.availableSize.width,
            height: this.availableSize.height
        });
    };
    /**
     * To initilize the private varibales of treemap.
     */
    TreeMap.prototype.initPrivateVariable = function () {
        this.renderer = new SvgRenderer(this.element.id);
        this.layout = new LayoutPanel(this);
    };
    /**
     * To change font styles of map based on themes
     */
    TreeMap.prototype.themeEffect = function () {
        switch (this.theme) {
            case 'Material':
            case 'Bootstrap':
            case 'Fabric':
                this.setTextStyle('#424242');
                break;
            case 'Highcontrast':
                this.setTextStyle('#FFFFFF');
                break;
        }
    };
    TreeMap.prototype.setTextStyle = function (color) {
        this.titleSettings.textStyle.color = this.titleSettings.textStyle.color || color;
        this.titleSettings.subtitleSettings.textStyle.color = this.titleSettings.subtitleSettings.textStyle.color || color;
        this.legendSettings.textStyle.color = this.legendSettings.textStyle.color || color;
        this.legendSettings.titleStyle.color = this.legendSettings.titleStyle.color || color;
    };
    TreeMap.prototype.createSecondaryElement = function () {
        var secondaryEle = document.getElementById(this.element.id + '_Secondary_Element');
        if (secondaryEle && secondaryEle.childElementCount > 0) {
            secondaryEle.remove();
        }
        if (isNullOrUndefined(document.getElementById(this.element.id + '_Secondary_Element'))) {
            var secondaryElement = createElement('div', {
                id: this.element.id + '_Secondary_Element',
                styles: 'position: absolute;z-index:1;'
            });
            this.element.appendChild(secondaryElement);
        }
    };
    TreeMap.prototype.elementChange = function () {
        if (this.treeMapLegendModule && this.legendSettings.visible && this.treeMapLegendModule.legendGroup && this.layout.layoutGroup) {
            this.svgObject.insertBefore(this.layout.layoutGroup, this.treeMapLegendModule.legendGroup);
        }
    };
    /**
     * @private
     * Render the treemap border
     */
    TreeMap.prototype.renderBorder = function () {
        var width = this.border.width;
        var color = this.theme === 'Highcontrast' ? '#000000' : '#FFFFFF';
        this.background = this.background ? this.background : color;
        var borderElement = document.getElementById(this.element.id + '_TreeMap_Border');
        if (isNullOrUndefined(borderElement)) {
            var borderRect = new RectOption(this.element.id + '_TreeMap_Border', this.background, this.border, 1, new Rect(width / 2, width / 2, this.availableSize.width - width, this.availableSize.height - width));
            this.svgObject.appendChild(this.renderer.drawRectangle(borderRect));
        }
        else {
            borderElement.setAttribute('fill', this.background);
        }
    };
    TreeMap.prototype.renderTitle = function (title, type, bounds, groupEle) {
        var style = title.textStyle;
        var height;
        var titlePadding = 10;
        var width = (this.availableSize.width - this.margin.right - this.margin.left);
        if (title.text) {
            if (isNullOrUndefined(groupEle)) {
                groupEle = this.renderer.createGroup({ id: this.element.id + '_Title_Group' });
            }
            var trimmedTitle = textTrim(width, title.text, style);
            var elementSize = measureText(trimmedTitle, style);
            var rect = (isNullOrUndefined(bounds)) ? new Rect(this.margin.left, this.margin.top, this.availableSize.width, this.availableSize.height) : bounds;
            var location_1 = findPosition(rect, title.alignment, elementSize, type);
            var options = new TextOption(this.element.id + '_TreeMap_' + type, location_1.x, location_1.y, 'start', trimmedTitle);
            var titleBounds = new Rect(location_1.x, location_1.y, elementSize.width, elementSize.height);
            var element = renderTextElement(options, style, style.color, groupEle);
            element.setAttribute('aria-label', title.description || title.text);
            element.setAttribute('tabindex', (this.tabIndex + (type === 'title' ? 1 : 2)).toString());
            if ((type === 'title' && !title.subtitleSettings.text) || (type === 'subtitle')) {
                height = (this.availableSize.height - titleBounds.y - titlePadding - this.margin.bottom);
                this.areaRect = new Rect(this.margin.left, titleBounds.y + titlePadding, width, height);
            }
            if (type !== 'subtitle' && title.subtitleSettings.text) {
                this.renderTitle(title.subtitleSettings, 'subtitle', titleBounds, groupEle);
            }
            else {
                this.svgObject.appendChild(groupEle);
            }
        }
        else {
            height = (this.availableSize.height - this.margin.top - this.margin.bottom);
            this.areaRect = new Rect(this.margin.left, this.margin.top, width, height);
        }
    };
    TreeMap.prototype.processingData = function () {
        var _this = this;
        var path;
        this.dataSource = this.dataSource;
        if (!isNullOrUndefined(this.dataSource) && this.dataSource.length > 0 && this.weightValuePath) {
            this.levelsOfData = [];
            this.dataSource.map(function (data) {
                data[_this.weightValuePath] = (data[_this.weightValuePath]) ? data[_this.weightValuePath].toString() :
                    data[_this.weightValuePath];
            });
            this.leafItemSettings.labelPath = this.leafItemSettings.labelPath || this.weightValuePath;
            this.checkIsHierarchicalData();
            if (this.levels.length === 0) {
                var data_1 = new Object();
                data_1['level'] = 0;
                path = this.leafItemSettings.labelPath;
                data_1[path] = [];
                for (var i = 0; i < this.dataSource.length; i++) {
                    var child = findChildren(this.dataSource[i])['values'];
                    if (this.isHierarchicalData && child && child.length > 0) {
                        child.forEach(function (currentData, dataIndex) {
                            if (currentData[path]) {
                                data_1[path].push({
                                    groupIndex: 0, name: currentData[path], levelOrderName: currentData[path].toString(),
                                    data: currentData, weight: currentData[_this.weightValuePath]
                                });
                            }
                        });
                    }
                    else {
                        if (this.dataSource[i][path]) {
                            data_1[path].push({
                                groupIndex: 0, name: this.dataSource[i][path], levelOrderName: this.dataSource[i][path].toString(), data: this.dataSource[i],
                                weight: this.dataSource[i][this.weightValuePath]
                            });
                        }
                    }
                }
                this.levelsOfData.push(data_1);
            }
            else {
                if (this.isHierarchicalData) {
                    this.hierarchyData = [];
                    this.hierarchyData = extend([], this.dataSource, this.hierarchyData, true);
                    for (var i = 0; i < this.hierarchyData.length; i++) {
                        this.processHierarchicalData(this.hierarchyData[i], i);
                    }
                    this.levelsOfData = this.hierarchyData;
                }
                else {
                    this.processFlatJsonData();
                    if (this.levelsOfData.length > 1) {
                        this.reOrderLevelData(this.levelsOfData.length - 1);
                    }
                }
                path = this.levels[0].groupPath;
            }
            if (!this.isHierarchicalData) {
                this.findTotalWeight(this.levelsOfData[0][path], 'Parent');
            }
        }
    };
    TreeMap.prototype.checkIsHierarchicalData = function () {
        var child;
        this.dataSource = this.dataSource;
        for (var i = 0; i < this.dataSource.length; i++) {
            child = findChildren(this.dataSource[i])['values'];
            if (child && child.length) {
                this.isHierarchicalData = true;
                break;
            }
            else if (i === this.dataSource.length - 1) {
                this.isHierarchicalData = false;
            }
        }
    };
    TreeMap.prototype.processHierarchicalData = function (data, dataCount) {
        var _this = this;
        var childData;
        var levelData = [];
        var newData = new Object();
        var levelIndex;
        var path = this.leafItemSettings.labelPath ? this.leafItemSettings.labelPath : this.weightValuePath;
        var currentData = new Object();
        var level;
        var key;
        newData = findChildren(data);
        childData = newData ? newData['values'] : null;
        if (childData && childData.length > 0) {
            key = newData['key'];
            for (var i = 0; i < this.levels.length; i++) {
                if (key === this.levels[i].groupPath) {
                    level = this.levels[i];
                    levelIndex = i;
                }
            }
            for (var j = 0; j < childData.length; j++) {
                childData[j]['name'] = childData[j][path];
                childData[j]['levelOrderName'] = (levelIndex === 0 ? childData[j]['name'] :
                    data['levelOrderName'] + '_' + childData[j]['name']) + '';
                childData[j]['groupIndex'] = isNullOrUndefined(levelIndex) ? this.levels.length : levelIndex;
                if (levelIndex !== 0) {
                    childData[j]['parent'] = data;
                }
                childData[j]['groupName'] = key;
                childData[j]['data'] = childData[j];
                childData[j]['isDrilled'] = false;
                childData[j]['weight'] = childData[j][this.weightValuePath];
            }
            childData.forEach(function (currentData) {
                _this.processHierarchicalData(currentData, dataCount);
            });
        }
        if (dataCount === this.hierarchyData.length - 1) {
            var mainData_1 = this.hierarchyData[0][this.levels[0].groupPath];
            for (var k = 0; k < this.hierarchyData.length; k++) {
                childData = findChildren(this.hierarchyData[k])['values'];
                if (k !== 0 && childData) {
                    childData.forEach(function (currentData) { mainData_1.push(currentData); });
                    this.hierarchyData.splice(k, 1);
                    k -= 1;
                }
            }
            mainData_1 = this.hierarchyData[0][this.levels[0].groupPath];
            for (var l = 0; l < mainData_1.length; l++) {
                newData[this.levels[0].groupPath] = mainData_1;
                mainData_1[l]['parent'] = newData;
            }
        }
    };
    /**
     * Handles the print method for chart control.
     */
    TreeMap.prototype.print = function (id) {
        var exportChart = new ExportUtils(this);
        exportChart.print(id);
    };
    /**
     * Handles the export method for chart control.
     * @param type
     * @param fileName
     */
    TreeMap.prototype.export = function (type, fileName, orientation) {
        var exportMap = new ExportUtils(this);
        exportMap.export(type, fileName, orientation);
    };
    /* tslint:disable:no-string-literal */
    TreeMap.prototype.processFlatJsonData = function () {
        this.dataSource = this.dataSource;
        var groupPath;
        var childGroupPath;
        var orderNames = [];
        var process = false;
        for (var i = 0; i < this.levels.length + 1; i++) {
            groupPath = this.levels[i] ? this.levels[i].groupPath : this.leafItemSettings.labelPath;
            var level = new Object();
            level['level'] = i;
            level[groupPath] = [];
            this.levelsOfData.push(level);
            for (var j = 0; j < this.dataSource.length; j++) {
                var currentData = {};
                var childName = '';
                if (this.dataSource[j][groupPath]) {
                    var name_1 = this.dataSource[j][groupPath];
                    if (i !== 0) {
                        for (var k = 0; k <= i; k++) {
                            var childGroupPath_1 = this.levels[k] ? this.levels[k].groupPath : groupPath;
                            childName += (this.dataSource[j][childGroupPath_1]) + ((k === i) ? '' : '_');
                        }
                    }
                    if (!(orderNames.length > 0 ? orderNames.indexOf(childName ?
                        childName : name_1) !== -1 : false)) {
                        currentData['name'] = name_1;
                        currentData['levelOrderName'] = ((childName) ? childName : name_1) + '';
                        currentData['groupIndex'] = i;
                        currentData['isDrilled'] = false;
                        currentData['groupName'] = groupPath;
                        currentData['data'] = this.dataSource[j];
                        this.levelsOfData[this.levelsOfData.length - 1][groupPath].push(currentData);
                        orderNames.push((childName) ? childName : name_1);
                    }
                }
            }
        }
    };
    TreeMap.prototype.reOrderLevelData = function (start) {
        var currentName;
        var currentPath = this.levels[start] ? this.levels[start].groupPath : this.leafItemSettings.labelPath;
        var prevPath = this.levels[start - 1].groupPath;
        var currentData = this.levelsOfData[start][currentPath];
        var previousData = this.levelsOfData[start - 1][prevPath];
        for (var i = 0; i < currentData.length; i++) {
            currentName = currentData[i]['levelOrderName'];
            for (var j = 0; j < previousData.length; j++) {
                previousData[j][currentPath] = isNullOrUndefined(previousData[j][currentPath]) ? [] : previousData[j][currentPath];
                if (currentName.indexOf(previousData[j]['levelOrderName']) !== -1) {
                    if (isNullOrUndefined(currentData[i]['parent'])) {
                        currentData[i]['parent'] = previousData[j];
                    }
                    previousData[j][currentPath].push(currentData[i]);
                    break;
                }
            }
        }
        this.findTotalWeight(this.levelsOfData[this.levelsOfData.length - 1][currentPath], 'Child');
        this.levelsOfData.splice(start, 1);
        if ((start - 1) > 0) {
            this.reOrderLevelData(start - 1);
        }
    };
    TreeMap.prototype.findTotalWeight = function (processData, type) {
        var _this = this;
        var totalWeight;
        var childData;
        var levelName;
        var start = 0;
        var split;
        var groupName;
        var groupObj = new Object();
        var _loop_1 = function (i) {
            totalWeight = 0;
            groupName = processData[i]['groupName'];
            split = processData[i]['levelOrderName'].split('_');
            this_1.dataSource.forEach(function (data) {
                if (isContainsData(split, processData[i]['levelOrderName'], data, _this)) {
                    totalWeight += parseFloat(data[_this.weightValuePath]);
                }
            });
            if (type === 'Parent') {
                groupObj[groupName] = processData;
                processData[i]['parent'] = groupObj;
            }
            processData[i]['weight'] = totalWeight;
        };
        var this_1 = this;
        for (var i = 0; i < processData.length; i++) {
            _loop_1(i);
        }
    };
    /**
     * To unbind event handlers for treemap.
     */
    TreeMap.prototype.unWireEVents = function () {
        EventHandler.remove(this.element, 'click', this.clickOnTreeMap);
        // EventHandler.remove(this.element, 'dblclick', this.doubleClick);
        EventHandler.remove(this.element, Browser.touchStartEvent, this.mouseDownOnTreeMap);
        EventHandler.remove(this.element, Browser.touchMoveEvent, this.mouseMoveOnTreeMap);
        EventHandler.remove(this.element, Browser.touchEndEvent, this.mouseEndOnTreeMap);
        EventHandler.remove(this.element, 'pointerleave mouseleave', this.mouseLeaveOnTreeMap);
        window.removeEventListener('resize', this.resizeOnTreeMap);
    };
    /**
     * To bind event handlers for treemap.
     */
    TreeMap.prototype.wireEVents = function () {
        EventHandler.add(this.element, 'click', this.clickOnTreeMap, this);
        //EventHandler.add(this.element, 'dblclick', this.doubleClick, this);
        EventHandler.add(this.element, Browser.touchStartEvent, this.mouseDownOnTreeMap, this);
        EventHandler.add(this.element, Browser.touchMoveEvent, this.mouseMoveOnTreeMap, this);
        EventHandler.add(this.element, Browser.touchEndEvent, this.mouseEndOnTreeMap, this);
        EventHandler.add(this.element, 'pointerleave mouseleave', this.mouseLeaveOnTreeMap, this);
        window.addEventListener('resize', this.resizeOnTreeMap.bind(this));
    };
    /**
     * Method to set culture for maps
     */
    TreeMap.prototype.setCulture = function () {
        this.intl = new Internationalization();
    };
    /**
     * To add tab index for treemap element
     */
    TreeMap.prototype.addTabIndex = function () {
        this.element.setAttribute('aria-label', this.description || 'TreeMap Element');
        this.element.setAttribute('tabindex', this.tabIndex.toString());
    };
    /**
     * To handle the window resize event on treemap.
     */
    TreeMap.prototype.resizeOnTreeMap = function (e) {
        var _this = this;
        var args = {
            name: resize,
            cancel: false,
            previousSize: this.availableSize,
            currentSize: new Size(0, 0),
            treemap: this
        };
        if (this.resizeTo) {
            clearTimeout(this.resizeTo);
        }
        if (this.element.classList.contains('e-treemap')) {
            this.resizeTo = setTimeout(function () {
                _this.unWireEVents();
                _this.createSvg();
                _this.refreshing = true;
                _this.wireEVents();
                args.currentSize = _this.availableSize;
                _this.trigger(resize, args);
                _this.render();
            }, 500);
        }
    };
    TreeMap.prototype.clickOnTreeMap = function (e) {
        var targetEle = e.target;
        var targetId = targetEle.id;
        var eventArgs;
        var itemIndex;
        var clickArgs = { cancel: false, name: click, treemap: this, mouseEvent: e };
        this.trigger(click, clickArgs);
        if (targetId.indexOf('_Item_Index') > -1) {
            e.preventDefault();
            itemIndex = parseFloat(targetId.split('_')[6]);
            eventArgs = { cancel: false, name: itemClick, treemap: this, item: this.layout.renderItems[itemIndex], mouseEvent: e };
            this.trigger(itemClick, eventArgs);
        }
    };
    /* tslint:disable-next-line:max-func-body-length */
    TreeMap.prototype.mouseDownOnTreeMap = function (e) {
        var targetEle = e.target;
        var startEvent;
        var endEvent;
        var targetId = targetEle.id;
        var totalRect;
        var index;
        var newDrillItem = new Object();
        var item;
        var process = true;
        var layoutID = this.element.id + '_TreeMap_' + this.layoutType + '_Layout';
        if (targetId.indexOf('_Item_Index') > -1 && this.enableDrillDown) {
            e.preventDefault();
            index = parseFloat(targetId.split('_')[6]);
            item = this.layout.renderItems[index];
            if (this.levels.length !== 0 && !item['isLeafItem'] && findChildren(item)['values'] &&
                findChildren(item)['values'].length > 0) {
                if (this.drilledItems.length > 0) {
                    for (var i = 0; i < this.drilledItems.length; i++) {
                        if (item['levelOrderName'] === this.drilledItems[i]['name']) {
                            if (item['groupIndex'] === 0 && item['parent'][item['groupName']] instanceof Array) {
                                item['isDrilled'] = !(item['isDrilled']);
                                if (!item['isDrilled']) {
                                    newDrillItem = item['parent'];
                                }
                                else {
                                    newDrillItem[item['groupName']] = [item];
                                }
                            }
                            else {
                                item['isDrilled'] = false;
                                item['parent']['isDrilled'] = true;
                                item = item['parent'];
                                newDrillItem[item['groupName']] = [item];
                            }
                            this.drilledItems.splice(i, 1);
                            i -= 1;
                            break;
                        }
                        else if (i === this.drilledItems.length - 1) {
                            item['isDrilled'] = true;
                            newDrillItem[item['groupName']] = [item];
                        }
                    }
                }
                else {
                    item['isDrilled'] = true;
                    newDrillItem[item['groupName']] = [item];
                }
                startEvent = { cancel: false, name: drillStart, treemap: this, item: newDrillItem, element: targetEle };
                this.trigger(drillStart, startEvent);
                if (!startEvent.cancel) {
                    if (document.getElementById(layoutID)) {
                        document.getElementById(layoutID).remove();
                    }
                    totalRect = extend({}, this.areaRect, totalRect, true);
                    this.layout.calculateLayoutItems(newDrillItem, totalRect);
                    this.layout.renderLayoutItems(newDrillItem);
                }
                endEvent = { cancel: false, name: drillEnd, treemap: this, renderItems: this.layout.renderItems };
                this.trigger(drillEnd, endEvent);
                if (process) {
                    this.drilledItems.push({ name: item['levelOrderName'], data: item });
                }
            }
        }
        this.notify(Browser.touchStartEvent, e);
    };
    TreeMap.prototype.mouseMoveOnTreeMap = function (e) {
        var targetEle = e.target;
        var targetId = targetEle.id;
        var eventArgs;
        var item;
        var moveArgs = { cancel: false, name: mouseMove, treemap: this, mouseEvent: e };
        this.trigger(mouseMove, moveArgs);
        var childItems;
        if (targetId.indexOf('_Item_Index') > -1) {
            item = this.layout.renderItems[parseFloat(targetId.split('_')[6])];
            childItems = findChildren(item)['values'];
            this.element.style.cursor = (!item['isLeafItem'] && childItems && childItems.length > 0 && this.enableDrillDown) ?
                'pointer' : 'auto';
            eventArgs = { cancel: false, name: itemMove, treemap: this, item: item, mouseEvent: e };
            this.trigger(itemMove, eventArgs);
        }
        this.notify(Browser.touchMoveEvent, e);
    };
    TreeMap.prototype.mouseEndOnTreeMap = function (e) {
        this.notify(Browser.touchEndEvent, e);
    };
    TreeMap.prototype.mouseLeaveOnTreeMap = function (e) {
        if (this.treeMapTooltipModule) {
            this.treeMapTooltipModule.removeTooltip();
        }
        if (this.treeMapLegendModule) {
            this.treeMapLegendModule.removeInteractivePointer();
        }
        removeClassNames(document.getElementsByClassName('treeMapHighLight'), 'treeMapHighLight', this);
    };
    /**
     * To provide the array of modules needed for maps rendering
     * @return {ModuleDeclaration[]}
     * @private
     */
    TreeMap.prototype.requiredModules = function () {
        var modules = [];
        if (this.tooltipSettings.visible) {
            modules.push({
                member: 'treeMapTooltip',
                args: [this]
            });
        }
        if (this.highlightSettings.enable) {
            modules.push({
                member: 'treeMapHighlight',
                args: [this]
            });
        }
        if (this.selectionSettings.enable) {
            modules.push({
                member: 'treeMapSelection',
                args: [this]
            });
        }
        if (this.legendSettings.visible) {
            modules.push({
                member: 'treeMapLegend',
                args: [this]
            });
        }
        return modules;
    };
    TreeMap.prototype.onPropertyChanged = function (newProp, oldProp) {
        var render = false;
        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
            var prop = _a[_i];
            switch (prop) {
                case 'background':
                    this.renderBorder();
                    break;
                case 'height':
                case 'width':
                    render = true;
                    break;
            }
        }
        if (render) {
            this.createSvg();
            this.render();
        }
    };
    /**
     * Get component name
     */
    TreeMap.prototype.getModuleName = function () {
        return 'treemap';
    };
    /**
     * To destroy the treemap control.
     */
    TreeMap.prototype.destroy = function () {
        this.unWireEVents();
        _super.prototype.destroy.call(this);
    };
    /**
     * Get the properties to be maintained in the persisted state.
     * @private
     */
    TreeMap.prototype.getPersistData = function () {
        return '';
    };
    __decorate([
        Property(null)
    ], TreeMap.prototype, "width", void 0);
    __decorate([
        Property(null)
    ], TreeMap.prototype, "height", void 0);
    __decorate([
        Complex({}, Border)
    ], TreeMap.prototype, "border", void 0);
    __decorate([
        Complex({}, Margin)
    ], TreeMap.prototype, "margin", void 0);
    __decorate([
        Property(null)
    ], TreeMap.prototype, "background", void 0);
    __decorate([
        Property('Material')
    ], TreeMap.prototype, "theme", void 0);
    __decorate([
        Complex({}, TitleSettings)
    ], TreeMap.prototype, "titleSettings", void 0);
    __decorate([
        Property('Squarified')
    ], TreeMap.prototype, "layoutType", void 0);
    __decorate([
        Property(null)
    ], TreeMap.prototype, "dataSource", void 0);
    __decorate([
        Property(null)
    ], TreeMap.prototype, "query", void 0);
    __decorate([
        Property(null)
    ], TreeMap.prototype, "weightValuePath", void 0);
    __decorate([
        Property('')
    ], TreeMap.prototype, "rangeColorValuePath", void 0);
    __decorate([
        Property('')
    ], TreeMap.prototype, "equalColorValuePath", void 0);
    __decorate([
        Property([])
    ], TreeMap.prototype, "palette", void 0);
    __decorate([
        Property(false)
    ], TreeMap.prototype, "enableDrillDown", void 0);
    __decorate([
        Complex({}, InitialDrillSettings)
    ], TreeMap.prototype, "initialDrillDown", void 0);
    __decorate([
        Complex({}, LeafItemSettings)
    ], TreeMap.prototype, "leafItemSettings", void 0);
    __decorate([
        Collection([], LevelSettings)
    ], TreeMap.prototype, "levels", void 0);
    __decorate([
        Complex({}, HighlightSettings)
    ], TreeMap.prototype, "highlightSettings", void 0);
    __decorate([
        Complex({}, SelectionSettings)
    ], TreeMap.prototype, "selectionSettings", void 0);
    __decorate([
        Complex({}, TooltipSettings)
    ], TreeMap.prototype, "tooltipSettings", void 0);
    __decorate([
        Complex({}, LegendSettings)
    ], TreeMap.prototype, "legendSettings", void 0);
    __decorate([
        Property(false)
    ], TreeMap.prototype, "useGroupingSeparator", void 0);
    __decorate([
        Property(null)
    ], TreeMap.prototype, "description", void 0);
    __decorate([
        Property(1)
    ], TreeMap.prototype, "tabIndex", void 0);
    __decorate([
        Property(null)
    ], TreeMap.prototype, "format", void 0);
    __decorate([
        Event()
    ], TreeMap.prototype, "load", void 0);
    __decorate([
        Event()
    ], TreeMap.prototype, "beforePrint", void 0);
    __decorate([
        Event()
    ], TreeMap.prototype, "loaded", void 0);
    __decorate([
        Event()
    ], TreeMap.prototype, "itemRendering", void 0);
    __decorate([
        Event()
    ], TreeMap.prototype, "drillStart", void 0);
    __decorate([
        Event()
    ], TreeMap.prototype, "drillEnd", void 0);
    __decorate([
        Event()
    ], TreeMap.prototype, "itemSelected", void 0);
    __decorate([
        Event()
    ], TreeMap.prototype, "itemHighlight", void 0);
    __decorate([
        Event()
    ], TreeMap.prototype, "tooltipRendering", void 0);
    __decorate([
        Event()
    ], TreeMap.prototype, "itemClick", void 0);
    __decorate([
        Event()
    ], TreeMap.prototype, "itemMove", void 0);
    __decorate([
        Event()
    ], TreeMap.prototype, "click", void 0);
    __decorate([
        Event()
    ], TreeMap.prototype, "mouseMove", void 0);
    __decorate([
        Event()
    ], TreeMap.prototype, "resize", void 0);
    TreeMap = __decorate([
        NotifyPropertyChanges
    ], TreeMap);
    return TreeMap;
}(Component));
export { TreeMap };
