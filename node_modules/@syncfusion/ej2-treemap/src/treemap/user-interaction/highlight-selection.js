import { Browser } from '@syncfusion/ej2-base';
import { itemHighlight, itemSelected } from '../model/constants';
import { findHightLightItems, removeClassNames, applyOptions } from '../utils/helper';
/**
 * Performing treemap highlight
 */
var TreeMapHighlight = /** @class */ (function () {
    function TreeMapHighlight(treeMap) {
        this.treemap = treeMap;
        this.addEventListener();
    }
    /* tslint:disable:no-string-literal */
    TreeMapHighlight.prototype.mouseMove = function (e) {
        var treemap = this.treemap;
        var processHighlight;
        var targetId = e.target.id;
        var eventArgs;
        var items = [];
        var highlight = this.treemap.highlightSettings;
        var item;
        var highLightElements = [];
        var process;
        var treeMapElement;
        var element;
        var orders;
        if (targetId.indexOf('_Item_Index') > -1) {
            if (this.highLightId !== targetId) {
                treeMapElement = document.getElementById(treemap.element.id + '_TreeMap_' + treemap.layoutType + '_Layout');
                var selectionElements = document.getElementsByClassName('treeMapSelection');
                item = this.treemap.layout.renderItems[parseFloat(targetId.split('_')[6])];
                orders = findHightLightItems(item, [], highlight.mode, treemap);
                for (var i = 0; i < treeMapElement.childElementCount; i++) {
                    element = treeMapElement.childNodes[i];
                    process = true;
                    item = treemap.layout.renderItems[element.id.split('_')[6]];
                    for (var j = 0; j < selectionElements.length; j++) {
                        if (element.id === selectionElements[j].id) {
                            process = false;
                            break;
                        }
                    }
                    if (orders.indexOf(item['levelOrderName']) > -1 && process) {
                        highLightElements.push(element);
                        items.push(item);
                    }
                }
                removeClassNames(document.getElementsByClassName('treeMapHighLight'), 'treeMapHighLight', treemap);
                for (var k = 0; k < highLightElements.length; k++) {
                    element = highLightElements[k];
                    applyOptions(element.childNodes[0], { border: highlight.border, fill: highlight.fill, opacity: highlight.opacity });
                    element.classList.add('treeMapHighLight');
                    this.highLightId = targetId;
                }
                eventArgs = { cancel: false, name: itemHighlight, treemap: treemap, items: items, elements: highLightElements };
                treemap.trigger(itemHighlight, eventArgs);
            }
            else {
                processHighlight = false;
            }
        }
        else {
            removeClassNames(document.getElementsByClassName('treeMapHighLight'), 'treeMapHighLight', treemap);
            processHighlight = false;
        }
        return processHighlight;
    };
    /**
     * To bind events for highlight
     */
    TreeMapHighlight.prototype.addEventListener = function () {
        if (this.treemap.isDestroyed) {
            return;
        }
        this.treemap.on(Browser.touchMoveEvent, this.mouseMove, this);
    };
    /**
     * To unbind events for highlight
     */
    TreeMapHighlight.prototype.removeEventListener = function () {
        if (this.treemap.isDestroyed) {
            return;
        }
        this.treemap.off(Browser.touchMoveEvent, this.mouseMove);
    };
    /**
     * Get module name.
     */
    TreeMapHighlight.prototype.getModuleName = function () {
        return 'treeMapHighlight';
    };
    /**
     * To destroy the hightlight.
     * @return {void}
     * @private
     */
    TreeMapHighlight.prototype.destroy = function (treeMap) {
        this.removeEventListener();
    };
    return TreeMapHighlight;
}());
export { TreeMapHighlight };
/**
 * Performing treemap selection
 */
var TreeMapSelection = /** @class */ (function () {
    function TreeMapSelection(treeMap) {
        this.treemap = treeMap;
        this.addEventListener();
    }
    /* tslint:disable:no-string-literal */
    /**
     * Mouse down event in selection
     */
    TreeMapSelection.prototype.mouseDown = function (e) {
        var targetEle = e.target;
        var eventArgs;
        var treemap = this.treemap;
        var items = [];
        var targetId = targetEle.id;
        var item;
        var selectionElements = [];
        var opacity;
        var treeMapElement;
        var element;
        var orders;
        var selection = treemap.selectionSettings;
        var layoutID = treemap.element.id + '_TreeMap_' + treemap.layoutType + '_Layout';
        if (targetId.indexOf('_Item_Index') > -1) {
            e.preventDefault();
            if (this.selectionId !== targetId) {
                treeMapElement = document.getElementById(layoutID);
                item = treemap.layout.renderItems[parseFloat(targetId.split('_')[6])];
                orders = findHightLightItems(item, [], selection.mode, treemap);
                for (var i = 0; i < treeMapElement.childElementCount; i++) {
                    element = treeMapElement.childNodes[i];
                    item = treemap.layout.renderItems[element.id.split('_')[6]];
                    if (orders.indexOf(item['levelOrderName']) > -1) {
                        selectionElements.push(element);
                        items.push(item);
                    }
                }
                removeClassNames(document.getElementsByClassName('treeMapSelection'), 'treeMapSelection', treemap);
                this.selectionId = targetId;
                var highLightElements = document.getElementsByClassName('treeMapHighLight');
                for (var k = 0; k < selectionElements.length; k++) {
                    element = selectionElements[k];
                    if (highLightElements.length > 0) {
                        for (var j = 0; j < highLightElements.length; j++) {
                            if (highLightElements[j].id === element.id) {
                                highLightElements[j].classList.remove('treeMapHighLight');
                            }
                            applyOptions(element.childNodes[0], { border: selection.border, fill: selection.fill, opacity: selection.opacity });
                            element.classList.add('treeMapSelection');
                        }
                    }
                    else {
                        applyOptions(element.childNodes[0], { border: selection.border, fill: selection.fill, opacity: selection.opacity });
                        element.classList.add('treeMapSelection');
                    }
                    eventArgs = { cancel: false, name: itemSelected, treemap: treemap, items: items, elements: selectionElements };
                    treemap.trigger(itemSelected, eventArgs);
                }
            }
            else {
                removeClassNames(document.getElementsByClassName('treeMapSelection'), 'treeMapSelection', treemap);
                this.selectionId = '';
            }
        }
        else {
            removeClassNames(document.getElementsByClassName('treeMapSelection'), 'treeMapSelection', treemap);
            this.selectionId = '';
        }
    };
    /**
     * To bind events for selection
     */
    TreeMapSelection.prototype.addEventListener = function () {
        if (this.treemap.isDestroyed) {
            return;
        }
        this.treemap.on(Browser.touchStartEvent, this.mouseDown, this);
    };
    /**
     * To unbind events for selection
     */
    TreeMapSelection.prototype.removeEventListener = function () {
        if (this.treemap.isDestroyed) {
            return;
        }
        this.treemap.off(Browser.touchStartEvent, this.mouseDown);
    };
    /**
     * Get module name.
     */
    TreeMapSelection.prototype.getModuleName = function () {
        return 'treeMapSelection';
    };
    /**
     * To destroy the selection.
     * @return {void}
     * @private
     */
    TreeMapSelection.prototype.destroy = function (treeMap) {
        this.removeEventListener();
    };
    return TreeMapSelection;
}());
export { TreeMapSelection };
