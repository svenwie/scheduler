import { IGrid, IAction, IIndex, ISelectedCell } from '../base/interface';
import { SelectionSettings } from '../base/grid';
import { ServiceLocator } from '../services/service-locator';
/**
 * The `Selection` module is used to handle cell and row selection.
 */
export declare class Selection implements IAction {
    /**
     * @hidden
     */
    selectedRowIndexes: number[];
    /**
     * @hidden
     */
    selectedRowCellIndexes: ISelectedCell[];
    /**
     * @hidden
     */
    selectedRecords: Element[];
    /**
     * @hidden
     */
    isRowSelected: boolean;
    /**
     * @hidden
     */
    isCellSelected: boolean;
    private selectionSettings;
    private prevRowIndex;
    private prevCIdxs;
    private prevECIdxs;
    private preventFocus;
    private selectedRowIndex;
    private isMultiShiftRequest;
    private isMultiCtrlRequest;
    private enableSelectMultiTouch;
    private element;
    private startIndex;
    private startCellIndex;
    private currentIndex;
    private isDragged;
    private isCellDrag;
    private x;
    private y;
    private target;
    private preSelectedCellIndex;
    private factory;
    private contentRenderer;
    private checkedTarget;
    private primaryKey;
    private chkField;
    private selectedRowState;
    private totalRecordsCount;
    private chkAllCollec;
    private isCheckedOnAdd;
    private persistSelectedData;
    private onDataBoundFunction;
    private actionBeginFunction;
    private actionCompleteFunction;
    private actionCompleteFunc;
    private parent;
    private focus;
    private isCancelDeSelect;
    private isPreventCellSelect;
    private disableUI;
    /**
     * Constructor for the Grid selection module
     * @hidden
     */
    constructor(parent?: IGrid, selectionSettings?: SelectionSettings, locator?: ServiceLocator);
    private initializeSelection();
    /**
     * The function used to trigger onActionBegin
     * @return {void}
     * @hidden
     */
    onActionBegin(args: Object, type: string): void;
    private fDataUpdate(args);
    /**
     * The function used to trigger onActionComplete
     * @return {void}
     * @hidden
     */
    onActionComplete(args: Object, type: string): void;
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
    /**
     * To destroy the selection
     * @return {void}
     * @hidden
     */
    destroy(): void;
    private isEditing();
    private getSelectedMovableRow(index);
    getCurrentBatchRecordChanges(): Object[];
    /**
     * Selects a row by the given index.
     * @param  {number} index - Defines the row index.
     * @param  {boolean} isToggle - If set to true, then it toggles the selection.
     * @return {void}
     */
    selectRow(index: number, isToggle?: boolean): void;
    private addMovableArgs(targetObj, mRow);
    /**
     * Selects a range of rows from start and end row indexes.
     * @param  {number} startIndex - Specifies the start row index.
     * @param  {number} endIndex - Specifies the end row index.
     * @return {void}
     */
    selectRowsByRange(startIndex: number, endIndex?: number): void;
    /**
     * Selects a collection of rows by index.
     * @param  {number[]} rowIndexes - Specifies an array of row indexes.
     * @return {void}
     */
    selectRows(rowIndexes: number[]): void;
    /**
     * Select rows with existing row selection by passing row indexes.
     * @param  {number} startIndex - Specifies the row indexes.
     * @return {void}
     * @hidden
     */
    addRowsToSelection(rowIndexes: number[]): void;
    private getCollectionFromIndexes(startIndex, endIndex);
    private clearRow();
    private updateRowProps(startIndex);
    private updatePersistCollection(selectedRow, chkState);
    private updatePersistDelete(pKey);
    private updateCheckBoxes(row, chkState?);
    private updateRowSelection(selectedRow, startIndex);
    /**
     * Deselects the currently selected rows and cells.
     * @return {void}
     */
    clearSelection(): void;
    /**
     * Deselects the currently selected rows.
     * @return {void}
     */
    clearRowSelection(): void;
    private rowDeselect(type, rowIndex, data, row, foreignKeyData, mRow?);
    private getRowObj(row?);
    private getSelectedMovableCell(cellIndex);
    /**
     * Selects a cell by the given index.
     * @param  {IIndex} cellIndex - Defines the row and column indexes.
     * @param  {boolean} isToggle - If set to true, then it toggles the selection.
     * @return {void}
     */
    selectCell(cellIndex: IIndex, isToggle?: boolean): void;
    private getCellIndex(rIdx, cIdx);
    /**
     * Selects a range of cells from start and end indexes.
     * @param  {IIndex} startIndex - Specifies the row and column's start index.
     * @param  {IIndex} endIndex - Specifies the row and column's end index.
     * @return {void}
     */
    selectCellsByRange(startIndex: IIndex, endIndex?: IIndex): void;
    /**
     * Selects a collection of cells by row and column indexes.
     * @param  {ISelectedCell[]} rowCellIndexes - Specifies the row and column indexes.
     * @return {void}
     */
    selectCells(rowCellIndexes: ISelectedCell[]): void;
    /**
     * Select cells with existing cell selection by passing row and column index.
     * @param  {IIndex} startIndex - Defines the collection of row and column index.
     * @return {void}
     * @hidden
     */
    addCellsToSelection(cellIndexes: IIndex[]): void;
    private getColIndex(rowIndex, index);
    private getLastColIndex(rowIndex);
    private clearCell();
    private cellDeselect(type, cellIndexes, data, cells, foreignKeyData);
    private updateCellSelection(selectedCell, rowIndex?, cellIndex?);
    private addAttribute(cell);
    private updateCellProps(startIndex, endIndex);
    private addRowCellIndex(rowCellIndex);
    /**
     * Deselects the currently selected cells.
     * @return {void}
     */
    clearCellSelection(): void;
    private getSelectedCellsElement();
    private mouseMoveHandler(e);
    private selectLikeExcel(rowIndex, cellIndex);
    private mouseUpHandler(e);
    private mouseDownHandler(e);
    private clearSelAfterRefresh(e);
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    removeEventListener(): void;
    private columnPositionChanged();
    private refreshHeader();
    private rowsRemoved(e);
    beforeFragAppend(e: {
        requestType: string;
    }): void;
    private getCheckAllBox();
    private enableAfterRender(e);
    private render(e?);
    private onPropertyChanged(e);
    private hidePopUp();
    private initialEnd();
    private checkBoxSelectionChanged();
    private initPerisistSelection();
    private ensureCheckboxFieldSelection();
    private dataSuccess(res);
    private setRowSelection(state);
    private getData();
    private refreshPersistSelection();
    private actionBegin(e);
    private actionComplete(e);
    private onDataBound();
    private checkSelectAllAction(checkState);
    private checkSelectAll(checkBox);
    private getCheckAllStatus(ele?);
    private checkSelect(checkBox);
    private moveIntoUncheckCollection(row);
    private triggerChkChangeEvent(checkBox, checkState);
    private updateSelectedRowIndex(index?);
    private setCheckAllState(index?, isInteraction?);
    private clickHandler(e);
    private popUpClickHandler(e);
    private showPopup(e);
    private rowCellSelectionHandler(rowIndex, cellIndex);
    private onCellFocused(e);
    /**
     * Apply ctrl + A key selection
     * @return {void}
     * @hidden
     */
    ctrlPlusA(): void;
    private applySpaceSelection(target);
    private applyDownUpKey(rowIndex?, cellIndex?);
    private applyUpDown(rowIndex);
    private applyRightLeftKey(rowIndex?, cellIndex?);
    private applyHomeEndKey(rowIndex?, cellIndex?);
    /**
     * Apply shift+down key selection
     * @return {void}
     * @hidden
     */
    shiftDownKey(rowIndex?: number, cellIndex?: number): void;
    private applyShiftLeftRightKey(rowIndex?, cellIndex?);
    private applyCtrlHomeEndKey(rowIndex, cellIndex);
    private addRemoveClassesForRow(row, isAdd, clearAll, ...args);
    private isRowType();
    private isCellType();
    private isSingleSel();
    private getRenderer();
    /**
     * Gets the collection of selected records.
     * @return {Object[]}
     */
    getSelectedRecords(): Object[];
    private addEventListener_checkbox();
    removeEventListener_checkbox(): void;
    dataReady(e: {
        requestType: string;
    }): void;
    private actionCompleteHandler(e);
}
