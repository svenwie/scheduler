{"ast":null,"code":"import { isNullOrUndefined, getDefaultDateObject, getValue, cldrData } from '@syncfusion/ej2-base';\nimport { MS_PER_DAY } from '../schedule/base/util';\n/**\n * Date Generator from Recurrence Rule\n */\n\nexport function generateSummary(rule, localeObject, locale) {\n  var ruleObject = extractObjectFromRule(rule);\n  var summary = localeObject.getConstant(EVERY) + ' ';\n  var cldrObj;\n  var cldrObj1;\n\n  if (locale === 'en' || locale === 'en-US') {\n    cldrObj1 = getValue('months.stand-alone.abbreviated', getDefaultDateObject());\n    cldrObj = getValue('days.stand-alone.abbreviated', getDefaultDateObject());\n  } else {\n    cldrObj1 = getValue('main.' + '' + locale + '.dates.calendars.gregorian.months.stand-alone.abbreviated', cldrData);\n    cldrObj = getValue('main.' + '' + locale + '.dates.calendars.gregorian.days.stand-alone.abbreviated', cldrData);\n  }\n\n  if (ruleObject.interval > 1) {\n    summary += ruleObject.interval + ' ';\n  }\n\n  switch (ruleObject.freq) {\n    case 'DAILY':\n      summary += localeObject.getConstant(DAYS);\n      break;\n\n    case 'WEEKLY':\n      summary += localeObject.getConstant(WEEKS) + ' ' + localeObject.getConstant(ON) + ' ';\n      ruleObject.day.forEach(function (day, index) {\n        summary += getValue(DAYINDEXOBJECT[day], cldrObj);\n        summary += ruleObject.day.length - 1 === index ? '' : ', ';\n      });\n      break;\n\n    case 'MONTHLY':\n      summary += localeObject.getConstant(MONTHS) + ' ' + localeObject.getConstant(ON) + ' ';\n      summary += getMonthSummary(ruleObject, cldrObj, localeObject);\n      break;\n\n    case 'YEARLY':\n      summary += localeObject.getConstant(YEARS) + ' ' + localeObject.getConstant(ON) + ' ';\n      summary += getValue(ruleObject.month[0].toString(), cldrObj1) + ' ';\n      summary += getMonthSummary(ruleObject, cldrObj, localeObject);\n      break;\n  }\n\n  if (ruleObject.count) {\n    summary += ', ' + ruleObject.count + ' ' + localeObject.getConstant(TIMES);\n  } else if (ruleObject.until) {\n    var tempDate = ruleObject.until;\n    summary += ', ' + localeObject.getConstant(UNTIL) + ' ' + tempDate.getDate() + ' ' + getValue((tempDate.getMonth() + 1).toString(), cldrObj1) + ' ' + tempDate.getFullYear();\n  }\n\n  return summary;\n}\n\nfunction getMonthSummary(ruleObject, cldrObj, localeObj) {\n  var summary = '';\n\n  if (ruleObject.monthDay.length) {\n    summary += ruleObject.monthDay[0];\n  } else if (ruleObject.day) {\n    var pos = ruleObject.setPosition - 1;\n    summary += localeObj.getConstant(WEEKPOS[pos > -1 ? pos : WEEKPOS.length - 1]) + ' ' + getValue(DAYINDEXOBJECT[ruleObject.day[0]], cldrObj);\n  }\n\n  return summary;\n}\n\nexport function generate(startDate, rule, excludeDate, startDayOfWeek, maximumCount, viewDate) {\n  if (maximumCount === void 0) {\n    maximumCount = MAXOCCURRENCE;\n  }\n\n  if (viewDate === void 0) {\n    viewDate = null;\n  }\n\n  var ruleObject = extractObjectFromRule(rule);\n  var cacheDate;\n  var data = [];\n  var modifiedDate = new Date(startDate.getTime());\n\n  if (viewDate && viewDate > startDate && !ruleObject.count) {\n    tempViewDate = new Date(new Date(viewDate.getTime()).setHours(0, 0, 0));\n  } else {\n    tempViewDate = null;\n  }\n\n  if (!ruleObject.until && tempViewDate) {\n    cacheDate = new Date(tempViewDate.getTime());\n    cacheDate.setDate(tempViewDate.getDate() + 42 * ruleObject.interval);\n    ruleObject.until = cacheDate;\n  }\n\n  if (ruleObject.until && startDate > ruleObject.until) {\n    return data;\n  }\n\n  maxOccurrence = maximumCount;\n  setFirstDayOfWeek(DAYINDEX[startDayOfWeek]);\n  tempExcludeDate = [];\n  var tempDate = isNullOrUndefined(excludeDate) ? [] : excludeDate.split(',');\n  tempDate.forEach(function (content) {\n    var parsedDate = getDateFromRecurrenceDateString(content);\n    tempExcludeDate.push(new Date(parsedDate.getTime()).setHours(0, 0, 0, 0));\n  });\n\n  switch (ruleObject.freq) {\n    case 'DAILY':\n      dailyType(modifiedDate, ruleObject.until, data, ruleObject);\n      break;\n\n    case 'WEEKLY':\n      weeklyType(modifiedDate, ruleObject.until, data, ruleObject);\n      break;\n\n    case 'MONTHLY':\n      monthlyType(modifiedDate, ruleObject.until, data, ruleObject);\n      break;\n\n    case 'YEARLY':\n      yearlyType(modifiedDate, ruleObject.until, data, ruleObject);\n  }\n\n  return data;\n}\n\nfunction getDateFromRecurrenceDateString(recDateString) {\n  return new Date(recDateString.substr(0, 4) + '-' + recDateString.substr(4, 2) + '-' + recDateString.substr(6, 5) + ':' + recDateString.substr(11, 2) + ':' + recDateString.substr(13));\n}\n\nfunction excludeDateHandler(data, date) {\n  var zeroIndex = new Date(date).setHours(0, 0, 0, 0);\n\n  if (tempExcludeDate.indexOf(zeroIndex) === -1 && (!tempViewDate || zeroIndex >= tempViewDate.getTime())) {\n    data.push(date);\n  }\n}\n\nfunction dailyType(startDate, endDate, data, ruleObject) {\n  var tempDate = new Date(startDate.getTime());\n  var interval = ruleObject.interval;\n  var expectedCount = ruleObject.count ? ruleObject.count : maxOccurrence;\n  var state;\n\n  while (compareDates(tempDate, endDate)) {\n    state = true;\n    state = validateRules(tempDate, ruleObject);\n\n    if (state) {\n      excludeDateHandler(data, tempDate.getTime());\n\n      if (expectedCount && data.length + tempExcludeDate.length >= expectedCount) {\n        break;\n      }\n    }\n\n    tempDate.setDate(tempDate.getDate() + interval);\n  }\n}\n\nfunction weeklyType(startDate, endDate, data, ruleObject) {\n  var tempDate = getStartDateForWeek(startDate, ruleObject.day);\n  var interval = ruleObject.interval;\n  var expectedDays = ruleObject.day;\n  var expectedCount = ruleObject.count ? ruleObject.count : maxOccurrence;\n  var state;\n  var dayCycleData = processWeekDays(expectedDays);\n\n  while (compareDates(tempDate, endDate)) {\n    state = true;\n    state = validateRules(tempDate, ruleObject);\n\n    if (state) {\n      excludeDateHandler(data, tempDate.getTime());\n\n      if (expectedCount && data.length + tempExcludeDate.length >= expectedCount) {\n        break;\n      }\n    }\n\n    if (expectedDays.length > 1) {\n      tempDate.setDate(tempDate.getDate() + dayCycleData[DAYINDEX[tempDate.getDay()]] + (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) === expectedDays.length - 1 ? (interval - 1) * 7 : 0));\n    } else {\n      tempDate.setDate(tempDate.getDate() + interval * 7);\n    }\n  }\n}\n\nfunction monthlyType(startDate, endDate, data, ruleObject) {\n  var ruleType = validateMonthlyRuleType(ruleObject);\n\n  switch (ruleType) {\n    case 'day':\n      monthlyDayTypeProcess(startDate, endDate, data, ruleObject);\n      break;\n\n    case 'both':\n    case 'date':\n      monthlyDateTypeProcess(startDate, endDate, data, ruleObject);\n      break;\n  }\n}\n\nfunction yearlyType(startDate, endDate, data, ruleObject) {\n  var typeValue = checkYearlyType(ruleObject);\n\n  switch (typeValue) {\n    case 'MONTH':\n      monthlyType(startDate, endDate, data, ruleObject);\n      break;\n\n    case 'WEEKNO':\n      processWeekNo(startDate, endDate, data, ruleObject);\n      break;\n\n    case 'YEARDAY':\n      processYearDay(startDate, endDate, data, ruleObject);\n      break;\n  }\n}\n\nfunction processWeekNo(startDate, endDate, data, ruleObject) {\n  var stDate = new Date(startDate.getFullYear(), 0, 0);\n  var tempDate;\n  var expectedCount = ruleObject.count ? ruleObject.count : maxOccurrence;\n  var state;\n  var startDay;\n  var firstWeekSpan;\n  var weekNos = ruleObject.weekNo;\n  var weekNo;\n  var maxDate;\n  var minDate;\n\n  while (compareDates(stDate, endDate)) {\n    startDay = dayIndex.indexOf(DAYINDEX[stDate.getDay()]);\n    firstWeekSpan = 6 - startDay + 1;\n\n    for (var index = 0; index < weekNos.length; index++) {\n      weekNo = weekNos[index];\n      weekNo = weekNo > 0 ? weekNo : 53 + weekNo + 1;\n      maxDate = weekNo === 1 ? firstWeekSpan : firstWeekSpan + (weekNo - 1) * 7;\n      minDate = weekNo === 1 ? firstWeekSpan - 7 : firstWeekSpan + (weekNo - 2) * 7;\n\n      while (minDate < maxDate) {\n        tempDate = new Date(stDate.getTime() + MS_PER_DAY * minDate);\n        state = validateRules(tempDate, ruleObject);\n\n        if (tempDate >= startDate && state && compareDates(tempDate, endDate)) {\n          excludeDateHandler(data, tempDate.getTime());\n\n          if (expectedCount && data.length + tempExcludeDate.length >= expectedCount) {\n            return;\n          }\n        }\n\n        minDate++;\n      }\n    }\n\n    stDate = new Date(tempDate.getFullYear() + ruleObject.interval, 0, 0);\n  }\n}\n\nfunction processYearDay(startDate, endDate, data, ruleObject) {\n  var stDate = new Date(startDate.getFullYear(), 0, 0);\n  var tempDate;\n  var expectedCount = ruleObject.count ? ruleObject.count : maxOccurrence;\n  var state;\n  var date;\n\n  while (compareDates(stDate, endDate)) {\n    for (var index = 0; index < ruleObject.yearDay.length; index++) {\n      date = ruleObject.yearDay[index];\n      tempDate = new Date(stDate.getTime());\n\n      if ((date === LEAPYEAR || date === -LEAPYEAR) && (tempDate.getFullYear() + 1) % 4 !== 0) {\n        tempDate.setDate(tempDate.getDate() + 1);\n        continue;\n      }\n\n      tempDate.setDate(tempDate.getDate() + (date < 0 ? getMaxYearDay(tempDate.getFullYear() + 1) + 1 + date : date));\n      state = validateRules(tempDate, ruleObject);\n\n      if (tempDate >= startDate && state && compareDates(tempDate, endDate)) {\n        excludeDateHandler(data, tempDate.getTime());\n\n        if (expectedCount && data.length + tempExcludeDate.length >= expectedCount) {\n          return;\n        }\n      }\n    }\n\n    stDate = new Date(tempDate.getFullYear() + ruleObject.interval, 0, 0);\n  }\n}\n\nfunction getMaxYearDay(date) {\n  return date % 4 === 0 ? LEAPYEAR : NORMALYEAR;\n}\n\nfunction checkYearlyType(ruleObject) {\n  if (ruleObject.yearDay.length) {\n    return 'YEARDAY';\n  } else if (ruleObject.weekNo.length) {\n    return 'WEEKNO';\n  }\n\n  return 'MONTH';\n}\n\nfunction monthlyDateTypeProcess(startDate, endDate, data, ruleObject) {\n  var tempDate = new Date(startDate.getTime());\n  var mainDate = new Date(startDate.getTime());\n  var expectedCount = ruleObject.count ? ruleObject.count : maxOccurrence;\n  var interval = ruleObject.interval;\n  var monthInit = 0;\n  var date;\n  var state;\n  tempDate.setDate(1);\n  mainDate.setDate(1);\n\n  if (ruleObject.month.length) {\n    tempDate.setMonth(ruleObject.month[0] - 1);\n  }\n\n  while (compareDates(tempDate, endDate)) {\n    for (var index = 0; index < ruleObject.monthDay.length; index++) {\n      date = ruleObject.monthDay[index];\n      var maxDate = tempDate.getMonth() === 1 ? tempDate.getFullYear() % 4 === 0 ? 29 : 28 : monthDay[tempDate.getMonth()];\n      date = date > 0 ? date : maxDate + date + 1;\n\n      if (date > 0 && validateProperDate(tempDate, date, mainDate)) {\n        tempDate.setDate(date);\n\n        if (endDate && tempDate > endDate) {\n          return;\n        }\n\n        state = validateRules(tempDate, ruleObject);\n\n        if (tempDate >= startDate && state && compareDates(tempDate, endDate)) {\n          excludeDateHandler(data, tempDate.getTime());\n\n          if (expectedCount && data.length + tempExcludeDate.length >= expectedCount) {\n            return;\n          }\n        }\n      }\n    }\n\n    monthInit = setNextValidDate(tempDate, ruleObject, monthInit, interval);\n  }\n}\n\nfunction setNextValidDate(tempDate, ruleObject, monthInit, interval, beginDate) {\n  if (beginDate === void 0) {\n    beginDate = null;\n  }\n\n  var monthData = beginDate ? beginDate.getMonth() : 0;\n  tempDate.setDate(1);\n\n  if (ruleObject.month.length) {\n    monthInit++;\n    monthInit = monthInit % ruleObject.month.length;\n    tempDate.setMonth(ruleObject.month[monthInit] - 1);\n\n    if (monthInit === 0) {\n      tempDate.setFullYear(tempDate.getFullYear() + interval);\n    }\n  } else {\n    if (beginDate && beginDate.getFullYear() < tempDate.getFullYear()) {\n      monthData = tempDate.getMonth() - 1;\n    }\n\n    tempDate.setMonth((beginDate ? monthData : tempDate.getMonth()) + interval);\n  }\n\n  return monthInit;\n}\n\nfunction monthlyDayTypeProcess(startDate, endDate, data, ruleObject) {\n  var tempDate = new Date(startDate.getTime());\n  var expectedDays = ruleObject.day;\n  var expectedCount = ruleObject.count ? ruleObject.count : maxOccurrence;\n  var dayCycleData = processWeekDays(expectedDays);\n  var interval = ruleObject.interval;\n  var state;\n  var monthCollection = [];\n  var weekCollection = [];\n  var month;\n  var index;\n  var beginDate;\n  var monthInit = 0;\n  tempDate.setDate(1);\n\n  if (ruleObject.month.length) {\n    tempDate.setMonth(ruleObject.month[0] - 1);\n  }\n\n  tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n\n  while (compareDates(tempDate, endDate)) {\n    month = tempDate.getMonth();\n    beginDate = new Date(tempDate.getTime());\n\n    if (expectedDays.length > 1) {\n      while (tempDate.getMonth() === month) {\n        weekCollection.push(tempDate.getTime());\n\n        if (DAYINDEX[tempDate.getDay()] === expectedDays[expectedDays.length - 1]) {\n          monthCollection.push(weekCollection);\n          weekCollection = [];\n        }\n\n        tempDate.setDate(tempDate.getDate() + dayCycleData[DAYINDEX[tempDate.getDay()]]);\n      }\n    } else {\n      var currentMonthDate = new Date(tempDate.getTime());\n\n      while (currentMonthDate.getMonth() === month) {\n        monthCollection.push([currentMonthDate.getTime()]);\n        currentMonthDate.setDate(currentMonthDate.getDate() + 7);\n      }\n    }\n\n    index = ruleObject.setPosition < 1 ? monthCollection.length + ruleObject.setPosition : ruleObject.setPosition - 1;\n\n    if (ruleObject.setPosition === null) {\n      index = 0;\n      var datas = [];\n\n      for (var week = 0; week < monthCollection.length; week++) {\n        for (var row = 0; row < monthCollection[week].length; row++) {\n          datas.push(monthCollection[week][row]);\n        }\n      }\n\n      monthCollection = [datas];\n    }\n\n    for (var week = 0; week < monthCollection[index].length; week++) {\n      var dayData = monthCollection[index][week];\n      var chDate = new Date(dayData);\n      state = validateRules(chDate, ruleObject);\n\n      if (chDate >= startDate && compareDates(chDate, endDate) && state) {\n        excludeDateHandler(data, dayData);\n\n        if (expectedCount && data.length + tempExcludeDate.length >= expectedCount) {\n          return;\n        }\n      }\n    }\n\n    monthInit = setNextValidDate(tempDate, ruleObject, monthInit, interval, beginDate);\n    monthCollection = [];\n    weekCollection = [];\n    tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n  }\n}\n\nfunction compareDates(startDate, endDate) {\n  return endDate ? startDate <= endDate : true;\n}\n\nfunction checkDayIndex(day, expectedDays) {\n  return expectedDays.indexOf(DAYINDEX[day]) === -1;\n}\n\nfunction getStartDateForWeek(startDate, expectedDays) {\n  var tempDate = new Date(startDate.getTime());\n\n  if (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) === -1) {\n    do {\n      tempDate.setDate(tempDate.getDate() + 1);\n    } while (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) === -1);\n  }\n\n  return tempDate;\n}\n\nexport function extractObjectFromRule(rules) {\n  var ruleObject = {\n    freq: null,\n    interval: 1,\n    count: null,\n    until: null,\n    day: [],\n    month: [],\n    weekNo: [],\n    monthDay: [],\n    yearDay: [],\n    setPosition: null,\n    validRules: []\n  };\n  var rulesList = rules.split(';');\n  var splitData = [];\n  var temp;\n  rulesList.forEach(function (data) {\n    splitData = data.split('=');\n\n    switch (splitData[0]) {\n      case 'UNTIL':\n        temp = splitData[1];\n        ruleObject.until = getDateFromRecurrenceDateString(temp);\n        break;\n\n      case 'BYDAY':\n        ruleObject.day = splitData[1].split(',');\n        ruleObject.validRules.push(splitData[0]);\n        break;\n\n      case 'BYMONTHDAY':\n        ruleObject.monthDay = splitData[1].split(',').map(Number);\n        ruleObject.validRules.push(splitData[0]);\n        break;\n\n      case 'BYMONTH':\n        ruleObject.month = splitData[1].split(',').map(Number);\n        ruleObject.validRules.push(splitData[0]);\n        break;\n\n      case 'BYYEARDAY':\n        ruleObject.yearDay = splitData[1].split(',').map(Number);\n        ruleObject.validRules.push(splitData[0]);\n        break;\n\n      case 'BYWEEKNO':\n        ruleObject.weekNo = splitData[1].split(',').map(Number);\n        ruleObject.validRules.push(splitData[0]);\n        break;\n\n      case 'INTERVAL':\n        ruleObject.interval = parseInt(splitData[1], 10);\n        break;\n\n      case 'COUNT':\n        ruleObject.count = parseInt(splitData[1], 10);\n        break;\n\n      case 'BYSETPOS':\n        ruleObject.setPosition = parseInt(splitData[1], 10);\n        break;\n\n      case 'FREQ':\n        ruleObject.freq = splitData[1];\n        break;\n    }\n  });\n\n  if (ruleObject.freq === 'MONTHLY' && ruleObject.monthDay.length === 0) {\n    var index = ruleObject.validRules.indexOf('BYDAY');\n    ruleObject.validRules.splice(index, 1);\n  }\n\n  return ruleObject;\n}\n\nfunction validateProperDate(tempDate, data, startDate) {\n  var maxDate = tempDate.getMonth() === 1 ? tempDate.getFullYear() % 4 === 0 ? 29 : 28 : monthDay[tempDate.getMonth()];\n  return data <= maxDate && tempDate >= startDate;\n}\n\nfunction processWeekDays(expectedDays) {\n  var dayCycle = {};\n  expectedDays.forEach(function (element, index) {\n    if (index === expectedDays.length - 1) {\n      var startIndex = dayIndex.indexOf(element);\n      var temp = startIndex;\n\n      while (temp % 7 !== dayIndex.indexOf(expectedDays[0])) {\n        temp++;\n      }\n\n      dayCycle[element] = temp - startIndex;\n    } else {\n      dayCycle[element] = dayIndex.indexOf(expectedDays[index + 1]) - dayIndex.indexOf(element);\n    }\n  });\n  return dayCycle;\n}\n\nfunction checkMonth(tempDate, expectedMonth) {\n  return expectedMonth.indexOf(tempDate.getMonth() + 1) === -1;\n}\n\nfunction checkDate(tempDate, expectedDate) {\n  var temp = expectedDate.slice(0);\n  var data;\n  var maxDate = tempDate.getMonth() === 1 ? tempDate.getFullYear() % 4 === 0 ? 29 : 28 : monthDay[tempDate.getMonth()];\n  data = temp.shift();\n\n  while (data) {\n    if (data < 0) {\n      data = data + maxDate + 1;\n    }\n\n    if (data === tempDate.getDate()) {\n      return false;\n    }\n\n    data = temp.shift();\n  }\n\n  return true;\n}\n\nfunction checkYear(tempDate, expectedyearDay) {\n  var temp = expectedyearDay.slice(0);\n  var data;\n  var yearDay = getYearDay(tempDate);\n  data = temp.shift();\n\n  while (data) {\n    if (data < 0) {\n      data = data + getMaxYearDay(tempDate.getFullYear()) + 1;\n    }\n\n    if (data === yearDay) {\n      return false;\n    }\n\n    data = temp.shift();\n  }\n\n  return true;\n}\n\nfunction getYearDay(currentDate) {\n  if (!startDateCollection[currentDate.getFullYear()]) {\n    startDateCollection[currentDate.getFullYear()] = new Date(currentDate.getFullYear(), 0, 0);\n  }\n\n  var tempDate = startDateCollection[currentDate.getFullYear()];\n  var diff = currentDate.getTime() - tempDate.getTime();\n  return Math.ceil(diff / MS_PER_DAY);\n}\n\nfunction validateMonthlyRuleType(ruleObject) {\n  if (ruleObject.monthDay.length && !ruleObject.day.length) {\n    return 'date';\n  } else if (!ruleObject.monthDay.length && ruleObject.day.length) {\n    return 'day';\n  }\n\n  return 'both';\n}\n\nfunction rotate(days) {\n  var data = days.shift();\n  days.push(data);\n}\n\nfunction setFirstDayOfWeek(day) {\n  while (dayIndex[0] !== day) {\n    rotate(dayIndex);\n  }\n}\n\nfunction validateRules(tempDate, ruleObject) {\n  var state = true;\n  var expectedDays = ruleObject.day;\n  var expectedMonth = ruleObject.month;\n  var expectedDate = ruleObject.monthDay;\n  var expectedyearDay = ruleObject.yearDay;\n  ruleObject.validRules.forEach(function (rule) {\n    switch (rule) {\n      case 'BYDAY':\n        if (checkDayIndex(tempDate.getDay(), expectedDays)) {\n          state = false;\n        }\n\n        break;\n\n      case 'BYMONTH':\n        if (checkMonth(tempDate, expectedMonth)) {\n          state = false;\n        }\n\n        break;\n\n      case 'BYMONTHDAY':\n        if (checkDate(tempDate, expectedDate)) {\n          state = false;\n        }\n\n        break;\n\n      case 'BYYEARDAY':\n        if (checkYear(tempDate, expectedyearDay)) {\n          state = false;\n        }\n\n        break;\n    }\n  });\n  return state;\n}\n\nvar startDateCollection = {};\nvar tempExcludeDate;\nvar dayIndex = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\nvar maxOccurrence;\nvar tempViewDate;\nvar monthDay = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nvar DAYINDEX = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\nvar MAXOCCURRENCE = 43;\nvar LEAPYEAR = 366;\nvar NORMALYEAR = 365;\nvar WEEKPOS = ['first', 'second', 'third', 'fourth', 'last'];\nvar TIMES = 'summaryTimes';\nvar ON = 'summaryOn';\nvar EVERY = 'every';\nvar UNTIL = 'summaryUntil';\nvar DAYS = 'summaryDay';\nvar WEEKS = 'summaryWeek';\nvar MONTHS = 'summaryMonth';\nvar YEARS = 'summaryYear';\nvar DAYINDEXOBJECT = {\n  SU: 'sun',\n  MO: 'mon',\n  TU: 'tue',\n  WE: 'wed',\n  TH: 'thu',\n  FR: 'fri',\n  SA: 'sat'\n};\nexport function getRecurrenceStringFromDate(date) {\n  return [date.getUTCFullYear(), roundDateValues(date.getUTCMonth() + 1), roundDateValues(date.getUTCDate()), 'T', roundDateValues(date.getUTCHours()), roundDateValues(date.getUTCMinutes()), roundDateValues(date.getUTCSeconds()), 'Z'].join('');\n}\n\nfunction roundDateValues(date) {\n  return ('0' + date).slice(-2);\n}","map":null,"metadata":{},"sourceType":"module"}