{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { isNullOrUndefined, setStyleAttribute, extend, EventHandler } from '@syncfusion/ej2-base';\nimport * as cls from '../base/css-constant';\nimport * as util from '../base/util';\nimport { MonthEvent } from './month';\nvar EVENT_GAP = 2;\n/**\n * Timeline view events render\n */\n\nvar TimelineEvent =\n/** @class */\nfunction (_super) {\n  __extends(TimelineEvent, _super);\n  /**\n   * Constructor for timeline views\n   */\n\n\n  function TimelineEvent(parent, type) {\n    var _this = _super.call(this, parent) || this;\n\n    _this.startHour = _this.parent.activeView.getStartHour();\n    _this.endHour = _this.parent.activeView.getEndHour();\n    _this.slotCount = _this.parent.activeViewOptions.timeScale.slotCount;\n    _this.interval = _this.parent.activeViewOptions.timeScale.interval;\n    _this.day = 0;\n    _this.renderType = type;\n    _this.appContainers = [].slice.call(_this.element.querySelectorAll('.' + cls.APPOINTMENT_CONTAINER_CLASS));\n    _this.dayLength = _this.element.querySelectorAll('.' + cls.CONTENT_TABLE_CLASS + ' tbody tr')[0].children.length;\n    _this.content = _this.parent.element.querySelector('.' + cls.CONTENT_TABLE_CLASS);\n    return _this;\n  }\n\n  TimelineEvent.prototype.getSlotDates = function () {\n    this.slots = [];\n    this.slots.push(this.parent.activeView.renderDates.map(function (date) {\n      return +date;\n    }));\n  };\n\n  TimelineEvent.prototype.getOverlapEvents = function (date, appointments) {\n    var appointmentsList = [];\n\n    if (this.renderType === 'day') {\n      for (var _i = 0, appointments_1 = appointments; _i < appointments_1.length; _i++) {\n        var app = appointments_1[_i];\n\n        if (util.resetTime(app[this.fields.startTime]).getTime() <= util.resetTime(new Date(date.getTime())).getTime() && util.resetTime(app[this.fields.endTime]).getTime() >= util.resetTime(new Date(date.getTime())).getTime()) {\n          appointmentsList.push(app);\n        }\n      }\n    } else {\n      for (var _a = 0, appointments_2 = appointments; _a < appointments_2.length; _a++) {\n        var app = appointments_2[_a];\n        var eventData = app.data;\n\n        if (eventData[this.fields.startTime].getTime() <= date.getTime() && eventData[this.fields.endTime].getTime() > date.getTime()) {\n          appointmentsList.push(app);\n        }\n      }\n    }\n\n    return appointmentsList;\n  };\n\n  TimelineEvent.prototype.renderResourceEvents = function () {\n    var resources = this.parent.uiStateValues.isGroupAdaptive ? [this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex]] : this.parent.resourceBase.lastResourceLevel;\n\n    for (var i = 0; i < resources.length; i++) {\n      this.renderEventsHandler(this.parent.activeView.renderDates, this.parent.activeViewOptions.workDays, resources[i]);\n    }\n  };\n\n  TimelineEvent.prototype.renderEvents = function (event, resIndex) {\n    if (this.parent.headerRows.length > 0 && this.parent.headerRows[this.parent.headerRows.length - 1].option !== 'Hour') {\n      this.renderType = 'day';\n      this.cellWidth = this.content.offsetWidth / this.dateRender.length;\n      this.slotsPerDay = 1;\n    } else {\n      this.slotsPerDay = this.dayLength / this.dateRender.length;\n    }\n\n    var wrapIndex = this.parent.uiStateValues.isGroupAdaptive ? 0 : resIndex;\n    var eventData = event.data;\n    var startTime = this.getStartTime(event, eventData);\n    var endTime = this.getEndTime(event, eventData);\n    this.day = this.parent.getIndexOfDate(this.dateRender, util.resetTime(new Date(startTime.getTime())));\n\n    if (this.day < 0) {\n      return;\n    }\n\n    var currentDate = util.resetTime(new Date(this.dateRender[this.day].getTime()));\n    var schedule = util.getStartEndHours(currentDate, this.startHour, this.endHour);\n    var overlapCount = this.getIndex(startTime);\n    event.Index = overlapCount;\n    var appHeight = this.eventHeight;\n    var diffInDays = eventData.count;\n\n    if (startTime <= endTime) {\n      var appWidth = 0;\n      var appLeft = 0;\n      var appRight = 0;\n      var position = 0;\n\n      if (this.renderType === 'day' || event[this.fields.isAllDay]) {\n        appWidth = this.renderType === 'day' ? diffInDays * this.slotsPerDay * this.cellWidth - 2 : diffInDays * this.slotsPerDay * this.cellWidth;\n        position = this.day * this.slotsPerDay * this.cellWidth;\n      } else {\n        appWidth = this.getNormalEventsWidth(startTime, endTime, diffInDays);\n        position = this.getPosition(schedule, startTime, endTime, this.day);\n        position = position * this.cellWidth;\n      }\n\n      appWidth = appWidth === 0 ? this.cellWidth : appWidth; // appWidth 0 when start and end time as same\n\n      this.renderedEvents.push(extend({}, event, null, true));\n      var cellTd = this.appContainers[wrapIndex];\n      var top_1 = this.getRowTop(resIndex);\n      var appTop = top_1 + EVENT_GAP + overlapCount * (appHeight + EVENT_GAP);\n      appLeft = this.parent.enableRtl ? 0 : position;\n      appRight = this.parent.enableRtl ? position : 0;\n\n      if (this.cellHeight > (overlapCount + 1) * (appHeight + EVENT_GAP) + this.moreIndicatorHeight) {\n        var appointmentElement = this.createAppointmentElement(event, resIndex);\n        this.applyResourceColor(appointmentElement, event, 'backgroundColor', this.groupOrder);\n        this.wireAppointmentEvents(appointmentElement);\n        setStyleAttribute(appointmentElement, {\n          'width': appWidth + 'px',\n          'left': appLeft + 'px',\n          'right': appRight + 'px',\n          'top': appTop + 'px'\n        });\n        this.renderEventElement(event, appointmentElement, cellTd);\n      } else {\n        for (var i = 0; i < diffInDays; i++) {\n          var cellTd_1 = this.appContainers[wrapIndex];\n          var moreIndicator = cellTd_1.querySelector('.' + cls.MORE_INDICATOR_CLASS);\n          var appPos = this.parent.enableRtl ? appRight : appLeft;\n          appPos = Math.floor(appPos / this.cellWidth) * this.cellWidth;\n\n          if (cellTd_1 && isNullOrUndefined(moreIndicator) || !this.isAlreadyAvail(appPos, cellTd_1)) {\n            var interval = this.interval / this.slotCount;\n            var startDate = new Date(this.dateRender[this.day + i].getTime());\n            var endDate = util.addDays(this.dateRender[this.day + i], 1);\n            var slotStartTime = new Date(startTime.setMinutes(Math.floor(startTime.getMinutes() / interval) * interval));\n            var slotEndTime = new Date(slotStartTime.getTime() + 60000 * interval);\n            var groupIndex = void 0;\n\n            if (this.parent.activeViewOptions.group.resources.length > 0 && !isNullOrUndefined(resIndex)) {\n              groupIndex = resIndex.toString();\n            }\n\n            var filterEvents = this.getFilterEvents(startDate, endDate, slotStartTime, slotEndTime, groupIndex);\n            var appArea = this.cellHeight - this.moreIndicatorHeight;\n            var renderedAppCount = Math.floor(appArea / (appHeight + EVENT_GAP));\n            var count = filterEvents.length - renderedAppCount <= 0 ? 1 : filterEvents.length - renderedAppCount;\n            var moreIndicatorElement = void 0;\n\n            if (this.renderType === 'day') {\n              moreIndicatorElement = this.getMoreIndicatorElement(count, startDate, endDate);\n            } else {\n              moreIndicatorElement = this.getMoreIndicatorElement(count, slotStartTime, slotEndTime);\n            }\n\n            if (!isNullOrUndefined(groupIndex)) {\n              moreIndicatorElement.setAttribute('data-group-index', groupIndex);\n            }\n\n            moreIndicatorElement.style.top = top_1 + appArea + 'px';\n            moreIndicatorElement.style.width = this.cellWidth + 'px';\n            moreIndicatorElement.style.left = Math.floor(appLeft / this.cellWidth) * this.cellWidth + 'px';\n            moreIndicatorElement.style.right = Math.floor(appRight / this.cellWidth) * this.cellWidth + 'px';\n            this.renderElement(cellTd_1, moreIndicatorElement);\n            EventHandler.add(moreIndicatorElement, 'click', this.moreIndicatorClick, this);\n          }\n        }\n      }\n    }\n  };\n\n  TimelineEvent.prototype.getStartTime = function (event, eventData) {\n    var startTime = event[this.fields.startTime];\n    var schedule = util.getStartEndHours(startTime, this.startHour, this.endHour);\n\n    if (schedule.startHour.getTime() >= eventData[this.fields.startTime]) {\n      startTime = schedule.startHour;\n    } else if (schedule.endHour.getTime() <= eventData[this.fields.startTime]) {\n      startTime = this.getNextDay(schedule.startHour, eventData);\n    } else {\n      startTime = eventData[this.fields.startTime];\n    } // To overcome the overflow\n\n\n    if (event[this.fields.isAllDay]) {\n      eventData[this.fields.startTime] = schedule.startHour;\n    }\n\n    return startTime;\n  };\n\n  TimelineEvent.prototype.getNextDay = function (startTime, eventData) {\n    var startDate;\n\n    for (var i = 1; i <= this.dateRender.length; i++) {\n      startDate = util.addDays(startTime, i);\n\n      if (this.parent.getIndexOfDate(this.dateRender, util.resetTime(new Date(startTime.getTime()))) !== -1) {\n        eventData.count = eventData.count - 1;\n        return startDate;\n      }\n    }\n\n    return startDate;\n  };\n\n  TimelineEvent.prototype.getEndTime = function (event, eventData) {\n    var endTime = event[this.fields.endTime];\n    var schedule = util.getStartEndHours(endTime, this.startHour, this.endHour);\n\n    if (schedule.endHour.getTime() <= eventData[this.fields.endTime]) {\n      endTime = schedule.endHour;\n    } else {\n      endTime = eventData[this.fields.endTime];\n    } // To overcome the overflow\n\n\n    if (event[this.fields.isAllDay]) {\n      eventData[this.fields.endTime] = schedule.endHour;\n    }\n\n    return endTime;\n  };\n\n  TimelineEvent.prototype.getNormalEventsWidth = function (startDate, endDate, diffInDays) {\n    if (this.isSameDay(startDate, endDate)) {\n      return this.getSameDayEventsWidth(startDate, endDate);\n    } else {\n      return this.getSpannedEventsWidth(startDate, endDate, diffInDays);\n    }\n  };\n\n  TimelineEvent.prototype.getSameDayEventsWidth = function (startDate, endDate) {\n    return (endDate.getTime() - startDate.getTime()) / (60 * 1000) * (this.cellWidth * this.slotCount) / this.interval;\n  };\n\n  TimelineEvent.prototype.getSpannedEventsWidth = function (startDate, endDate, diffInDays) {\n    var width = diffInDays * this.slotsPerDay * this.cellWidth;\n    var startWidth;\n    var endWidth;\n    var start = util.getStartEndHours(util.resetTime(new Date(startDate.getTime())), this.startHour, this.endHour);\n    startWidth = this.getSameDayEventsWidth(start.startHour, startDate);\n\n    if (this.parent.getIndexOfDate(this.dateRender, util.resetTime(new Date(endDate.getTime()))) === -1) {\n      endWidth = 0;\n    } else {\n      var end = util.getStartEndHours(util.resetTime(new Date(endDate.getTime())), this.startHour, this.endHour);\n      endWidth = this.getSameDayEventsWidth(endDate, end.endHour);\n    }\n\n    var spannedWidth = startWidth + endWidth;\n    return width > spannedWidth ? width - spannedWidth : endWidth - startWidth;\n  };\n\n  TimelineEvent.prototype.isSameDay = function (startTime, endTime) {\n    var startDay = this.parent.getIndexOfDate(this.dateRender, util.resetTime(new Date(startTime.getTime())));\n    var endDay = this.parent.getIndexOfDate(this.dateRender, util.resetTime(new Date(endTime.getTime())));\n    return startDay === endDay;\n  };\n\n  TimelineEvent.prototype.getAppointmentLeft = function (schedule, startTime, endTime, day) {\n    var slotTd = this.isSameDay(startTime, schedule.startHour) ? (startTime.getTime() - schedule.startHour.getTime()) / (60 * 1000 * this.interval) * this.slotCount : 0;\n\n    if (day === 0) {\n      return slotTd;\n    } else {\n      var daySlot = (schedule.endHour.getTime() - schedule.startHour.getTime()) / (60 * 1000) / this.interval * this.slotCount;\n      return daySlot * day + slotTd;\n    }\n  };\n\n  TimelineEvent.prototype.getPosition = function (schedule, startTime, endTime, day) {\n    if (schedule.endHour.getTime() <= endTime.getTime() && schedule.startHour.getTime() >= startTime.getTime()) {\n      return this.getAppointmentLeft(schedule, schedule.startHour, schedule.endHour, day);\n    } else if (schedule.endHour.getTime() <= endTime.getTime()) {\n      return this.getAppointmentLeft(schedule, startTime, schedule.endHour, day);\n    } else if (schedule.startHour.getTime() >= startTime.getTime()) {\n      return this.getAppointmentLeft(schedule, schedule.startHour, endTime, day);\n    } else {\n      return this.getAppointmentLeft(schedule, startTime, endTime, day);\n    }\n  };\n\n  TimelineEvent.prototype.getFilterEvents = function (startDate, endDate, startTime, endTime, gIndex) {\n    if (this.renderType === 'day') {\n      return this.getFilteredEvents(startDate, endDate, gIndex);\n    } else {\n      return this.getFilteredEvents(startTime, endTime, gIndex);\n    }\n  };\n\n  TimelineEvent.prototype.isAlreadyAvail = function (appPos, cellTd) {\n    var moreIndicator = [].slice.call(cellTd.querySelectorAll('.' + cls.MORE_INDICATOR_CLASS));\n\n    for (var i = 0; i < moreIndicator.length; i++) {\n      var indicatorPos = void 0;\n\n      if (moreIndicator) {\n        indicatorPos = this.parent.enableRtl ? moreIndicator[i].style.right : moreIndicator[i].style.left;\n      }\n\n      if (parseInt(indicatorPos, 10) === Math.floor(appPos)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  TimelineEvent.prototype.getRowTop = function (resIndex) {\n    if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n      var tr = this.parent.element.querySelector('.' + cls.CONTENT_WRAP_CLASS + ' tbody tr:nth-child(' + (resIndex + 1) + ')');\n      return tr.offsetTop;\n    }\n\n    return 0;\n  };\n\n  return TimelineEvent;\n}(MonthEvent);\n\nexport { TimelineEvent };","map":null,"metadata":{},"sourceType":"module"}