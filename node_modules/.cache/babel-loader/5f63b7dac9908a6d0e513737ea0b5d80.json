{"ast":null,"code":"/**\n * Template Engine Bridge\n */\nimport { compile as render } from './template';\nimport { createElement } from './dom';\nvar HAS_ROW = /^[\\n\\r.]+\\<tr|^\\<tr/;\nvar HAS_SVG = /^[\\n\\r.]+\\<svg|^\\<path|^\\<g/;\n/**\n * Compile the template string into template function.\n * @param  {string} templateString - The template string which is going to convert.\n * @param  {Object} helper? - Helper functions as an object.\n * @private\n */\n//tslint:disable-next-line\n\nexport function compile(templateString, helper) {\n  var compiler = engineObj.compile(templateString, helper); //tslint:disable-next-line\n\n  return function (data, component, propName) {\n    var result = compiler(data, component, propName);\n\n    if (typeof result === 'string') {\n      if (HAS_SVG.test(result)) {\n        var ele = createElement('svg', {\n          innerHTML: result\n        });\n        return ele.childNodes;\n      } else {\n        var ele = createElement(HAS_ROW.test(result) ? 'table' : 'div', {\n          innerHTML: result\n        });\n        return ele.childNodes;\n      }\n    } else {\n      return result;\n    }\n  };\n}\n/**\n * Set your custom template engine for template rendering.\n * @param  {ITemplateEngine} classObj - Class object for custom template.\n * @private\n */\n\nexport function setTemplateEngine(classObj) {\n  engineObj.compile = classObj.compile;\n}\n/**\n * Get current template engine for template rendering.\n * @param  {ITemplateEngine} classObj - Class object for custom template.\n * @private\n */\n\nexport function getTemplateEngine() {\n  return engineObj.compile;\n} //Default Engine Class\n\nvar Engine =\n/** @class */\nfunction () {\n  function Engine() {}\n\n  Engine.prototype.compile = function (templateString, helper) {\n    if (helper === void 0) {\n      helper = {};\n    }\n\n    return render(templateString, helper);\n  };\n\n  return Engine;\n}();\n\nvar engineObj = {\n  compile: new Engine().compile\n};","map":null,"metadata":{},"sourceType":"module"}